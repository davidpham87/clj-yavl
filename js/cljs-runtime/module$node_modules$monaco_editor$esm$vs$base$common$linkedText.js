shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$linkedText = function(require, module, exports) {
  function parseLinkedText(text) {
    const result = [];
    let index = 0, match;
    for (; match = LINK_REGEX.exec(text);) {
      match.index - index > 0 && result.push(text.substring(index, match.index));
      const [, label, href, , title] = match;
      title ? result.push({label, href, title}) : result.push({label, href});
      index = match.index + match[0].length;
    }
    index < text.length && result.push(text.substring(index));
    return new LinkedText(result);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LinkedText:{enumerable:!0, get:function() {
    return LinkedText;
  }}, parseLinkedText:{enumerable:!0, get:function() {
    return parseLinkedText;
  }}});
  require = require("module$node_modules$monaco_editor$esm$vs$base$common$decorators");
  class LinkedText {
    constructor(nodes) {
      this.nodes = nodes;
    }
    toString() {
      return this.nodes.map(node => typeof node === "string" ? node : node.label).join("");
    }
  }
  (this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  })([require.memoize], LinkedText.prototype, "toString", null);
  const LINK_REGEX = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$linkedText.js.map
