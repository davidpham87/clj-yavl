shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$markdownRenderer = function(require, module, exports) {
  function renderMarkdown(markdown, options = {}, markedOptions = {}) {
    var _a, _b;
    const disposables = new require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
    let isDisposed = !1;
    const element = (0,require$_DOT__SLASH_formattedTextRenderer_DOT_js.createElement)(options), _uriMassage = function(part) {
      let data;
      try {
        data = (0,require$_DOT__DOT__SLASH_common_SLASH_marshalling_DOT_js.parse)(decodeURIComponent(part));
      } catch (e) {
      }
      if (!data) {
        return part;
      }
      data = (0,require$_DOT__DOT__SLASH_common_SLASH_objects_DOT_js.cloneAndChange)(data, value => {
        if (markdown.uris && markdown.uris[value]) {
          return require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.revive(markdown.uris[value]);
        }
      });
      return encodeURIComponent(JSON.stringify(data));
    }, _href = function(href, isDomUri) {
      let uri = require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.revive(markdown.uris && markdown.uris[href]);
      if (isDomUri) {
        if (href.startsWith(require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.data + ":")) {
          return href;
        }
        uri ||= require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.parse(href);
        return require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.FileAccess.uriToBrowserUri(uri).toString(!0);
      }
      if (!uri || require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.parse(href).toString() === uri.toString()) {
        return href;
      }
      uri.query && (uri = uri.with({query:_uriMassage(uri.query)}));
      return uri.toString();
    };
    var renderer = new require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.Renderer();
    renderer.image = defaultMarkedRenderers.image;
    renderer.link = defaultMarkedRenderers.link;
    renderer.paragraph = defaultMarkedRenderers.paragraph;
    const codeBlocks = [], syncCodeBlocks = [];
    options.codeBlockRendererSync ? renderer.code = (code, lang) => {
      const id = require$_DOT__DOT__SLASH_common_SLASH_idGenerator_DOT_js.defaultGenerator.nextId();
      lang = options.codeBlockRendererSync(postProcessCodeBlockLanguageId(lang), code);
      syncCodeBlocks.push([id, lang]);
      return `<div class="code" data-code="${id}">${(0,require$_DOT__DOT__SLASH_common_SLASH_strings_DOT_js.escape)(code)}</div>`;
    } : options.codeBlockRenderer && (renderer.code = (code, lang) => {
      const id = require$_DOT__DOT__SLASH_common_SLASH_idGenerator_DOT_js.defaultGenerator.nextId();
      lang = options.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), code);
      codeBlocks.push(lang.then(element => [id, element]));
      return `<div class="code" data-code="${id}">${(0,require$_DOT__DOT__SLASH_common_SLASH_strings_DOT_js.escape)(code)}</div>`;
    });
    if (options.actionHandler) {
      const _activateLink = function(event) {
        let target = event.target;
        if (target.tagName !== "A" && (target = target.parentElement, !target || target.tagName !== "A")) {
          return;
        }
        try {
          let href = target.dataset.href;
          href && (markdown.baseUri && (href = resolveWithBaseUri(require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.from(markdown.baseUri), href)), options.actionHandler.callback(href, event));
        } catch (err) {
          (0,require$_DOT__DOT__SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(err);
        } finally {
          event.preventDefault();
        }
      }, onClick = options.actionHandler.disposables.add(new require$_DOT__SLASH_event_DOT_js.DomEmitter(element, "click")), onAuxClick = options.actionHandler.disposables.add(new require$_DOT__SLASH_event_DOT_js.DomEmitter(element, "auxclick"));
      options.actionHandler.disposables.add(require$_DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.any(onClick.event, onAuxClick.event)(e => {
        e = new require$_DOT__SLASH_mouseEvent_DOT_js.StandardMouseEvent(DOM.getWindow(element), e);
        (e.leftButton || e.middleButton) && _activateLink(e);
      }));
      options.actionHandler.disposables.add(DOM.addDisposableListener(element, "keydown", e => {
        e = new require$_DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e);
        (e.equals(10) || e.equals(3)) && _activateLink(e);
      }));
    }
    markdown.supportHtml || (markedOptions.sanitizer = html => markdown.isTrusted && html.match(/^(<span[^>]+>)|(<\/\s*span>)$/) ? html : "", markedOptions.sanitize = !0, markedOptions.silent = !0);
    markedOptions.renderer = renderer;
    renderer = (_a = markdown.value) !== null && _a !== void 0 ? _a : "";
    renderer.length > 100000 && (renderer = `${renderer.substr(0, 100000)}\u2026`);
    markdown.supportThemeIcons && (renderer = (0,require$_DOT__DOT__SLASH_common_SLASH_iconLabels_DOT_js.markdownEscapeEscapedIcons)(renderer));
    options.fillInIncompleteTokens ? (markedOptions = {...require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.defaults, ...markedOptions}, _a = require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.lexer(renderer, markedOptions), _a = fillInIncompleteTokens(_a), markedOptions = require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.parser(_a, markedOptions)) : markedOptions = require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.parse(renderer, 
    markedOptions);
    markdown.supportThemeIcons && (markedOptions = (0,require$_DOT__SLASH_ui_SLASH_iconLabel_SLASH_iconLabels_DOT_js.renderLabelWithIcons)(markedOptions).map(e => typeof e === "string" ? e : e.outerHTML).join(""));
    markedOptions = (new DOMParser()).parseFromString(sanitizeRenderedMarkdown(markdown, markedOptions), "text/html");
    markedOptions.body.querySelectorAll("img").forEach(img => {
      var src = img.getAttribute("src");
      if (src) {
        try {
          markdown.baseUri && (src = resolveWithBaseUri(require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.from(markdown.baseUri), src));
        } catch (err) {
        }
        img.src = _href(src, !0);
      }
    });
    markedOptions.body.querySelectorAll("a").forEach(a => {
      const href = a.getAttribute("href");
      a.setAttribute("href", "");
      if (!href || /^data:|javascript:/i.test(href) || /^command:/i.test(href) && !markdown.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(href)) {
        a.replaceWith(...a.childNodes);
      } else {
        let resolvedHref = _href(href, !1);
        markdown.baseUri && (resolvedHref = resolveWithBaseUri(require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js.URI.from(markdown.baseUri), href));
        a.dataset.href = resolvedHref;
      }
    });
    element.innerHTML = sanitizeRenderedMarkdown(markdown, markedOptions.body.innerHTML);
    if (codeBlocks.length > 0) {
      Promise.all(codeBlocks).then(tuples => {
        var _a, _b;
        if (!isDisposed) {
          tuples = new Map(tuples);
          var placeholderElements = element.querySelectorAll("div[data-code]");
          for (const placeholderElement of placeholderElements) {
            (placeholderElements = tuples.get((_a = placeholderElement.dataset.code) !== null && _a !== void 0 ? _a : "")) && DOM.reset(placeholderElement, placeholderElements);
          }
          (_b = options.asyncRenderCallback) === null || _b === void 0 || _b.call(options);
        }
      });
    } else if (syncCodeBlocks.length > 0) {
      markedOptions = new Map(syncCodeBlocks);
      _a = element.querySelectorAll("div[data-code]");
      for (const placeholderElement of _a) {
        (_a = markedOptions.get((_b = placeholderElement.dataset.code) !== null && _b !== void 0 ? _b : "")) && DOM.reset(placeholderElement, _a);
      }
    }
    if (options.asyncRenderCallback) {
      for (const img of element.getElementsByTagName("img")) {
        const listener = disposables.add(DOM.addDisposableListener(img, "load", () => {
          listener.dispose();
          options.asyncRenderCallback();
        }));
      }
    }
    return {element, dispose:() => {
      isDisposed = !0;
      disposables.dispose();
    }};
  }
  function postProcessCodeBlockLanguageId(lang) {
    if (!lang) {
      return "";
    }
    const parts = lang.split(/[\s+|:|,|\{|\?]/, 1);
    return parts.length ? parts[0] : lang;
  }
  function resolveWithBaseUri(baseUri, href) {
    return /^\w[\w\d+.-]*:/.test(href) ? href : baseUri.path.endsWith("/") ? (0,require$_DOT__DOT__SLASH_common_SLASH_resources_DOT_js.resolvePath)(baseUri, href).toString() : (0,require$_DOT__DOT__SLASH_common_SLASH_resources_DOT_js.resolvePath)((0,require$_DOT__DOT__SLASH_common_SLASH_resources_DOT_js.dirname)(baseUri), href).toString();
  }
  function sanitizeRenderedMarkdown(options, renderedMarkdown) {
    const {config, allowedSchemes} = getSanitizerOptions(options);
    dompurify.addHook("uponSanitizeAttribute", (element, e) => {
      if (e.attrName === "style" || e.attrName === "class") {
        if (element.tagName === "SPAN") {
          if (e.attrName === "style") {
            e.keepAttr = /^(color:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?$/.test(e.attrValue);
            return;
          }
          if (e.attrName === "class") {
            e.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(e.attrValue);
            return;
          }
        }
        e.keepAttr = !1;
      }
    });
    options = DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);
    try {
      return dompurify.sanitize(renderedMarkdown, {...config, RETURN_TRUSTED_TYPE:!0});
    } finally {
      dompurify.removeHook("uponSanitizeAttribute"), options.dispose();
    }
  }
  function getSanitizerOptions(options) {
    const allowedSchemes = [require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.http, require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.https, require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.mailto, require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.data, require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.file, require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.vscodeFileResource, require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.vscodeRemote, 
    require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.vscodeRemoteResource];
    options.isTrusted && allowedSchemes.push(require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.Schemas.command);
    return {config:{ALLOWED_TAGS:[...DOM.basicMarkupHtmlTags], ALLOWED_ATTR:allowedMarkdownAttr, ALLOW_UNKNOWN_PROTOCOLS:!0}, allowedSchemes};
  }
  function renderStringAsPlaintext(string) {
    return typeof string === "string" ? string : renderMarkdownAsPlaintext(string);
  }
  function renderMarkdownAsPlaintext(markdown) {
    var _a;
    markdown = (_a = markdown.value) !== null && _a !== void 0 ? _a : "";
    markdown.length > 100000 && (markdown = `${markdown.substr(0, 100000)}\u2026`);
    _a = require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.parse(markdown, {renderer:plainTextRenderer.value}).replace(/&(#\d+|[a-zA-Z]+);/g, m => {
      var _a;
      return (_a = unescapeInfo.get(m)) !== null && _a !== void 0 ? _a : m;
    });
    return sanitizeRenderedMarkdown({isTrusted:!1}, _a).toString();
  }
  function mergeRawTokenText(tokens) {
    let mergedTokenText = "";
    tokens.forEach(token => {
      mergedTokenText += token.raw;
    });
    return mergedTokenText;
  }
  function completeSingleLinePattern(token) {
    for (const subtoken of token.tokens) {
      if (subtoken.type === "text") {
        var lines = subtoken.raw.split("\n");
        lines = lines[lines.length - 1];
        if (lines.includes("`")) {
          return completeWithString(token, "`");
        }
        if (lines.includes("**")) {
          return completeWithString(token, "**");
        }
        if (lines.match(/\*\w/)) {
          return completeWithString(token, "*");
        }
        if (lines.match(/(^|\s)__\w/)) {
          return completeWithString(token, "__");
        }
        if (lines.match(/(^|\s)_\w/)) {
          return completeWithString(token, "_");
        }
        if (lines.match(/(^|\s)\[.*\]\(\w*/)) {
          return completeWithString(token, ")");
        }
        if (lines.match(/(^|\s)\[\w/)) {
          return completeWithString(token, "](about:blank)");
        }
      }
    }
  }
  function fillInIncompleteTokens(tokens) {
    var i;
    for (i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (token.type === "paragraph" && token.raw.match(/(\n|^)```/)) {
        var newTokens = tokens.slice(i);
        newTokens = mergeRawTokenText(newTokens);
        newTokens = require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.lexer(newTokens + "\n```");
        break;
      }
      if (token.type === "paragraph" && token.raw.match(/(\n|^)\|/)) {
        a: {
          newTokens = void 0;
          token = tokens.slice(i);
          token = mergeRawTokenText(token);
          var lines = token.split("\n");
          let hasSeparatorRow = !1;
          for (let i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            if (typeof newTokens === "undefined" && line.match(/^\s*\|/)) {
              if (line = line.match(/(\|[^\|]+)(?=\||$)/g)) {
                newTokens = line.length;
              }
            } else if (typeof newTokens === "number") {
              if (line.match(/^\s*\|/)) {
                if (i !== lines.length - 1) {
                  newTokens = void 0;
                  break a;
                }
                hasSeparatorRow = !0;
              } else {
                newTokens = void 0;
                break a;
              }
            }
          }
          typeof newTokens === "number" && newTokens > 0 ? (token = hasSeparatorRow ? lines.slice(0, -1).join("\n") : token, lines = !!token.match(/\|\s*$/), newTokens = token + (lines ? "" : "|") + `\n|${" --- |".repeat(newTokens)}`, newTokens = require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.lexer(newTokens)) : newTokens = void 0;
        }
        break;
      }
      if (i === tokens.length - 1 && token.type === "paragraph" && (token = completeSingleLinePattern(token))) {
        newTokens = [token];
        break;
      }
    }
    return newTokens ? (i = [...tokens.slice(0, i), ...newTokens], i.links = tokens.links, i) : tokens;
  }
  function completeWithString(tokens, closingString) {
    tokens = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);
    return require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.lexer(tokens + closingString)[0];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, allowedMarkdownAttr:{enumerable:!0, get:function() {
    return allowedMarkdownAttr;
  }}, fillInIncompleteTokens:{enumerable:!0, get:function() {
    return fillInIncompleteTokens;
  }}, renderMarkdown:{enumerable:!0, get:function() {
    return renderMarkdown;
  }}, renderMarkdownAsPlaintext:{enumerable:!0, get:function() {
    return renderMarkdownAsPlaintext;
  }}, renderStringAsPlaintext:{enumerable:!0, get:function() {
    return renderStringAsPlaintext;
  }}});
  var DOM = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), dompurify = require("module$node_modules$monaco_editor$esm$vs$base$browser$dompurify$dompurify"), require$_DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$event"), require$_DOT__SLASH_formattedTextRenderer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$formattedTextRenderer"), require$_DOT__SLASH_keyboardEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$keyboardEvent"), 
  require$_DOT__SLASH_mouseEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$mouseEvent"), require$_DOT__SLASH_ui_SLASH_iconLabel_SLASH_iconLabels_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$iconLabel$iconLabels"), require$_DOT__DOT__SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), 
  require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$htmlContent"), require$_DOT__DOT__SLASH_common_SLASH_iconLabels_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iconLabels"), require$_DOT__DOT__SLASH_common_SLASH_idGenerator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$idGenerator");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lazy");
  var require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$marked$marked"), require$_DOT__DOT__SLASH_common_SLASH_marshalling_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$marshalling"), require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$network"), 
  require$_DOT__DOT__SLASH_common_SLASH_objects_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$objects"), require$_DOT__DOT__SLASH_common_SLASH_resources_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$resources"), require$_DOT__DOT__SLASH_common_SLASH_strings_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_common_SLASH_uri_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$uri");
  const defaultMarkedRenderers = Object.freeze({image:(href, title, text) => {
    let dimensions = [], attributes = [];
    href && ({href, dimensions} = (0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.parseHrefAndDimensions)(href), attributes.push(`src="${(0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.escapeDoubleQuotes)(href)}"`));
    text && attributes.push(`alt="${(0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.escapeDoubleQuotes)(text)}"`);
    title && attributes.push(`title="${(0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.escapeDoubleQuotes)(title)}"`);
    dimensions.length && (attributes = attributes.concat(dimensions));
    return "\x3cimg " + attributes.join(" ") + "\x3e";
  }, paragraph:text => `<p>${text}</p>`, link:(href, title, text) => {
    if (typeof href !== "string") {
      return "";
    }
    href === text && (text = (0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.removeMarkdownEscapes)(text));
    title = typeof title === "string" ? (0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.escapeDoubleQuotes)((0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.removeMarkdownEscapes)(title)) : "";
    href = (0,require$_DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.removeMarkdownEscapes)(href);
    href = href.replace(/&/g, "\x26amp;").replace(/</g, "\x26lt;").replace(/>/g, "\x26gt;").replace(/"/g, "\x26quot;").replace(/'/g, "\x26#39;");
    return `<a href="${href}" title="${title || href}" draggable="false">${text}</a>`;
  }}), allowedMarkdownAttr = "align autoplay alt class controls data-code data-href draggable height href loop muted playsinline poster src style target title width start".split(" "), unescapeInfo = new Map([["\x26quot;", '"'], ["\x26nbsp;", " "], ["\x26amp;", "\x26"], ["\x26#39;", "'"], ["\x26lt;", "\x3c"], ["\x26gt;", "\x3e"]]), plainTextRenderer = new module.Lazy(() => {
    const renderer = new require$_DOT__DOT__SLASH_common_SLASH_marked_SLASH_marked_DOT_js.marked.Renderer();
    renderer.code = code => code;
    renderer.blockquote = quote => quote;
    renderer.html = _html => "";
    renderer.heading = (text, _level, _raw) => text + "\n";
    renderer.hr = () => "";
    renderer.list = (body, _ordered) => body;
    renderer.listitem = text => text + "\n";
    renderer.paragraph = text => text + "\n";
    renderer.table = (header, body) => header + body + "\n";
    renderer.tablerow = content => content;
    renderer.tablecell = (content, _flags) => content + " ";
    renderer.strong = text => text;
    renderer.em = text => text;
    renderer.codespan = code => code;
    renderer.br = () => "\n";
    renderer.del = text => text;
    renderer.image = (_href, _title, _text) => "";
    renderer.text = text => text;
    renderer.link = (_href, _title, text) => text;
    return renderer;
  });
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$markdownRenderer.js.map
