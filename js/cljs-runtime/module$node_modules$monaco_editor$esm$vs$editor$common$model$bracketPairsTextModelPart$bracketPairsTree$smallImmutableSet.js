shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$smallImmutableSet = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DenseKeyProvider:{enumerable:!0, get:function() {
    return DenseKeyProvider;
  }}, SmallImmutableSet:{enumerable:!0, get:function() {
    return SmallImmutableSet;
  }}, identityKeyProvider:{enumerable:!0, get:function() {
    return identityKeyProvider;
  }}});
  const emptyArr = [];
  class SmallImmutableSet {
    static create(items, additionalItems) {
      if (items <= 128 && additionalItems.length === 0) {
        let cached = SmallImmutableSet.cache[items];
        cached || (cached = new SmallImmutableSet(items, additionalItems), SmallImmutableSet.cache[items] = cached);
        return cached;
      }
      return new SmallImmutableSet(items, additionalItems);
    }
    static getEmpty() {
      return this.empty;
    }
    constructor(items, additionalItems) {
      this.items = items;
      this.additionalItems = additionalItems;
    }
    add(value, keyProvider) {
      value = keyProvider.getKey(value);
      keyProvider = value >> 5;
      if (keyProvider === 0) {
        return value = 1 << value | this.items, value === this.items ? this : SmallImmutableSet.create(value, this.additionalItems);
      }
      keyProvider--;
      const newItems = this.additionalItems.slice(0);
      for (; newItems.length < keyProvider;) {
        newItems.push(0);
      }
      newItems[keyProvider] |= 1 << (value & 31);
      return SmallImmutableSet.create(this.items, newItems);
    }
    merge(other) {
      const merged = this.items | other.items;
      if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {
        return merged === this.items ? this : merged === other.items ? other : SmallImmutableSet.create(merged, emptyArr);
      }
      const newItems = [];
      for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {
        newItems.push((this.additionalItems[i] || 0) | (other.additionalItems[i] || 0));
      }
      return SmallImmutableSet.create(merged, newItems);
    }
    intersects(other) {
      if ((this.items & other.items) !== 0) {
        return !0;
      }
      for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {
        if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {
          return !0;
        }
      }
      return !1;
    }
  }
  SmallImmutableSet.cache = Array(129);
  SmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);
  const identityKeyProvider = {getKey(value) {
    return value;
  }};
  class DenseKeyProvider {
    constructor() {
      this.items = new Map();
    }
    getKey(value) {
      let existing = this.items.get(value);
      existing === void 0 && (existing = this.items.size, this.items.set(value, existing));
      return existing;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$smallImmutableSet.js.map
