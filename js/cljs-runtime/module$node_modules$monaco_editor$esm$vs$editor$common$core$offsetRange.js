shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, OffsetRange:{enumerable:!0, get:function() {
    return OffsetRange;
  }}, OffsetRangeSet:{enumerable:!0, get:function() {
    return OffsetRangeSet;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors");
  class OffsetRange {
    static addRange(range, sortedRanges) {
      let i = 0;
      for (; i < sortedRanges.length && sortedRanges[i].endExclusive < range.start;) {
        i++;
      }
      let j = i;
      for (; j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive;) {
        j++;
      }
      i === j ? sortedRanges.splice(i, 0, range) : sortedRanges.splice(i, j - i, new OffsetRange(Math.min(range.start, sortedRanges[i].start), Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive)));
    }
    static tryCreate(start, endExclusive) {
      if (!(start > endExclusive)) {
        return new OffsetRange(start, endExclusive);
      }
    }
    static ofLength(length) {
      return new OffsetRange(0, length);
    }
    static ofStartAndLength(start, length) {
      return new OffsetRange(start, start + length);
    }
    constructor(start, endExclusive) {
      this.start = start;
      this.endExclusive = endExclusive;
      if (start > endExclusive) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError(`Invalid range: ${this.toString()}`);
      }
    }
    get isEmpty() {
      return this.start === this.endExclusive;
    }
    delta(offset) {
      return new OffsetRange(this.start + offset, this.endExclusive + offset);
    }
    deltaStart(offset) {
      return new OffsetRange(this.start + offset, this.endExclusive);
    }
    deltaEnd(offset) {
      return new OffsetRange(this.start, this.endExclusive + offset);
    }
    get length() {
      return this.endExclusive - this.start;
    }
    toString() {
      return `[${this.start}, ${this.endExclusive})`;
    }
    equals(other) {
      return this.start === other.start && this.endExclusive === other.endExclusive;
    }
    containsRange(other) {
      return this.start <= other.start && other.endExclusive <= this.endExclusive;
    }
    contains(offset) {
      return this.start <= offset && offset < this.endExclusive;
    }
    join(other) {
      return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    intersect(other) {
      const start = Math.max(this.start, other.start);
      other = Math.min(this.endExclusive, other.endExclusive);
      if (start <= other) {
        return new OffsetRange(start, other);
      }
    }
    isBefore(other) {
      return this.endExclusive <= other.start;
    }
    isAfter(other) {
      return this.start >= other.endExclusive;
    }
    slice(arr) {
      return arr.slice(this.start, this.endExclusive);
    }
    clip(value) {
      if (this.isEmpty) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      return Math.max(this.start, Math.min(this.endExclusive - 1, value));
    }
    clipCyclic(value) {
      if (this.isEmpty) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      return value < this.start ? this.endExclusive - (this.start - value) % this.length : value >= this.endExclusive ? this.start + (value - this.start) % this.length : value;
    }
    forEach(f) {
      for (let i = this.start; i < this.endExclusive; i++) {
        f(i);
      }
    }
  }
  class OffsetRangeSet {
    constructor() {
      this._sortedRanges = [];
    }
    addRange(range) {
      let i = 0;
      for (; i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start;) {
        i++;
      }
      let j = i;
      for (; j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive;) {
        j++;
      }
      i === j ? this._sortedRanges.splice(i, 0, range) : this._sortedRanges.splice(i, j - i, new OffsetRange(Math.min(range.start, this._sortedRanges[i].start), Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive)));
    }
    toString() {
      return this._sortedRanges.map(r => r.toString()).join(", ");
    }
    intersectsStrict(other) {
      let i = 0;
      for (; i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start;) {
        i++;
      }
      return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;
    }
    intersectWithRange(other) {
      const result = new OffsetRangeSet();
      for (const range of this._sortedRanges) {
        const intersection = range.intersect(other);
        intersection && result.addRange(intersection);
      }
      return result;
    }
    intersectWithRangeLength(other) {
      return this.intersectWithRange(other).length;
    }
    get length() {
      return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange.js.map
