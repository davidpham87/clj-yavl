shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$linesSliceCharSequence = function(require, module, exports) {
  function isWordChar(charCode) {
    return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
  }
  function getCategory(charCode) {
    return charCode === 10 ? 8 : charCode === 13 ? 7 : (0,require$_DOT__SLASH_utils_DOT_js.isSpace)(charCode) ? 6 : charCode >= 97 && charCode <= 122 ? 0 : charCode >= 65 && charCode <= 90 ? 1 : charCode >= 48 && charCode <= 57 ? 2 : charCode === -1 ? 3 : charCode === 44 || charCode === 59 ? 5 : 4;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LinesSliceCharSequence:{enumerable:!0, get:function() {
    return LinesSliceCharSequence;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arraysFind"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__SLASH_utils_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$utils");
  class LinesSliceCharSequence {
    constructor(lines, lineRange, considerWhitespaceChanges) {
      this.lines = lines;
      this.considerWhitespaceChanges = considerWhitespaceChanges;
      this.elements = [];
      this.firstCharOffsetByLine = [];
      this.additionalOffsetByLine = [];
      let trimFirstLineFully = !1;
      lineRange.start > 0 && lineRange.endExclusive >= lines.length && (lineRange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(lineRange.start - 1, lineRange.endExclusive), trimFirstLineFully = !0);
      this.lineRange = lineRange;
      this.firstCharOffsetByLine[0] = 0;
      for (lineRange = this.lineRange.start; lineRange < this.lineRange.endExclusive; lineRange++) {
        let line = lines[lineRange];
        var offset = 0;
        if (trimFirstLineFully) {
          offset = line.length, line = "", trimFirstLineFully = !1;
        } else if (!considerWhitespaceChanges) {
          const trimmedStartLine = line.trimStart();
          offset = line.length - trimmedStartLine.length;
          line = trimmedStartLine.trimEnd();
        }
        this.additionalOffsetByLine.push(offset);
        for (offset = 0; offset < line.length; offset++) {
          this.elements.push(line.charCodeAt(offset));
        }
        lineRange < lines.length - 1 && (this.elements.push(10), this.firstCharOffsetByLine[lineRange - this.lineRange.start + 1] = this.elements.length);
      }
      this.additionalOffsetByLine.push(0);
    }
    toString() {
      return `Slice: "${this.text}"`;
    }
    get text() {
      return this.getText(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(0, this.length));
    }
    getText(range) {
      return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join("");
    }
    getElement(offset) {
      return this.elements[offset];
    }
    get length() {
      return this.elements.length;
    }
    getBoundaryScore(length) {
      const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
      length = getCategory(length < this.elements.length ? this.elements[length] : -1);
      if (prevCategory === 7 && length === 8) {
        return 0;
      }
      let score = 0;
      prevCategory !== length && (score += 10, prevCategory === 0 && length === 1 && (score += 1));
      score += score$jscomp$0[prevCategory];
      return score += score$jscomp$0[length];
    }
    translateOffset(offset) {
      if (this.lineRange.isEmpty) {
        return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(this.lineRange.start + 1, 1);
      }
      const i = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastIdxMonotonous)(this.firstCharOffsetByLine, value => value <= offset);
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);
    }
    translateRange(range) {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
    }
    findWordContaining(offset) {
      if (!(offset < 0 || offset >= this.elements.length) && isWordChar(this.elements[offset])) {
        for (var start = offset; start > 0 && isWordChar(this.elements[start - 1]);) {
          start--;
        }
        for (; offset < this.elements.length && isWordChar(this.elements[offset]);) {
          offset++;
        }
        return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(start, offset);
      }
    }
    countLinesIn(range) {
      return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
    }
    isStronglyEqual(offset1, offset2) {
      return this.elements[offset1] === this.elements[offset2];
    }
    extendToFullLines(range) {
      var _a, _b;
      const start = (_a = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMonotonous)(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;
      _a = (_b = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findFirstMonotonous)(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(start, _a);
    }
  }
  const score$jscomp$0 = {[0]:0, [1]:0, [2]:0, [3]:10, [4]:2, [5]:3, [6]:3, [7]:10, [8]:10};
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$linesSliceCharSequence.js.map
