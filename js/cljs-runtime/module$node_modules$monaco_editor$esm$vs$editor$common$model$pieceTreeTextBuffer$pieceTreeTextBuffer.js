shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBuffer = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, PieceTreeTextBuffer:{enumerable:!0, get:function() {
    return PieceTreeTextBuffer;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_model_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model"), 
  require$_DOT__SLASH_pieceTreeBase_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeBase"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$eolCounter"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_textChange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$textChange");
  require = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  class PieceTreeTextBuffer extends require.Disposable {
    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {
      super();
      this._onDidChangeContent = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this._BOM = BOM;
      this._mightContainNonBasicASCII = !isBasicASCII;
      this._mightContainRTL = containsRTL;
      this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;
      this._pieceTree = new require$_DOT__SLASH_pieceTreeBase_DOT_js.PieceTreeBase(chunks, eol, eolNormalized);
    }
    mightContainRTL() {
      return this._mightContainRTL;
    }
    mightContainUnusualLineTerminators() {
      return this._mightContainUnusualLineTerminators;
    }
    resetMightContainUnusualLineTerminators() {
      this._mightContainUnusualLineTerminators = !1;
    }
    mightContainNonBasicASCII() {
      return this._mightContainNonBasicASCII;
    }
    getBOM() {
      return this._BOM;
    }
    getEOL() {
      return this._pieceTree.getEOL();
    }
    createSnapshot(preserveBOM) {
      return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : "");
    }
    getOffsetAt(lineNumber, column) {
      return this._pieceTree.getOffsetAt(lineNumber, column);
    }
    getPositionAt(offset) {
      return this._pieceTree.getPositionAt(offset);
    }
    getRangeAt(start, length) {
      length = start + length;
      start = this.getPositionAt(start);
      length = this.getPositionAt(length);
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(start.lineNumber, start.column, length.lineNumber, length.column);
    }
    getValueInRange(range, eol = 0) {
      if (range.isEmpty()) {
        return "";
      }
      eol = this._getEndOfLine(eol);
      return this._pieceTree.getValueInRange(range, eol);
    }
    getValueLengthInRange(range, eol = 0) {
      if (range.isEmpty()) {
        return 0;
      }
      if (range.startLineNumber === range.endLineNumber) {
        return range.endColumn - range.startColumn;
      }
      const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn), endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);
      let eolOffsetCompensation = 0;
      eol = this._getEndOfLine(eol);
      const actualEOL = this.getEOL();
      eol.length !== actualEOL.length && (eolOffsetCompensation = (eol.length - actualEOL.length) * (range.endLineNumber - range.startLineNumber));
      return endOffset - startOffset + eolOffsetCompensation;
    }
    getCharacterCountInRange(range, eol = 0) {
      if (this._mightContainNonBasicASCII) {
        let result = 0;
        const fromLineNumber = range.startLineNumber, toLineNumber = range.endLineNumber;
        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
          const lineContent = this.getLineContent(lineNumber);
          var fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;
          const toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;
          for (; fromOffset < toOffset; fromOffset++) {
            strings.isHighSurrogate(lineContent.charCodeAt(fromOffset)) ? (result += 1, fromOffset += 1) : result += 1;
          }
        }
        return result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);
      }
      return this.getValueLengthInRange(range, eol);
    }
    getLength() {
      return this._pieceTree.getLength();
    }
    getLineCount() {
      return this._pieceTree.getLineCount();
    }
    getLinesContent() {
      return this._pieceTree.getLinesContent();
    }
    getLineContent(lineNumber) {
      return this._pieceTree.getLineContent(lineNumber);
    }
    getLineCharCode(lineNumber, index) {
      return this._pieceTree.getLineCharCode(lineNumber, index);
    }
    getLineLength(lineNumber) {
      return this._pieceTree.getLineLength(lineNumber);
    }
    getLineFirstNonWhitespaceColumn(lineNumber) {
      lineNumber = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
      return lineNumber === -1 ? 0 : lineNumber + 1;
    }
    getLineLastNonWhitespaceColumn(lineNumber) {
      lineNumber = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
      return lineNumber === -1 ? 0 : lineNumber + 2;
    }
    _getEndOfLine(eol) {
      switch(eol) {
        case 1:
          return "\n";
        case 2:
          return "\r\n";
        case 0:
          return this.getEOL();
        default:
          throw Error("Unknown EOL preference");
      }
    }
    setEOL(newEOL) {
      this._pieceTree.setEOL(newEOL);
    }
    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
      var mightContainRTL = this._mightContainRTL, mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators, mightContainNonBasicASCII = this._mightContainNonBasicASCII, canReduceOperations = !0, operations = [];
      for (var i$jscomp$0 = 0; i$jscomp$0 < rawOperations.length; i$jscomp$0++) {
        var op = rawOperations[i$jscomp$0];
        canReduceOperations && op._isTracked && (canReduceOperations = !1);
        var validatedRange = op.range;
        if (op.text) {
          var textMightContainNonBasicASCII = !0;
          mightContainNonBasicASCII || (mightContainNonBasicASCII = textMightContainNonBasicASCII = !strings.isBasicASCII(op.text));
          !mightContainRTL && textMightContainNonBasicASCII && (mightContainRTL = strings.containsRTL(op.text));
          !mightContainUnusualLineTerminators && textMightContainNonBasicASCII && (mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text));
        }
        var validText = "", firstLineLength = textMightContainNonBasicASCII = 0, lastLineLength = 0;
        if (op.text) {
          [textMightContainNonBasicASCII, firstLineLength, lastLineLength, validText] = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(op.text);
          const bufferEOL = this.getEOL(), expectedStrEOL = bufferEOL === "\r\n" ? 2 : 1;
          validText = validText === 0 || validText === expectedStrEOL ? op.text : op.text.replace(/\r\n|\r|\n/g, bufferEOL);
        }
        operations[i$jscomp$0] = {sortIndex:i$jscomp$0, identifier:op.identifier || null, range:validatedRange, rangeOffset:this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn), rangeLength:this.getValueLengthInRange(validatedRange), text:validText, eolCount:textMightContainNonBasicASCII, firstLineLength, lastLineLength, forceMoveMarkers:!!op.forceMoveMarkers, isAutoWhitespaceEdit:op.isAutoWhitespaceEdit || !1};
      }
      operations.sort(PieceTreeTextBuffer._sortOpsAscending);
      rawOperations = !1;
      for (let i = 0, count = operations.length - 1; i < count; i++) {
        if (i$jscomp$0 = operations[i].range.getEndPosition(), op = operations[i + 1].range.getStartPosition(), op.isBeforeOrEqual(i$jscomp$0)) {
          if (op.isBefore(i$jscomp$0)) {
            throw Error("Overlapping ranges are not allowed!");
          }
          rawOperations = !0;
        }
      }
      canReduceOperations && (operations = this._reduceOperations(operations));
      i$jscomp$0 = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];
      canReduceOperations = [];
      if (recordTrimAutoWhitespace) {
        for (op = 0; op < operations.length; op++) {
          if (validatedRange = operations[op], textMightContainNonBasicASCII = i$jscomp$0[op], validatedRange.isAutoWhitespaceEdit && validatedRange.range.isEmpty()) {
            for (firstLineLength = textMightContainNonBasicASCII.startLineNumber; firstLineLength <= textMightContainNonBasicASCII.endLineNumber; firstLineLength++) {
              lastLineLength = "";
              if (firstLineLength === textMightContainNonBasicASCII.startLineNumber && (lastLineLength = this.getLineContent(validatedRange.range.startLineNumber), strings.firstNonWhitespaceIndex(lastLineLength) !== -1)) {
                continue;
              }
              canReduceOperations.push({lineNumber:firstLineLength, oldContent:lastLineLength});
            }
          }
        }
      }
      op = null;
      if (computeUndoEdits) {
        computeUndoEdits = 0;
        op = [];
        for (validatedRange = 0; validatedRange < operations.length; validatedRange++) {
          textMightContainNonBasicASCII = operations[validatedRange], firstLineLength = i$jscomp$0[validatedRange], lastLineLength = this.getValueInRange(textMightContainNonBasicASCII.range), validText = textMightContainNonBasicASCII.rangeOffset + computeUndoEdits, computeUndoEdits += textMightContainNonBasicASCII.text.length - lastLineLength.length, op[validatedRange] = {sortIndex:textMightContainNonBasicASCII.sortIndex, identifier:textMightContainNonBasicASCII.identifier, range:firstLineLength, 
          text:lastLineLength, textChange:new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_textChange_DOT_js.TextChange(textMightContainNonBasicASCII.rangeOffset, lastLineLength, validText, textMightContainNonBasicASCII.text)};
        }
        rawOperations || op.sort((a, b) => a.sortIndex - b.sortIndex);
      }
      this._mightContainRTL = mightContainRTL;
      this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;
      this._mightContainNonBasicASCII = mightContainNonBasicASCII;
      mightContainRTL = this._doApplyEdits(operations);
      mightContainUnusualLineTerminators = null;
      if (recordTrimAutoWhitespace && canReduceOperations.length > 0) {
        canReduceOperations.sort((a, b) => b.lineNumber - a.lineNumber);
        mightContainUnusualLineTerminators = [];
        for (let i = 0, len = canReduceOperations.length; i < len; i++) {
          recordTrimAutoWhitespace = canReduceOperations[i].lineNumber, i > 0 && canReduceOperations[i - 1].lineNumber === recordTrimAutoWhitespace || (mightContainNonBasicASCII = canReduceOperations[i].oldContent, operations = this.getLineContent(recordTrimAutoWhitespace), operations.length !== 0 && operations !== mightContainNonBasicASCII && strings.firstNonWhitespaceIndex(operations) === -1 && mightContainUnusualLineTerminators.push(recordTrimAutoWhitespace));
        }
      }
      this._onDidChangeContent.fire();
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_model_DOT_js.ApplyEditsResult(op, mightContainRTL, mightContainUnusualLineTerminators);
    }
    _reduceOperations(operations) {
      return operations.length < 1000 ? operations : [this._toSingleEditOperation(operations)];
    }
    _toSingleEditOperation(operations) {
      let forceMoveMarkers = !1;
      var firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range;
      lastEditRange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
      var lastEndLineNumber = firstEditRange.startLineNumber;
      firstEditRange = firstEditRange.startColumn;
      const result = [];
      for (let i = 0, len = operations.length; i < len; i++) {
        const operation = operations[i], range = operation.range;
        forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
        result.push(this.getValueInRange(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lastEndLineNumber, firstEditRange, range.startLineNumber, range.startColumn)));
        operation.text.length > 0 && result.push(operation.text);
        lastEndLineNumber = range.endLineNumber;
        firstEditRange = range.endColumn;
      }
      lastEndLineNumber = result.join("");
      const [eolCount, firstLineLength, lastLineLength] = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(lastEndLineNumber);
      return {sortIndex:0, identifier:operations[0].identifier, range:lastEditRange, rangeOffset:this.getOffsetAt(lastEditRange.startLineNumber, lastEditRange.startColumn), rangeLength:this.getValueLengthInRange(lastEditRange, 0), text:lastEndLineNumber, eolCount, firstLineLength, lastLineLength, forceMoveMarkers, isAutoWhitespaceEdit:!1};
    }
    _doApplyEdits(operations) {
      operations.sort(PieceTreeTextBuffer._sortOpsDescending);
      const contentChanges = [];
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        var startLineNumber = op.range.startLineNumber;
        const startColumn = op.range.startColumn, endLineNumber = op.range.endLineNumber, endColumn = op.range.endColumn;
        if (startLineNumber !== endLineNumber || startColumn !== endColumn || op.text.length !== 0) {
          op.text ? (this._pieceTree.delete(op.rangeOffset, op.rangeLength), this._pieceTree.insert(op.rangeOffset, op.text, !0)) : this._pieceTree.delete(op.rangeOffset, op.rangeLength), startLineNumber = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, startColumn, endLineNumber, endColumn), contentChanges.push({range:startLineNumber, rangeLength:op.rangeLength, text:op.text, rangeOffset:op.rangeOffset, forceMoveMarkers:op.forceMoveMarkers});
        }
      }
      return contentChanges;
    }
    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
      return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    }
    static _getInverseEditRanges(operations) {
      const result = [];
      var prevOpEndLineNumber = 0, prevOpEndColumn = 0, prevOp = null;
      for (let i = 0, len = operations.length; i < len; i++) {
        const op = operations[i];
        prevOp ? prevOp.range.endLineNumber === op.range.startLineNumber ? prevOpEndColumn += op.range.startColumn - prevOp.range.endColumn : (prevOpEndLineNumber += op.range.startLineNumber - prevOp.range.endLineNumber, prevOpEndColumn = op.range.startColumn) : (prevOpEndLineNumber = op.range.startLineNumber, prevOpEndColumn = op.range.startColumn);
        op.text.length > 0 ? (prevOp = op.eolCount + 1, prevOp = prevOp === 1 ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(prevOpEndLineNumber, prevOpEndColumn, prevOpEndLineNumber, prevOpEndColumn + op.firstLineLength) : new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(prevOpEndLineNumber, prevOpEndColumn, prevOpEndLineNumber + prevOp - 1, op.lastLineLength + 1)) : prevOp = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(prevOpEndLineNumber, 
        prevOpEndColumn, prevOpEndLineNumber, prevOpEndColumn);
        prevOpEndLineNumber = prevOp.endLineNumber;
        prevOpEndColumn = prevOp.endColumn;
        result.push(prevOp);
        prevOp = op;
      }
      return result;
    }
    static _sortOpsAscending(a, b) {
      const r = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingEnds(a.range, b.range);
      return r === 0 ? a.sortIndex - b.sortIndex : r;
    }
    static _sortOpsDescending(a, b) {
      const r = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingEnds(a.range, b.range);
      return r === 0 ? b.sortIndex - a.sortIndex : -r;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBuffer.js.map
