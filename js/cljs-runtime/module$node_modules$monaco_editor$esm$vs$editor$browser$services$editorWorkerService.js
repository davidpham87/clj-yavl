shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$services$editorWorkerService = function(require, module, exports) {
  function canSyncModel(modelService, resource) {
    modelService = modelService.getModel(resource);
    return !modelService || modelService.isTooLargeForSyncing() ? !1 : !0;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, EditorWorkerClient:{enumerable:!0, get:function() {
    return EditorWorkerClient;
  }}, EditorWorkerHost:{enumerable:!0, get:function() {
    return EditorWorkerHost;
  }}, EditorWorkerService:{enumerable:!0, get:function() {
    return EditorWorkerService;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_worker_SLASH_simpleWorker_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$worker$simpleWorker"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_defaultWorkerFactory_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$defaultWorkerFactory"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfigurationRegistry");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorSimpleWorker_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$editorSimpleWorker");
  exports = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$model");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_textResourceConfiguration_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$textResourceConfiguration"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$log$common$log"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_stopwatch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$stopwatch"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$languageFeatures"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_linesDiffComputer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$linesDiffComputer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_rangeMapping_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$rangeMapping"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_lineRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_window_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$window"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom");
  require = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  let EditorWorkerService = class extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(modelService, configurationService, logService, languageConfigurationService, languageFeaturesService) {
      super();
      this._modelService = modelService;
      this._workerManager = this._register(new WorkerManager(this._modelService, languageConfigurationService));
      this._logService = logService;
      this._register(languageFeaturesService.linkProvider.register({language:"*", hasAccessToAllModels:!0}, {provideLinks:(model, token) => canSyncModel(this._modelService, model.uri) ? this._workerManager.withWorker().then(client => client.computeLinks(model.uri)).then(links => links && {links}) : Promise.resolve({links:[]})}));
      this._register(languageFeaturesService.completionProvider.register("*", new WordBasedCompletionItemProvider(this._workerManager, configurationService, this._modelService, languageConfigurationService)));
    }
    dispose() {
      super.dispose();
    }
    canComputeUnicodeHighlights(uri) {
      return canSyncModel(this._modelService, uri);
    }
    computedUnicodeHighlights(uri, options, range) {
      return this._workerManager.withWorker().then(client => client.computedUnicodeHighlights(uri, options, range));
    }
    async computeDiff(original, modified, options, algorithm) {
      function toLineRangeMappings(changes) {
        return changes.map(c => {
          var _a;
          return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_rangeMapping_DOT_js.DetailedLineRangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_lineRange_DOT_js.LineRange(c[0], c[1]), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_lineRange_DOT_js.LineRange(c[2], c[3]), (_a = c[4]) === null || _a === void 0 ? void 0 : _a.map(c => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_rangeMapping_DOT_js.RangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(c[0], 
          c[1], c[2], c[3]), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(c[4], c[5], c[6], c[7]))));
        });
      }
      const result = await this._workerManager.withWorker().then(client => client.computeDiff(original, modified, options, algorithm));
      return result ? {identical:result.identical, quitEarly:result.quitEarly, changes:toLineRangeMappings(result.changes), moves:result.moves.map(m => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_linesDiffComputer_DOT_js.MovedText(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_rangeMapping_DOT_js.LineRangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_lineRange_DOT_js.LineRange(m[0], m[1]), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_lineRange_DOT_js.LineRange(m[2], 
      m[3])), toLineRangeMappings(m[4])))} : null;
    }
    computeMoreMinimalEdits(resource, edits, pretty = !1) {
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.isNonEmptyArray)(edits)) {
        if (!canSyncModel(this._modelService, resource)) {
          return Promise.resolve(edits);
        }
        const sw = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_stopwatch_DOT_js.StopWatch.create(), result = this._workerManager.withWorker().then(client => client.computeMoreMinimalEdits(resource, edits, pretty));
        result.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", resource.toString(!0), sw.elapsed()));
        return Promise.race([result, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.timeout)(1000).then(() => edits)]);
      }
      return Promise.resolve(void 0);
    }
    canNavigateValueSet(resource) {
      return canSyncModel(this._modelService, resource);
    }
    navigateValueSet(resource, range, up) {
      return this._workerManager.withWorker().then(client => client.navigateValueSet(resource, range, up));
    }
    canComputeWordRanges(resource) {
      return canSyncModel(this._modelService, resource);
    }
    computeWordRanges(resource, range) {
      return this._workerManager.withWorker().then(client => client.computeWordRanges(resource, range));
    }
  };
  EditorWorkerService = (this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  })([require(0, exports.IModelService), require(1, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_textResourceConfiguration_DOT_js.ITextResourceConfigurationService), require(2, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.ILogService), require(3, module.ILanguageConfigurationService), require(4, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js.ILanguageFeaturesService)], 
  EditorWorkerService);
  class WordBasedCompletionItemProvider {
    constructor(workerManager, configurationService, modelService, languageConfigurationService) {
      this.languageConfigurationService = languageConfigurationService;
      this._debugDisplayName = "wordbasedCompletions";
      this._workerManager = workerManager;
      this._configurationService = configurationService;
      this._modelService = modelService;
    }
    async provideCompletionItems(model, position) {
      var config = this._configurationService.getValue(model.uri, position, "editor");
      if (config.wordBasedSuggestions !== "off") {
        var models = [];
        if (config.wordBasedSuggestions === "currentDocument") {
          canSyncModel(this._modelService, model.uri) && models.push(model.uri);
        } else {
          for (const candidate of this._modelService.getModels()) {
            canSyncModel(this._modelService, candidate.uri) && (candidate === model ? models.unshift(candidate.uri) : (config.wordBasedSuggestions === "allDocuments" || candidate.getLanguageId() === model.getLanguageId()) && models.push(candidate.uri));
          }
        }
        if (models.length !== 0) {
          config = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
          var replace = (model = model.getWordAtPosition(position)) ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, model.startColumn, position.lineNumber, model.endColumn) : require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(position), insert = replace.setEndPosition(position.lineNumber, position.column);
          if (position = await (await this._workerManager.withWorker()).textualSuggest(models, model === null || model === void 0 ? void 0 : model.word, config)) {
            return {duration:position.duration, suggestions:position.words.map(word => ({kind:18, label:word, insertText:word, range:{insert, replace}}))};
          }
        }
      }
    }
  }
  class WorkerManager extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(modelService, languageConfigurationService) {
      super();
      this.languageConfigurationService = languageConfigurationService;
      this._modelService = modelService;
      this._editorWorkerClient = null;
      this._lastWorkerUsedTime = (new Date()).getTime();
      this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js.WindowIntervalTimer()).cancelAndSet(() => this._checkStopIdleWorker(), 15E4, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_window_DOT_js.$window);
      this._register(this._modelService.onModelRemoved(_ => this._checkStopEmptyWorker()));
    }
    dispose() {
      this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
      super.dispose();
    }
    _checkStopEmptyWorker() {
      this._editorWorkerClient && this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
    }
    _checkStopIdleWorker() {
      this._editorWorkerClient && (new Date()).getTime() - this._lastWorkerUsedTime > 3E5 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
    }
    withWorker() {
      this._lastWorkerUsedTime = (new Date()).getTime();
      this._editorWorkerClient || (this._editorWorkerClient = new EditorWorkerClient(this._modelService, !1, "editorWorkerService", this.languageConfigurationService));
      return Promise.resolve(this._editorWorkerClient);
    }
  }
  class EditorModelManager extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(proxy, modelService, keepIdleModels) {
      super();
      this._syncedModels = Object.create(null);
      this._syncedModelsLastUsedTime = Object.create(null);
      this._proxy = proxy;
      this._modelService = modelService;
      keepIdleModels || (proxy = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.IntervalTimer(), proxy.cancelAndSet(() => this._checkStopModelSync(), 3E4), this._register(proxy));
    }
    dispose() {
      for (const modelUrl in this._syncedModels) {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this._syncedModels[modelUrl]);
      }
      this._syncedModels = Object.create(null);
      this._syncedModelsLastUsedTime = Object.create(null);
      super.dispose();
    }
    ensureSyncedResources(resources, forceLargeModels) {
      for (const resource of resources) {
        resources = resource.toString(), this._syncedModels[resources] || this._beginModelSync(resource, forceLargeModels), this._syncedModels[resources] && (this._syncedModelsLastUsedTime[resources] = (new Date()).getTime());
      }
    }
    _checkStopModelSync() {
      const currentTime = (new Date()).getTime(), toRemove = [];
      for (const modelUrl in this._syncedModelsLastUsedTime) {
        currentTime - this._syncedModelsLastUsedTime[modelUrl] > 6E4 && toRemove.push(modelUrl);
      }
      for (const e of toRemove) {
        this._stopModelSync(e);
      }
    }
    _beginModelSync(resource, forceLargeModels) {
      const model = this._modelService.getModel(resource);
      if (model && (forceLargeModels || !model.isTooLargeForSyncing())) {
        var modelUrl = resource.toString();
        this._proxy.acceptNewModel({url:model.uri.toString(), lines:model.getLinesContent(), EOL:model.getEOL(), versionId:model.getVersionId()});
        resource = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
        resource.add(model.onDidChangeContent(e => {
          this._proxy.acceptModelChanged(modelUrl.toString(), e);
        }));
        resource.add(model.onWillDispose(() => {
          this._stopModelSync(modelUrl);
        }));
        resource.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
          this._proxy.acceptRemovedModel(modelUrl);
        }));
        this._syncedModels[modelUrl] = resource;
      }
    }
    _stopModelSync(modelUrl) {
      const toDispose = this._syncedModels[modelUrl];
      delete this._syncedModels[modelUrl];
      delete this._syncedModelsLastUsedTime[modelUrl];
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.dispose)(toDispose);
    }
  }
  class SynchronousWorkerClient {
    constructor(instance) {
      this._instance = instance;
      this._proxyObj = Promise.resolve(this._instance);
    }
    dispose() {
      this._instance.dispose();
    }
    getProxyObject() {
      return this._proxyObj;
    }
  }
  class EditorWorkerHost {
    constructor(workerClient) {
      this._workerClient = workerClient;
    }
    fhr(method, args) {
      return this._workerClient.fhr(method, args);
    }
  }
  class EditorWorkerClient extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(modelService, keepIdleModels, label, languageConfigurationService) {
      super();
      this.languageConfigurationService = languageConfigurationService;
      this._disposed = !1;
      this._modelService = modelService;
      this._keepIdleModels = keepIdleModels;
      this._workerFactory = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_defaultWorkerFactory_DOT_js.DefaultWorkerFactory(label);
      this._modelManager = this._worker = null;
    }
    fhr(method, args) {
      throw Error("Not implemented!");
    }
    _getOrCreateWorker() {
      if (!this._worker) {
        try {
          this._worker = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_worker_SLASH_simpleWorker_DOT_js.SimpleWorkerClient(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new EditorWorkerHost(this)));
        } catch (err) {
          (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_worker_SLASH_simpleWorker_DOT_js.logOnceWebWorkerWarning)(err), this._worker = new SynchronousWorkerClient(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorSimpleWorker_DOT_js.EditorSimpleWorker(new EditorWorkerHost(this), null));
        }
      }
      return this._worker;
    }
    _getProxy() {
      return this._getOrCreateWorker().getProxyObject().then(void 0, err => {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_worker_SLASH_simpleWorker_DOT_js.logOnceWebWorkerWarning)(err);
        this._worker = new SynchronousWorkerClient(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorSimpleWorker_DOT_js.EditorSimpleWorker(new EditorWorkerHost(this), null));
        return this._getOrCreateWorker().getProxyObject();
      });
    }
    _getOrCreateModelManager(proxy) {
      this._modelManager || (this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, this._keepIdleModels)));
      return this._modelManager;
    }
    async _withSyncedResources(resources, forceLargeModels = !1) {
      return this._disposed ? Promise.reject((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.canceled)()) : this._getProxy().then(proxy => {
        this._getOrCreateModelManager(proxy).ensureSyncedResources(resources, forceLargeModels);
        return proxy;
      });
    }
    computedUnicodeHighlights(uri, options, range) {
      return this._withSyncedResources([uri]).then(proxy => proxy.computeUnicodeHighlights(uri.toString(), options, range));
    }
    computeDiff(original, modified, options, algorithm) {
      return this._withSyncedResources([original, modified], !0).then(proxy => proxy.computeDiff(original.toString(), modified.toString(), options, algorithm));
    }
    computeMoreMinimalEdits(resource, edits, pretty) {
      return this._withSyncedResources([resource]).then(proxy => proxy.computeMoreMinimalEdits(resource.toString(), edits, pretty));
    }
    computeLinks(resource) {
      return this._withSyncedResources([resource]).then(proxy => proxy.computeLinks(resource.toString()));
    }
    computeDefaultDocumentColors(resource) {
      return this._withSyncedResources([resource]).then(proxy => proxy.computeDefaultDocumentColors(resource.toString()));
    }
    async textualSuggest(resources, leadingWord, wordDefRegExp) {
      const proxy = await this._withSyncedResources(resources), wordDef = wordDefRegExp.source;
      wordDefRegExp = wordDefRegExp.flags;
      return proxy.textualSuggest(resources.map(r => r.toString()), leadingWord, wordDef, wordDefRegExp);
    }
    computeWordRanges(resource, range) {
      return this._withSyncedResources([resource]).then(proxy => {
        var model = this._modelService.getModel(resource);
        if (!model) {
          return Promise.resolve(null);
        }
        model = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
        return proxy.computeWordRanges(resource.toString(), range, model.source, model.flags);
      });
    }
    navigateValueSet(resource, range, up) {
      return this._withSyncedResources([resource]).then(proxy => {
        var model = this._modelService.getModel(resource);
        if (!model) {
          return null;
        }
        model = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
        return proxy.navigateValueSet(resource.toString(), range, up, model.source, model.flags);
      });
    }
    dispose() {
      super.dispose();
      this._disposed = !0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$services$editorWorkerService.js.map
