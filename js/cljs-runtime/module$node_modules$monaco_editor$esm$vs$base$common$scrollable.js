shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$scrollable = function(require, module, exports) {
  function createEaseOutCubic(from, to) {
    const delta = to - from;
    return function(completion) {
      return from + delta * (1 - Math.pow(1 - completion, 3));
    };
  }
  function createComposed(a, b, cut) {
    return function(completion) {
      return completion < cut ? a(completion / cut) : b((completion - cut) / (1 - cut));
    };
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ScrollState:{enumerable:!0, get:function() {
    return ScrollState;
  }}, Scrollable:{enumerable:!0, get:function() {
    return Scrollable;
  }}, SmoothScrollingOperation:{enumerable:!0, get:function() {
    return SmoothScrollingOperation;
  }}, SmoothScrollingUpdate:{enumerable:!0, get:function() {
    return SmoothScrollingUpdate;
  }}});
  var require$_DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event");
  require = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  class ScrollState {
    constructor(_forceIntegerValues, width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
      this._forceIntegerValues = _forceIntegerValues;
      this._scrollStateBrand = void 0;
      this._forceIntegerValues && (width |= 0, scrollWidth |= 0, scrollLeft |= 0, height |= 0, scrollHeight |= 0, scrollTop |= 0);
      this.rawScrollLeft = scrollLeft;
      this.rawScrollTop = scrollTop;
      width < 0 && (width = 0);
      scrollLeft + width > scrollWidth && (scrollLeft = scrollWidth - width);
      scrollLeft < 0 && (scrollLeft = 0);
      height < 0 && (height = 0);
      scrollTop + height > scrollHeight && (scrollTop = scrollHeight - height);
      scrollTop < 0 && (scrollTop = 0);
      this.width = width;
      this.scrollWidth = scrollWidth;
      this.scrollLeft = scrollLeft;
      this.height = height;
      this.scrollHeight = scrollHeight;
      this.scrollTop = scrollTop;
    }
    equals(other) {
      return this.rawScrollLeft === other.rawScrollLeft && this.rawScrollTop === other.rawScrollTop && this.width === other.width && this.scrollWidth === other.scrollWidth && this.scrollLeft === other.scrollLeft && this.height === other.height && this.scrollHeight === other.scrollHeight && this.scrollTop === other.scrollTop;
    }
    withScrollDimensions(update, useRawScrollPositions) {
      return new ScrollState(this._forceIntegerValues, typeof update.width !== "undefined" ? update.width : this.width, typeof update.scrollWidth !== "undefined" ? update.scrollWidth : this.scrollWidth, useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, typeof update.height !== "undefined" ? update.height : this.height, typeof update.scrollHeight !== "undefined" ? update.scrollHeight : this.scrollHeight, useRawScrollPositions ? this.rawScrollTop : this.scrollTop);
    }
    withScrollPosition(update) {
      return new ScrollState(this._forceIntegerValues, this.width, this.scrollWidth, typeof update.scrollLeft !== "undefined" ? update.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof update.scrollTop !== "undefined" ? update.scrollTop : this.rawScrollTop);
    }
    createScrollEvent(previous, inSmoothScrolling) {
      return {inSmoothScrolling, oldWidth:previous.width, oldScrollWidth:previous.scrollWidth, oldScrollLeft:previous.scrollLeft, width:this.width, scrollWidth:this.scrollWidth, scrollLeft:this.scrollLeft, oldHeight:previous.height, oldScrollHeight:previous.scrollHeight, oldScrollTop:previous.scrollTop, height:this.height, scrollHeight:this.scrollHeight, scrollTop:this.scrollTop, widthChanged:this.width !== previous.width, scrollWidthChanged:this.scrollWidth !== previous.scrollWidth, scrollLeftChanged:this.scrollLeft !== 
      previous.scrollLeft, heightChanged:this.height !== previous.height, scrollHeightChanged:this.scrollHeight !== previous.scrollHeight, scrollTopChanged:this.scrollTop !== previous.scrollTop};
    }
  }
  class Scrollable extends require.Disposable {
    constructor(options) {
      super();
      this._scrollableBrand = void 0;
      this._onScroll = this._register(new require$_DOT__SLASH_event_DOT_js.Emitter());
      this.onScroll = this._onScroll.event;
      this._smoothScrollDuration = options.smoothScrollDuration;
      this._scheduleAtNextAnimationFrame = options.scheduleAtNextAnimationFrame;
      this._state = new ScrollState(options.forceIntegerValues, 0, 0, 0, 0, 0, 0);
      this._smoothScrolling = null;
    }
    dispose() {
      this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null);
      super.dispose();
    }
    setSmoothScrollDuration(smoothScrollDuration) {
      this._smoothScrollDuration = smoothScrollDuration;
    }
    validateScrollPosition(scrollPosition) {
      return this._state.withScrollPosition(scrollPosition);
    }
    getScrollDimensions() {
      return this._state;
    }
    setScrollDimensions(dimensions, useRawScrollPositions) {
      var _a;
      dimensions = this._state.withScrollDimensions(dimensions, useRawScrollPositions);
      this._setState(dimensions, !!this._smoothScrolling);
      (_a = this._smoothScrolling) === null || _a === void 0 || _a.acceptScrollDimensions(this._state);
    }
    getFutureScrollPosition() {
      return this._smoothScrolling ? this._smoothScrolling.to : this._state;
    }
    getCurrentScrollPosition() {
      return this._state;
    }
    setScrollPositionNow(update) {
      update = this._state.withScrollPosition(update);
      this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null);
      this._setState(update, !1);
    }
    setScrollPositionSmooth(update, reuseAnimation) {
      if (this._smoothScrollDuration === 0) {
        return this.setScrollPositionNow(update);
      }
      if (this._smoothScrolling) {
        update = {scrollLeft:typeof update.scrollLeft === "undefined" ? this._smoothScrolling.to.scrollLeft : update.scrollLeft, scrollTop:typeof update.scrollTop === "undefined" ? this._smoothScrolling.to.scrollTop : update.scrollTop};
        update = this._state.withScrollPosition(update);
        if (this._smoothScrolling.to.scrollLeft === update.scrollLeft && this._smoothScrolling.to.scrollTop === update.scrollTop) {
          return;
        }
        reuseAnimation = reuseAnimation ? new SmoothScrollingOperation(this._smoothScrolling.from, update, this._smoothScrolling.startTime, this._smoothScrolling.duration) : this._smoothScrolling.combine(this._state, update, this._smoothScrollDuration);
        this._smoothScrolling.dispose();
        this._smoothScrolling = reuseAnimation;
      } else {
        reuseAnimation = this._state.withScrollPosition(update), this._smoothScrolling = SmoothScrollingOperation.start(this._state, reuseAnimation, this._smoothScrollDuration);
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
    hasPendingScrollAnimation() {
      return !!this._smoothScrolling;
    }
    _performSmoothScrolling() {
      if (this._smoothScrolling) {
        var update = this._smoothScrolling.tick(), newState = this._state.withScrollPosition(update);
        this._setState(newState, !0);
        this._smoothScrolling && (update.isDone ? (this._smoothScrolling.dispose(), this._smoothScrolling = null) : this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
          this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
        }));
      }
    }
    _setState(newState, inSmoothScrolling) {
      const oldState = this._state;
      oldState.equals(newState) || (this._state = newState, this._onScroll.fire(this._state.createScrollEvent(oldState, inSmoothScrolling)));
    }
  }
  class SmoothScrollingUpdate {
    constructor(scrollLeft, scrollTop, isDone) {
      this.scrollLeft = scrollLeft;
      this.scrollTop = scrollTop;
      this.isDone = isDone;
    }
  }
  class SmoothScrollingOperation {
    constructor(from, to, startTime, duration) {
      this.from = from;
      this.to = to;
      this.duration = duration;
      this.startTime = startTime;
      this.animationFrameDisposable = null;
      this._initAnimations();
    }
    _initAnimations() {
      this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
      this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
    }
    _initAnimation(from, to, viewportSize) {
      if (Math.abs(from - to) > 2.5 * viewportSize) {
        let stop1;
        from < to ? (stop1 = from + 0.75 * viewportSize, viewportSize = to - 0.75 * viewportSize) : (stop1 = from - 0.75 * viewportSize, viewportSize = to + 0.75 * viewportSize);
        return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(viewportSize, to), 0.33);
      }
      return createEaseOutCubic(from, to);
    }
    dispose() {
      this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
    }
    acceptScrollDimensions(state) {
      this.to = state.withScrollPosition(this.to);
      this._initAnimations();
    }
    tick() {
      return this._tick(Date.now());
    }
    _tick(now) {
      var completion = (now - this.startTime) / this.duration;
      return completion < 1 ? (now = this.scrollLeft(completion), completion = this.scrollTop(completion), new SmoothScrollingUpdate(now, completion, !1)) : new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, !0);
    }
    combine(from, to, duration) {
      return SmoothScrollingOperation.start(from, to, duration);
    }
    static start(from, to, duration) {
      duration += 10;
      const startTime = Date.now() - 10;
      return new SmoothScrollingOperation(from, to, startTime, duration);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$scrollable.js.map
