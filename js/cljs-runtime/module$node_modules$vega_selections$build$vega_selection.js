shadow$provide.module$node_modules$vega_selections$build$vega_selection = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega_util$build$vega_util"), require("module$node_modules$vega_expression$build$vega_expression")) : typeof define === "function" && define.amd ? define(["exports", "vega-util", "vega-expression"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega));
  })(this, function(exports, vegaUtil, vegaExpression) {
    function ascending(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    function descending(a, b) {
      return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
    function zero() {
      return 0;
    }
    function intern_get({_intern, _key}, value) {
      _key = _key(value);
      return _intern.has(_key) ? _intern.get(_key) : value;
    }
    function intern_set({_intern, _key}, value) {
      _key = _key(value);
      if (_intern.has(_key)) {
        return _intern.get(_key);
      }
      _intern.set(_key, value);
      return value;
    }
    function intern_delete({_intern, _key}, value) {
      _key = _key(value);
      _intern.has(_key) && (value = _intern.get(_key), _intern.delete(_key));
      return value;
    }
    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }
    function set(values) {
      return values instanceof InternSet ? values : new InternSet(values);
    }
    function getter(f) {
      f.getter && f.getter[SELECTION_GETTER] || (f.getter = vegaUtil.field(f.field), f.getter[SELECTION_GETTER] = !0);
      return f.getter;
    }
    function testPoint(datum, entry) {
      var fields = entry.fields;
      entry = entry.values;
      for (var n = fields.length, i = 0, dval, f; i < n; ++i) {
        if (f = fields[i], dval = getter(f)(datum), vegaUtil.isDate(dval) && (dval = vegaUtil.toNumber(dval)), vegaUtil.isDate(entry[i]) && (entry[i] = vegaUtil.toNumber(entry[i])), vegaUtil.isArray(entry[i]) && vegaUtil.isDate(entry[i][0]) && (entry[i] = entry[i].map(vegaUtil.toNumber)), f.type === "E") {
          if (vegaUtil.isArray(entry[i]) ? !entry[i].includes(dval) : dval !== entry[i]) {
            return !1;
          }
        } else {
          if (f.type === "R") {
            if (!vegaUtil.inrange(dval, entry[i])) {
              return !1;
            }
          } else if (f.type === "R-RE") {
            if (!vegaUtil.inrange(dval, entry[i], !0, !1)) {
              return !1;
            }
          } else if (f.type === "R-E") {
            if (!vegaUtil.inrange(dval, entry[i], !1, !1)) {
              return !1;
            }
          } else if (f.type === "R-LE") {
            if (!vegaUtil.inrange(dval, entry[i], !1, !0)) {
              return !1;
            }
          } else if (f.type === "E-LT") {
            if (dval >= entry[i]) {
              return !1;
            }
          } else if (f.type === "E-LTE") {
            if (dval > entry[i]) {
              return !1;
            }
          } else if (f.type === "E-GT") {
            if (dval <= entry[i]) {
              return !1;
            }
          } else if (f.type === "E-GTE") {
            if (dval < entry[i]) {
              return !1;
            }
          } else if (f.type === "E-VALID") {
            if (dval === null || isNaN(dval)) {
              return !1;
            }
          } else if (f.type === "E-ONE" && entry[i].indexOf(dval) === -1) {
            return !1;
          }
        }
      }
      return !0;
    }
    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern:{value:new Map()}, _key:{value:key}});
        if (values != null) {
          for (const value of values) {
            this.add(value);
          }
        }
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }
    const SELECTION_GETTER = Symbol("vega_selection_getter"), $selectionId = vegaUtil.field("_vgsid_"), bisect = function(f) {
      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) {
            return hi;
          }
          do {
            const mid = lo + hi >>> 1;
            compare2(a[mid], x) < 0 ? lo = mid + 1 : hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      let compare1, compare2, delta;
      f.length !== 2 ? (compare1 = ascending, compare2 = (d, x) => ascending(f(d), x), delta = (d, x) => f(d) - x) : (compare1 = f === ascending || f === descending ? f : zero, delta = compare2 = f);
      return {left, center:function(a, x, lo = 0, hi = a.length) {
        hi = left(a, x, lo, hi - 1);
        return hi > lo && delta(a[hi - 1], x) > -delta(a[hi], x) ? hi - 1 : hi;
      }, right:function(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) {
            return hi;
          }
          do {
            const mid = lo + hi >>> 1;
            compare2(a[mid], x) <= 0 ? lo = mid + 1 : hi = mid;
          } while (lo < hi);
        }
        return lo;
      }};
    }($selectionId), bisectLeft = bisect.left, bisectRight = bisect.right;
    var ops = {_vgsid__union:function(...others) {
      const set = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }, _vgsid__intersect:function(values, ...others) {
      values = new InternSet(values);
      others = others.map(set);
      a: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue a;
          }
        }
      }
      return values;
    }, E_union:function(base, value) {
      if (!base.length) {
        return value;
      }
      for (var i = 0, n = value.length; i < n; ++i) {
        base.includes(value[i]) || base.push(value[i]);
      }
      return base;
    }, E_intersect:function(base, value) {
      return base.length ? base.filter(v => value.includes(v)) : value;
    }, R_union:function(base, value) {
      var lo = vegaUtil.toNumber(value[0]), hi = vegaUtil.toNumber(value[1]);
      lo > hi && (lo = value[1], hi = value[0]);
      if (!base.length) {
        return [lo, hi];
      }
      base[0] > lo && (base[0] = lo);
      base[1] < hi && (base[1] = hi);
      return base;
    }, R_intersect:function(base, value) {
      var lo = vegaUtil.toNumber(value[0]), hi = vegaUtil.toNumber(value[1]);
      lo > hi && (lo = value[1], hi = value[0]);
      if (!base.length) {
        return [lo, hi];
      }
      if (hi < base[0] || base[1] < lo) {
        return [];
      }
      base[0] < lo && (base[0] = lo);
      base[1] > hi && (base[1] = hi);
      return base;
    }};
    exports.selectionIdTest = function(name, datum, op) {
      var data = this.context.data[name];
      name = data ? data.values.value : [];
      data = data ? data["index:unit"] && data["index:unit"].value : void 0;
      op = op === "intersect";
      datum = $selectionId(datum);
      const index = bisectLeft(name, datum);
      if (index === name.length || $selectionId(name[index]) !== datum) {
        return !1;
      }
      if (data && op) {
        if (data.size === 1) {
          return !0;
        }
        if (bisectRight(name, datum) - index < data.size) {
          return !1;
        }
      }
      return !0;
    };
    exports.selectionResolve = function(name, op, isMulti, vl5) {
      name = (name = this.context.data[name]) ? name.values.value : [];
      for (var resolved = {}, multiRes = {}, types = {}, entry, fields, values, unit, field, resUnit, n = name.length, i = 0, j, m; i < n; ++i) {
        if (entry = name[i], unit = entry.unit, fields = entry.fields, values = entry.values, fields && values) {
          j = 0;
          for (m = fields.length; j < m; ++j) {
            field = fields[j], entry = resolved[field.field] || (resolved[field.field] = {}), resUnit = entry[unit] || (entry[unit] = []), types[field.field] = field = field.type.charAt(0), field = ops[`${field}_union`], entry[unit] = field(resUnit, vegaUtil.array(values[j]));
          }
          isMulti && (resUnit = multiRes[unit] || (multiRes[unit] = []), resUnit.push(vegaUtil.array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {})));
        } else {
          field = "_vgsid_", values = $selectionId(entry), entry = resolved[field] || (resolved[field] = {}), resUnit = entry[unit] || (entry[unit] = []), resUnit.push(values), isMulti && (resUnit = multiRes[unit] || (multiRes[unit] = []), resUnit.push({_vgsid_:values}));
        }
      }
      op = op || "union";
      resolved._vgsid_ ? resolved._vgsid_ = ops[`${"_vgsid_"}_${op}`](...Object.values(resolved._vgsid_)) : Object.keys(resolved).forEach(field => {
        resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === void 0 ? curr : ops[`${types[field]}_${op}`](acc, curr));
      });
      name = Object.keys(multiRes);
      isMulti && name.length && (resolved[vl5 ? "vlPoint" : "vlMulti"] = op === "union" ? {or:name.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])} : {and:name.map(k => ({or:multiRes[k]}))});
      return resolved;
    };
    exports.selectionTest = function(name, datum, op) {
      var data = this.context.data[name];
      name = data ? data.values.value : [];
      data = data ? data["index:unit"] && data["index:unit"].value : void 0;
      op = op === "intersect";
      for (var n = name.length, i = 0, entry, miss, count, unit; i < n; ++i) {
        if (entry = name[i], data && op) {
          if (miss = miss || {}, count = miss[unit = entry.unit] || 0, count !== -1) {
            entry = testPoint(datum, entry);
            miss[unit] = entry ? -1 : ++count;
            if (entry && data.size === 1) {
              return !0;
            }
            if (!entry && count === data.get(unit).count) {
              return !1;
            }
          }
        } else {
          if (entry = testPoint(datum, entry), op ^ entry) {
            return entry;
          }
        }
      }
      return n && op;
    };
    exports.selectionTuples = function(array, base) {
      vegaUtil.isArray(array) || vegaUtil.error("First argument to selectionTuples must be an array.");
      vegaUtil.isObject(base) || vegaUtil.error("Second argument to selectionTuples must be an object.");
      return array.map(x => vegaUtil.extend(base.fields ? {values:base.fields.map(f => getter(f)(x.datum))} : {_vgsid_:$selectionId(x.datum)}, base));
    };
    exports.selectionVisitor = function(name, args, scope, params) {
      args[0].type !== vegaExpression.Literal && vegaUtil.error("First argument to selection functions must be a string literal.");
      name = args[0].value;
      args = args.length >= 2 && vegaUtil.peek(args).value;
      const dataName = ":" + name;
      args !== "intersect" || vegaUtil.hasOwnProperty(params, "@unit") || (params["@unit"] = scope.getData(name).indataRef(scope, "unit"));
      vegaUtil.hasOwnProperty(params, dataName) || (params[dataName] = scope.getData(name).tuplesRef());
    };
  });
};

//# sourceMappingURL=module$node_modules$vega_selections$build$vega_selection.js.map
