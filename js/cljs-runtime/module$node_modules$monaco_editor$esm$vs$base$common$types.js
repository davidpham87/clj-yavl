shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$types = function(require, module, exports) {
  function isString(str) {
    return typeof str === "string";
  }
  function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
  }
  function isTypedArray(obj) {
    const TypedArray = Object.getPrototypeOf(Uint8Array);
    return typeof obj === "object" && obj instanceof TypedArray;
  }
  function isNumber(obj) {
    return typeof obj === "number" && !isNaN(obj);
  }
  function isIterable(obj) {
    return !!obj && typeof obj[Symbol.iterator] === "function";
  }
  function isBoolean(obj) {
    return obj === !0 || obj === !1;
  }
  function isUndefined(obj) {
    return typeof obj === "undefined";
  }
  function isDefined(arg) {
    return !isUndefinedOrNull(arg);
  }
  function isUndefinedOrNull(obj) {
    return isUndefined(obj) || obj === null;
  }
  function assertType(condition, type) {
    if (!condition) {
      throw Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
    }
  }
  function assertIsDefined(arg) {
    if (isUndefinedOrNull(arg)) {
      throw Error("Assertion Failed: argument is undefined or null");
    }
    return arg;
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function validateConstraints(args, constraints) {
    const len = Math.min(args.length, constraints.length);
    for (let i = 0; i < len; i++) {
      validateConstraint(args[i], constraints[i]);
    }
  }
  function validateConstraint(arg, constraint) {
    if (isString(constraint)) {
      if (typeof arg !== constraint) {
        throw Error(`argument does not match constraint: typeof ${constraint}`);
      }
    } else if (isFunction(constraint)) {
      try {
        if (arg instanceof constraint) {
          return;
        }
      } catch (_a) {
      }
      if (!(!isUndefinedOrNull(arg) && arg.constructor === constraint || constraint.length === 1 && constraint.call(void 0, arg) === !0)) {
        throw Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor \x3d\x3d\x3d constraint, nor constraint(arg) \x3d\x3d\x3d true");
      }
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, assertIsDefined:{enumerable:!0, get:function() {
    return assertIsDefined;
  }}, assertType:{enumerable:!0, get:function() {
    return assertType;
  }}, isBoolean:{enumerable:!0, get:function() {
    return isBoolean;
  }}, isDefined:{enumerable:!0, get:function() {
    return isDefined;
  }}, isFunction:{enumerable:!0, get:function() {
    return isFunction;
  }}, isIterable:{enumerable:!0, get:function() {
    return isIterable;
  }}, isNumber:{enumerable:!0, get:function() {
    return isNumber;
  }}, isObject:{enumerable:!0, get:function() {
    return isObject;
  }}, isString:{enumerable:!0, get:function() {
    return isString;
  }}, isTypedArray:{enumerable:!0, get:function() {
    return isTypedArray;
  }}, isUndefined:{enumerable:!0, get:function() {
    return isUndefined;
  }}, isUndefinedOrNull:{enumerable:!0, get:function() {
    return isUndefinedOrNull;
  }}, validateConstraint:{enumerable:!0, get:function() {
    return validateConstraint;
  }}, validateConstraints:{enumerable:!0, get:function() {
    return validateConstraints;
  }}});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$types.js.map
