shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$linesLayout = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, EditorWhitespace:{enumerable:!0, get:function() {
    return EditorWhitespace;
  }}, LinesLayout:{enumerable:!0, get:function() {
    return LinesLayout;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  class PendingChanges {
    constructor() {
      this._hasPending = !1;
      this._inserts = [];
      this._changes = [];
      this._removes = [];
    }
    insert(x) {
      this._hasPending = !0;
      this._inserts.push(x);
    }
    change(x) {
      this._hasPending = !0;
      this._changes.push(x);
    }
    remove(x) {
      this._hasPending = !0;
      this._removes.push(x);
    }
    mustCommit() {
      return this._hasPending;
    }
    commit(linesLayout) {
      if (this._hasPending) {
        var inserts = this._inserts, changes = this._changes, removes = this._removes;
        this._hasPending = !1;
        this._inserts = [];
        this._changes = [];
        this._removes = [];
        linesLayout._commitPendingChanges(inserts, changes, removes);
      }
    }
  }
  class EditorWhitespace {
    constructor(id, afterLineNumber, ordinal, height, minWidth) {
      this.id = id;
      this.afterLineNumber = afterLineNumber;
      this.ordinal = ordinal;
      this.height = height;
      this.minWidth = minWidth;
      this.prefixSum = 0;
    }
  }
  class LinesLayout {
    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {
      this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);
      this._pendingChanges = new PendingChanges();
      this._lastWhitespaceId = 0;
      this._arr = [];
      this._minWidth = this._prefixSumValidIndex = -1;
      this._lineCount = lineCount;
      this._lineHeight = lineHeight;
      this._paddingTop = paddingTop;
      this._paddingBottom = paddingBottom;
    }
    static findInsertionIndex(arr, afterLineNumber, ordinal) {
      let low = 0, high = arr.length;
      for (; low < high;) {
        const mid = low + high >>> 1;
        afterLineNumber === arr[mid].afterLineNumber ? ordinal < arr[mid].ordinal ? high = mid : low = mid + 1 : afterLineNumber < arr[mid].afterLineNumber ? high = mid : low = mid + 1;
      }
      return low;
    }
    setLineHeight(lineHeight) {
      this._checkPendingChanges();
      this._lineHeight = lineHeight;
    }
    setPadding(paddingTop, paddingBottom) {
      this._paddingTop = paddingTop;
      this._paddingBottom = paddingBottom;
    }
    onFlushed(lineCount) {
      this._checkPendingChanges();
      this._lineCount = lineCount;
    }
    changeWhitespace(callback) {
      let hadAChange = !1;
      try {
        callback({insertWhitespace:(afterLineNumber, ordinal, heightInPx, minWidth) => {
          hadAChange = !0;
          const id = this._instanceId + ++this._lastWhitespaceId;
          this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber | 0, ordinal | 0, heightInPx | 0, minWidth | 0));
          return id;
        }, changeOneWhitespace:(id, newAfterLineNumber, newHeight) => {
          hadAChange = !0;
          this._pendingChanges.change({id, newAfterLineNumber:newAfterLineNumber | 0, newHeight:newHeight | 0});
        }, removeWhitespace:id => {
          hadAChange = !0;
          this._pendingChanges.remove({id});
        }});
      } finally {
        this._pendingChanges.commit(this);
      }
      return hadAChange;
    }
    _commitPendingChanges(inserts, changes, removes) {
      if (inserts.length > 0 || removes.length > 0) {
        this._minWidth = -1;
      }
      if (inserts.length + changes.length + removes.length <= 1) {
        for (const insert of inserts) {
          this._insertWhitespace(insert);
        }
        for (const change of changes) {
          this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);
        }
        for (var remove of removes) {
          inserts = this._findWhitespaceIndex(remove.id), inserts !== -1 && this._removeWhitespace(inserts);
        }
      } else {
        var toRemove = new Set();
        for (const remove of removes) {
          toRemove.add(remove.id);
        }
        var toChange = new Map();
        for (const change of changes) {
          toChange.set(change.id, change);
        }
        remove = whitespaces => {
          const result = [];
          for (const whitespace of whitespaces) {
            toRemove.has(whitespace.id) || (toChange.has(whitespace.id) && (whitespaces = toChange.get(whitespace.id), whitespace.afterLineNumber = whitespaces.newAfterLineNumber, whitespace.height = whitespaces.newHeight), result.push(whitespace));
          }
          return result;
        };
        inserts = remove(this._arr).concat(remove(inserts));
        inserts.sort((a, b) => a.afterLineNumber === b.afterLineNumber ? a.ordinal - b.ordinal : a.afterLineNumber - b.afterLineNumber);
        this._arr = inserts;
        this._prefixSumValidIndex = -1;
      }
    }
    _checkPendingChanges() {
      this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
    }
    _insertWhitespace(whitespace) {
      const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);
      this._arr.splice(insertIndex, 0, whitespace);
      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);
    }
    _findWhitespaceIndex(id) {
      const arr = this._arr;
      for (let i = 0, len = arr.length; i < len; i++) {
        if (arr[i].id === id) {
          return i;
        }
      }
      return -1;
    }
    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {
      id = this._findWhitespaceIndex(id);
      id !== -1 && (this._arr[id].height !== newHeight && (this._arr[id].height = newHeight, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, id - 1)), this._arr[id].afterLineNumber !== newAfterLineNumber && (newHeight = this._arr[id], this._removeWhitespace(id), newHeight.afterLineNumber = newAfterLineNumber, this._insertWhitespace(newHeight)));
    }
    _removeWhitespace(removeIndex) {
      this._arr.splice(removeIndex, 1);
      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);
    }
    onLinesDeleted(fromLineNumber, toLineNumber) {
      this._checkPendingChanges();
      fromLineNumber |= 0;
      toLineNumber |= 0;
      this._lineCount -= toLineNumber - fromLineNumber + 1;
      for (let i = 0, len = this._arr.length; i < len; i++) {
        const afterLineNumber = this._arr[i].afterLineNumber;
        fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber ? this._arr[i].afterLineNumber = fromLineNumber - 1 : afterLineNumber > toLineNumber && (this._arr[i].afterLineNumber -= toLineNumber - fromLineNumber + 1);
      }
    }
    onLinesInserted(fromLineNumber, toLineNumber) {
      this._checkPendingChanges();
      fromLineNumber |= 0;
      toLineNumber |= 0;
      this._lineCount += toLineNumber - fromLineNumber + 1;
      for (let i = 0, len = this._arr.length; i < len; i++) {
        fromLineNumber <= this._arr[i].afterLineNumber && (this._arr[i].afterLineNumber += toLineNumber - fromLineNumber + 1);
      }
    }
    getWhitespacesTotalHeight() {
      this._checkPendingChanges();
      return this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
    }
    getWhitespacesAccumulatedHeight(index) {
      this._checkPendingChanges();
      index |= 0;
      var startIndex = Math.max(0, this._prefixSumValidIndex + 1);
      startIndex === 0 && (this._arr[0].prefixSum = this._arr[0].height, startIndex++);
      for (; startIndex <= index; startIndex++) {
        this._arr[startIndex].prefixSum = this._arr[startIndex - 1].prefixSum + this._arr[startIndex].height;
      }
      this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);
      return this._arr[index].prefixSum;
    }
    getLinesTotalHeight() {
      this._checkPendingChanges();
      const linesHeight = this._lineHeight * this._lineCount, whitespacesHeight = this.getWhitespacesTotalHeight();
      return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;
    }
    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {
      this._checkPendingChanges();
      lineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber | 0);
      return lineNumber === -1 ? 0 : this.getWhitespacesAccumulatedHeight(lineNumber);
    }
    _findLastWhitespaceBeforeLineNumber(lineNumber) {
      lineNumber |= 0;
      const arr = this._arr;
      let low = 0, high = arr.length - 1;
      for (; low <= high;) {
        const mid = low + ((high - low | 0) / 2 | 0) | 0;
        if (arr[mid].afterLineNumber < lineNumber) {
          if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {
            return mid;
          }
          low = mid + 1 | 0;
        } else {
          high = mid - 1 | 0;
        }
      }
      return -1;
    }
    _findFirstWhitespaceAfterLineNumber(lineNumber) {
      lineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber | 0) + 1;
      return lineNumber < this._arr.length ? lineNumber : -1;
    }
    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {
      this._checkPendingChanges();
      return this._findFirstWhitespaceAfterLineNumber(lineNumber | 0);
    }
    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = !1) {
      this._checkPendingChanges();
      lineNumber |= 0;
      let previousLinesHeight;
      previousLinesHeight = lineNumber > 1 ? this._lineHeight * (lineNumber - 1) : 0;
      lineNumber = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));
      return previousLinesHeight + lineNumber + this._paddingTop;
    }
    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = !1) {
      this._checkPendingChanges();
      lineNumber |= 0;
      const previousLinesHeight = this._lineHeight * lineNumber;
      lineNumber = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));
      return previousLinesHeight + lineNumber + this._paddingTop;
    }
    getWhitespaceMinWidth() {
      this._checkPendingChanges();
      if (this._minWidth === -1) {
        let minWidth = 0;
        for (let i = 0, len = this._arr.length; i < len; i++) {
          minWidth = Math.max(minWidth, this._arr[i].minWidth);
        }
        this._minWidth = minWidth;
      }
      return this._minWidth;
    }
    isAfterLines(verticalOffset) {
      this._checkPendingChanges();
      const totalHeight = this.getLinesTotalHeight();
      return verticalOffset > totalHeight;
    }
    isInTopPadding(verticalOffset) {
      if (this._paddingTop === 0) {
        return !1;
      }
      this._checkPendingChanges();
      return verticalOffset < this._paddingTop;
    }
    isInBottomPadding(verticalOffset) {
      if (this._paddingBottom === 0) {
        return !1;
      }
      this._checkPendingChanges();
      const totalHeight = this.getLinesTotalHeight();
      return verticalOffset >= totalHeight - this._paddingBottom;
    }
    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {
      this._checkPendingChanges();
      verticalOffset |= 0;
      if (verticalOffset < 0) {
        return 1;
      }
      const linesCount = this._lineCount | 0, lineHeight = this._lineHeight;
      let minLineNumber = 1, maxLineNumber = linesCount;
      for (; minLineNumber < maxLineNumber;) {
        const midLineNumber = (minLineNumber + maxLineNumber) / 2 | 0, midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;
        if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {
          minLineNumber = midLineNumber + 1;
        } else {
          if (verticalOffset >= midLineNumberVerticalOffset) {
            return midLineNumber;
          }
          maxLineNumber = midLineNumber;
        }
      }
      return minLineNumber > linesCount ? linesCount : minLineNumber;
    }
    getLinesViewportData(verticalOffset1, verticalOffset2) {
      this._checkPendingChanges();
      verticalOffset1 |= 0;
      verticalOffset2 |= 0;
      const lineHeight = this._lineHeight, startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0, startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;
      let endLineNumber = this._lineCount | 0;
      var whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0, whitespaceCount = this.getWhitespacesCount() | 0;
      let currentWhitespaceAfterLineNumber;
      if (whitespaceIndex === -1) {
        whitespaceIndex = whitespaceCount;
        currentWhitespaceAfterLineNumber = endLineNumber + 1;
        var currentWhitespaceHeight = 0;
      } else {
        currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0, currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
      }
      let currentVerticalOffset = startLineNumberVerticalOffset, currentLineRelativeOffset = currentVerticalOffset, bigNumbersDelta = 0;
      startLineNumberVerticalOffset >= 500000 && (bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / 500000) * 500000, bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight, currentLineRelativeOffset -= bigNumbersDelta);
      const linesOffsets = [], verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;
      let centeredLineNumber = -1;
      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        if (centeredLineNumber === -1) {
          const currentLineTop = currentVerticalOffset, currentLineBottom = currentVerticalOffset + lineHeight;
          if (currentLineTop <= verticalCenter && verticalCenter < currentLineBottom || currentLineTop > verticalCenter) {
            centeredLineNumber = lineNumber;
          }
        }
        currentVerticalOffset += lineHeight;
        linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;
        for (currentLineRelativeOffset += lineHeight; currentWhitespaceAfterLineNumber === lineNumber;) {
          currentLineRelativeOffset += currentWhitespaceHeight, currentVerticalOffset += currentWhitespaceHeight, whitespaceIndex++, whitespaceIndex >= whitespaceCount ? currentWhitespaceAfterLineNumber = endLineNumber + 1 : (currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0, currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0);
        }
        if (currentVerticalOffset >= verticalOffset2) {
          endLineNumber = lineNumber;
          break;
        }
      }
      centeredLineNumber === -1 && (centeredLineNumber = endLineNumber);
      whitespaceIndex = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;
      whitespaceCount = startLineNumber;
      currentWhitespaceHeight = endLineNumber;
      whitespaceCount < currentWhitespaceHeight && startLineNumberVerticalOffset < verticalOffset1 && whitespaceCount++;
      whitespaceCount < currentWhitespaceHeight && whitespaceIndex + lineHeight > verticalOffset2 && currentWhitespaceHeight--;
      return {bigNumbersDelta, startLineNumber, endLineNumber, relativeVerticalOffset:linesOffsets, centeredLineNumber, completelyVisibleStartLineNumber:whitespaceCount, completelyVisibleEndLineNumber:currentWhitespaceHeight};
    }
    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {
      this._checkPendingChanges();
      whitespaceIndex |= 0;
      var afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);
      afterLineNumber = afterLineNumber >= 1 ? this._lineHeight * afterLineNumber : 0;
      whitespaceIndex = whitespaceIndex > 0 ? this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1) : 0;
      return afterLineNumber + whitespaceIndex + this._paddingTop;
    }
    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {
      this._checkPendingChanges();
      verticalOffset |= 0;
      let minWhitespaceIndex = 0, maxWhitespaceIndex = this.getWhitespacesCount() - 1;
      if (maxWhitespaceIndex < 0) {
        return -1;
      }
      var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex), maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);
      if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {
        return -1;
      }
      for (; minWhitespaceIndex < maxWhitespaceIndex;) {
        maxWhitespaceVerticalOffset = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);
        maxWhitespaceHeight = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceVerticalOffset);
        const midWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceVerticalOffset);
        if (verticalOffset >= maxWhitespaceHeight + midWhitespaceHeight) {
          minWhitespaceIndex = maxWhitespaceVerticalOffset + 1;
        } else {
          if (verticalOffset >= maxWhitespaceHeight) {
            return maxWhitespaceVerticalOffset;
          }
          maxWhitespaceIndex = maxWhitespaceVerticalOffset;
        }
      }
      return minWhitespaceIndex;
    }
    getWhitespaceAtVerticalOffset(verticalOffset) {
      this._checkPendingChanges();
      verticalOffset |= 0;
      var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);
      if (candidateIndex < 0 || candidateIndex >= this.getWhitespacesCount()) {
        return null;
      }
      const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);
      if (candidateTop > verticalOffset) {
        return null;
      }
      verticalOffset = this.getHeightForWhitespaceIndex(candidateIndex);
      const candidateId = this.getIdForWhitespaceIndex(candidateIndex);
      candidateIndex = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);
      return {id:candidateId, afterLineNumber:candidateIndex, verticalOffset:candidateTop, height:verticalOffset};
    }
    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {
      this._checkPendingChanges();
      verticalOffset2 |= 0;
      var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1 | 0);
      verticalOffset1 = this.getWhitespacesCount() - 1;
      if (startIndex < 0) {
        return [];
      }
      const result = [];
      for (; startIndex <= verticalOffset1; startIndex++) {
        const top = this.getVerticalOffsetForWhitespaceIndex(startIndex), height = this.getHeightForWhitespaceIndex(startIndex);
        if (top >= verticalOffset2) {
          break;
        }
        result.push({id:this.getIdForWhitespaceIndex(startIndex), afterLineNumber:this.getAfterLineNumberForWhitespaceIndex(startIndex), verticalOffset:top, height});
      }
      return result;
    }
    getWhitespaces() {
      this._checkPendingChanges();
      return this._arr.slice(0);
    }
    getWhitespacesCount() {
      this._checkPendingChanges();
      return this._arr.length;
    }
    getIdForWhitespaceIndex(index) {
      this._checkPendingChanges();
      return this._arr[index | 0].id;
    }
    getAfterLineNumberForWhitespaceIndex(index) {
      this._checkPendingChanges();
      return this._arr[index | 0].afterLineNumber;
    }
    getHeightForWhitespaceIndex(index) {
      this._checkPendingChanges();
      return this._arr[index | 0].height;
    }
  }
  LinesLayout.INSTANCE_COUNT = 0;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$linesLayout.js.map
