shadow$provide.module$node_modules$monaco_editor$esm$vs$nls = function(require, module, exports) {
  function _format(message, args) {
    message = args.length === 0 ? message : message.replace(/\{(\d+)\}/g, (match, rest) => {
      rest = args[rest[0]];
      if (typeof rest === "string") {
        match = rest;
      } else if (typeof rest === "number" || typeof rest === "boolean" || rest === void 0 || rest === null) {
        match = String(rest);
      }
      return match;
    });
    isPseudo && (message = "［" + message.replace(/[aouei]/g, "$\x26$\x26") + "］");
    return message;
  }
  function findLanguageForModule(config, name) {
    return (name = config[name]) ? name : (name = config["*"]) ? name : null;
  }
  function endWithSlash(path) {
    return path.charAt(path.length - 1) === "/" ? path : path + "/";
  }
  async function getMessagesFromTranslationsService(translationServiceUrl, language, name) {
    translationServiceUrl = endWithSlash(translationServiceUrl) + endWithSlash(language) + "vscode/" + endWithSlash(name);
    translationServiceUrl = await fetch(translationServiceUrl);
    if (translationServiceUrl.ok) {
      return await translationServiceUrl.json();
    }
    throw Error(`${translationServiceUrl.status} - ${translationServiceUrl.statusText}`);
  }
  function createScopedLocalize(scope) {
    return function(idx, defaultValue) {
      const restArgs = Array.prototype.slice.call(arguments, 2);
      return _format(scope[idx], restArgs);
    };
  }
  function createScopedLocalize2(scope) {
    return (idx, defaultValue, ...args) => ({value:_format(scope[idx], args), original:_format(defaultValue, args)});
  }
  function localize(data, message, ...args) {
    return _format(message, args);
  }
  function localize2(data, message, ...args) {
    data = _format(message, args);
    return {value:data, original:data};
  }
  function getConfiguredDefaultLocale(_) {
  }
  function setPseudoTranslation(value) {
    isPseudo = value;
  }
  function create(key, data) {
    var _a;
    return {localize:createScopedLocalize(data[key]), localize2:createScopedLocalize2(data[key]), getConfiguredDefaultLocale:(_a = data.getConfiguredDefaultLocale) !== null && _a !== void 0 ? _a : _ => {
    }};
  }
  function load(name, req, load, config) {
    var _a;
    const pluginConfig = (_a = config["vs/nls"]) !== null && _a !== void 0 ? _a : {};
    if (!name || name.length === 0) {
      return load({localize, localize2, getConfiguredDefaultLocale:() => {
        var _a;
        return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a["*"];
      }});
    }
    const language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;
    config = language === null || language === "i-default";
    let suffix = ".nls";
    config || (suffix = suffix + "." + language);
    const messagesLoaded = messages => {
      Array.isArray(messages) ? (messages.localize = createScopedLocalize(messages), messages.localize2 = createScopedLocalize2(messages)) : (messages.localize = createScopedLocalize(messages[name]), messages.localize2 = createScopedLocalize2(messages[name]));
      messages.getConfiguredDefaultLocale = () => {
        var _a;
        return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a["*"];
      };
      load(messages);
    };
    typeof pluginConfig.loadBundle === "function" ? pluginConfig.loadBundle(name, language, (err, messages) => {
      err ? req([name + ".nls"], messagesLoaded) : messagesLoaded(messages);
    }) : pluginConfig.translationServiceUrl && !config ? (async() => {
      var _a;
      try {
        const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, language, name);
        return messagesLoaded(messages);
      } catch (err) {
        if (!language.includes("-")) {
          return console.error(err), req([name + ".nls"], messagesLoaded);
        }
        try {
          const genericLanguage = language.split("-")[0], messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, genericLanguage, name);
          (_a = pluginConfig.availableLanguages) !== null && _a !== void 0 ? _a : pluginConfig.availableLanguages = {};
          pluginConfig.availableLanguages["*"] = genericLanguage;
          return messagesLoaded(messages);
        } catch (err) {
          return console.error(err), req([name + ".nls"], messagesLoaded);
        }
      }
    })() : req([name + suffix], messagesLoaded, err => {
      suffix === ".nls" ? console.error("Failed trying to load default language strings", err) : (console.error(`Failed to load message bundle for language ${language}. Falling back to the default language:`, err), req([name + ".nls"], messagesLoaded));
    });
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, create:{enumerable:!0, get:function() {
    return create;
  }}, getConfiguredDefaultLocale:{enumerable:!0, get:function() {
    return getConfiguredDefaultLocale;
  }}, load:{enumerable:!0, get:function() {
    return load;
  }}, localize:{enumerable:!0, get:function() {
    return localize;
  }}, localize2:{enumerable:!0, get:function() {
    return localize2;
  }}, setPseudoTranslation:{enumerable:!0, get:function() {
    return setPseudoTranslation;
  }}});
  let isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo\x3dtrue") >= 0;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$nls.js.map
