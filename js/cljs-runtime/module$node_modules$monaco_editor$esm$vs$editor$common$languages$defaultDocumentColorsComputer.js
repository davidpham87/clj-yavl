shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$defaultDocumentColorsComputer = function(require, module, exports) {
  function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
      ((captureGroups = Number(captureGroup)) || captureGroups === 0 && captureGroup.replace(/\s/g, "") !== "") && values.push(captureGroups);
    }
    return values;
  }
  function _findRange(model, match) {
    const index = match.index;
    match = match[0].length;
    if (index) {
      return model = model.positionAt(index), {startLineNumber:model.lineNumber, startColumn:model.column, endLineNumber:model.lineNumber, endColumn:model.column + match};
    }
  }
  function _findHexColorInformation(range, hexValue) {
    if (range && (hexValue = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.Format.CSS.parseHex(hexValue))) {
      return {range, color:{red:hexValue.rgba.r / 255, blue:hexValue.rgba.b / 255, green:hexValue.rgba.g / 255, alpha:hexValue.rgba.a}};
    }
  }
  function _findRGBColorInformation(range, matches, isAlpha) {
    if (range && matches.length === 1) {
      return matches = matches[0].values(), matches = _parseCaptureGroups(matches), {range, color:{red:matches[0] / 255, blue:matches[2] / 255, green:matches[1] / 255, alpha:isAlpha ? matches[3] : 1}};
    }
  }
  function _findHSLColorInformation(range, matches, isAlpha) {
    if (range && matches.length === 1) {
      return matches = matches[0].values(), matches = _parseCaptureGroups(matches), isAlpha = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.HSLA(matches[0], matches[1] / 100, matches[2] / 100, isAlpha ? matches[3] : 1)), {range, color:{red:isAlpha.rgba.r / 255, blue:isAlpha.rgba.b / 255, green:isAlpha.rgba.g / 255, alpha:isAlpha.rgba.a}};
    }
  }
  function _findMatches(model, regex) {
    return typeof model === "string" ? [...model.matchAll(regex)] : model.findMatches(regex);
  }
  function computeColors(model) {
    const result = [];
    var initialValidationMatches = _findMatches(model, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
    if (initialValidationMatches.length > 0) {
      for (const initialMatch of initialValidationMatches) {
        var initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== void 0);
        initialValidationMatches = initialCaptureGroups[1];
        initialCaptureGroups = initialCaptureGroups[2];
        if (!initialCaptureGroups) {
          continue;
        }
        let colorInformation;
        initialValidationMatches === "rgb" ? colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(initialCaptureGroups, /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm), !1) : initialValidationMatches === "rgba" ? colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(initialCaptureGroups, /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm), 
        !0) : initialValidationMatches === "hsl" ? colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(initialCaptureGroups, /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm), !1) : initialValidationMatches === "hsla" ? colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(initialCaptureGroups, /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm), 
        !0) : initialValidationMatches === "#" && (colorInformation = _findHexColorInformation(_findRange(model, initialMatch), initialValidationMatches + initialCaptureGroups));
        colorInformation && result.push(colorInformation);
      }
    }
    return result;
  }
  function computeDefaultDocumentColors(model) {
    return model && typeof model.getValue === "function" && typeof model.positionAt === "function" ? computeColors(model) : [];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, computeDefaultDocumentColors:{enumerable:!0, get:function() {
    return computeDefaultDocumentColors;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$color");
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$defaultDocumentColorsComputer.js.map
