shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseTokensStore = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SparseTokensStore:{enumerable:!0, get:function() {
    return SparseTokensStore;
  }}});
  var arrays = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens");
  class SparseTokensStore {
    constructor(languageIdCodec) {
      this._pieces = [];
      this._isComplete = !1;
      this._languageIdCodec = languageIdCodec;
    }
    flush() {
      this._pieces = [];
      this._isComplete = !1;
    }
    isEmpty() {
      return this._pieces.length === 0;
    }
    set(pieces, isComplete) {
      this._pieces = pieces || [];
      this._isComplete = isComplete;
    }
    setPartial(_range, pieces) {
      var range = _range;
      if (pieces.length > 0) {
        range = pieces[0].getRange();
        var _lastRange = pieces[pieces.length - 1].getRange();
        if (!range || !_lastRange) {
          return _range;
        }
        range = _range.plusRange(range).plusRange(_lastRange);
      }
      _range = null;
      for (let i = 0, len = this._pieces.length; i < len; i++) {
        _lastRange = this._pieces[i];
        if (_lastRange.endLineNumber < range.startLineNumber) {
          continue;
        }
        if (_lastRange.startLineNumber > range.endLineNumber) {
          _range = _range || {index:i};
          break;
        }
        _lastRange.removeTokens(range);
        if (_lastRange.isEmpty()) {
          this._pieces.splice(i, 1);
          i--;
          len--;
          continue;
        }
        if (_lastRange.endLineNumber < range.startLineNumber) {
          continue;
        }
        if (_lastRange.startLineNumber > range.endLineNumber) {
          _range = _range || {index:i};
          continue;
        }
        const [a, b] = _lastRange.split(range);
        a.isEmpty() ? _range = _range || {index:i} : b.isEmpty() || (this._pieces.splice(i, 1, a, b), i++, len++, _range = _range || {index:i});
      }
      _range = _range || {index:this._pieces.length};
      pieces.length > 0 && (this._pieces = arrays.arrayInsert(this._pieces, _range.index, pieces));
      return range;
    }
    isComplete() {
      return this._isComplete;
    }
    addSparseTokens(lineNumber, aTokens) {
      if (aTokens.getLineContent().length === 0) {
        return aTokens;
      }
      var pieces = this._pieces;
      if (pieces.length === 0) {
        return aTokens;
      }
      var pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);
      lineNumber = pieces[pieceIndex].getLineTokens(lineNumber);
      if (!lineNumber) {
        return aTokens;
      }
      pieces = aTokens.getCount();
      pieceIndex = lineNumber.getCount();
      let aIndex = 0;
      const result = [];
      let resultLen = 0, lastEndOffset = 0;
      const emitToken = (endOffset, metadata) => {
        endOffset !== lastEndOffset && (lastEndOffset = endOffset, result[resultLen++] = endOffset, result[resultLen++] = metadata);
      };
      for (let bIndex = 0; bIndex < pieceIndex; bIndex++) {
        const bStartCharacter = lineNumber.getStartCharacter(bIndex), bEndCharacter = lineNumber.getEndCharacter(bIndex), bMetadata = lineNumber.getMetadata(bIndex), bMask = ((bMetadata & 1 ? 2048 : 0) | (bMetadata & 2 ? 4096 : 0) | (bMetadata & 4 ? 8192 : 0) | (bMetadata & 8 ? 16384 : 0) | (bMetadata & 16 ? 16744448 : 0) | (bMetadata & 32 ? 4278190080 : 0)) >>> 0, aMask = ~bMask >>> 0;
        for (; aIndex < pieces && aTokens.getEndOffset(aIndex) <= bStartCharacter;) {
          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex)), aIndex++;
        }
        for (aIndex < pieces && aTokens.getStartOffset(aIndex) < bStartCharacter && emitToken(bStartCharacter, aTokens.getMetadata(aIndex)); aIndex < pieces && aTokens.getEndOffset(aIndex) < bEndCharacter;) {
          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask), aIndex++;
        }
        aIndex < pieces ? (emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask), aTokens.getEndOffset(aIndex) === bEndCharacter && aIndex++) : emitToken(bEndCharacter, aTokens.getMetadata(Math.min(Math.max(0, aIndex - 1), pieces - 1)) & aMask | bMetadata & bMask);
      }
      for (; aIndex < pieces;) {
        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex)), aIndex++;
      }
      return new require$_DOT__SLASH_lineTokens_DOT_js.LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);
    }
    static _findFirstPieceWithLine(pieces, lineNumber) {
      let low = 0, high = pieces.length - 1;
      for (; low < high;) {
        let mid = low + Math.floor((high - low) / 2);
        if (pieces[mid].endLineNumber < lineNumber) {
          low = mid + 1;
        } else if (pieces[mid].startLineNumber > lineNumber) {
          high = mid - 1;
        } else {
          for (; mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber;) {
            mid--;
          }
          return mid;
        }
      }
      return low;
    }
    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {
      for (const piece of this._pieces) {
        piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseTokensStore.js.map
