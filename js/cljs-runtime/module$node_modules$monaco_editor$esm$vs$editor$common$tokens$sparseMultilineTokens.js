shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseMultilineTokens = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SparseLineTokens:{enumerable:!0, get:function() {
    return SparseLineTokens;
  }}, SparseMultilineTokens:{enumerable:!0, get:function() {
    return SparseMultilineTokens;
  }}});
  var require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$eolCounter");
  class SparseMultilineTokens {
    static create(startLineNumber, tokens) {
      return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));
    }
    get startLineNumber() {
      return this._startLineNumber;
    }
    get endLineNumber() {
      return this._endLineNumber;
    }
    constructor(startLineNumber, tokens) {
      this._startLineNumber = startLineNumber;
      this._tokens = tokens;
      this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
    }
    toString() {
      return this._tokens.toString(this._startLineNumber);
    }
    _updateEndLineNumber() {
      this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
    }
    isEmpty() {
      return this._tokens.isEmpty();
    }
    getLineTokens(lineNumber) {
      return this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber ? this._tokens.getLineTokens(lineNumber - this._startLineNumber) : null;
    }
    getRange() {
      const deltaRange = this._tokens.getRange();
      return deltaRange ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn) : deltaRange;
    }
    removeTokens(range) {
      this._startLineNumber += this._tokens.removeTokens(range.startLineNumber - this._startLineNumber, range.startColumn - 1, range.endLineNumber - this._startLineNumber, range.endColumn - 1);
      this._updateEndLineNumber();
    }
    split(range) {
      const [a, b, bDeltaLine] = this._tokens.split(range.startLineNumber - this._startLineNumber, range.startColumn - 1, range.endLineNumber - this._startLineNumber, range.endColumn - 1);
      return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];
    }
    applyEdit(range, text) {
      const [eolCount, firstLineLength, lastLineLength] = (0,require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(text);
      this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0);
    }
    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {
      this._acceptDeleteRange(range);
      this._acceptInsertText(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);
      this._updateEndLineNumber();
    }
    _acceptDeleteRange(range) {
      if (range.startLineNumber !== range.endLineNumber || range.startColumn !== range.endColumn) {
        var firstLineIndex = range.startLineNumber - this._startLineNumber, lastLineIndex = range.endLineNumber - this._startLineNumber;
        if (lastLineIndex < 0) {
          this._startLineNumber -= lastLineIndex - firstLineIndex;
        } else {
          var tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();
          firstLineIndex >= tokenMaxDeltaLine + 1 || (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1 ? (this._startLineNumber = 0, this._tokens.clear()) : firstLineIndex < 0 ? (this._startLineNumber -= -firstLineIndex, this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1)) : this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1));
        }
      }
    }
    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {
      if (eolCount !== 0 || firstLineLength !== 0) {
        var lineIndex = position.lineNumber - this._startLineNumber;
        if (lineIndex < 0) {
          this._startLineNumber += eolCount;
        } else {
          var tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();
          lineIndex >= tokenMaxDeltaLine + 1 || this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);
        }
      }
    }
  }
  class SparseMultilineTokensStorage {
    constructor(tokens) {
      this._tokens = tokens;
      this._tokenCount = tokens.length / 4;
    }
    toString(startLineNumber) {
      const pieces = [];
      for (let i = 0; i < this._tokenCount; i++) {
        pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
      }
      return `[${pieces.join(",")}]`;
    }
    getMaxDeltaLine() {
      const tokenCount = this._getTokenCount();
      return tokenCount === 0 ? -1 : this._getDeltaLine(tokenCount - 1);
    }
    getRange() {
      var tokenCount = this._getTokenCount();
      if (tokenCount === 0) {
        return null;
      }
      const startChar = this._getStartCharacter(0), maxDeltaLine = this._getDeltaLine(tokenCount - 1);
      tokenCount = this._getEndCharacter(tokenCount - 1);
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(0, startChar + 1, maxDeltaLine, tokenCount + 1);
    }
    _getTokenCount() {
      return this._tokenCount;
    }
    _getDeltaLine(tokenIndex) {
      return this._tokens[4 * tokenIndex];
    }
    _getStartCharacter(tokenIndex) {
      return this._tokens[4 * tokenIndex + 1];
    }
    _getEndCharacter(tokenIndex) {
      return this._tokens[4 * tokenIndex + 2];
    }
    isEmpty() {
      return this._getTokenCount() === 0;
    }
    getLineTokens(deltaLine) {
      var low = 0;
      let high = this._getTokenCount() - 1;
      for (; low < high;) {
        const mid = low + Math.floor((high - low) / 2);
        var midDeltaLine = this._getDeltaLine(mid);
        if (midDeltaLine < deltaLine) {
          low = mid + 1;
        } else if (midDeltaLine > deltaLine) {
          high = mid - 1;
        } else {
          for (midDeltaLine = mid; midDeltaLine > low && this._getDeltaLine(midDeltaLine - 1) === deltaLine;) {
            midDeltaLine--;
          }
          for (low = mid; low < high && this._getDeltaLine(low + 1) === deltaLine;) {
            low++;
          }
          return new SparseLineTokens(this._tokens.subarray(4 * midDeltaLine, 4 * low + 4));
        }
      }
      return this._getDeltaLine(low) === deltaLine ? new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4)) : null;
    }
    clear() {
      this._tokenCount = 0;
    }
    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {
      const tokens = this._tokens, tokenCount = this._tokenCount;
      let newTokenCount = 0, hasDeletedTokens = !1, firstDeltaLine = 0;
      for (let i = 0; i < tokenCount; i++) {
        var srcOffset = 4 * i;
        const tokenDeltaLine = tokens[srcOffset], tokenStartCharacter = tokens[srcOffset + 1], tokenEndCharacter = tokens[srcOffset + 2];
        srcOffset = tokens[srcOffset + 3];
        if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {
          hasDeletedTokens = !0;
        } else {
          newTokenCount === 0 && (firstDeltaLine = tokenDeltaLine);
          if (hasDeletedTokens) {
            const destOffset = 4 * newTokenCount;
            tokens[destOffset] = tokenDeltaLine - firstDeltaLine;
            tokens[destOffset + 1] = tokenStartCharacter;
            tokens[destOffset + 2] = tokenEndCharacter;
            tokens[destOffset + 3] = srcOffset;
          }
          newTokenCount++;
        }
      }
      this._tokenCount = newTokenCount;
      return firstDeltaLine;
    }
    split(startDeltaLine, startChar, endDeltaLine, endChar) {
      const tokens = this._tokens, tokenCount = this._tokenCount, aTokens = [], bTokens = [];
      let destTokens = aTokens, destOffset = 0, destFirstDeltaLine = 0;
      for (let i = 0; i < tokenCount; i++) {
        var srcOffset = 4 * i;
        const tokenDeltaLine = tokens[srcOffset], tokenStartCharacter = tokens[srcOffset + 1], tokenEndCharacter = tokens[srcOffset + 2];
        srcOffset = tokens[srcOffset + 3];
        if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {
          if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {
            continue;
          } else {
            destTokens !== bTokens && (destTokens = bTokens, destOffset = 0, destFirstDeltaLine = tokenDeltaLine);
          }
        }
        destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;
        destTokens[destOffset++] = tokenStartCharacter;
        destTokens[destOffset++] = tokenEndCharacter;
        destTokens[destOffset++] = srcOffset;
      }
      return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];
    }
    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {
      const tokens = this._tokens, tokenCount = this._tokenCount, deletedLineCount = endDeltaLine - startDeltaLine;
      let newTokenCount = 0, hasDeletedTokens = !1;
      for (let i = 0; i < tokenCount; i++) {
        var srcOffset = 4 * i;
        let tokenDeltaLine = tokens[srcOffset], tokenStartCharacter = tokens[srcOffset + 1], tokenEndCharacter = tokens[srcOffset + 2];
        srcOffset = tokens[srcOffset + 3];
        if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {
          newTokenCount++;
          continue;
        } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {
          tokenEndCharacter = tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter ? tokenEndCharacter - (endCharacter - startCharacter) : startCharacter;
        } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {
          if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
            tokenEndCharacter -= endCharacter - startCharacter;
          } else {
            hasDeletedTokens = !0;
            continue;
          }
        } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {
          if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
            tokenDeltaLine = startDeltaLine, tokenStartCharacter = startCharacter, tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);
          } else {
            hasDeletedTokens = !0;
            continue;
          }
        } else if (tokenDeltaLine > endDeltaLine) {
          if (deletedLineCount === 0 && !hasDeletedTokens) {
            newTokenCount = tokenCount;
            break;
          }
          tokenDeltaLine -= deletedLineCount;
        } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {
          horizontalShiftForFirstLineTokens && tokenDeltaLine === 0 && (tokenStartCharacter += horizontalShiftForFirstLineTokens, tokenEndCharacter += horizontalShiftForFirstLineTokens), tokenDeltaLine -= deletedLineCount, tokenStartCharacter -= endCharacter - startCharacter, tokenEndCharacter -= endCharacter - startCharacter;
        } else {
          throw Error("Not possible!");
        }
        const destOffset = 4 * newTokenCount;
        tokens[destOffset] = tokenDeltaLine;
        tokens[destOffset + 1] = tokenStartCharacter;
        tokens[destOffset + 2] = tokenEndCharacter;
        tokens[destOffset + 3] = srcOffset;
        newTokenCount++;
      }
      this._tokenCount = newTokenCount;
    }
    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {
      firstCharCode = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48 && firstCharCode <= 57 || firstCharCode >= 65 && firstCharCode <= 90 || firstCharCode >= 97 && firstCharCode <= 122);
      const tokens = this._tokens, tokenCount = this._tokenCount;
      for (let i = 0; i < tokenCount; i++) {
        const offset = 4 * i;
        let tokenDeltaLine = tokens[offset], tokenStartCharacter = tokens[offset + 1];
        var tokenEndCharacter = tokens[offset + 2];
        if (!(tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {
          if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {
            if (firstCharCode) {
              tokenEndCharacter += 1;
            } else {
              continue;
            }
          } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {
            tokenEndCharacter = eolCount === 0 ? tokenEndCharacter + firstLineLength : character;
          } else {
            if (tokenDeltaLine === deltaLine && tokenStartCharacter === character && firstCharCode) {
              continue;
            }
            tokenDeltaLine === deltaLine ? (tokenDeltaLine += eolCount, eolCount === 0 ? (tokenStartCharacter += firstLineLength, tokenEndCharacter += firstLineLength) : (tokenEndCharacter -= tokenStartCharacter, tokenStartCharacter = lastLineLength + (tokenStartCharacter - character), tokenEndCharacter = tokenStartCharacter + tokenEndCharacter)) : tokenDeltaLine += eolCount;
          }
          tokens[offset] = tokenDeltaLine;
          tokens[offset + 1] = tokenStartCharacter;
          tokens[offset + 2] = tokenEndCharacter;
        }
      }
    }
  }
  class SparseLineTokens {
    constructor(tokens) {
      this._tokens = tokens;
    }
    getCount() {
      return this._tokens.length / 4;
    }
    getStartCharacter(tokenIndex) {
      return this._tokens[4 * tokenIndex + 1];
    }
    getEndCharacter(tokenIndex) {
      return this._tokens[4 * tokenIndex + 2];
    }
    getMetadata(tokenIndex) {
      return this._tokens[4 * tokenIndex + 3];
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseMultilineTokens.js.map
