{
"version":3,
"file":"module$node_modules$vega_regression$build$vega_regression.js",
"lineCount":95,
"mappings":"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",
"sources":["node_modules/vega-regression/build/vega-regression.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vega_regression$build$vega_regression\"] = function(require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-statistics'), require('vega-dataflow'), require('vega-util')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-statistics', 'vega-dataflow', 'vega-util'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega));\n})(this, (function (exports, vegaStatistics, vegaDataflow, vegaUtil) { 'use strict';\n\n  function partition (data, groupby) {\n    var groups = [],\n      get = function (f) {\n        return f(t);\n      },\n      map,\n      i,\n      n,\n      t,\n      k,\n      g;\n\n    // partition data points into stack groups\n    if (groupby == null) {\n      groups.push(data);\n    } else {\n      for (map = {}, i = 0, n = data.length; i < n; ++i) {\n        t = data[i];\n        k = groupby.map(get);\n        g = map[k];\n        if (!g) {\n          map[k] = g = [];\n          g.dims = k;\n          groups.push(g);\n        }\n        g.push(t);\n      }\n    }\n    return groups;\n  }\n\n  /**\n   * Compute locally-weighted regression fits for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n   */\n  function Loess(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n  Loess.Definition = {\n    'type': 'Loess',\n    'metadata': {\n      'generates': true\n    },\n    'params': [{\n      'name': 'x',\n      'type': 'field',\n      'required': true\n    }, {\n      'name': 'y',\n      'type': 'field',\n      'required': true\n    }, {\n      'name': 'groupby',\n      'type': 'field',\n      'array': true\n    }, {\n      'name': 'bandwidth',\n      'type': 'number',\n      'default': 0.3\n    }, {\n      'name': 'as',\n      'type': 'string',\n      'array': true\n    }]\n  };\n  vegaUtil.inherits(Loess, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(vegaUtil.accessorName),\n          m = names.length,\n          as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\n          values = [];\n        groups.forEach(g => {\n          vegaStatistics.regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n            const t = {};\n            for (let i = 0; i < m; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = p[0];\n            t[as[1]] = p[1];\n            values.push(vegaDataflow.ingest(t));\n          });\n        });\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n      return out;\n    }\n  });\n\n  const Methods = {\n    constant: vegaStatistics.regressionConstant,\n    linear: vegaStatistics.regressionLinear,\n    log: vegaStatistics.regressionLog,\n    exp: vegaStatistics.regressionExp,\n    pow: vegaStatistics.regressionPow,\n    quad: vegaStatistics.regressionQuad,\n    poly: vegaStatistics.regressionPoly\n  };\n  const degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n  /**\n   * Compute regression fits for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\n   * @param {string} [params.method='linear'] - The regression method to apply.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n   * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n   */\n  function Regression(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n  Regression.Definition = {\n    'type': 'Regression',\n    'metadata': {\n      'generates': true\n    },\n    'params': [{\n      'name': 'x',\n      'type': 'field',\n      'required': true\n    }, {\n      'name': 'y',\n      'type': 'field',\n      'required': true\n    }, {\n      'name': 'groupby',\n      'type': 'field',\n      'array': true\n    }, {\n      'name': 'method',\n      'type': 'string',\n      'default': 'linear',\n      'values': Object.keys(Methods)\n    }, {\n      'name': 'order',\n      'type': 'number',\n      'default': 3\n    }, {\n      'name': 'extent',\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }, {\n      'name': 'params',\n      'type': 'boolean',\n      'default': false\n    }, {\n      'name': 'as',\n      'type': 'string',\n      'array': true\n    }]\n  };\n  vegaUtil.inherits(Regression, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(vegaUtil.accessorName),\n          method = _.method || 'linear',\n          order = _.order == null ? 3 : _.order,\n          dof = degreesOfFreedom(method, order),\n          as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\n          fit = Methods[method],\n          values = [];\n        let domain = _.extent;\n        if (!vegaUtil.hasOwnProperty(Methods, method)) {\n          vegaUtil.error('Invalid regression method: ' + method);\n        }\n        if (domain != null) {\n          if (method === 'log' && domain[0] <= 0) {\n            pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n            domain = null;\n          }\n        }\n        groups.forEach(g => {\n          const n = g.length;\n          if (n <= dof) {\n            pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n            return;\n          }\n          const model = fit(g, _.x, _.y, order);\n          if (_.params) {\n            // if parameter vectors requested return those\n            values.push(vegaDataflow.ingest({\n              keys: g.dims,\n              coef: model.coef,\n              rSquared: model.rSquared\n            }));\n            return;\n          }\n          const dom = domain || vegaUtil.extent(g, _.x),\n            add = p => {\n              const t = {};\n              for (let i = 0; i < names.length; ++i) {\n                t[names[i]] = g.dims[i];\n              }\n              t[as[0]] = p[0];\n              t[as[1]] = p[1];\n              values.push(vegaDataflow.ingest(t));\n            };\n          if (method === 'linear' || method === 'constant') {\n            // for linear or constant regression we only need the end points\n            dom.forEach(x => add([x, model.predict(x)]));\n          } else {\n            // otherwise return trend line sample points\n            vegaStatistics.sampleCurve(model.predict, dom, 25, 200).forEach(add);\n          }\n        });\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n      return out;\n    }\n  });\n\n  exports.loess = Loess;\n  exports.regression = Regression;\n\n}));\n\n};"],
"names":["shadow$provide","require","module","exports","global","factory","define","amd","globalThis","self","vega","vegaStatistics","vegaDataflow","vegaUtil","partition","data","groupby","groups","get","f","t","n","push","map","i","length","k","g","dims","Loess","params","Transform","call","Regression","Definition","inherits","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","accessorName","m","as","x","y","values","forEach","regressionLoess","bandwidth","p","ingest","rem","add","Methods","constant","regressionConstant","linear","regressionLinear","log","regressionLog","exp","regressionExp","pow","regressionPow","quad","regressionQuad","poly","regressionPoly","Object","keys","method","order","dof","fit","domain","extent","hasOwnProperty","error","dataflow","warn","model","coef","rSquared","dom","predict","sampleCurve","loess","regression"]
}
