shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLine = function(require, module, exports) {
  function createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {
    return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);
  }
  function getColumnOfNodeOffset(characterMapping, spanNode, offset) {
    const spanNodeTextContentLength = spanNode.textContent.length;
    let spanIndex = -1;
    for (; spanNode;) {
      spanNode = spanNode.previousSibling, spanIndex++;
    }
    return characterMapping.getColumn(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.DomPosition(spanIndex, offset), spanNodeTextContentLength);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ViewLine:{enumerable:!0, get:function() {
    return ViewLine;
  }}, ViewLineOptions:{enumerable:!0, get:function() {
    return ViewLineOptions;
  }}, getColumnOfNodeOffset:{enumerable:!0, get:function() {
    return getColumnOfNodeOffset;
  }}});
  module = require("module$node_modules$monaco_editor$esm$vs$base$browser$browser");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode");
  exports = require("module$node_modules$monaco_editor$esm$vs$base$common$platform");
  var require$_DOT__SLASH_rangeUtil_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$rangeUtil"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$renderingContext"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_lineDecorations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$lineDecorations"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$viewLineRenderer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_theme_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$theme"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$config$editorOptions");
  const canUseFastRenderedViewLine = exports.isNative ? !0 : exports.isLinux || module.isFirefox || module.isSafari ? !1 : !0;
  let monospaceAssumptionsAreValid = !0;
  class ViewLineOptions {
    constructor(config, themeType) {
      this.themeType = themeType;
      config = config.options;
      themeType = config.get(50);
      config.get(38) === "off" ? this.renderWhitespace = config.get(98) : this.renderWhitespace = "none";
      this.renderControlCharacters = config.get(93);
      this.spaceWidth = themeType.spaceWidth;
      this.middotWidth = themeType.middotWidth;
      this.wsmiddotWidth = themeType.wsmiddotWidth;
      this.useMonospaceOptimizations = themeType.isMonospace && !config.get(33);
      this.canUseHalfwidthRightwardsArrow = themeType.canUseHalfwidthRightwardsArrow;
      this.lineHeight = config.get(66);
      this.stopRenderingLineAfter = config.get(116);
      this.fontLigatures = config.get(51);
    }
    equals(other) {
      return this.themeType === other.themeType && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineHeight === other.lineHeight && this.stopRenderingLineAfter === 
      other.stopRenderingLineAfter && this.fontLigatures === other.fontLigatures;
    }
  }
  class ViewLine {
    constructor(options) {
      this._options = options;
      this._isMaybeInvalid = !0;
      this._renderedViewLine = null;
    }
    getDomNode() {
      return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
    }
    setDomNode(domNode) {
      if (this._renderedViewLine) {
        this._renderedViewLine.domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(domNode);
      } else {
        throw Error("I have no rendered view line to set the dom node to...");
      }
    }
    onContentChanged() {
      this._isMaybeInvalid = !0;
    }
    onTokensChanged() {
      this._isMaybeInvalid = !0;
    }
    onDecorationsChanged() {
      this._isMaybeInvalid = !0;
    }
    onOptionsChanged(newOptions) {
      this._isMaybeInvalid = !0;
      this._options = newOptions;
    }
    onSelectionChanged() {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_theme_DOT_js.isHighContrast)(this._options.themeType) || this._options.renderWhitespace === "selection" ? this._isMaybeInvalid = !0 : !1;
    }
    renderLine(lineNumber, deltaTop, viewportData, sb) {
      if (this._isMaybeInvalid === !1) {
        return !1;
      }
      this._isMaybeInvalid = !1;
      const lineData = viewportData.getViewLineRenderingData(lineNumber), options = this._options, actualInlineDecorations = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_lineDecorations_DOT_js.LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);
      let selectionsOnLine = null;
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_theme_DOT_js.isHighContrast)(options.themeType) || this._options.renderWhitespace === "selection") {
        viewportData = viewportData.selections;
        for (const selection of viewportData) {
          if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {
            continue;
          }
          viewportData = selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn;
          const endColumn = selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn;
          viewportData < endColumn && ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_theme_DOT_js.isHighContrast)(options.themeType) && actualInlineDecorations.push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_lineDecorations_DOT_js.LineDecoration(viewportData, endColumn, "inline-selected-text", 0)), this._options.renderWhitespace === "selection" && (selectionsOnLine ||= [], selectionsOnLine.push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.LineRange(viewportData - 
          1, endColumn - 1))));
        }
      }
      lineNumber = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, 
      options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.EditorFontLigatures.OFF, selectionsOnLine);
      if (this._renderedViewLine && this._renderedViewLine.input.equals(lineNumber)) {
        return !1;
      }
      sb.appendString('\x3cdiv style\x3d"top:');
      sb.appendString(String(deltaTop));
      sb.appendString("px;height:");
      sb.appendString(String(this._options.lineHeight));
      sb.appendString('px;" class\x3d"');
      sb.appendString(ViewLine.CLASS_NAME);
      sb.appendString('"\x3e');
      deltaTop = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.renderViewLine)(lineNumber, sb);
      sb.appendString("\x3c/div\x3e");
      sb = null;
      monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && deltaTop.containsForeignElements === 0 && (sb = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, lineNumber, deltaTop.characterMapping));
      sb ||= createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, lineNumber, deltaTop.characterMapping, deltaTop.containsRTL, deltaTop.containsForeignElements);
      this._renderedViewLine = sb;
      return !0;
    }
    layoutLine(lineNumber, deltaTop) {
      this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(deltaTop), this._renderedViewLine.domNode.setHeight(this._options.lineHeight));
    }
    getWidth(context) {
      return this._renderedViewLine ? this._renderedViewLine.getWidth(context) : 0;
    }
    getWidthIsFast() {
      return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
    }
    needsMonospaceFontCheck() {
      return this._renderedViewLine ? this._renderedViewLine instanceof FastRenderedViewLine : !1;
    }
    monospaceAssumptionsAreValid() {
      return this._renderedViewLine ? this._renderedViewLine instanceof FastRenderedViewLine ? this._renderedViewLine.monospaceAssumptionsAreValid() : monospaceAssumptionsAreValid : monospaceAssumptionsAreValid;
    }
    onMonospaceAssumptionsInvalidated() {
      this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
    }
    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {
      if (!this._renderedViewLine) {
        return null;
      }
      startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));
      endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));
      const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter;
      if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {
        return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.VisibleRanges(!0, [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.FloatHorizontalRange(this.getWidth(context), 0)]);
      }
      stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && (startColumn = stopRenderingLineAfter + 1);
      stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1 && (endColumn = stopRenderingLineAfter + 1);
      return (lineNumber = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context)) && lineNumber.length > 0 ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.VisibleRanges(!1, lineNumber) : null;
    }
    getColumnOfNodeOffset(spanNode, offset) {
      return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(spanNode, offset) : 1;
    }
  }
  ViewLine.CLASS_NAME = "view-line";
  class FastRenderedViewLine {
    constructor(domNode, renderLineInput, characterMapping) {
      this._cachedWidth = -1;
      this.domNode = domNode;
      this.input = renderLineInput;
      domNode = Math.floor(renderLineInput.lineContent.length / 300);
      if (domNode > 0) {
        this._keyColumnPixelOffsetCache = new Float32Array(domNode);
        for (let i = 0; i < domNode; i++) {
          this._keyColumnPixelOffsetCache[i] = -1;
        }
      } else {
        this._keyColumnPixelOffsetCache = null;
      }
      this._characterMapping = characterMapping;
      this._charWidth = renderLineInput.spaceWidth;
    }
    getWidth(context) {
      if (!this.domNode || this.input.lineContent.length < 300) {
        return context = this._characterMapping.getHorizontalOffset(this._characterMapping.length), Math.round(this._charWidth * context);
      }
      this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, context === null || context === void 0 || context.markDidDomLayout());
      return this._cachedWidth;
    }
    getWidthIsFast() {
      return this.input.lineContent.length < 300 || this._cachedWidth !== -1;
    }
    monospaceAssumptionsAreValid() {
      if (!this.domNode) {
        return monospaceAssumptionsAreValid;
      }
      if (this.input.lineContent.length < 300) {
        const expectedWidth = this.getWidth(null);
        Math.abs(expectedWidth - this.domNode.domNode.firstChild.offsetWidth) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), monospaceAssumptionsAreValid = !1);
      }
      return monospaceAssumptionsAreValid;
    }
    toSlowRenderedLine() {
      return createRenderedLine(this.domNode, this.input, this._characterMapping, !1, 0);
    }
    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {
      startColumn = this._getColumnPixelOffset(lineNumber, startColumn, context);
      lineNumber = this._getColumnPixelOffset(lineNumber, endColumn, context);
      return [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.FloatHorizontalRange(startColumn, lineNumber - startColumn)];
    }
    _getColumnPixelOffset(lineNumber, column, context) {
      if (column <= 300) {
        var horizontalOffset = this._characterMapping.getHorizontalOffset(column);
        return this._charWidth * horizontalOffset;
      }
      const keyColumnOrdinal = Math.floor((column - 1) / 300) - 1, keyColumn = (keyColumnOrdinal + 1) * 300 + 1;
      horizontalOffset = -1;
      this._keyColumnPixelOffsetCache && (horizontalOffset = this._keyColumnPixelOffsetCache[keyColumnOrdinal], horizontalOffset === -1 && (horizontalOffset = this._actualReadPixelOffset(lineNumber, keyColumn, context), this._keyColumnPixelOffsetCache[keyColumnOrdinal] = horizontalOffset));
      if (horizontalOffset === -1) {
        return horizontalOffset = this._characterMapping.getHorizontalOffset(column), this._charWidth * horizontalOffset;
      }
      lineNumber = this._characterMapping.getHorizontalOffset(keyColumn);
      column = this._characterMapping.getHorizontalOffset(column);
      return horizontalOffset + this._charWidth * (column - lineNumber);
    }
    _getReadingTarget(myDomNode) {
      return myDomNode.domNode.firstChild;
    }
    _actualReadPixelOffset(lineNumber, column, context) {
      if (!this.domNode) {
        return -1;
      }
      lineNumber = this._characterMapping.getDomPosition(column);
      return (context = require$_DOT__SLASH_rangeUtil_DOT_js.RangeUtil.readHorizontalRanges(this._getReadingTarget(this.domNode), lineNumber.partIndex, lineNumber.charIndex, lineNumber.partIndex, lineNumber.charIndex, context)) && context.length !== 0 ? context[0].left : -1;
    }
    getColumnOfNodeOffset(spanNode, offset) {
      return getColumnOfNodeOffset(this._characterMapping, spanNode, offset);
    }
  }
  class RenderedViewLine {
    constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {
      this.domNode = domNode;
      this.input = renderLineInput;
      this._characterMapping = characterMapping;
      this._isWhitespaceOnly = /^\s*$/.test(renderLineInput.lineContent);
      this._containsForeignElements = containsForeignElements;
      this._cachedWidth = -1;
      this._pixelOffsetCache = null;
      if (!containsRTL || this._characterMapping.length === 0) {
        this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
        for (let column = 0, len = this._characterMapping.length; column <= len; column++) {
          this._pixelOffsetCache[column] = -1;
        }
      }
    }
    _getReadingTarget(myDomNode) {
      return myDomNode.domNode.firstChild;
    }
    getWidth(context) {
      if (!this.domNode) {
        return 0;
      }
      this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, context === null || context === void 0 || context.markDidDomLayout());
      return this._cachedWidth;
    }
    getWidthIsFast() {
      return this._cachedWidth === -1 ? !1 : !0;
    }
    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {
      if (!this.domNode) {
        return null;
      }
      if (this._pixelOffsetCache !== null) {
        startColumn = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);
        if (startColumn === -1) {
          return null;
        }
        lineNumber = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);
        return lineNumber === -1 ? null : [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.FloatHorizontalRange(startColumn, lineNumber - startColumn)];
      }
      return this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);
    }
    _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {
      return startColumn === endColumn ? (domNode = this._readPixelOffset(domNode, lineNumber, startColumn, context), domNode === -1 ? null : [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.FloatHorizontalRange(domNode, 0)]) : this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);
    }
    _readPixelOffset(domNode, lineNumber, column, context) {
      if (this._characterMapping.length === 0) {
        if (this._containsForeignElements === 0 || this._containsForeignElements === 2) {
          return 0;
        }
        if (this._containsForeignElements === 1) {
          return this.getWidth(context);
        }
        column = this._getReadingTarget(domNode);
        return column.firstChild ? (context.markDidDomLayout(), column.firstChild.offsetWidth) : 0;
      }
      if (this._pixelOffsetCache !== null) {
        const cachedPixelOffset = this._pixelOffsetCache[column];
        if (cachedPixelOffset !== -1) {
          return cachedPixelOffset;
        }
        context = this._actualReadPixelOffset(domNode, lineNumber, column, context);
        return this._pixelOffsetCache[column] = context;
      }
      return this._actualReadPixelOffset(domNode, lineNumber, column, context);
    }
    _actualReadPixelOffset(domNode, lineNumber, column, context) {
      if (this._characterMapping.length === 0) {
        return (column = require$_DOT__SLASH_rangeUtil_DOT_js.RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context)) && column.length !== 0 ? column[0].left : -1;
      }
      if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0) {
        return this.getWidth(context);
      }
      lineNumber = this._characterMapping.getDomPosition(column);
      domNode = require$_DOT__SLASH_rangeUtil_DOT_js.RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), lineNumber.partIndex, lineNumber.charIndex, lineNumber.partIndex, lineNumber.charIndex, context);
      if (!domNode || domNode.length === 0) {
        return -1;
      }
      domNode = domNode[0].left;
      return this.input.isBasicASCII && (column = this._characterMapping.getHorizontalOffset(column), column = Math.round(this.input.spaceWidth * column), Math.abs(column - domNode) <= 1) ? column : domNode;
    }
    _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {
      if (startColumn === 1 && endColumn === this._characterMapping.length) {
        return [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.FloatHorizontalRange(0, this.getWidth(context))];
      }
      startColumn = this._characterMapping.getDomPosition(startColumn);
      endColumn = this._characterMapping.getDomPosition(endColumn);
      return require$_DOT__SLASH_rangeUtil_DOT_js.RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startColumn.partIndex, startColumn.charIndex, endColumn.partIndex, endColumn.charIndex, context);
    }
    getColumnOfNodeOffset(spanNode, offset) {
      return getColumnOfNodeOffset(this._characterMapping, spanNode, offset);
    }
  }
  class WebKitRenderedViewLine extends RenderedViewLine {
    _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {
      const output = super._readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context);
      if (!output || output.length === 0 || startColumn === endColumn || startColumn === 1 && endColumn === this._characterMapping.length) {
        return output;
      }
      this.input.containsRTL || (domNode = this._readPixelOffset(domNode, lineNumber, endColumn, context), domNode !== -1 && (lineNumber = output[output.length - 1], lineNumber.left < domNode && (lineNumber.width = domNode - lineNumber.left)));
      return output;
    }
  }
  require = module.isWebKit ? createWebKitRenderedLine : function(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {
    return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);
  };
  const createRenderedLine = require;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLine.js.map
