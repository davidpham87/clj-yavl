shadow$provide.module$node_modules$vega_transforms$build$vega_transforms = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega_util$build$vega_util"), require("module$node_modules$vega_dataflow$build$vega_dataflow"), require("module$node_modules$vega_statistics$build$vega_statistics"), require("module$node_modules$vega_time$build$vega_time")) : typeof define === "function" && define.amd ? define(["exports", "vega-util", "vega-dataflow", "vega-statistics", "vega-time"], factory) : (global = typeof globalThis !== 
    "undefined" ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega, global.vega));
  })(this, function(exports, vegaUtil, vegaDataflow, vegaStatistics, vegaTime) {
    function multikey(f) {
      return x => {
        const n = f.length;
        let i = 1, k = String(f[0](x));
        for (; i < n; ++i) {
          k += "|" + f[i](x);
        }
        return k;
      };
    }
    function groupkey(fields) {
      return fields && fields.length ? fields.length === 1 ? fields[0] : multikey(fields) : function() {
        return "";
      };
    }
    function measure(key, value) {
      return (out, aggregate_param) => vegaUtil.extend({name:key, aggregate_param, out:out || key}, base_op, value);
    }
    function compareIndex(a, b) {
      return a.idx - b.idx;
    }
    function resolve(agg) {
      const map = {};
      agg.forEach(a => map[a.name] = a);
      const getreqs = a => {
        a.req && a.req.forEach(key => {
          map[key] || getreqs(map[key] = AggregateOps[key]());
        });
      };
      agg.forEach(getreqs);
      return Object.values(map).sort(compareIndex);
    }
    function init() {
      this.missing = this.valid = 0;
      this._ops.forEach(op => op.aggregate_param == null ? op.init(this) : op.init(this, op.aggregate_param));
    }
    function add(v, t) {
      v == null || v === "" ? ++this.missing : v === v && (++this.valid, this._ops.forEach(op => op.add(this, v, t)));
    }
    function rem(v, t) {
      v == null || v === "" ? --this.missing : v === v && (--this.valid, this._ops.forEach(op => op.rem(this, v, t)));
    }
    function set(t) {
      this._out.forEach(op => t[op.out] = op.value(this));
      return t;
    }
    function compileMeasures(agg, field) {
      function ctr(cell) {
        this._ops = ops;
        this._out = out;
        this.cell = cell;
        this.init();
      }
      field = field || vegaUtil.identity;
      const ops = resolve(agg), out = agg.slice().sort(compareIndex);
      ctr.prototype.init = init;
      ctr.prototype.add = add;
      ctr.prototype.rem = rem;
      ctr.prototype.set = set;
      ctr.prototype.get = field;
      ctr.fields = agg.map(op => op.out);
      return ctr;
    }
    function TupleStore(key) {
      this._key = key ? vegaUtil.field(key) : vegaDataflow.tupleid;
      this.reset();
    }
    function Aggregate(params) {
      vegaDataflow.Transform.call(this, null, params);
      this._adds = [];
      this._mods = [];
      this._mlen = this._alen = 0;
      this._drop = !0;
      this._cross = !1;
      this._dims = [];
      this._dnames = [];
      this._measures = [];
      this._countOnly = !1;
      this._outputs = this._inputs = this._prev = this._counts = null;
    }
    function Bin(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function SortedList(idFunc, source, input) {
      let data = source || [], add = input || [], rem = {}, cnt = 0;
      return {add:t => add.push(t), remove:t => rem[idFunc(t)] = ++cnt, size:() => data.length, data:(compare, resort) => {
        cnt && (data = data.filter(t => !rem[idFunc(t)]), rem = {}, cnt = 0);
        resort && compare && data.sort(compare);
        add.length && (data = compare ? vegaUtil.merge(compare, data, add.sort(compare)) : data.concat(add), add = []);
        return data;
      }};
    }
    function Collect(params) {
      vegaDataflow.Transform.call(this, [], params);
    }
    function Compare(params) {
      vegaDataflow.Operator.call(this, null, update$5, params);
    }
    function update$5(_) {
      return this.value && !_.modified() ? this.value : vegaUtil.compare(_.fields, _.orders);
    }
    function CountPattern(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Cross(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function parse(def, data) {
      var func = def["function"];
      vegaUtil.hasOwnProperty(Distributions, func) || vegaUtil.error("Unknown distribution function: " + func);
      func = Distributions[func]();
      for (const name in def) {
        if (name === "field") {
          func.data((def.from || data()).map(def[name]));
        } else if (name === "distributions") {
          func[name](def[name].map(_ => parse(_, data)));
        } else if (typeof func[name] === "function") {
          func[name](def[name]);
        }
      }
      return func;
    }
    function Density(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function source(pulse) {
      return () => pulse.materialize(pulse.SOURCE).source;
    }
    function fieldNames(fields, as) {
      return fields ? fields.map((f, i) => as[i] || vegaUtil.accessorName(f)) : null;
    }
    function partition$1(data, groupby, field) {
      const groups = [], get = f => f(t);
      let map, i, n, t, k, g;
      if (groupby == null) {
        groups.push(data.map(field));
      } else {
        for (map = {}, i = 0, n = data.length; i < n; ++i) {
          t = data[i], k = groupby.map(get), g = map[k], g || (map[k] = g = [], g.dims = k, groups.push(g)), g.push(field(t));
        }
      }
      return groups;
    }
    function DotBin(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Expression(params) {
      vegaDataflow.Operator.call(this, null, update$4, params);
      this.modified(!0);
    }
    function update$4(_) {
      const expr = _.expr;
      return this.value && !_.modified("expr") ? this.value : vegaUtil.accessor(datum => expr(datum, _), vegaUtil.accessorFields(expr), vegaUtil.accessorName(expr));
    }
    function Extent(params) {
      vegaDataflow.Transform.call(this, [void 0, void 0], params);
    }
    function Subflow(pulse, parent) {
      vegaDataflow.Operator.call(this, pulse);
      this.parent = parent;
      this.count = 0;
    }
    function Facet(params) {
      vegaDataflow.Transform.call(this, {}, params);
      this._keys = vegaUtil.fastmap();
      const a = this._targets = [];
      a.active = 0;
      a.forEach = f => {
        for (let i = 0, n = a.active; i < n; ++i) {
          f(a[i], i, a);
        }
      };
    }
    function Field(params) {
      vegaDataflow.Operator.call(this, null, update$3, params);
    }
    function update$3(_) {
      return this.value && !_.modified() ? this.value : vegaUtil.isArray(_.name) ? vegaUtil.array(_.name).map(f => vegaUtil.field(f)) : vegaUtil.field(_.name, _.as);
    }
    function Filter(params) {
      vegaDataflow.Transform.call(this, vegaUtil.fastmap(), params);
    }
    function Flatten(params) {
      vegaDataflow.Transform.call(this, [], params);
    }
    function Fold(params) {
      vegaDataflow.Transform.call(this, [], params);
    }
    function Formula(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Generate(params) {
      vegaDataflow.Transform.call(this, [], params);
    }
    function ascending(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    function descending(a, b) {
      return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
    function bisector(f) {
      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) {
            return hi;
          }
          do {
            const mid = lo + hi >>> 1;
            compare2(a[mid], x) < 0 ? lo = mid + 1 : hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      let compare1, compare2, delta;
      f.length !== 2 ? (compare1 = ascending, compare2 = (d, x) => ascending(f(d), x), delta = (d, x) => f(d) - x) : (compare1 = f === ascending || f === descending ? f : zero, delta = compare2 = f);
      return {left, center:function(a, x, lo = 0, hi = a.length) {
        hi = left(a, x, lo, hi - 1);
        return hi > lo && delta(a[hi - 1], x) > -delta(a[hi], x) ? hi - 1 : hi;
      }, right:function(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) {
            return hi;
          }
          do {
            const mid = lo + hi >>> 1;
            compare2(a[mid], x) <= 0 ? lo = mid + 1 : hi = mid;
          } while (lo < hi);
        }
        return lo;
      }};
    }
    function zero() {
      return 0;
    }
    function* numbers(values, valueof) {
      if (valueof === void 0) {
        for (var value$jscomp$0 of values) {
          value$jscomp$0 != null && (value$jscomp$0 = +value$jscomp$0) >= value$jscomp$0 && (yield value$jscomp$0);
        }
      } else {
        value$jscomp$0 = -1;
        for (let value of values) {
          (value = valueof(value, ++value$jscomp$0, values)) != null && (value = +value) >= value && (yield value);
        }
      }
    }
    function compareDefined(compare = ascending) {
      if (compare === ascending) {
        return ascendingDefined;
      }
      if (typeof compare !== "function") {
        throw new TypeError("compare is not a function");
      }
      return (a, b) => {
        const x = compare(a, b);
        return x || x === 0 ? x : (compare(b, b) === 0) - (compare(a, a) === 0);
      };
    }
    function ascendingDefined(a, b) {
      return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
    }
    function max(values, valueof) {
      let max;
      if (valueof === void 0) {
        for (var value$jscomp$0 of values) {
          value$jscomp$0 != null && (max < value$jscomp$0 || max === void 0 && value$jscomp$0 >= value$jscomp$0) && (max = value$jscomp$0);
        }
      } else {
        value$jscomp$0 = -1;
        for (let value of values) {
          (value = valueof(value, ++value$jscomp$0, values)) != null && (max < value || max === void 0 && value >= value) && (max = value);
        }
      }
      return max;
    }
    function min(values, valueof) {
      let min;
      if (valueof === void 0) {
        for (var value$jscomp$0 of values) {
          value$jscomp$0 != null && (min > value$jscomp$0 || min === void 0 && value$jscomp$0 >= value$jscomp$0) && (min = value$jscomp$0);
        }
      } else {
        value$jscomp$0 = -1;
        for (let value of values) {
          (value = valueof(value, ++value$jscomp$0, values)) != null && (min > value || min === void 0 && value >= value) && (min = value);
        }
      }
      return min;
    }
    function quickselect(array, k, left = 0, right = Infinity, compare) {
      k = Math.floor(k);
      left = Math.floor(Math.max(0, left));
      right = Math.floor(Math.min(array.length - 1, right));
      if (!(left <= k && k <= right)) {
        return array;
      }
      for (compare = compare === void 0 ? ascendingDefined : compareDefined(compare); right > left;) {
        if (right - left > 600) {
          var n = right - left + 1, m = k - left + 1, z = Math.log(n), s = 0.5 * Math.exp(2 * z / 3);
          z = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          quickselect(array, k, Math.max(left, Math.floor(k - m * s / n + z)), Math.min(right, Math.floor(k + (n - m) * s / n + z)), compare);
        }
        n = array[k];
        m = left;
        s = right;
        swap(array, left, k);
        for (compare(array[right], n) > 0 && swap(array, left, right); m < s;) {
          swap(array, m, s);
          ++m;
          for (--s; compare(array[m], n) < 0;) {
            ++m;
          }
          for (; compare(array[s], n) > 0;) {
            --s;
          }
        }
        compare(array[left], n) === 0 ? swap(array, left, s) : (++s, swap(array, s, right));
        s <= k && (left = s + 1);
        k <= s && (right = s - 1);
      }
      return array;
    }
    function swap(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }
    function range(start, stop, step) {
      start = +start;
      stop = +stop;
      step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
      for (var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = Array(n); ++i < n;) {
        range[i] = start + i * step;
      }
      return range;
    }
    function Impute(params) {
      vegaDataflow.Transform.call(this, [], params);
    }
    function getValue(_) {
      var m = _.method || Methods.value;
      if (Methods[m] == null) {
        vegaUtil.error("Unrecognized imputation method: " + m);
      } else {
        if (m === Methods.value) {
          var v = _.value !== void 0 ? _.value : 0;
          return () => v;
        }
        return Methods[m];
      }
    }
    function getField(_) {
      const f = _.field;
      return t => t ? f(t) : NaN;
    }
    function partition(data, groupby, key, keyvals) {
      var get = f => f(t), groups = [];
      keyvals = keyvals ? keyvals.slice() : [];
      var kMap = {}, gMap = {}, group, n;
      keyvals.forEach((k, i) => kMap[k] = i + 1);
      var i = 0;
      for (n = data.length; i < n; ++i) {
        var t = data[i];
        var gVals = key(t);
        var j = kMap[gVals] || (kMap[gVals] = keyvals.push(gVals));
        var gKey = (gVals = groupby ? groupby.map(get) : Empty) + "";
        (group = gMap[gKey]) || (group = gMap[gKey] = [], groups.push(group), group.values = gVals);
        group[j - 1] = t;
      }
      groups.domain = keyvals;
      return groups;
    }
    function JoinAggregate(params) {
      Aggregate.call(this, params);
    }
    function KDE(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Key(params) {
      vegaDataflow.Operator.call(this, null, update$2, params);
    }
    function update$2(_) {
      return this.value && !_.modified() ? this.value : vegaUtil.key(_.fields, _.flat);
    }
    function Load(params) {
      vegaDataflow.Transform.call(this, [], params);
      this._pending = null;
    }
    function stop(_) {
      return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
    }
    function output(op, pulse, data) {
      data.forEach(vegaDataflow.ingest);
      pulse = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);
      pulse.rem = op.value;
      op.value = pulse.source = pulse.add = data;
      op._pending = null;
      pulse.rem.length && pulse.clean(!0);
      return pulse;
    }
    function Lookup(params) {
      vegaDataflow.Transform.call(this, {}, params);
    }
    function MultiExtent(params) {
      vegaDataflow.Operator.call(this, null, update$1, params);
    }
    function update$1(_) {
      if (this.value && !_.modified()) {
        return this.value;
      }
      _ = _.extents;
      const n = _.length;
      let min = Infinity, max = -Infinity, i, e;
      for (i = 0; i < n; ++i) {
        e = _[i], e[0] < min && (min = e[0]), e[1] > max && (max = e[1]);
      }
      return [min, max];
    }
    function MultiValues(params) {
      vegaDataflow.Operator.call(this, null, update, params);
    }
    function update(_) {
      return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);
    }
    function Params(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Pivot(params) {
      Aggregate.call(this, params);
    }
    function aggregateParams(_, pulse) {
      const key = _.field, value = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = vegaUtil.accessorFields(key).concat(vegaUtil.accessorFields(value)), keys = pivotKeys(key, _.limit || 0, pulse);
      pulse.changed() && _.set("__pivot__", null, null, !0);
      return {key:_.key, groupby:_.groupby, ops:keys.map(() => op), fields:keys.map(k => get(k, key, value, fields)), as:keys.map(k => k + ""), modified:_.modified.bind(_)};
    }
    function get(k, key, value, fields) {
      return vegaUtil.accessor(d => key(d) === k ? value(d) : NaN, fields, k + "");
    }
    function pivotKeys(key, limit, pulse) {
      const map = {}, list = [];
      pulse.visit(pulse.SOURCE, t => {
        t = key(t);
        map[t] || (map[t] = 1, list.push(t));
      });
      list.sort(vegaUtil.ascending);
      return limit ? list.slice(0, limit) : list;
    }
    function PreFacet(params) {
      Facet.call(this, params);
    }
    function Project(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Proxy(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Quantile(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Relay(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Sample(params) {
      vegaDataflow.Transform.call(this, [], params);
      this.count = 0;
    }
    function Sequence(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Sieve(params) {
      vegaDataflow.Transform.call(this, null, params);
      this.modified(!0);
    }
    function TimeUnit(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function TupleIndex(params) {
      vegaDataflow.Transform.call(this, vegaUtil.fastmap(), params);
    }
    function Values(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function WindowOp(op, field, param, as) {
      const fn = WindowOps[op](field, param);
      return {init:fn.init || vegaUtil.zero, update:function(w, t) {
        t[as] = fn.next(w);
      }};
    }
    function WindowState(_) {
      function visitInputs(f) {
        vegaUtil.array(vegaUtil.accessorFields(f)).forEach(_ => inputs[_] = 1);
      }
      const ops = vegaUtil.array(_.ops), fields = vegaUtil.array(_.fields), params = vegaUtil.array(_.params), aggregate_params = vegaUtil.array(_.aggregate_params), as = vegaUtil.array(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map = {}, counts = [], measures = [];
      let countOnly = !0;
      visitInputs(_.sort);
      ops.forEach((op, i) => {
        const field = fields[i];
        var param = params[i];
        const aggregate_param = aggregate_params[i] || null, mname = vegaUtil.accessorName(field);
        i = as[i] || op + (mname ? "_" + mname : "");
        visitInputs(field);
        outputs.push(i);
        vegaUtil.hasOwnProperty(WindowOps, op) ? windows.push(WindowOp(op, field, param, i)) : (field == null && op !== "count" && vegaUtil.error("Null aggregate field specified."), op === "count" ? counts.push(i) : (countOnly = !1, param = map[mname], param || (param = map[mname] = [], param.field = field, measures.push(param)), param.push(AggregateOps[op](i, aggregate_param))));
      });
      if (counts.length || measures.length) {
        this.cell = cell(measures, counts, countOnly);
      }
      this.inputs = Object.keys(inputs);
    }
    function cell(measures, counts, countOnly) {
      measures = measures.map(m => compileMeasures(m, m.field));
      const cell = {num:0, agg:null, store:!1, count:counts};
      if (!countOnly) {
        for (var n = measures.length, a = cell.agg = Array(n), i = 0; i < n; ++i) {
          a[i] = new measures[i](cell);
        }
      }
      if (cell.store) {
        var store = cell.data = new TupleStore();
      }
      cell.add = function(t) {
        cell.num += 1;
        if (!countOnly) {
          store && store.add(t);
          for (let i = 0; i < n; ++i) {
            a[i].add(a[i].get(t), t);
          }
        }
      };
      cell.rem = function(t) {
        --cell.num;
        if (!countOnly) {
          store && store.rem(t);
          for (let i = 0; i < n; ++i) {
            a[i].rem(a[i].get(t), t);
          }
        }
      };
      cell.set = function(t) {
        let i, n;
        store && store.values();
        i = 0;
        for (n = counts.length; i < n; ++i) {
          t[counts[i]] = cell.num;
        }
        if (!countOnly) {
          for (i = 0, n = a.length; i < n; ++i) {
            a[i].set(t);
          }
        }
      };
      cell.init = function() {
        cell.num = 0;
        store && store.reset();
        for (let i = 0; i < n; ++i) {
          a[i].init();
        }
      };
      return cell;
    }
    function Window(params) {
      vegaDataflow.Transform.call(this, {}, params);
      this._mlen = 0;
      this._mods = [];
    }
    function processPartition(list, state, cmp, _) {
      var sort = _.sort;
      const range = sort && !_.ignorePeers;
      _ = _.frame || [null, 0];
      list = list.data(cmp);
      cmp = list.length;
      const b = range ? bisector(sort) : null;
      sort = {i0:0, i1:0, p0:0, p1:0, index:0, data:list, compare:sort || vegaUtil.constant(-1)};
      state.init();
      for (let i = 0; i < cmp; ++i) {
        var w = sort, f = _, i$jscomp$0 = i;
        w.p0 = w.i0;
        w.p1 = w.i1;
        w.i0 = f[0] == null ? 0 : Math.max(0, i$jscomp$0 - Math.abs(f[0]));
        w.i1 = f[1] == null ? cmp : Math.min(cmp, i$jscomp$0 + Math.abs(f[1]) + 1);
        w.index = i$jscomp$0;
        if (range) {
          w = sort.i0;
          f = sort.i1 - 1;
          i$jscomp$0 = sort.compare;
          const d = sort.data, n = d.length - 1;
          w > 0 && !i$jscomp$0(d[w], d[w - 1]) && (sort.i0 = b.left(d, d[w]));
          f < n && !i$jscomp$0(d[f], d[f + 1]) && (sort.i1 = b.right(d, d[f]));
        }
        state.update(sort, list[i]);
      }
    }
    const noop = () => {
    }, base_op = {init:noop, add:noop, rem:noop, idx:0}, AggregateOps = {values:{init:m => m.cell.store = !0, value:m => m.cell.data.values(), idx:-1}, count:{value:m => m.cell.num}, __count__:{value:m => m.missing + m.valid}, missing:{value:m => m.missing}, valid:{value:m => m.valid}, sum:{init:m => m.sum = 0, value:m => m.valid ? m.sum : void 0, add:(m, v) => m.sum += +v, rem:(m, v) => m.sum -= v}, product:{init:m => m.product = 1, value:m => m.valid ? m.product : void 0, add:(m, v) => m.product *= 
    v, rem:(m, v) => m.product /= v}, mean:{init:m => m.mean = 0, value:m => m.valid ? m.mean : void 0, add:(m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid), rem:(m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)}, average:{value:m => m.valid ? m.mean : void 0, req:["mean"], idx:1}, variance:{init:m => m.dev = 0, value:m => m.valid > 1 ? m.dev / (m.valid - 1) : void 0, add:(m, v) => m.dev += m.mean_d * (v - m.mean), rem:(m, v) => m.dev -= m.mean_d * 
    (v - m.mean), req:["mean"], idx:1}, variancep:{value:m => m.valid > 1 ? m.dev / m.valid : void 0, req:["variance"], idx:2}, stdev:{value:m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : void 0, req:["variance"], idx:2}, stdevp:{value:m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : void 0, req:["variance"], idx:2}, stderr:{value:m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : void 0, req:["variance"], idx:2}, distinct:{value:m => m.cell.data.distinct(m.get), req:["values"], 
    idx:3}, ci0:{value:m => m.cell.data.ci0(m.get), req:["values"], idx:3}, ci1:{value:m => m.cell.data.ci1(m.get), req:["values"], idx:3}, median:{value:m => m.cell.data.q2(m.get), req:["values"], idx:3}, q1:{value:m => m.cell.data.q1(m.get), req:["values"], idx:3}, q3:{value:m => m.cell.data.q3(m.get), req:["values"], idx:3}, min:{init:m => m.min = void 0, value:m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min, add:(m, v) => {
      if (v < m.min || m.min === void 0) {
        m.min = v;
      }
    }, rem:(m, v) => {
      v <= m.min && (m.min = NaN);
    }, req:["values"], idx:4}, max:{init:m => m.max = void 0, value:m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max, add:(m, v) => {
      if (v > m.max || m.max === void 0) {
        m.max = v;
      }
    }, rem:(m, v) => {
      v >= m.max && (m.max = NaN);
    }, req:["values"], idx:4}, argmin:{init:m => m.argmin = void 0, value:m => m.argmin || m.cell.data.argmin(m.get), add:(m, v, t) => {
      v < m.min && (m.argmin = t);
    }, rem:(m, v) => {
      v <= m.min && (m.argmin = void 0);
    }, req:["min", "values"], idx:3}, argmax:{init:m => m.argmax = void 0, value:m => m.argmax || m.cell.data.argmax(m.get), add:(m, v, t) => {
      v > m.max && (m.argmax = t);
    }, rem:(m, v) => {
      v >= m.max && (m.argmax = void 0);
    }, req:["max", "values"], idx:3}, exponential:{init:(m, r) => {
      m.exp = 0;
      m.exp_r = r;
    }, value:m => m.valid ? m.exp * (1 - m.exp_r) / (1 - m.exp_r ** m.valid) : void 0, add:(m, v) => m.exp = m.exp_r * m.exp + v, rem:(m, v) => m.exp = (m.exp - v / m.exp_r ** (m.valid - 1)) / m.exp_r}, exponentialb:{value:m => m.valid ? m.exp * (1 - m.exp_r) : void 0, req:["exponential"], idx:1}}, ValidAggregateOps = Object.keys(AggregateOps).filter(d => d !== "__count__");
    [...ValidAggregateOps, "__count__"].forEach(key => {
      AggregateOps[key] = measure(key, AggregateOps[key]);
    });
    const prototype$1 = TupleStore.prototype;
    prototype$1.reset = function() {
      this._add = [];
      this._rem = [];
      this._q = this._get = this._ext = null;
    };
    prototype$1.add = function(v) {
      this._add.push(v);
    };
    prototype$1.rem = function(v) {
      this._rem.push(v);
    };
    prototype$1.values = function() {
      this._get = null;
      if (this._rem.length === 0) {
        return this._add;
      }
      const a = this._add;
      var r = this._rem;
      const k = this._key, n = a.length, m = r.length, x = Array(n - m), map = {};
      let i, v;
      for (i = 0; i < m; ++i) {
        map[k(r[i])] = 1;
      }
      for (r = i = 0; i < n; ++i) {
        map[k(v = a[i])] ? map[k(v)] = 0 : x[r++] = v;
      }
      this._rem = [];
      return this._add = x;
    };
    prototype$1.distinct = function(get) {
      const v = this.values(), map = {};
      let n = v.length, count = 0, s;
      for (; --n >= 0;) {
        s = get(v[n]) + "", vegaUtil.hasOwnProperty(map, s) || (map[s] = 1, ++count);
      }
      return count;
    };
    prototype$1.extent = function(get) {
      if (this._get !== get || !this._ext) {
        const v = this.values(), i = vegaUtil.extentIndex(v, get);
        this._ext = [v[i[0]], v[i[1]]];
        this._get = get;
      }
      return this._ext;
    };
    prototype$1.argmin = function(get) {
      return this.extent(get)[0] || {};
    };
    prototype$1.argmax = function(get) {
      return this.extent(get)[1] || {};
    };
    prototype$1.min = function(get) {
      const m = this.extent(get)[0];
      return m != null ? get(m) : void 0;
    };
    prototype$1.max = function(get) {
      const m = this.extent(get)[1];
      return m != null ? get(m) : void 0;
    };
    prototype$1.quartile = function(get) {
      this._get === get && this._q || (this._q = vegaStatistics.quartiles(this.values(), get), this._get = get);
      return this._q;
    };
    prototype$1.q1 = function(get) {
      return this.quartile(get)[0];
    };
    prototype$1.q2 = function(get) {
      return this.quartile(get)[1];
    };
    prototype$1.q3 = function(get) {
      return this.quartile(get)[2];
    };
    prototype$1.ci = function(get) {
      this._get === get && this._ci || (this._ci = vegaStatistics.bootstrapCI(this.values(), 1000, 0.05, get), this._get = get);
      return this._ci;
    };
    prototype$1.ci0 = function(get) {
      return this.ci(get)[0];
    };
    prototype$1.ci1 = function(get) {
      return this.ci(get)[1];
    };
    Aggregate.Definition = {type:"Aggregate", metadata:{generates:!0, changes:!0}, params:[{name:"groupby", type:"field", array:!0}, {name:"ops", type:"enum", array:!0, values:ValidAggregateOps}, {name:"aggregate_params", type:"number", "null":!0, array:!0}, {name:"fields", type:"field", "null":!0, array:!0}, {name:"as", type:"string", "null":!0, array:!0}, {name:"drop", type:"boolean", "default":!0}, {name:"cross", type:"boolean", "default":!1}, {name:"key", type:"field"}]};
    vegaUtil.inherits(Aggregate, vegaDataflow.Transform, {transform(_, pulse) {
      const aggr = this, out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS), mod = _.modified();
      aggr.stamp = out.stamp;
      aggr.value && (mod || pulse.modified(aggr._inputs, !0)) ? (aggr._prev = aggr.value, aggr.value = mod ? aggr.init(_) : Object.create(null), pulse.visit(pulse.SOURCE, t => aggr.add(t))) : (aggr.value = aggr.value || aggr.init(_), pulse.visit(pulse.REM, t => aggr.rem(t)), pulse.visit(pulse.ADD, t => aggr.add(t)));
      out.modifies(aggr._outputs);
      aggr._drop = _.drop !== !1;
      _.cross && aggr._dims.length > 1 && (aggr._drop = !1, aggr.cross());
      pulse.clean() && aggr._drop && out.clean(!0).runAfter(() => this.clean());
      return aggr.changes(out);
    }, cross() {
      function collect(cells) {
        let key, i, t, v;
        for (key in cells) {
          for (t = cells[key].tuple, i = 0; i < n; ++i) {
            vals[i][v = t[dims[i]]] = v;
          }
        }
      }
      function generate(base, tuple, index) {
        const name = dims[index], v = vals[index++];
        for (const k in v) {
          const key = base ? base + "|" + k : k;
          tuple[name] = v[k];
          index < n ? generate(key, tuple, index) : curr[key] || aggr.cell(key, tuple);
        }
      }
      const aggr = this, curr = aggr.value, dims = aggr._dnames, vals = dims.map(() => ({})), n = dims.length;
      collect(aggr._prev);
      collect(curr);
      generate("", {}, 0);
    }, init(_) {
      function inputVisit(get) {
        get = vegaUtil.array(vegaUtil.accessorFields(get));
        const n = get.length;
        let i = 0, f;
        for (; i < n; ++i) {
          inputMap[f = get[i]] || (inputMap[f] = 1, inputs.push(f));
        }
      }
      const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
      this._dims = vegaUtil.array(_.groupby);
      this._dnames = this._dims.map(d => {
        const dname = vegaUtil.accessorName(d);
        inputVisit(d);
        outputs.push(dname);
        return dname;
      });
      this.cellkey = _.key ? _.key : groupkey(this._dims);
      this._countOnly = !0;
      this._counts = [];
      this._measures = [];
      const fields = _.fields || [null], ops = _.ops || ["count"], aggregate_params = _.aggregate_params || [null];
      _ = _.as || [];
      const n = fields.length, map = {};
      let field, op, aggregate_param, m, mname, outname, i;
      n !== ops.length && vegaUtil.error("Unmatched number of fields and aggregate ops.");
      for (i = 0; i < n; ++i) {
        field = fields[i], op = ops[i], aggregate_param = aggregate_params[i] || null, field == null && op !== "count" && vegaUtil.error("Null aggregate field specified."), mname = vegaUtil.accessorName(field), outname = _[i] || op + (mname ? "_" + mname : ""), outputs.push(outname), op === "count" ? this._counts.push(outname) : (m = map[mname], m || (inputVisit(field), m = map[mname] = [], m.field = field, this._measures.push(m)), op !== "count" && (this._countOnly = !1), m.push(AggregateOps[op](outname, 
        aggregate_param)));
      }
      this._measures = this._measures.map(m => compileMeasures(m, m.field));
      return Object.create(null);
    }, cellkey:groupkey(), cell(key, t) {
      let cell = this.value[key];
      cell ? cell.num === 0 && this._drop && cell.stamp < this.stamp ? (cell.stamp = this.stamp, this._adds[this._alen++] = cell) : cell.stamp < this.stamp && (cell.stamp = this.stamp, this._mods[this._mlen++] = cell) : (cell = this.value[key] = this.newcell(key, t), this._adds[this._alen++] = cell);
      return cell;
    }, newcell(key, t) {
      key = {key, num:0, agg:null, tuple:this.newtuple(t, this._prev && this._prev[key]), stamp:this.stamp, store:!1};
      if (!this._countOnly) {
        t = this._measures;
        const n = t.length;
        key.agg = Array(n);
        for (let i = 0; i < n; ++i) {
          key.agg[i] = new t[i](key);
        }
      }
      key.store && (key.data = new TupleStore());
      return key;
    }, newtuple(t, p) {
      const names = this._dnames, dims = this._dims, n = dims.length, x = {};
      for (let i = 0; i < n; ++i) {
        x[names[i]] = dims[i](t);
      }
      return p ? vegaDataflow.replace(p.tuple, x) : vegaDataflow.ingest(x);
    }, clean() {
      const cells = this.value;
      for (const key in cells) {
        cells[key].num === 0 && delete cells[key];
      }
    }, add(t) {
      var key = this.cellkey(t);
      key = this.cell(key, t);
      key.num += 1;
      if (!this._countOnly) {
        key.store && key.data.add(t);
        key = key.agg;
        for (let i = 0, n = key.length; i < n; ++i) {
          key[i].add(key[i].get(t), t);
        }
      }
    }, rem(t) {
      var key = this.cellkey(t);
      key = this.cell(key, t);
      --key.num;
      if (!this._countOnly) {
        key.store && key.data.rem(t);
        key = key.agg;
        for (let i = 0, n = key.length; i < n; ++i) {
          key[i].rem(key[i].get(t), t);
        }
      }
    }, celltuple(cell) {
      const tuple = cell.tuple, counts = this._counts;
      cell.store && cell.data.values();
      for (let i = 0, n = counts.length; i < n; ++i) {
        tuple[counts[i]] = cell.num;
      }
      if (!this._countOnly) {
        cell = cell.agg;
        for (let i = 0, n = cell.length; i < n; ++i) {
          cell[i].set(tuple);
        }
      }
      return tuple;
    }, changes(out) {
      const adds = this._adds, mods = this._mods;
      var prev = this._prev;
      const drop = this._drop, add = out.add, rem = out.rem, mod = out.mod;
      let cell;
      var key;
      if (prev) {
        for (key in prev) {
          cell = prev[key], drop && !cell.num || rem.push(cell.tuple);
        }
      }
      prev = 0;
      for (key = this._alen; prev < key; ++prev) {
        add.push(this.celltuple(adds[prev])), adds[prev] = null;
      }
      prev = 0;
      for (key = this._mlen; prev < key; ++prev) {
        cell = mods[prev], (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell)), mods[prev] = null;
      }
      this._alen = this._mlen = 0;
      this._prev = null;
      return out;
    }});
    Bin.Definition = {type:"Bin", metadata:{modifies:!0}, params:[{name:"field", type:"field", required:!0}, {name:"interval", type:"boolean", "default":!0}, {name:"anchor", type:"number"}, {name:"maxbins", type:"number", "default":20}, {name:"base", type:"number", "default":10}, {name:"divide", type:"number", array:!0, "default":[5, 2]}, {name:"extent", type:"number", array:!0, length:2, required:!0}, {name:"span", type:"number"}, {name:"step", type:"number"}, {name:"steps", type:"number", array:!0}, 
    {name:"minstep", type:"number", "default":0}, {name:"nice", type:"boolean", "default":!0}, {name:"name", type:"string"}, {name:"as", type:"string", array:!0, length:2, "default":["bin0", "bin1"]}]};
    vegaUtil.inherits(Bin, vegaDataflow.Transform, {transform(_, pulse) {
      const band = _.interval !== !1, bins = this._bins(_), start = bins.start, step = bins.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
      _.modified() ? (pulse = pulse.reflow(!0), _ = pulse.SOURCE) : _ = pulse.modified(vegaUtil.accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;
      pulse.visit(_, band ? t => {
        const v = bins(t);
        t[b0] = v;
        t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
      } : t => t[b0] = bins(t));
      return pulse.modifies(band ? as : b0);
    }, _bins(_) {
      if (this.value && !_.modified()) {
        return this.value;
      }
      const field = _.field, bins = vegaStatistics.bin(_), step = bins.step;
      let start = bins.start, stop = start + Math.ceil((bins.stop - start) / step) * step;
      var a;
      (a = _.anchor) != null && (a -= start + step * Math.floor((a - start) / step), start += a, stop += a);
      a = function(t) {
        t = vegaUtil.toNumber(field(t));
        return t == null ? null : t < start ? -Infinity : t > stop ? Infinity : (t = Math.max(start, Math.min(t, stop - step)), start + step * Math.floor(1e-14 + (t - start) / step));
      };
      a.start = start;
      a.stop = bins.stop;
      a.step = step;
      return this.value = vegaUtil.accessor(a, vegaUtil.accessorFields(field), _.name || "bin_" + vegaUtil.accessorName(field));
    }});
    Collect.Definition = {type:"Collect", metadata:{source:!0}, params:[{name:"sort", type:"compare"}]};
    vegaUtil.inherits(Collect, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.ALL), list = SortedList(vegaDataflow.tupleid, this.value, out.materialize(out.ADD).add), sort = _.sort;
      _ = pulse.changed() || sort && (_.modified("sort") || pulse.modified(sort.fields));
      out.visit(out.REM, list.remove);
      this.modified(_);
      this.value = out.source = list.data(vegaDataflow.stableCompare(sort), _);
      pulse.source && pulse.source.root && (this.value.root = pulse.source.root);
      return out;
    }});
    vegaUtil.inherits(Compare, vegaDataflow.Operator);
    CountPattern.Definition = {type:"CountPattern", metadata:{generates:!0, changes:!0}, params:[{name:"field", type:"field", required:!0}, {name:"case", type:"enum", values:["upper", "lower", "mixed"], "default":"mixed"}, {name:"pattern", type:"string", "default":'[\\w"]+'}, {name:"stopwords", type:"string", "default":""}, {name:"as", type:"string", array:!0, length:2, "default":["text", "count"]}]};
    vegaUtil.inherits(CountPattern, vegaDataflow.Transform, {transform(_, pulse) {
      var process = update => tuple => {
        tuple = get(tuple);
        switch(_.case) {
          case "upper":
            tuple = tuple.toUpperCase();
            break;
          case "lower":
            tuple = tuple.toLowerCase();
        }
        tuple = tuple.match(match) || [];
        for (var t, i = 0, n = tuple.length; i < n; ++i) {
          stop.test(t = tuple[i]) || update(t);
        }
      };
      const init = this._parameterCheck(_, pulse), counts = this._counts, match = this._match, stop = this._stop, get = _.field, as = _.as || ["text", "count"], add = process(t => counts[t] = 1 + (counts[t] || 0));
      process = process(t => --counts[t]);
      init ? pulse.visit(pulse.SOURCE, add) : (pulse.visit(pulse.ADD, add), pulse.visit(pulse.REM, process));
      return this._finish(pulse, as);
    }, _parameterCheck(_, pulse) {
      let init = !1;
      if (_.modified("stopwords") || !this._stop) {
        this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i"), init = !0;
      }
      if (_.modified("pattern") || !this._match) {
        this._match = new RegExp(_.pattern || "[\\w']+", "g"), init = !0;
      }
      if (_.modified("field") || pulse.modified(_.field.fields)) {
        init = !0;
      }
      init && (this._counts = {});
      return init;
    }, _finish(pulse, as) {
      const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text = as[0], count = as[1];
      pulse = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      let w, t, c;
      for (w in counts) {
        t = tuples[w], c = counts[w] || 0, !t && c ? (tuples[w] = t = vegaDataflow.ingest({}), t[text] = w, t[count] = c, pulse.add.push(t)) : c === 0 ? (t && pulse.rem.push(t), counts[w] = null, tuples[w] = null) : t[count] !== c && (t[count] = c, pulse.mod.push(t));
      }
      return pulse.modifies(as);
    }});
    Cross.Definition = {type:"Cross", metadata:{generates:!0}, params:[{name:"filter", type:"expr"}, {name:"as", type:"string", array:!0, length:2, "default":["a", "b"]}]};
    vegaUtil.inherits(Cross, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE), as = _.as || ["a", "b"], a = as[0], b = as[1];
      var reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified("as") || _.modified("filter"), data = this.value;
      if (reset) {
        data && (out.rem = data);
        pulse = data = pulse.materialize(pulse.SOURCE).source;
        _ = _.filter || vegaUtil.truthy;
        reset = [];
        data = {};
        for (var n = pulse.length, i = 0, j, left; i < n; ++i) {
          for (data[a] = left = pulse[i], j = 0; j < n; ++j) {
            data[b] = pulse[j], _(data) && (reset.push(vegaDataflow.ingest(data)), data = {}, data[a] = left);
          }
        }
        out.add = this.value = reset;
      } else {
        out.mod = data;
      }
      out.source = this.value;
      return out.modifies(as);
    }});
    const Distributions = {kde:vegaStatistics.randomKDE, mixture:vegaStatistics.randomMixture, normal:vegaStatistics.randomNormal, lognormal:vegaStatistics.randomLogNormal, uniform:vegaStatistics.randomUniform}, distributions = [{key:{"function":"normal"}, params:[{name:"mean", type:"number", "default":0}, {name:"stdev", type:"number", "default":1}]}, {key:{"function":"lognormal"}, params:[{name:"mean", type:"number", "default":0}, {name:"stdev", type:"number", "default":1}]}, {key:{"function":"uniform"}, 
    params:[{name:"min", type:"number", "default":0}, {name:"max", type:"number", "default":1}]}, {key:{"function":"kde"}, params:[{name:"field", type:"field", required:!0}, {name:"from", type:"data"}, {name:"bandwidth", type:"number", "default":0}]}];
    Density.Definition = {type:"Density", metadata:{generates:!0}, params:[{name:"extent", type:"number", array:!0, length:2}, {name:"steps", type:"number"}, {name:"minsteps", type:"number", "default":25}, {name:"maxsteps", type:"number", "default":200}, {name:"method", type:"string", "default":"pdf", values:["pdf", "cdf"]}, {name:"distribution", type:"param", params:distributions.concat({key:{"function":"mixture"}, params:[{name:"distributions", type:"param", array:!0, params:distributions}, {name:"weights", 
    type:"number", array:!0}]})}, {name:"as", type:"string", array:!0, "default":["value", "density"]}]};
    vegaUtil.inherits(Density, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      if (!this.value || pulse.changed() || _.modified()) {
        const dist = parse(_.distribution, source(pulse));
        pulse = _.steps || _.minsteps || 25;
        const maxsteps = _.steps || _.maxsteps || 200;
        let method = _.method || "pdf";
        method !== "pdf" && method !== "cdf" && vegaUtil.error("Invalid density method: " + method);
        _.extent || dist.data || vegaUtil.error("Missing density extent parameter.");
        method = dist[method];
        const as = _.as || ["value", "density"];
        _ = _.extent || vegaUtil.extent(dist.data());
        _ = vegaStatistics.sampleCurve(method, _, pulse, maxsteps).map(v => {
          const tuple = {};
          tuple[as[0]] = v[0];
          tuple[as[1]] = v[1];
          return vegaDataflow.ingest(tuple);
        });
        this.value && (out.rem = this.value);
        this.value = out.add = out.source = _;
      }
      return out;
    }});
    DotBin.Definition = {type:"DotBin", metadata:{modifies:!0}, params:[{name:"field", type:"field", required:!0}, {name:"groupby", type:"field", array:!0}, {name:"step", type:"number"}, {name:"smooth", type:"boolean", "default":!1}, {name:"as", type:"string", "default":"bin"}]};
    vegaUtil.inherits(DotBin, vegaDataflow.Transform, {transform(_, pulse) {
      if (this.value && !_.modified() && !pulse.changed()) {
        return pulse;
      }
      var source = pulse.materialize(pulse.SOURCE).source;
      const groups = partition$1(pulse.source, _.groupby, vegaUtil.identity), smooth = _.smooth || !1, field = _.field;
      source = _.step || vegaUtil.span(vegaUtil.extent(source, field)) / 30;
      const sort = vegaDataflow.stableCompare((a, b) => field(a) - field(b));
      _ = _.as || "bin";
      const n = groups.length;
      let min = Infinity, max = -Infinity, i = 0, j;
      for (; i < n; ++i) {
        const g = groups[i].sort(sort);
        j = -1;
        for (const v of vegaStatistics.dotbin(g, source, smooth, field)) {
          v < min && (min = v), v > max && (max = v), g[++j][_] = v;
        }
      }
      this.value = {start:min, stop:max, step:source};
      return pulse.reflow(!0).modifies(_);
    }});
    vegaUtil.inherits(Expression, vegaDataflow.Operator);
    Extent.Definition = {type:"Extent", metadata:{}, params:[{name:"field", type:"field", required:!0}]};
    vegaUtil.inherits(Extent, vegaDataflow.Transform, {transform(_, pulse) {
      var extent = this.value;
      const field = _.field;
      _ = pulse.changed() || pulse.modified(field.fields) || _.modified("field");
      let min = extent[0], max = extent[1];
      if (_ || min == null) {
        min = Infinity, max = -Infinity;
      }
      pulse.visit(_ ? pulse.SOURCE : pulse.ADD, t => {
        t = vegaUtil.toNumber(field(t));
        t != null && (t < min && (min = t), t > max && (max = t));
      });
      Number.isFinite(min) && Number.isFinite(max) || ((extent = vegaUtil.accessorName(field)) && (extent = ` for field "${extent}"`), pulse.dataflow.warn(`Infinite extent${extent}: [${min}, ${max}]`), min = max = void 0);
      this.value = [min, max];
    }});
    vegaUtil.inherits(Subflow, vegaDataflow.Operator, {connect(target) {
      this.detachSubflow = target.detachSubflow;
      this.targets().add(target);
      return target.source = this;
    }, add(t) {
      this.count += 1;
      this.value.add.push(t);
    }, rem(t) {
      --this.count;
      this.value.rem.push(t);
    }, mod(t) {
      this.value.mod.push(t);
    }, init(pulse) {
      this.value.init(pulse, pulse.NO_SOURCE);
    }, evaluate() {
      return this.value;
    }});
    vegaUtil.inherits(Facet, vegaDataflow.Transform, {activate(flow) {
      this._targets[this._targets.active++] = flow;
    }, subflow(key, flow, pulse, parent) {
      const flows = this.value;
      let sf = vegaUtil.hasOwnProperty(flows, key) && flows[key], p;
      sf ? sf.value.stamp < pulse.stamp && (sf.init(pulse), this.activate(sf)) : (p = parent || (p = this._group[key]) && p.tuple, parent = pulse.dataflow, sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this), parent.add(sf).connect(flow(parent, key, p)), flows[key] = sf, this.activate(sf));
      return sf;
    }, clean() {
      var flows = this.value;
      let detached = 0;
      for (const key in flows) {
        if (flows[key].count === 0) {
          const detach = flows[key].detachSubflow;
          detach && detach();
          delete flows[key];
          ++detached;
        }
      }
      detached && (flows = this._targets.filter(sf => sf && sf.count > 0), this.initTargets(flows));
    }, initTargets(act) {
      const a = this._targets, n = a.length, m = act ? act.length : 0;
      let i = 0;
      for (; i < m; ++i) {
        a[i] = act[i];
      }
      for (; i < n && a[i] != null; ++i) {
        a[i] = null;
      }
      a.active = m;
    }, transform(_, pulse) {
      const df = pulse.dataflow, key = _.key, flow = _.subflow, cache = this._keys, rekey = _.modified("key"), subflow = key => this.subflow(key, flow, pulse);
      this._group = _.group || {};
      this.initTargets();
      pulse.visit(pulse.REM, t => {
        const id = vegaDataflow.tupleid(t), k = cache.get(id);
        k !== void 0 && (cache.delete(id), subflow(k).rem(t));
      });
      pulse.visit(pulse.ADD, t => {
        const k = key(t);
        cache.set(vegaDataflow.tupleid(t), k);
        subflow(k).add(t);
      });
      rekey || pulse.modified(key.fields) ? pulse.visit(pulse.MOD, t => {
        const id = vegaDataflow.tupleid(t), k0 = cache.get(id), k1 = key(t);
        k0 === k1 ? subflow(k1).mod(t) : (cache.set(id, k1), subflow(k0).rem(t), subflow(k1).add(t));
      }) : pulse.changed(pulse.MOD) && pulse.visit(pulse.MOD, t => {
        subflow(cache.get(vegaDataflow.tupleid(t))).mod(t);
      });
      rekey && pulse.visit(pulse.REFLOW, t => {
        const id = vegaDataflow.tupleid(t), k0 = cache.get(id), k1 = key(t);
        k0 !== k1 && (cache.set(id, k1), subflow(k0).rem(t), subflow(k1).add(t));
      });
      pulse.clean() ? df.runAfter(() => {
        this.clean();
        cache.clean();
      }) : cache.empty > df.cleanThreshold && df.runAfter(cache.clean);
      return pulse;
    }});
    vegaUtil.inherits(Field, vegaDataflow.Operator);
    Filter.Definition = {type:"Filter", metadata:{changes:!0}, params:[{name:"expr", type:"expr", required:!0}]};
    vegaUtil.inherits(Filter, vegaDataflow.Transform, {transform(_, pulse) {
      function revisit(t) {
        const id = vegaDataflow.tupleid(t), b = test(t, _), s = cache.get(id);
        b && s ? (cache.delete(id), add.push(t)) : b || s ? isMod && b && !s && mod.push(t) : (cache.set(id, 1), rem.push(t));
      }
      const df = pulse.dataflow, cache = this.value, output = pulse.fork(), add = output.add, rem = output.rem, mod = output.mod, test = _.expr;
      let isMod = !0;
      pulse.visit(pulse.REM, t => {
        const id = vegaDataflow.tupleid(t);
        cache.has(id) ? cache.delete(id) : rem.push(t);
      });
      pulse.visit(pulse.ADD, t => {
        test(t, _) ? add.push(t) : cache.set(vegaDataflow.tupleid(t), 1);
      });
      pulse.visit(pulse.MOD, revisit);
      _.modified() && (isMod = !1, pulse.visit(pulse.REFLOW, revisit));
      cache.empty > df.cleanThreshold && df.runAfter(cache.clean);
      return output;
    }});
    Flatten.Definition = {type:"Flatten", metadata:{generates:!0}, params:[{name:"fields", type:"field", array:!0, required:!0}, {name:"index", type:"string"}, {name:"as", type:"string", array:!0}]};
    vegaUtil.inherits(Flatten, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index = _.index || null, m = as.length;
      out.rem = this.value;
      pulse.visit(pulse.SOURCE, t => {
        const arrays = fields.map(f => f(t)), maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
        let i = 0, j, d, v;
        for (; i < maxlen; ++i) {
          d = vegaDataflow.derive(t);
          for (j = 0; j < m; ++j) {
            d[as[j]] = (v = arrays[j][i]) == null ? null : v;
          }
          index && (d[index] = i);
          out.add.push(d);
        }
      });
      this.value = out.source = out.add;
      index && out.modifies(index);
      return out.modifies(as);
    }});
    Fold.Definition = {type:"Fold", metadata:{generates:!0}, params:[{name:"fields", type:"field", array:!0, required:!0}, {name:"as", type:"string", array:!0, length:2, "default":["key", "value"]}]};
    vegaUtil.inherits(Fold, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE), fields = _.fields, fnames = fields.map(vegaUtil.accessorName);
      _ = _.as || ["key", "value"];
      const k = _[0], v = _[1], n = fields.length;
      out.rem = this.value;
      pulse.visit(pulse.SOURCE, t => {
        for (let i = 0, d; i < n; ++i) {
          d = vegaDataflow.derive(t), d[k] = fnames[i], d[v] = fields[i](t), out.add.push(d);
        }
      });
      this.value = out.source = out.add;
      return out.modifies(_);
    }});
    Formula.Definition = {type:"Formula", metadata:{modifies:!0}, params:[{name:"expr", type:"expr", required:!0}, {name:"as", type:"string", required:!0}, {name:"initonly", type:"boolean"}]};
    vegaUtil.inherits(Formula, vegaDataflow.Transform, {transform(_, pulse) {
      const func = _.expr, as = _.as, mod = _.modified(), flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;
      mod && (pulse = pulse.materialize().reflow(!0));
      _.initonly || pulse.modifies(as);
      return pulse.visit(flag, t => t[as] = func(t, _));
    }});
    vegaUtil.inherits(Generate, vegaDataflow.Transform, {transform(_, pulse) {
      pulse = pulse.fork(pulse.ALL);
      const gen = _.generator;
      let data = this.value, num = _.size - data.length, add, t;
      if (num > 0) {
        for (add = []; --num >= 0;) {
          add.push(t = vegaDataflow.ingest(gen(_))), data.push(t);
        }
        pulse.add = pulse.add.length ? pulse.materialize(pulse.ADD).add.concat(add) : add;
      } else {
        _ = data.slice(0, -num), pulse.rem = pulse.rem.length ? pulse.materialize(pulse.REM).rem.concat(_) : _, data = data.slice(-num);
      }
      pulse.source = this.value = data;
      return pulse;
    }});
    const Methods = {value:"value", median:function(values, valueof) {
      var p = 0.5;
      values = Float64Array.from(numbers(values, valueof));
      if ((valueof = values.length) && !isNaN(p = +p)) {
        if (p <= 0 || valueof < 2) {
          values = min(values);
        } else {
          if (p >= 1) {
            values = max(values);
          } else {
            p *= valueof - 1;
            valueof = Math.floor(p);
            var value0 = max(quickselect(values, valueof).subarray(0, valueof + 1));
            values = min(values.subarray(valueof + 1));
            values = value0 + (values - value0) * (p - valueof);
          }
        }
      } else {
        values = void 0;
      }
      return values;
    }, mean:function(values, valueof) {
      let count = 0, sum = 0;
      if (valueof === void 0) {
        for (var value$jscomp$0 of values) {
          value$jscomp$0 != null && (value$jscomp$0 = +value$jscomp$0) >= value$jscomp$0 && (++count, sum += value$jscomp$0);
        }
      } else {
        value$jscomp$0 = -1;
        for (let value of values) {
          (value = valueof(value, ++value$jscomp$0, values)) != null && (value = +value) >= value && (++count, sum += value);
        }
      }
      if (count) {
        return sum / count;
      }
    }, min, max}, Empty = [];
    Impute.Definition = {type:"Impute", metadata:{changes:!0}, params:[{name:"field", type:"field", required:!0}, {name:"key", type:"field", required:!0}, {name:"keyvals", array:!0}, {name:"groupby", type:"field", array:!0}, {name:"method", type:"enum", "default":"value", values:["value", "mean", "median", "max", "min"]}, {name:"value", "default":0}]};
    vegaUtil.inherits(Impute, vegaDataflow.Transform, {transform(_, pulse) {
      var out = pulse.fork(pulse.ALL), impute = getValue(_), field = getField(_), fName = vegaUtil.accessorName(_.field), kName = vegaUtil.accessorName(_.key), gNames = (_.groupby || []).map(vegaUtil.accessorName);
      _ = partition(pulse.source, _.groupby, _.key, _.keyvals);
      pulse = [];
      var prev = this.value, m = _.domain.length, j, l, n;
      var g = 0;
      for (l = _.length; g < l; ++g) {
        var group = _[g];
        var gVals = group.values;
        var value = NaN;
        for (j = 0; j < m; ++j) {
          if (group[j] == null) {
            var kVal = _.domain[j];
            var t = {_impute:!0};
            var i = 0;
            for (n = gVals.length; i < n; ++i) {
              t[gNames[i]] = gVals[i];
            }
            t[kName] = kVal;
            t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;
            pulse.push(vegaDataflow.ingest(t));
          }
        }
      }
      pulse.length && (out.add = out.materialize(out.ADD).add.concat(pulse));
      prev.length && (out.rem = out.materialize(out.REM).rem.concat(prev));
      this.value = pulse;
      return out;
    }});
    JoinAggregate.Definition = {type:"JoinAggregate", metadata:{modifies:!0}, params:[{name:"groupby", type:"field", array:!0}, {name:"fields", type:"field", "null":!0, array:!0}, {name:"ops", type:"enum", array:!0, values:ValidAggregateOps}, {name:"as", type:"string", "null":!0, array:!0}, {name:"key", type:"field"}]};
    vegaUtil.inherits(JoinAggregate, Aggregate, {transform(_, pulse) {
      const aggr = this, mod = _.modified();
      let cells;
      aggr.value && (mod || pulse.modified(aggr._inputs, !0)) ? (cells = aggr.value = mod ? aggr.init(_) : {}, pulse.visit(pulse.SOURCE, t => aggr.add(t))) : (cells = aggr.value = aggr.value || this.init(_), pulse.visit(pulse.REM, t => aggr.rem(t)), pulse.visit(pulse.ADD, t => aggr.add(t)));
      aggr.changes();
      pulse.visit(pulse.SOURCE, t => {
        vegaUtil.extend(t, cells[aggr.cellkey(t)].tuple);
      });
      return pulse.reflow(mod).modifies(this._outputs);
    }, changes() {
      const adds = this._adds, mods = this._mods;
      let i, n;
      i = 0;
      for (n = this._alen; i < n; ++i) {
        this.celltuple(adds[i]), adds[i] = null;
      }
      i = 0;
      for (n = this._mlen; i < n; ++i) {
        this.celltuple(mods[i]), mods[i] = null;
      }
      this._alen = this._mlen = 0;
    }});
    KDE.Definition = {type:"KDE", metadata:{generates:!0}, params:[{name:"groupby", type:"field", array:!0}, {name:"field", type:"field", required:!0}, {name:"cumulative", type:"boolean", "default":!1}, {name:"counts", type:"boolean", "default":!1}, {name:"bandwidth", type:"number", "default":0}, {name:"extent", type:"number", array:!0, length:2}, {name:"resolve", type:"enum", values:["shared", "independent"], "default":"independent"}, {name:"steps", type:"number"}, {name:"minsteps", type:"number", 
    "default":25}, {name:"maxsteps", type:"number", "default":200}, {name:"as", type:"string", array:!0, "default":["value", "density"]}]};
    vegaUtil.inherits(KDE, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      if (!this.value || pulse.changed() || _.modified()) {
        pulse = pulse.materialize(pulse.SOURCE).source;
        const groups = partition$1(pulse, _.groupby, _.field), names = (_.groupby || []).map(vegaUtil.accessorName), bandwidth = _.bandwidth, method = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values = [];
        let domain = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
        method !== "pdf" && method !== "cdf" && vegaUtil.error("Invalid density method: " + method);
        _.resolve === "shared" && (domain ||= vegaUtil.extent(pulse, _.field), minsteps = maxsteps = _.steps || maxsteps);
        groups.forEach(g => {
          const density = vegaStatistics.randomKDE(g, bandwidth)[method], scale = _.counts ? g.length : 1, local = domain || vegaUtil.extent(g);
          vegaStatistics.sampleCurve(density, local, minsteps, maxsteps).forEach(v => {
            const t = {};
            for (let i = 0; i < names.length; ++i) {
              t[names[i]] = g.dims[i];
            }
            t[as[0]] = v[0];
            t[as[1]] = v[1] * scale;
            values.push(vegaDataflow.ingest(t));
          });
        });
        this.value && (out.rem = this.value);
        this.value = out.add = out.source = values;
      }
      return out;
    }});
    vegaUtil.inherits(Key, vegaDataflow.Operator);
    vegaUtil.inherits(Load, vegaDataflow.Transform, {transform(_, pulse) {
      const df = pulse.dataflow;
      return this._pending ? output(this, pulse, this._pending) : stop(_) ? pulse.StopPropagation : _.values ? output(this, pulse, df.parse(_.values, _.format)) : _.async ? {async:df.request(_.url, _.format).then(res => {
        this._pending = vegaUtil.array(res.data);
        return df => df.touch(this);
      })} : df.request(_.url, _.format).then(res => output(this, pulse, vegaUtil.array(res.data)));
    }});
    Lookup.Definition = {type:"Lookup", metadata:{modifies:!0}, params:[{name:"index", type:"index", params:[{name:"from", type:"data", required:!0}, {name:"key", type:"field", required:!0}]}, {name:"values", type:"field", array:!0}, {name:"fields", type:"field", array:!0, required:!0}, {name:"as", type:"string", array:!0}, {name:"default", "default":null}]};
    vegaUtil.inherits(Lookup, vegaDataflow.Transform, {transform(_, pulse) {
      const keys = _.fields, index = _.index, values = _.values, defaultValue = _.default == null ? null : _.default;
      var reset = _.modified();
      const n = keys.length;
      let flag = reset ? pulse.SOURCE : pulse.ADD, out = pulse, as = _.as, m;
      values ? (m = values.length, n > 1 && !as && vegaUtil.error('Multi-field lookup requires explicit "as" parameter.'), as && as.length !== n * m && vegaUtil.error('The "as" parameter has too few output field names.'), as = as || values.map(vegaUtil.accessorName), _ = function(t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          if (v = index.get(keys[i](t)), v == null) {
            for (j = 0; j < m; ++j, ++k) {
              t[as[k]] = defaultValue;
            }
          } else {
            for (j = 0; j < m; ++j, ++k) {
              t[as[k]] = values[j](v);
            }
          }
        }
      }) : (as || vegaUtil.error("Missing output field names."), _ = function(t) {
        for (var i = 0, v; i < n; ++i) {
          v = index.get(keys[i](t)), t[as[i]] = v == null ? defaultValue : v;
        }
      });
      reset ? out = pulse.reflow(!0) : (reset = keys.some(k => pulse.modified(k.fields)), flag |= reset ? pulse.MOD : 0);
      pulse.visit(flag, _);
      return out.modifies(as);
    }});
    vegaUtil.inherits(MultiExtent, vegaDataflow.Operator);
    vegaUtil.inherits(MultiValues, vegaDataflow.Operator);
    vegaUtil.inherits(Params, vegaDataflow.Transform, {transform(_, pulse) {
      this.modified(_.modified());
      this.value = _;
      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    }});
    Pivot.Definition = {type:"Pivot", metadata:{generates:!0, changes:!0}, params:[{name:"groupby", type:"field", array:!0}, {name:"field", type:"field", required:!0}, {name:"value", type:"field", required:!0}, {name:"op", type:"enum", values:ValidAggregateOps, "default":"sum"}, {name:"limit", type:"number", "default":0}, {name:"key", type:"field"}]};
    vegaUtil.inherits(Pivot, Aggregate, {_transform:Aggregate.prototype.transform, transform(_, pulse) {
      return this._transform(aggregateParams(_, pulse), pulse);
    }});
    vegaUtil.inherits(PreFacet, Facet, {transform(_, pulse) {
      const flow = _.subflow, field = _.field, subflow = t => this.subflow(vegaDataflow.tupleid(t), flow, pulse, t);
      (_.modified("field") || field && pulse.modified(vegaUtil.accessorFields(field))) && vegaUtil.error("PreFacet does not support field modification.");
      this.initTargets();
      field ? (pulse.visit(pulse.MOD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.mod(_));
      }), pulse.visit(pulse.ADD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.add(vegaDataflow.ingest(_)));
      }), pulse.visit(pulse.REM, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.rem(_));
      })) : (pulse.visit(pulse.MOD, t => subflow(t).mod(t)), pulse.visit(pulse.ADD, t => subflow(t).add(t)), pulse.visit(pulse.REM, t => subflow(t).rem(t)));
      pulse.clean() && pulse.runAfter(() => this.clean());
      return pulse;
    }});
    Project.Definition = {type:"Project", metadata:{generates:!0, changes:!0}, params:[{name:"fields", type:"field", array:!0}, {name:"as", type:"string", "null":!0, array:!0}]};
    vegaUtil.inherits(Project, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive = fields ? (s, t) => {
        for (let i = 0, n = fields.length; i < n; ++i) {
          t[as[i]] = fields[i](s);
        }
        return t;
      } : vegaDataflow.rederive;
      let lut;
      this.value ? lut = this.value : (pulse = pulse.addAll(), lut = this.value = {});
      pulse.visit(pulse.REM, t => {
        t = vegaDataflow.tupleid(t);
        out.rem.push(lut[t]);
        lut[t] = null;
      });
      pulse.visit(pulse.ADD, t => {
        const dt = derive(t, vegaDataflow.ingest({}));
        lut[vegaDataflow.tupleid(t)] = dt;
        out.add.push(dt);
      });
      pulse.visit(pulse.MOD, t => {
        out.mod.push(derive(t, lut[vegaDataflow.tupleid(t)]));
      });
      return out;
    }});
    vegaUtil.inherits(Proxy, vegaDataflow.Transform, {transform(_, pulse) {
      this.value = _.value;
      return _.modified("value") ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
    }});
    Quantile.Definition = {type:"Quantile", metadata:{generates:!0, changes:!0}, params:[{name:"groupby", type:"field", array:!0}, {name:"field", type:"field", required:!0}, {name:"probs", type:"number", array:!0}, {name:"step", type:"number", "default":0.01}, {name:"as", type:"string", array:!0, "default":["prob", "value"]}]};
    vegaUtil.inherits(Quantile, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS), as = _.as || ["prob", "value"];
      if (this.value && !_.modified() && !pulse.changed()) {
        return out.source = this.value, out;
      }
      pulse = pulse.materialize(pulse.SOURCE).source;
      pulse = partition$1(pulse, _.groupby, _.field);
      const names = (_.groupby || []).map(vegaUtil.accessorName), values = [], step = _.step || 0.01, p = _.probs || range(step / 2, 1 - 1e-14, step), n = p.length;
      pulse.forEach(g => {
        const q = vegaStatistics.quantiles(g, p);
        for (let i = 0; i < n; ++i) {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[i];
          t[as[1]] = q[i];
          values.push(vegaDataflow.ingest(t));
        }
      });
      this.value && (out.rem = this.value);
      this.value = out.add = out.source = values;
      return out;
    }});
    vegaUtil.inherits(Relay, vegaDataflow.Transform, {transform(_, pulse) {
      let out, lut;
      this.value ? lut = this.value : (out = pulse = pulse.addAll(), lut = this.value = {});
      _.derive && (out = pulse.fork(pulse.NO_SOURCE), pulse.visit(pulse.REM, t => {
        t = vegaDataflow.tupleid(t);
        out.rem.push(lut[t]);
        lut[t] = null;
      }), pulse.visit(pulse.ADD, t => {
        const dt = vegaDataflow.derive(t);
        lut[vegaDataflow.tupleid(t)] = dt;
        out.add.push(dt);
      }), pulse.visit(pulse.MOD, t => {
        const dt = lut[vegaDataflow.tupleid(t)];
        for (const k in t) {
          dt[k] = t[k], out.modifies(k);
        }
        out.mod.push(dt);
      }));
      return out;
    }});
    Sample.Definition = {type:"Sample", metadata:{}, params:[{name:"size", type:"number", "default":1000}]};
    vegaUtil.inherits(Sample, vegaDataflow.Transform, {transform(_, pulse) {
      function update(t) {
        let p, idx;
        res.length < num ? res.push(t) : (idx = ~~((cnt + 1) * vegaStatistics.random()), idx < res.length && idx >= cap && (p = res[idx], map[vegaDataflow.tupleid(p)] && out.rem.push(p), res[idx] = t));
        ++cnt;
      }
      const out = pulse.fork(pulse.NO_SOURCE);
      var mod = _.modified("size");
      const num = _.size, map = this.value.reduce((m, t) => (m[vegaDataflow.tupleid(t)] = 1, m), {});
      let res = this.value, cnt = this.count, cap = 0;
      pulse.rem.length && (pulse.visit(pulse.REM, t => {
        const id = vegaDataflow.tupleid(t);
        map[id] && (map[id] = -1, out.rem.push(t));
        --cnt;
      }), res = res.filter(t => map[vegaDataflow.tupleid(t)] !== -1));
      (pulse.rem.length || mod) && res.length < num && pulse.source && (cap = cnt = res.length, pulse.visit(pulse.SOURCE, t => {
        map[vegaDataflow.tupleid(t)] || update(t);
      }), cap = -1);
      if (mod && res.length > num) {
        _ = res.length - num;
        for (mod = 0; mod < _; ++mod) {
          map[vegaDataflow.tupleid(res[mod])] = -1, out.rem.push(res[mod]);
        }
        res = res.slice(_);
      }
      pulse.mod.length && pulse.visit(pulse.MOD, t => {
        map[vegaDataflow.tupleid(t)] && out.mod.push(t);
      });
      pulse.add.length && pulse.visit(pulse.ADD, update);
      if (pulse.add.length || cap < 0) {
        out.add = res.filter(t => !map[vegaDataflow.tupleid(t)]);
      }
      this.count = cnt;
      this.value = out.source = res;
      return out;
    }});
    Sequence.Definition = {type:"Sequence", metadata:{generates:!0, changes:!0}, params:[{name:"start", type:"number", required:!0}, {name:"stop", type:"number", required:!0}, {name:"step", type:"number", "default":1}, {name:"as", type:"string", "default":"data"}]};
    vegaUtil.inherits(Sequence, vegaDataflow.Transform, {transform(_, pulse) {
      if (!this.value || _.modified()) {
        var out = pulse.materialize().fork(pulse.MOD), as = _.as || "data";
        out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;
        this.value = range(_.start, _.stop, _.step || 1).map(v => {
          const t = {};
          t[as] = v;
          return vegaDataflow.ingest(t);
        });
        out.add = pulse.add.concat(this.value);
        return out;
      }
    }});
    vegaUtil.inherits(Sieve, vegaDataflow.Transform, {transform(_, pulse) {
      this.value = pulse.source;
      return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
    }});
    const OUTPUT = ["unit0", "unit1"];
    TimeUnit.Definition = {type:"TimeUnit", metadata:{modifies:!0}, params:[{name:"field", type:"field", required:!0}, {name:"interval", type:"boolean", "default":!0}, {name:"units", type:"enum", values:vegaTime.TIME_UNITS, array:!0}, {name:"step", type:"number", "default":1}, {name:"maxbins", type:"number", "default":40}, {name:"extent", type:"date", array:!0}, {name:"timezone", type:"enum", "default":"local", values:["local", "utc"]}, {name:"as", type:"string", array:!0, length:2, "default":OUTPUT}]};
    vegaUtil.inherits(TimeUnit, vegaDataflow.Transform, {transform(_, pulse) {
      const field = _.field, band = _.interval !== !1;
      var utc = _.timezone === "utc";
      const floor = this._floor(_, pulse), offset = (utc ? vegaTime.utcInterval : vegaTime.timeInterval)(floor.unit).offset;
      utc = _.as || OUTPUT;
      const u0 = utc[0], u1 = utc[1], step = floor.step;
      let min = floor.start || Infinity, max = floor.stop || -Infinity, flag = pulse.ADD;
      if (_.modified() || pulse.changed(pulse.REM) || pulse.modified(vegaUtil.accessorFields(field))) {
        pulse = pulse.reflow(!0), flag = pulse.SOURCE, min = Infinity, max = -Infinity;
      }
      pulse.visit(flag, t => {
        var v = field(t);
        let b;
        v == null ? (t[u0] = null, band && (t[u1] = null)) : (t[u0] = v = b = floor(v), band && (t[u1] = b = offset(v, step)), v < min && (min = v), b > max && (max = b));
      });
      floor.start = min;
      floor.stop = max;
      return pulse.modifies(band ? utc : u0);
    }, _floor(_, pulse) {
      var utc = _.timezone === "utc";
      const {units, step} = _.units ? {units:_.units, step:_.step || 1} : vegaTime.timeBin({extent:_.extent || vegaUtil.extent(pulse.materialize(pulse.SOURCE).source, _.field), maxbins:_.maxbins});
      _ = vegaTime.timeUnits(units);
      pulse = this.value || {};
      utc = (utc ? vegaTime.utcFloor : vegaTime.timeFloor)(_, step);
      utc.unit = vegaUtil.peek(_);
      utc.units = _;
      utc.step = step;
      utc.start = pulse.start;
      utc.stop = pulse.stop;
      return this.value = utc;
    }});
    vegaUtil.inherits(TupleIndex, vegaDataflow.Transform, {transform(_, pulse) {
      const df = pulse.dataflow, field = _.field, index = this.value, set = t => index.set(field(t), t);
      let mod = !0;
      _.modified("field") || pulse.modified(field.fields) ? (index.clear(), pulse.visit(pulse.SOURCE, set)) : pulse.changed() ? (pulse.visit(pulse.REM, t => index.delete(field(t))), pulse.visit(pulse.ADD, set)) : mod = !1;
      this.modified(mod);
      index.empty > df.cleanThreshold && df.runAfter(index.clean);
      return pulse.fork();
    }});
    vegaUtil.inherits(Values, vegaDataflow.Transform, {transform(_, pulse) {
      if (!this.value || _.modified("field") || _.modified("sort") || pulse.changed() || _.sort && pulse.modified(_.sort.fields)) {
        this.value = (_.sort ? pulse.source.slice().sort(vegaDataflow.stableCompare(_.sort)) : pulse.source).map(_.field);
      }
    }});
    const WindowOps = {row_number:function() {
      return {next:w => w.index + 1};
    }, rank:function() {
      let rank;
      return {init:() => rank = 1, next:w => {
        const i = w.index, data = w.data;
        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;
      }};
    }, dense_rank:function() {
      let drank;
      return {init:() => drank = 1, next:w => {
        const i = w.index, d = w.data;
        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;
      }};
    }, percent_rank:function() {
      const rank = WindowOps.rank(), next = rank.next;
      return {init:rank.init, next:w => (next(w) - 1) / (w.data.length - 1)};
    }, cume_dist:function() {
      let cume;
      return {init:() => cume = 0, next:w => {
        const d = w.data, c = w.compare;
        w = w.index;
        if (cume < w) {
          for (; w + 1 < d.length && !c(d[w], d[w + 1]);) {
            ++w;
          }
          cume = w;
        }
        return (1 + cume) / d.length;
      }};
    }, ntile:function(field, num) {
      num = +num;
      num > 0 || vegaUtil.error("ntile num must be greater than zero.");
      field = WindowOps.cume_dist();
      const next = field.next;
      return {init:field.init, next:w => Math.ceil(num * next(w))};
    }, lag:function(field, offset) {
      offset = +offset || 1;
      return {next:w => {
        const i = w.index - offset;
        return i >= 0 ? field(w.data[i]) : null;
      }};
    }, lead:function(field, offset) {
      offset = +offset || 1;
      return {next:w => {
        const i = w.index + offset;
        w = w.data;
        return i < w.length ? field(w[i]) : null;
      }};
    }, first_value:function(field) {
      return {next:w => field(w.data[w.i0])};
    }, last_value:function(field) {
      return {next:w => field(w.data[w.i1 - 1])};
    }, nth_value:function(field, nth) {
      nth = +nth;
      nth > 0 || vegaUtil.error("nth_value nth must be greater than zero.");
      return {next:w => {
        const i = w.i0 + (nth - 1);
        return i < w.i1 ? field(w.data[i]) : null;
      }};
    }, prev_value:function(field) {
      let prev;
      return {init:() => prev = null, next:w => {
        w = field(w.data[w.index]);
        return w != null ? prev = w : prev;
      }};
    }, next_value:function(field) {
      let v, i;
      return {init:() => (v = null, i = -1), next:w => {
        var d = w.data;
        if (w.index <= i) {
          d = v;
        } else {
          a: {
            w = w.index;
            for (let n = d.length; w < n; ++w) {
              if (field(d[w]) != null) {
                break a;
              }
            }
            w = -1;
          }
          d = (i = w) < 0 ? (i = d.length, v = null) : v = field(d[i]);
        }
        return d;
      }};
    }}, ValidWindowOps = Object.keys(WindowOps), prototype = WindowState.prototype;
    prototype.init = function() {
      this.windows.forEach(_ => _.init());
      this.cell && this.cell.init();
    };
    prototype.update = function(w, t) {
      const cell = this.cell, wind = this.windows, data = w.data, m = wind && wind.length;
      let j;
      if (cell) {
        for (j = w.p0; j < w.i0; ++j) {
          cell.rem(data[j]);
        }
        for (j = w.p1; j < w.i1; ++j) {
          cell.add(data[j]);
        }
        cell.set(t);
      }
      for (j = 0; j < m; ++j) {
        wind[j].update(w, t);
      }
    };
    Window.Definition = {type:"Window", metadata:{modifies:!0}, params:[{name:"sort", type:"compare"}, {name:"groupby", type:"field", array:!0}, {name:"ops", type:"enum", array:!0, values:ValidWindowOps.concat(ValidAggregateOps)}, {name:"params", type:"number", "null":!0, array:!0}, {name:"aggregate_params", type:"number", "null":!0, array:!0}, {name:"fields", type:"field", "null":!0, array:!0}, {name:"as", type:"string", "null":!0, array:!0}, {name:"frame", type:"number", "null":!0, array:!0, length:2, 
    "default":[null, 0]}, {name:"ignorePeers", type:"boolean", "default":!1}]};
    vegaUtil.inherits(Window, vegaDataflow.Transform, {transform(_, pulse) {
      this.stamp = pulse.stamp;
      const mod = _.modified(), cmp = vegaDataflow.stableCompare(_.sort), key = groupkey(_.groupby), group = t => this.group(key(t));
      let state = this.state;
      if (!state || mod) {
        state = this.state = new WindowState(_);
      }
      mod || pulse.modified(state.inputs) ? (this.value = {}, pulse.visit(pulse.SOURCE, t => group(t).add(t))) : (pulse.visit(pulse.REM, t => group(t).remove(t)), pulse.visit(pulse.ADD, t => group(t).add(t)));
      for (let i = 0, n = this._mlen; i < n; ++i) {
        processPartition(this._mods[i], state, cmp, _);
      }
      this._mlen = 0;
      this._mods = [];
      return pulse.reflow(mod).modifies(state.outputs);
    }, group(key) {
      let group = this.value[key];
      group || (group = this.value[key] = SortedList(vegaDataflow.tupleid), group.stamp = -1);
      group.stamp < this.stamp && (group.stamp = this.stamp, this._mods[this._mlen++] = group);
      return group;
    }});
    exports.aggregate = Aggregate;
    exports.bin = Bin;
    exports.collect = Collect;
    exports.compare = Compare;
    exports.countpattern = CountPattern;
    exports.cross = Cross;
    exports.density = Density;
    exports.dotbin = DotBin;
    exports.expression = Expression;
    exports.extent = Extent;
    exports.facet = Facet;
    exports.field = Field;
    exports.filter = Filter;
    exports.flatten = Flatten;
    exports.fold = Fold;
    exports.formula = Formula;
    exports.generate = Generate;
    exports.impute = Impute;
    exports.joinaggregate = JoinAggregate;
    exports.kde = KDE;
    exports.key = Key;
    exports.load = Load;
    exports.lookup = Lookup;
    exports.multiextent = MultiExtent;
    exports.multivalues = MultiValues;
    exports.params = Params;
    exports.pivot = Pivot;
    exports.prefacet = PreFacet;
    exports.project = Project;
    exports.proxy = Proxy;
    exports.quantile = Quantile;
    exports.relay = Relay;
    exports.sample = Sample;
    exports.sequence = Sequence;
    exports.sieve = Sieve;
    exports.subflow = Subflow;
    exports.timeunit = TimeUnit;
    exports.tupleindex = TupleIndex;
    exports.values = Values;
    exports.window = Window;
  });
};

//# sourceMappingURL=module$node_modules$vega_transforms$build$vega_transforms.js.map
