shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$controller$mouseTarget = function(require, module, exports) {
  function createEmptyContentDataInLines(horizontalDistanceToText) {
    return {isAfterLines:!1, horizontalDistanceToText};
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, HitTestContext:{enumerable:!0, get:function() {
    return HitTestContext;
  }}, MouseTarget:{enumerable:!0, get:function() {
    return MouseTarget;
  }}, MouseTargetFactory:{enumerable:!0, get:function() {
    return MouseTargetFactory;
  }}, PointerHandlerLastRenderData:{enumerable:!0, get:function() {
    return PointerHandlerLastRenderData;
  }}});
  var require$_DOT__DOT__SLASH_editorDom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$editorDom"), require$_DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart"), require$_DOT__DOT__SLASH_viewParts_SLASH_lines_SLASH_viewLine_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLine"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_cursorColumns_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$cursorColumns"), dom = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_cursor_SLASH_cursorAtomicMoveOperations_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorAtomicMoveOperations");
  class UnknownHitTestResult {
    constructor(hitTarget = null) {
      this.hitTarget = hitTarget;
      this.type = 0;
    }
  }
  class ContentHitTestResult {
    constructor(position, spanNode, injectedText) {
      this.position = position;
      this.spanNode = spanNode;
      this.injectedText = injectedText;
      this.type = 1;
    }
  }
  var HitTestResult;
  (function(HitTestResult) {
    HitTestResult.createFromDOMInfo = function(ctx, spanNode, offset) {
      return (ctx = ctx.getPositionFromDOMInfo(spanNode, offset)) ? new ContentHitTestResult(ctx, spanNode, null) : new UnknownHitTestResult(spanNode);
    };
  })(HitTestResult ||= {});
  class PointerHandlerLastRenderData {
    constructor(lastViewCursorsRenderData, lastTextareaPosition) {
      this.lastViewCursorsRenderData = lastViewCursorsRenderData;
      this.lastTextareaPosition = lastTextareaPosition;
    }
  }
  class MouseTarget {
    static _deduceRage(position, range = null) {
      return !range && position ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, position.column, position.lineNumber, position.column) : range !== null && range !== void 0 ? range : null;
    }
    static createUnknown(element, mouseColumn, position) {
      return {type:0, element, mouseColumn, position, range:this._deduceRage(position)};
    }
    static createTextarea(element, mouseColumn) {
      return {type:1, element, mouseColumn, position:null, range:null};
    }
    static createMargin(type, element, mouseColumn, position, range, detail) {
      return {type, element, mouseColumn, position, range, detail};
    }
    static createViewZone(type, element, mouseColumn, position, detail) {
      return {type, element, mouseColumn, position, range:this._deduceRage(position), detail};
    }
    static createContentText(element, mouseColumn, position, range, detail) {
      return {type:6, element, mouseColumn, position, range:this._deduceRage(position, range), detail};
    }
    static createContentEmpty(element, mouseColumn, position, detail) {
      return {type:7, element, mouseColumn, position, range:this._deduceRage(position), detail};
    }
    static createContentWidget(element, mouseColumn, detail) {
      return {type:9, element, mouseColumn, position:null, range:null, detail};
    }
    static createScrollbar(element, mouseColumn, position) {
      return {type:11, element, mouseColumn, position, range:this._deduceRage(position)};
    }
    static createOverlayWidget(element, mouseColumn, detail) {
      return {type:12, element, mouseColumn, position:null, range:null, detail};
    }
    static createOutsideEditor(mouseColumn, position, outsidePosition, outsideDistance) {
      return {type:13, element:null, mouseColumn, position, range:this._deduceRage(position), outsidePosition, outsideDistance};
    }
    static _typeToString(type) {
      return type === 1 ? "TEXTAREA" : type === 2 ? "GUTTER_GLYPH_MARGIN" : type === 3 ? "GUTTER_LINE_NUMBERS" : type === 4 ? "GUTTER_LINE_DECORATIONS" : type === 5 ? "GUTTER_VIEW_ZONE" : type === 6 ? "CONTENT_TEXT" : type === 7 ? "CONTENT_EMPTY" : type === 8 ? "CONTENT_VIEW_ZONE" : type === 9 ? "CONTENT_WIDGET" : type === 10 ? "OVERVIEW_RULER" : type === 11 ? "SCROLLBAR" : type === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
    }
    static toString(target) {
      return this._typeToString(target.type) + ": " + target.position + " - " + target.range + " - " + JSON.stringify(target.detail);
    }
  }
  class ElementPath {
    static isTextArea(path) {
      return path.length === 2 && path[0] === 3 && path[1] === 6;
    }
    static isChildOfViewLines(path) {
      return path.length >= 4 && path[0] === 3 && path[3] === 7;
    }
    static isStrictChildOfViewLines(path) {
      return path.length > 4 && path[0] === 3 && path[3] === 7;
    }
    static isChildOfScrollableElement(path) {
      return path.length >= 2 && path[0] === 3 && path[1] === 5;
    }
    static isChildOfMinimap(path) {
      return path.length >= 2 && path[0] === 3 && path[1] === 8;
    }
    static isChildOfContentWidgets(path) {
      return path.length >= 4 && path[0] === 3 && path[3] === 1;
    }
    static isChildOfOverflowGuard(path) {
      return path.length >= 1 && path[0] === 3;
    }
    static isChildOfOverflowingContentWidgets(path) {
      return path.length >= 1 && path[0] === 2;
    }
    static isChildOfOverlayWidgets(path) {
      return path.length >= 2 && path[0] === 3 && path[1] === 4;
    }
  }
  class HitTestContext {
    constructor(context, viewHelper, lastRenderData) {
      this.viewModel = context.viewModel;
      const options = context.configuration.options;
      this.layoutInfo = options.get(143);
      this.viewDomNode = viewHelper.viewDomNode;
      this.lineHeight = options.get(66);
      this.stickyTabStops = options.get(115);
      this.typicalHalfwidthCharacterWidth = options.get(50).typicalHalfwidthCharacterWidth;
      this.lastRenderData = lastRenderData;
      this._context = context;
      this._viewHelper = viewHelper;
    }
    getZoneAtCoord(mouseVerticalOffset) {
      return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);
    }
    static getZoneAtCoord(context, mouseVerticalOffset) {
      const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);
      if (viewZoneWhitespace) {
        const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2, lineCount = context.viewModel.getLineCount();
        let positionBefore = null, positionAfter = null;
        viewZoneWhitespace.afterLineNumber !== lineCount && (positionAfter = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewZoneWhitespace.afterLineNumber + 1, 1));
        viewZoneWhitespace.afterLineNumber > 0 && (positionBefore = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber)));
        return {viewZoneId:viewZoneWhitespace.id, afterLineNumber:viewZoneWhitespace.afterLineNumber, positionBefore, positionAfter, position:positionAfter === null ? positionBefore : positionBefore === null ? positionAfter : mouseVerticalOffset < viewZoneMiddle ? positionBefore : positionAfter};
      }
      return null;
    }
    getFullLineRangeAtCoord(mouseVerticalOffset) {
      if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {
        mouseVerticalOffset = this._context.viewModel.getLineCount();
        var maxLineColumn = this._context.viewModel.getLineMaxColumn(mouseVerticalOffset);
        return {range:new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(mouseVerticalOffset, maxLineColumn, mouseVerticalOffset, maxLineColumn), isAfterLines:!0};
      }
      mouseVerticalOffset = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);
      maxLineColumn = this._context.viewModel.getLineMaxColumn(mouseVerticalOffset);
      return {range:new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(mouseVerticalOffset, 1, mouseVerticalOffset, maxLineColumn), isAfterLines:!1};
    }
    getLineNumberAtVerticalOffset(mouseVerticalOffset) {
      return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);
    }
    isAfterLines(mouseVerticalOffset) {
      return this._context.viewLayout.isAfterLines(mouseVerticalOffset);
    }
    isInTopPadding(mouseVerticalOffset) {
      return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);
    }
    isInBottomPadding(mouseVerticalOffset) {
      return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);
    }
    getVerticalOffsetForLineNumber(lineNumber) {
      return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);
    }
    findAttribute(element, attr) {
      return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);
    }
    static _findAttribute(element, attr, stopAt) {
      for (; element && element !== element.ownerDocument.body;) {
        if (element.hasAttribute && element.hasAttribute(attr)) {
          return element.getAttribute(attr);
        }
        if (element === stopAt) {
          break;
        }
        element = element.parentNode;
      }
      return null;
    }
    getLineWidth(lineNumber) {
      return this._viewHelper.getLineWidth(lineNumber);
    }
    visibleRangeForPosition(lineNumber, column) {
      return this._viewHelper.visibleRangeForPosition(lineNumber, column);
    }
    getPositionFromDOMInfo(spanNode, offset) {
      return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);
    }
    getCurrentScrollTop() {
      return this._context.viewLayout.getCurrentScrollTop();
    }
    getCurrentScrollLeft() {
      return this._context.viewLayout.getCurrentScrollLeft();
    }
  }
  class BareHitTestRequest {
    constructor(ctx, editorPos, pos, relativePos) {
      this.editorPos = editorPos;
      this.pos = pos;
      this.relativePos = relativePos;
      this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);
      this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;
      this.isInMarginArea = this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft;
      this.isInContentArea = !this.isInMarginArea;
      this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));
    }
  }
  class HitTestRequest extends BareHitTestRequest {
    constructor(ctx, editorPos, pos, relativePos, target) {
      super(ctx, editorPos, pos, relativePos);
      this._ctx = ctx;
      target ? (this.target = target, this.targetPath = require$_DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.collect(target, ctx.viewDomNode)) : (this.target = null, this.targetPath = new Uint8Array(0));
    }
    toString() {
      return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\n\ttarget: ${this.target ? this.target.outerHTML : null}`;
    }
    _getMouseColumn(position = null) {
      return position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber) ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
    }
    fulfillUnknown(position = null) {
      return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);
    }
    fulfillTextarea() {
      return MouseTarget.createTextarea(this.target, this._getMouseColumn());
    }
    fulfillMargin(type, position, range, detail) {
      return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);
    }
    fulfillViewZone(type, position, detail) {
      return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);
    }
    fulfillContentText(position, range, detail) {
      return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);
    }
    fulfillContentEmpty(position, detail) {
      return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);
    }
    fulfillContentWidget(detail) {
      return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);
    }
    fulfillScrollbar(position) {
      return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);
    }
    fulfillOverlayWidget(detail) {
      return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);
    }
    withTarget(target) {
      return new HitTestRequest(this._ctx, this.editorPos, this.pos, this.relativePos, target);
    }
  }
  const EMPTY_CONTENT_AFTER_LINES = {isAfterLines:!0};
  class MouseTargetFactory {
    constructor(context, viewHelper) {
      this._context = context;
      this._viewHelper = viewHelper;
    }
    mouseTargetIsWidget(e) {
      e = require$_DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.collect(e.target, this._viewHelper.viewDomNode);
      return ElementPath.isChildOfContentWidgets(e) || ElementPath.isChildOfOverflowingContentWidgets(e) || ElementPath.isChildOfOverlayWidgets(e) ? !0 : !1;
    }
    createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {
      lastRenderData = new HitTestContext(this._context, this._viewHelper, lastRenderData);
      editorPos = new HitTestRequest(lastRenderData, editorPos, pos, relativePos, target);
      try {
        const r = MouseTargetFactory._createMouseTarget(lastRenderData, editorPos, !1);
        if (r.type === 6 && lastRenderData.stickyTabStops && r.position !== null) {
          const position = MouseTargetFactory._snapToSoftTabBoundary(r.position, lastRenderData.viewModel), range = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(position, position).plusRange(r.range);
          return editorPos.fulfillContentText(position, range, r.detail);
        }
        return r;
      } catch (err) {
        return editorPos.fulfillUnknown();
      }
    }
    static _createMouseTarget(ctx, request, domHitTestExecuted) {
      if (request.target === null) {
        if (domHitTestExecuted) {
          return request.fulfillUnknown();
        }
        domHitTestExecuted = MouseTargetFactory._doHitTest(ctx, request);
        return domHitTestExecuted.type === 1 ? MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, domHitTestExecuted.spanNode, domHitTestExecuted.position, domHitTestExecuted.injectedText) : this._createMouseTarget(ctx, request.withTarget(domHitTestExecuted.hitTarget), !0);
      }
      let result = null;
      ElementPath.isChildOfOverflowGuard(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) || (result = result || request.fulfillUnknown());
      return (result = (result = (result = (result = (result = (result = (result = (result = (result = (result = result || MouseTargetFactory._hitTestContentWidget(ctx, request)) || MouseTargetFactory._hitTestOverlayWidget(ctx, request)) || MouseTargetFactory._hitTestMinimap(ctx, request)) || MouseTargetFactory._hitTestScrollbarSlider(ctx, request)) || MouseTargetFactory._hitTestViewZone(ctx, request)) || MouseTargetFactory._hitTestMargin(ctx, request)) || MouseTargetFactory._hitTestViewCursor(ctx, 
      request)) || MouseTargetFactory._hitTestTextArea(ctx, request)) || MouseTargetFactory._hitTestViewLines(ctx, request, domHitTestExecuted)) || MouseTargetFactory._hitTestScrollbar(ctx, request)) || request.fulfillUnknown();
    }
    static _hitTestContentWidget(ctx, request) {
      return ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) ? (ctx = ctx.findAttribute(request.target, "widgetId")) ? request.fulfillContentWidget(ctx) : request.fulfillUnknown() : null;
    }
    static _hitTestOverlayWidget(ctx, request) {
      return ElementPath.isChildOfOverlayWidgets(request.targetPath) ? (ctx = ctx.findAttribute(request.target, "widgetId")) ? request.fulfillOverlayWidget(ctx) : request.fulfillUnknown() : null;
    }
    static _hitTestViewCursor(ctx, request) {
      if (request.target) {
        var lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;
        for (var d$jscomp$0 of lastViewCursorsRenderData) {
          if (request.target === d$jscomp$0.domNode) {
            return request.fulfillContentText(d$jscomp$0.position, null, {mightBeForeignElement:!1, injectedText:null});
          }
        }
      }
      if (request.isInContentArea) {
        var lastViewCursorsRenderData$jscomp$0 = ctx.lastRenderData.lastViewCursorsRenderData;
        lastViewCursorsRenderData = request.mouseContentHorizontalOffset;
        d$jscomp$0 = request.mouseVerticalOffset;
        for (const d of lastViewCursorsRenderData$jscomp$0) {
          if (!(lastViewCursorsRenderData < d.contentLeft || lastViewCursorsRenderData > d.contentLeft + d.width) && (lastViewCursorsRenderData$jscomp$0 = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber), lastViewCursorsRenderData$jscomp$0 <= d$jscomp$0 && d$jscomp$0 <= lastViewCursorsRenderData$jscomp$0 + d.height)) {
            return request.fulfillContentText(d.position, null, {mightBeForeignElement:!1, injectedText:null});
          }
        }
      }
      return null;
    }
    static _hitTestViewZone(ctx, request) {
      return (ctx = ctx.getZoneAtCoord(request.mouseVerticalOffset)) ? request.fulfillViewZone(request.isInContentArea ? 8 : 5, ctx.position, ctx) : null;
    }
    static _hitTestTextArea(ctx, request) {
      return ElementPath.isTextArea(request.targetPath) ? ctx.lastRenderData.lastTextareaPosition ? request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, {mightBeForeignElement:!1, injectedText:null}) : request.fulfillTextarea() : null;
    }
    static _hitTestMargin(ctx, request) {
      if (request.isInMarginArea) {
        const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset), pos = res.range.getStartPosition();
        let offset = Math.abs(request.relativePos.x);
        const detail = {isAfterLines:res.isAfterLines, glyphMarginLeft:ctx.layoutInfo.glyphMarginLeft, glyphMarginWidth:ctx.layoutInfo.glyphMarginWidth, lineNumbersWidth:ctx.layoutInfo.lineNumbersWidth, offsetX:offset};
        offset -= ctx.layoutInfo.glyphMarginLeft;
        if (offset <= ctx.layoutInfo.glyphMarginWidth) {
          return request.fulfillMargin(2, pos, res.range, detail);
        }
        offset -= ctx.layoutInfo.glyphMarginWidth;
        return offset <= ctx.layoutInfo.lineNumbersWidth ? request.fulfillMargin(3, pos, res.range, detail) : request.fulfillMargin(4, pos, res.range, detail);
      }
      return null;
    }
    static _hitTestViewLines(ctx, request, domHitTestExecuted) {
      if (!ElementPath.isChildOfViewLines(request.targetPath)) {
        return null;
      }
      if (ctx.isInTopPadding(request.mouseVerticalOffset)) {
        return request.fulfillContentEmpty(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(1, 1), EMPTY_CONTENT_AFTER_LINES);
      }
      if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {
        return domHitTestExecuted = ctx.viewModel.getLineCount(), ctx = ctx.viewModel.getLineMaxColumn(domHitTestExecuted), request.fulfillContentEmpty(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(domHitTestExecuted, ctx), EMPTY_CONTENT_AFTER_LINES);
      }
      if (domHitTestExecuted) {
        if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {
          domHitTestExecuted = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
          if (ctx.viewModel.getLineLength(domHitTestExecuted) === 0) {
            return ctx = ctx.getLineWidth(domHitTestExecuted), ctx = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - ctx), request.fulfillContentEmpty(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(domHitTestExecuted, 1), ctx);
          }
          var lineWidth = ctx.getLineWidth(domHitTestExecuted);
          if (request.mouseContentHorizontalOffset >= lineWidth) {
            return lineWidth = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth), ctx = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(domHitTestExecuted, ctx.viewModel.getLineMaxColumn(domHitTestExecuted)), request.fulfillContentEmpty(ctx, lineWidth);
          }
        }
        return request.fulfillUnknown();
      }
      domHitTestExecuted = MouseTargetFactory._doHitTest(ctx, request);
      return domHitTestExecuted.type === 1 ? MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, domHitTestExecuted.spanNode, domHitTestExecuted.position, domHitTestExecuted.injectedText) : this._createMouseTarget(ctx, request.withTarget(domHitTestExecuted.hitTarget), !0);
    }
    static _hitTestMinimap(ctx, request) {
      if (ElementPath.isChildOfMinimap(request.targetPath)) {
        const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
        ctx = ctx.viewModel.getLineMaxColumn(possibleLineNumber);
        return request.fulfillScrollbar(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(possibleLineNumber, ctx));
      }
      return null;
    }
    static _hitTestScrollbarSlider(ctx, request) {
      if (ElementPath.isChildOfScrollableElement(request.targetPath) && request.target && request.target.nodeType === 1) {
        var className = request.target.className;
        if (className && /\b(slider|scrollbar)\b/.test(className)) {
          return className = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset), ctx = ctx.viewModel.getLineMaxColumn(className), request.fulfillScrollbar(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(className, ctx));
        }
      }
      return null;
    }
    static _hitTestScrollbar(ctx, request) {
      if (ElementPath.isChildOfScrollableElement(request.targetPath)) {
        const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
        ctx = ctx.viewModel.getLineMaxColumn(possibleLineNumber);
        return request.fulfillScrollbar(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(possibleLineNumber, ctx));
      }
      return null;
    }
    getMouseColumn(relativePos) {
      const options = this._context.configuration.options, layoutInfo = options.get(143);
      relativePos = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;
      return MouseTargetFactory._getMouseColumn(relativePos, options.get(50).typicalHalfwidthCharacterWidth);
    }
    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {
      return mouseContentHorizontalOffset < 0 ? 1 : Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth) + 1;
    }
    static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {
      const lineNumber = pos.lineNumber;
      var column = pos.column, lineWidth = ctx.getLineWidth(lineNumber);
      if (request.mouseContentHorizontalOffset > lineWidth) {
        return injectedText = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth), request.fulfillContentEmpty(pos, injectedText);
      }
      var visibleRange = ctx.visibleRangeForPosition(lineNumber, column);
      if (!visibleRange) {
        return request.fulfillUnknown(pos);
      }
      if (Math.abs(request.mouseContentHorizontalOffset - visibleRange.left) < 1) {
        return request.fulfillContentText(pos, null, {mightBeForeignElement:!!injectedText, injectedText});
      }
      lineWidth = [];
      lineWidth.push({offset:visibleRange.left, column});
      column > 1 && (visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1)) && lineWidth.push({offset:visibleRange.left, column:column - 1});
      visibleRange = ctx.viewModel.getLineMaxColumn(lineNumber);
      column < visibleRange && (visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1)) && lineWidth.push({offset:visibleRange.left, column:column + 1});
      lineWidth.sort((a, b) => a.offset - b.offset);
      ctx = request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode));
      spanNode = spanNode.getBoundingClientRect();
      spanNode = spanNode.left <= ctx.clientX && ctx.clientX <= spanNode.right;
      ctx = null;
      for (column = 1; column < lineWidth.length; column++) {
        visibleRange = lineWidth[column - 1];
        const curr = lineWidth[column];
        if (visibleRange.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {
          ctx = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(lineNumber, visibleRange.column, lineNumber, curr.column);
          pos = Math.abs(visibleRange.offset - request.mouseContentHorizontalOffset) < Math.abs(curr.offset - request.mouseContentHorizontalOffset) ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(lineNumber, visibleRange.column) : new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(lineNumber, curr.column);
          break;
        }
      }
      return request.fulfillContentText(pos, ctx, {mightBeForeignElement:!spanNode || !!injectedText, injectedText});
    }
    static _doHitTestWithCaretRangeFromPoint(ctx, request) {
      var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
      const lineStartVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber), lineEndVerticalOffset = lineStartVerticalOffset + ctx.lineHeight;
      return lineNumber === ctx.viewModel.getLineCount() && request.mouseVerticalOffset > lineEndVerticalOffset || (lineNumber = request.pos.y + (Math.floor((lineStartVerticalOffset + lineEndVerticalOffset) / 2) - request.mouseVerticalOffset), lineNumber <= request.editorPos.y && (lineNumber = request.editorPos.y + 1), lineNumber >= request.editorPos.y + request.editorPos.height && (lineNumber = request.editorPos.y + request.editorPos.height - 1), lineNumber = new require$_DOT__DOT__SLASH_editorDom_DOT_js.PageCoordinates(request.pos.x, 
      lineNumber), lineNumber = this._actualDoHitTestWithCaretRangeFromPoint(ctx, lineNumber.toClientCoordinates(dom.getWindow(ctx.viewDomNode))), lineNumber.type !== 1) ? this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode))) : lineNumber;
    }
    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {
      var shadowRoot = dom.getShadowRoot(ctx.viewDomNode);
      if (shadowRoot) {
        if (typeof shadowRoot.caretRangeFromPoint === "undefined") {
          var x = coords.clientX, y = coords.clientY;
          coords = document.createRange();
          shadowRoot = shadowRoot.elementFromPoint(x, y);
          if (shadowRoot !== null) {
            for (; shadowRoot && shadowRoot.firstChild && shadowRoot.firstChild.nodeType !== shadowRoot.firstChild.TEXT_NODE && shadowRoot.lastChild && shadowRoot.lastChild.firstChild;) {
              shadowRoot = shadowRoot.lastChild;
            }
            y = shadowRoot.getBoundingClientRect();
            var elWindow = dom.getWindow(shadowRoot), fontStyle = elWindow.getComputedStyle(shadowRoot, null).getPropertyValue("font-style"), fontVariant = elWindow.getComputedStyle(shadowRoot, null).getPropertyValue("font-variant"), fontWeight = elWindow.getComputedStyle(shadowRoot, null).getPropertyValue("font-weight"), fontSize = elWindow.getComputedStyle(shadowRoot, null).getPropertyValue("font-size"), lineHeight = elWindow.getComputedStyle(shadowRoot, null).getPropertyValue("line-height");
            elWindow = elWindow.getComputedStyle(shadowRoot, null).getPropertyValue("font-family");
            fontStyle = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${elWindow}`;
            fontVariant = shadowRoot.innerText;
            fontWeight = y.left;
            fontSize = 0;
            if (x > y.left + y.width) {
              fontSize = fontVariant.length;
            } else {
              for (lineHeight = CharWidthReader.getInstance(), elWindow = 0; elWindow < fontVariant.length + 1; elWindow++) {
                y = lineHeight.getCharWidth(fontVariant.charAt(elWindow), fontStyle) / 2;
                fontWeight += y;
                if (x < fontWeight) {
                  fontSize = elWindow;
                  break;
                }
                fontWeight += y;
              }
            }
            coords.setStart(shadowRoot.firstChild, fontSize);
            coords.setEnd(shadowRoot.firstChild, fontSize);
          }
        } else {
          coords = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);
        }
      } else {
        coords = ctx.viewDomNode.ownerDocument.caretRangeFromPoint(coords.clientX, coords.clientY);
      }
      if (!coords || !coords.startContainer) {
        return new UnknownHitTestResult();
      }
      x = coords.startContainer;
      return x.nodeType === x.TEXT_NODE ? (y = (y = (shadowRoot = x.parentNode) ? shadowRoot.parentNode : null) ? y.parentNode : null, (y && y.nodeType === y.ELEMENT_NODE ? y.className : null) === require$_DOT__DOT__SLASH_viewParts_SLASH_lines_SLASH_viewLine_DOT_js.ViewLine.CLASS_NAME ? HitTestResult.createFromDOMInfo(ctx, shadowRoot, coords.startOffset) : new UnknownHitTestResult(x.parentNode)) : x.nodeType === x.ELEMENT_NODE ? (coords = (coords = x.parentNode) ? coords.parentNode : null, (coords && 
      coords.nodeType === coords.ELEMENT_NODE ? coords.className : null) === require$_DOT__DOT__SLASH_viewParts_SLASH_lines_SLASH_viewLine_DOT_js.ViewLine.CLASS_NAME ? HitTestResult.createFromDOMInfo(ctx, x, x.textContent.length) : new UnknownHitTestResult(x)) : new UnknownHitTestResult();
    }
    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {
      coords = ctx.viewDomNode.ownerDocument.caretPositionFromPoint(coords.clientX, coords.clientY);
      if (coords.offsetNode.nodeType === coords.offsetNode.TEXT_NODE) {
        var parent1 = coords.offsetNode.parentNode;
        parent1 = (parent1 = parent1 ? parent1.parentNode : null) ? parent1.parentNode : null;
        return (parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null) === require$_DOT__DOT__SLASH_viewParts_SLASH_lines_SLASH_viewLine_DOT_js.ViewLine.CLASS_NAME ? HitTestResult.createFromDOMInfo(ctx, coords.offsetNode.parentNode, coords.offset) : new UnknownHitTestResult(coords.offsetNode.parentNode);
      }
      if (coords.offsetNode.nodeType === coords.offsetNode.ELEMENT_NODE) {
        var parent2 = (parent1 = coords.offsetNode.parentNode) ? parent1.parentNode : null;
        parent2 = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;
        if ((parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null) === require$_DOT__DOT__SLASH_viewParts_SLASH_lines_SLASH_viewLine_DOT_js.ViewLine.CLASS_NAME) {
          if (parent1 = coords.offsetNode.childNodes[Math.min(coords.offset, coords.offsetNode.childNodes.length - 1)]) {
            return HitTestResult.createFromDOMInfo(ctx, parent1, 0);
          }
        } else if (parent2 === require$_DOT__DOT__SLASH_viewParts_SLASH_lines_SLASH_viewLine_DOT_js.ViewLine.CLASS_NAME) {
          return HitTestResult.createFromDOMInfo(ctx, coords.offsetNode, 0);
        }
      }
      return new UnknownHitTestResult(coords.offsetNode);
    }
    static _snapToSoftTabBoundary(position, viewModel) {
      var lineContent = viewModel.getLineContent(position.lineNumber);
      ({tabSize:viewModel} = viewModel.model.getOptions());
      lineContent = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_cursor_SLASH_cursorAtomicMoveOperations_DOT_js.AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, viewModel, 2);
      return lineContent !== -1 ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(position.lineNumber, lineContent + 1) : position;
    }
    static _doHitTest(ctx, request) {
      let result = new UnknownHitTestResult();
      typeof ctx.viewDomNode.ownerDocument.caretRangeFromPoint === "function" ? result = this._doHitTestWithCaretRangeFromPoint(ctx, request) : ctx.viewDomNode.ownerDocument.caretPositionFromPoint && (result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode))));
      result.type === 1 && (request = ctx.viewModel.getInjectedTextAt(result.position), ctx = ctx.viewModel.normalizePosition(result.position, 2), request || !ctx.equals(result.position)) && (result = new ContentHitTestResult(ctx, result.spanNode, request));
      return result;
    }
  }
  class CharWidthReader {
    static getInstance() {
      CharWidthReader._INSTANCE || (CharWidthReader._INSTANCE = new CharWidthReader());
      return CharWidthReader._INSTANCE;
    }
    constructor() {
      this._cache = {};
      this._canvas = document.createElement("canvas");
    }
    getCharWidth(char, font) {
      const cacheKey = char + font;
      if (this._cache[cacheKey]) {
        return this._cache[cacheKey];
      }
      const context = this._canvas.getContext("2d");
      context.font = font;
      char = context.measureText(char).width;
      return this._cache[cacheKey] = char;
    }
  }
  CharWidthReader._INSTANCE = null;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$controller$mouseTarget.js.map
