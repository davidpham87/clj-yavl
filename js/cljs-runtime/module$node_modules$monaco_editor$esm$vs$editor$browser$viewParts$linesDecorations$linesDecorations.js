shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$linesDecorations$linesDecorations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LinesDecorationsOverlay:{enumerable:!0, get:function() {
    return LinesDecorationsOverlay;
  }}});
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$linesDecorations$linesDecorations_css");
  var require$_DOT__DOT__SLASH_glyphMargin_SLASH_glyphMargin_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$glyphMargin$glyphMargin");
  class LinesDecorationsOverlay extends require$_DOT__DOT__SLASH_glyphMargin_SLASH_glyphMargin_DOT_js.DedupOverlay {
    constructor(context) {
      super();
      this._context = context;
      context = this._context.configuration.options.get(143);
      this._decorationsLeft = context.decorationsLeft;
      this._decorationsWidth = context.decorationsWidth;
      this._renderResult = null;
      this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this);
      this._renderResult = null;
      super.dispose();
    }
    onConfigurationChanged(e) {
      e = this._context.configuration.options.get(143);
      this._decorationsLeft = e.decorationsLeft;
      this._decorationsWidth = e.decorationsWidth;
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _getDecorations(ctx) {
      ctx = ctx.getDecorationsInViewport();
      const r = [];
      let rLen = 0;
      for (let i = 0, len = ctx.length; i < len; i++) {
        const d = ctx[i];
        var linesDecorationsClassName = d.options.linesDecorationsClassName;
        const zIndex = d.options.zIndex;
        linesDecorationsClassName && (r[rLen++] = new require$_DOT__DOT__SLASH_glyphMargin_SLASH_glyphMargin_DOT_js.DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, linesDecorationsClassName, zIndex));
        (linesDecorationsClassName = d.options.firstLineDecorationClassName) && (r[rLen++] = new require$_DOT__DOT__SLASH_glyphMargin_SLASH_glyphMargin_DOT_js.DecorationToRender(d.range.startLineNumber, d.range.startLineNumber, linesDecorationsClassName, zIndex));
      }
      return r;
    }
    prepareRender(ctx) {
      const visibleStartLineNumber = ctx.visibleRange.startLineNumber, visibleEndLineNumber = ctx.visibleRange.endLineNumber;
      ctx = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
      const common = '" style\x3d"left:' + this._decorationsLeft.toString() + "px;width:" + this._decorationsWidth.toString() + 'px;"\x3e\x3c/div\x3e', output = [];
      for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
        const lineIndex = lineNumber - visibleStartLineNumber, decorations = ctx[lineIndex].getDecorations();
        let lineOutput = "";
        for (const decoration of decorations) {
          lineOutput += '\x3cdiv class\x3d"cldr ' + decoration.className + common;
        }
        output[lineIndex] = lineOutput;
      }
      this._renderResult = output;
    }
    render(startLineNumber, lineNumber) {
      return this._renderResult ? this._renderResult[lineNumber - startLineNumber] : "";
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$linesDecorations$linesDecorations.js.map
