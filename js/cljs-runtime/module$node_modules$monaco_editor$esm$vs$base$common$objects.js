shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$objects = function(require, module, exports) {
  function deepClone(obj) {
    if (!obj || typeof obj !== "object" || obj instanceof RegExp) {
      return obj;
    }
    const result = Array.isArray(obj) ? [] : {};
    Object.entries(obj).forEach(([key, value]) => {
      result[key] = value && typeof value === "object" ? deepClone(value) : value;
    });
    return result;
  }
  function deepFreeze(obj) {
    if (!obj || typeof obj !== "object") {
      return obj;
    }
    const stack = [obj];
    for (; stack.length > 0;) {
      const obj = stack.shift();
      Object.freeze(obj);
      for (const key in obj) {
        if (_hasOwnProperty.call(obj, key)) {
          const prop = obj[key];
          typeof prop !== "object" || Object.isFrozen(prop) || (0,require$_DOT__SLASH_types_DOT_js.isTypedArray)(prop) || stack.push(prop);
        }
      }
    }
    return obj;
  }
  function cloneAndChange(obj, changer) {
    return _cloneAndChange(obj, changer, new Set());
  }
  function _cloneAndChange(obj, changer, seen) {
    if ((0,require$_DOT__SLASH_types_DOT_js.isUndefinedOrNull)(obj)) {
      return obj;
    }
    const changed = changer(obj);
    if (typeof changed !== "undefined") {
      return changed;
    }
    if (Array.isArray(obj)) {
      var r1 = [];
      for (var e of obj) {
        r1.push(_cloneAndChange(e, changer, seen));
      }
      return r1;
    }
    if ((0,require$_DOT__SLASH_types_DOT_js.isObject)(obj)) {
      if (seen.has(obj)) {
        throw Error("Cannot clone recursive data-structure");
      }
      seen.add(obj);
      e = {};
      for (r1 in obj) {
        _hasOwnProperty.call(obj, r1) && (e[r1] = _cloneAndChange(obj[r1], changer, seen));
      }
      seen.delete(obj);
      return e;
    }
    return obj;
  }
  function mixin(destination, source, overwrite = !0) {
    if (!(0,require$_DOT__SLASH_types_DOT_js.isObject)(destination)) {
      return source;
    }
    (0,require$_DOT__SLASH_types_DOT_js.isObject)(source) && Object.keys(source).forEach(key => {
      key in destination ? overwrite && ((0,require$_DOT__SLASH_types_DOT_js.isObject)(destination[key]) && (0,require$_DOT__SLASH_types_DOT_js.isObject)(source[key]) ? mixin(destination[key], source[key], overwrite) : destination[key] = source[key]) : destination[key] = source[key];
    });
    return destination;
  }
  function equals(one, other) {
    if (one === other) {
      return !0;
    }
    if (one === null || one === void 0 || other === null || other === void 0 || typeof one !== typeof other || typeof one !== "object" || Array.isArray(one) !== Array.isArray(other)) {
      return !1;
    }
    var i;
    if (Array.isArray(one)) {
      if (one.length !== other.length) {
        return !1;
      }
      for (i = 0; i < one.length; i++) {
        if (!equals(one[i], other[i])) {
          return !1;
        }
      }
    } else {
      const oneKeys = [];
      for (i in one) {
        oneKeys.push(i);
      }
      oneKeys.sort();
      const otherKeys = [];
      for (i in other) {
        otherKeys.push(i);
      }
      otherKeys.sort();
      if (!equals(oneKeys, otherKeys)) {
        return !1;
      }
      for (i = 0; i < oneKeys.length; i++) {
        if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
          return !1;
        }
      }
    }
    return !0;
  }
  function getAllPropertyNames(obj) {
    let res = [];
    for (; Object.prototype !== obj;) {
      res = res.concat(Object.getOwnPropertyNames(obj)), obj = Object.getPrototypeOf(obj);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      typeof obj[prop] === "function" && methods.push(prop);
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = method => function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    }, result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, cloneAndChange:{enumerable:!0, get:function() {
    return cloneAndChange;
  }}, createProxyObject:{enumerable:!0, get:function() {
    return createProxyObject;
  }}, deepClone:{enumerable:!0, get:function() {
    return deepClone;
  }}, deepFreeze:{enumerable:!0, get:function() {
    return deepFreeze;
  }}, equals:{enumerable:!0, get:function() {
    return equals;
  }}, getAllMethodNames:{enumerable:!0, get:function() {
    return getAllMethodNames;
  }}, getAllPropertyNames:{enumerable:!0, get:function() {
    return getAllPropertyNames;
  }}, mixin:{enumerable:!0, get:function() {
    return mixin;
  }}});
  var require$_DOT__SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types");
  const _hasOwnProperty = Object.prototype.hasOwnProperty;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$objects.js.map
