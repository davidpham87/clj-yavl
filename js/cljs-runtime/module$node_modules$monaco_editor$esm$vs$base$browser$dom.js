shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$dom = function(require, module, exports) {
  function clearNode(node) {
    for (; node.firstChild;) {
      node.firstChild.remove();
    }
  }
  function addDisposableListener(node, type, handler, useCaptureOrOptions) {
    return new DomListener(node, type, handler, useCaptureOrOptions);
  }
  function _wrapAsStandardMouseEvent(targetWindow, handler) {
    return function(e) {
      return handler(new require$_DOT__SLASH_mouseEvent_DOT_js.StandardMouseEvent(targetWindow, e));
    };
  }
  function _wrapAsStandardKeyboardEvent(handler) {
    return function(e) {
      return handler(new require$_DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e));
    };
  }
  function addDisposableGenericMouseDownListener(node, handler, useCapture) {
    return addDisposableListener(node, platform.isIOS && require$_DOT__SLASH_canIUse_DOT_js.BrowserFeatures.pointerEvents ? EventType.POINTER_DOWN : EventType.MOUSE_DOWN, handler, useCapture);
  }
  function addDisposableGenericMouseUpListener(node, handler, useCapture) {
    return addDisposableListener(node, platform.isIOS && require$_DOT__SLASH_canIUse_DOT_js.BrowserFeatures.pointerEvents ? EventType.POINTER_UP : EventType.MOUSE_UP, handler, useCapture);
  }
  function runWhenWindowIdle(targetWindow, callback, timeout) {
    return (0,require$_DOT__DOT__SLASH_common_SLASH_async_DOT_js._runWhenIdle)(targetWindow, callback, timeout);
  }
  function getComputedStyle(el) {
    return getWindow(el).getComputedStyle(el, null);
  }
  function getClientArea(element, fallback) {
    const elWindow = getWindow(element), elDocument = elWindow.document;
    if (element !== elDocument.body) {
      return new Dimension(element.clientWidth, element.clientHeight);
    }
    if (platform.isIOS && (elWindow === null || elWindow === void 0 ? 0 : elWindow.visualViewport)) {
      return new Dimension(elWindow.visualViewport.width, elWindow.visualViewport.height);
    }
    if ((elWindow === null || elWindow === void 0 ? 0 : elWindow.innerWidth) && elWindow.innerHeight) {
      return new Dimension(elWindow.innerWidth, elWindow.innerHeight);
    }
    if (elDocument.body && elDocument.body.clientWidth && elDocument.body.clientHeight) {
      return new Dimension(elDocument.body.clientWidth, elDocument.body.clientHeight);
    }
    if (elDocument.documentElement && elDocument.documentElement.clientWidth && elDocument.documentElement.clientHeight) {
      return new Dimension(elDocument.documentElement.clientWidth, elDocument.documentElement.clientHeight);
    }
    if (fallback) {
      return getClientArea(fallback);
    }
    throw Error("Unable to figure out browser width and height");
  }
  function getTopLeftOffset(element) {
    let offsetParent = element.offsetParent, top = element.offsetTop, left = element.offsetLeft;
    for (; (element = element.parentNode) !== null && element !== element.ownerDocument.body && element !== element.ownerDocument.documentElement;) {
      top -= element.scrollTop;
      const c = isShadowRoot(element) ? null : getComputedStyle(element);
      c && (left -= c.direction !== "rtl" ? element.scrollLeft : -element.scrollLeft);
      element === offsetParent && (left += SizeUtils.getBorderLeftWidth(element), top += SizeUtils.getBorderTopWidth(element), top += element.offsetTop, left += element.offsetLeft, offsetParent = element.offsetParent);
    }
    return {left, top};
  }
  function size(element, width, height) {
    typeof width === "number" && (element.style.width = `${width}px`);
    typeof height === "number" && (element.style.height = `${height}px`);
  }
  function getDomNodePagePosition(domNode) {
    const bb = domNode.getBoundingClientRect();
    domNode = getWindow(domNode);
    return {left:bb.left + domNode.scrollX, top:bb.top + domNode.scrollY, width:bb.width, height:bb.height};
  }
  function getDomNodeZoomLevel(domNode) {
    let zoom = 1.0;
    do {
      const elementZoomLevel = getComputedStyle(domNode).zoom;
      elementZoomLevel !== null && elementZoomLevel !== void 0 && elementZoomLevel !== "1" && (zoom *= elementZoomLevel);
      domNode = domNode.parentElement;
    } while (domNode !== null && domNode !== domNode.ownerDocument.documentElement);
    return zoom;
  }
  function getTotalWidth(element) {
    const margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
    return element.offsetWidth + margin;
  }
  function getContentWidth(element) {
    const border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element), padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
    return element.offsetWidth - border - padding;
  }
  function getContentHeight(element) {
    const border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element), padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);
    return element.offsetHeight - border - padding;
  }
  function getTotalHeight(element) {
    const margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
    return element.offsetHeight + margin;
  }
  function isAncestor(testChild, testAncestor) {
    return !(testAncestor === null || testAncestor === void 0 || !testAncestor.contains(testChild));
  }
  function findParentWithClass(node, clazz, stopAtClazzOrNode) {
    for (; node && node.nodeType === node.ELEMENT_NODE;) {
      if (node.classList.contains(clazz)) {
        return node;
      }
      if (stopAtClazzOrNode) {
        if (typeof stopAtClazzOrNode === "string") {
          if (node.classList.contains(stopAtClazzOrNode)) {
            break;
          }
        } else {
          if (node === stopAtClazzOrNode) {
            break;
          }
        }
      }
      node = node.parentNode;
    }
    return null;
  }
  function hasParentWithClass(node, clazz, stopAtClazzOrNode) {
    return !!findParentWithClass(node, clazz, stopAtClazzOrNode);
  }
  function isShadowRoot(node) {
    return node && !!node.host && !!node.mode;
  }
  function isInShadowDOM(domNode) {
    return !!getShadowRoot(domNode);
  }
  function getShadowRoot(domNode) {
    for (var _a; domNode.parentNode;) {
      if (domNode === ((_a = domNode.ownerDocument) === null || _a === void 0 ? void 0 : _a.body)) {
        return null;
      }
      domNode = domNode.parentNode;
    }
    return isShadowRoot(domNode) ? domNode : null;
  }
  function getActiveElement() {
    let result = getActiveDocument().activeElement;
    for (; result === null || result === void 0 ? 0 : result.shadowRoot;) {
      result = result.shadowRoot.activeElement;
    }
    return result;
  }
  function isActiveElement(element) {
    return element.ownerDocument.activeElement === element;
  }
  function isAncestorOfActiveElement(ancestor) {
    return isAncestor(ancestor.ownerDocument.activeElement, ancestor);
  }
  function getActiveDocument() {
    var _a;
    return getWindowsCount() <= 1 ? document : (_a = Array.from(getWindows()).map(({window}) => window.document).find(doc => doc.hasFocus())) !== null && _a !== void 0 ? _a : document;
  }
  function getActiveWindow() {
    var _a, _b;
    return (_b = (_a = getActiveDocument().defaultView) === null || _a === void 0 ? void 0 : _a.window) !== null && _b !== void 0 ? _b : require$_DOT__SLASH_window_DOT_js.mainWindow;
  }
  function createStyleSheet(container = require$_DOT__SLASH_window_DOT_js.mainWindow.document.head, beforeAppend, disposableStore) {
    const style = document.createElement("style");
    style.type = "text/css";
    style.media = "screen";
    beforeAppend === null || beforeAppend === void 0 || beforeAppend(style);
    container.appendChild(style);
    disposableStore && disposableStore.add((0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => container.removeChild(style)));
    if (container === require$_DOT__SLASH_window_DOT_js.mainWindow.document.head) {
      beforeAppend = new Set();
      globalStylesheets.set(style, beforeAppend);
      for (const {window:targetWindow, disposables} of getWindows()) {
        if (targetWindow === require$_DOT__SLASH_window_DOT_js.mainWindow) {
          continue;
        }
        const cloneDisposable = disposables.add(cloneGlobalStyleSheet(style, beforeAppend, targetWindow));
        disposableStore === null || disposableStore === void 0 || disposableStore.add(cloneDisposable);
      }
    }
    return style;
  }
  function cloneGlobalStyleSheet(globalStylesheet, globalStylesheetClones, targetWindow) {
    var _a, _b;
    const disposables = new require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore(), clone = globalStylesheet.cloneNode(!0);
    targetWindow.document.head.appendChild(clone);
    disposables.add((0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => targetWindow.document.head.removeChild(clone)));
    for (const rule of getDynamicStyleSheetRules(globalStylesheet)) {
      (_a = clone.sheet) === null || _a === void 0 || _a.insertRule(rule.cssText, (_b = clone.sheet) === null || _b === void 0 ? void 0 : _b.cssRules.length);
    }
    disposables.add(sharedMutationObserver.observe(globalStylesheet, disposables, {childList:!0})(() => {
      clone.textContent = globalStylesheet.textContent;
    }));
    globalStylesheetClones.add(clone);
    disposables.add((0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => globalStylesheetClones.delete(clone)));
    return disposables;
  }
  function getSharedStyleSheet() {
    _sharedStyleSheet ||= createStyleSheet();
    return _sharedStyleSheet;
  }
  function getDynamicStyleSheetRules(style) {
    var _a, _b;
    return ((_a = style === null || style === void 0 ? void 0 : style.sheet) === null || _a === void 0 ? 0 : _a.rules) ? style.sheet.rules : ((_b = style === null || style === void 0 ? void 0 : style.sheet) === null || _b === void 0 ? 0 : _b.cssRules) ? style.sheet.cssRules : [];
  }
  function createCSSRule(selector, cssText, style = getSharedStyleSheet()) {
    var _a, _b;
    if (style && cssText) {
      (_a = style.sheet) === null || _a === void 0 || _a.insertRule(`${selector} {${cssText}}`, 0);
      for (const clonedGlobalStylesheet of (_b = globalStylesheets.get(style)) !== null && _b !== void 0 ? _b : []) {
        createCSSRule(selector, cssText, clonedGlobalStylesheet);
      }
    }
  }
  function removeCSSRulesContainingSelector(ruleName, style = getSharedStyleSheet()) {
    var _a, _b;
    if (style) {
      var rules = getDynamicStyleSheetRules(style), toDelete = [];
      for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        typeof rule.selectorText === "string" && rule.selectorText.indexOf(ruleName) !== -1 && toDelete.push(i);
      }
      for (rules = toDelete.length - 1; rules >= 0; rules--) {
        (_a = style.sheet) === null || _a === void 0 || _a.deleteRule(toDelete[rules]);
      }
      for (const clonedGlobalStylesheet of (_b = globalStylesheets.get(style)) !== null && _b !== void 0 ? _b : []) {
        removeCSSRulesContainingSelector(ruleName, clonedGlobalStylesheet);
      }
    }
  }
  function isMouseEvent(e) {
    return e instanceof MouseEvent || e instanceof getWindow(e).MouseEvent;
  }
  function isKeyboardEvent(e) {
    return e instanceof KeyboardEvent || e instanceof getWindow(e).KeyboardEvent;
  }
  function isEventLike(obj) {
    return !(!obj || typeof obj.preventDefault !== "function" || typeof obj.stopPropagation !== "function");
  }
  function saveParentsScrollTop(node) {
    const r = [];
    for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
      r[i] = node.scrollTop, node = node.parentNode;
    }
    return r;
  }
  function restoreParentsScrollTop(node, state) {
    for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
      node.scrollTop !== state[i] && (node.scrollTop = state[i]), node = node.parentNode;
    }
  }
  function trackFocus(element) {
    return new FocusTracker(element);
  }
  function after(sibling, child) {
    sibling.after(child);
    return child;
  }
  function append(parent, ...children) {
    parent.append(...children);
    if (children.length === 1 && typeof children[0] !== "string") {
      return children[0];
    }
  }
  function prepend(parent, child) {
    parent.insertBefore(child, parent.firstChild);
    return child;
  }
  function reset(parent, ...children) {
    parent.innerText = "";
    append(parent, ...children);
  }
  function _$(namespace, description, attrs, ...children) {
    description = SELECTOR_REGEX.exec(description);
    if (!description) {
      throw Error("Bad use of emmet");
    }
    const tagName = description[1] || "div";
    let result;
    result = namespace !== Namespace.HTML ? document.createElementNS(namespace, tagName) : document.createElement(tagName);
    description[3] && (result.id = description[3]);
    description[4] && (result.className = description[4].replace(/\./g, " ").trim());
    attrs && Object.entries(attrs).forEach(([name, value]) => {
      typeof value !== "undefined" && (/^on\w+$/.test(name) ? result[name] = value : name === "selected" ? value && result.setAttribute(name, "true") : result.setAttribute(name, value));
    });
    result.append(...children);
    return result;
  }
  function $(description, attrs, ...children) {
    return _$(Namespace.HTML, description, attrs, ...children);
  }
  function setVisibility(visible, ...elements) {
    visible ? show(...elements) : hide(...elements);
  }
  function show(...elements) {
    for (const element of elements) {
      element.style.display = "", element.removeAttribute("aria-hidden");
    }
  }
  function hide(...elements) {
    for (const element of elements) {
      element.style.display = "none", element.setAttribute("aria-hidden", "true");
    }
  }
  function computeScreenAwareSize(window, cssPx) {
    return Math.max(1, Math.floor(window.devicePixelRatio * cssPx)) / window.devicePixelRatio;
  }
  function windowOpenNoOpener(url) {
    require$_DOT__SLASH_window_DOT_js.mainWindow.open(url, "_blank", "noopener");
  }
  function animate(targetWindow, fn) {
    const step = () => {
      fn();
      stepDisposable = scheduleAtNextAnimationFrame(targetWindow, step);
    };
    let stepDisposable = scheduleAtNextAnimationFrame(targetWindow, step);
    return (0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => stepDisposable.dispose());
  }
  function asCSSUrl(uri) {
    return uri ? `url('${require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.FileAccess.uriToBrowserUri(uri).toString(!0).replace(/'/g, "%27")}')` : "url('')";
  }
  function asCSSPropertyValue(value) {
    return `'${value.replace(/'/g, "%27")}'`;
  }
  function asCssValueWithDefault(cssPropertyValue, dflt) {
    if (cssPropertyValue !== void 0) {
      const variableMatch = cssPropertyValue.match(/^\s*var\((.+)\)$/);
      return variableMatch ? (cssPropertyValue = variableMatch[1].split(",", 2), cssPropertyValue.length === 2 && (dflt = asCssValueWithDefault(cssPropertyValue[1].trim(), dflt)), `var(${cssPropertyValue[0]}, ${dflt})`) : cssPropertyValue;
    }
    return dflt;
  }
  function hookDomPurifyHrefAndSrcSanitizer(allowedProtocols, allowDataImages = !1) {
    const anchor = document.createElement("a");
    dompurify.addHook("afterSanitizeAttributes", node => {
      for (const attr of ["href", "src"]) {
        if (node.hasAttribute(attr)) {
          const attrValue = node.getAttribute(attr);
          attr === "href" && attrValue.startsWith("#") || (anchor.href = attrValue, allowedProtocols.includes(anchor.protocol.replace(/:$/, "")) || allowDataImages && attr === "src" && anchor.href.startsWith("data:") || node.removeAttribute(attr));
        }
      }
    });
    return (0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
      dompurify.removeHook("afterSanitizeAttributes");
    });
  }
  function h(tag, ...args) {
    let attributes;
    Array.isArray(args[0]) ? (attributes = {}, args = args[0]) : (attributes = args[0] || {}, args = args[1]);
    tag = H_REGEX.exec(tag);
    if (!tag || !tag.groups) {
      throw Error("Bad use of h");
    }
    const el = document.createElement(tag.groups.tag || "div");
    tag.groups.id && (el.id = tag.groups.id);
    const classNames = [];
    if (tag.groups["class"]) {
      for (var className of tag.groups["class"].split(".")) {
        className !== "" && classNames.push(className);
      }
    }
    if (attributes.className !== void 0) {
      for (const className of attributes.className.split(".")) {
        className !== "" && classNames.push(className);
      }
    }
    classNames.length > 0 && (el.className = classNames.join(" "));
    className = {};
    tag.groups.name && (className[tag.groups.name] = el);
    if (args) {
      for (const c of args) {
        c instanceof HTMLElement ? el.appendChild(c) : typeof c === "string" ? el.append(c) : "root" in c && (Object.assign(className, c), el.appendChild(c.root));
      }
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (key !== "className") {
        if (key === "style") {
          for (const [cssKey, cssValue] of Object.entries(value)) {
            el.style.setProperty(camelCaseToHyphenCase(cssKey), typeof cssValue === "number" ? cssValue + "px" : "" + cssValue);
          }
        } else {
          key === "tabIndex" ? el.tabIndex = value : el.setAttribute(camelCaseToHyphenCase(key), value.toString());
        }
      }
    }
    className.root = el;
    return className;
  }
  function camelCaseToHyphenCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, $:{enumerable:!0, get:function() {
    return $;
  }}, Dimension:{enumerable:!0, get:function() {
    return Dimension;
  }}, DragAndDropObserver:{enumerable:!0, get:function() {
    return DragAndDropObserver;
  }}, EventHelper:{enumerable:!0, get:function() {
    return EventHelper;
  }}, EventType:{enumerable:!0, get:function() {
    return EventType;
  }}, ModifierKeyEmitter:{enumerable:!0, get:function() {
    return ModifierKeyEmitter;
  }}, Namespace:{enumerable:!0, get:function() {
    return Namespace;
  }}, WindowIdleValue:{enumerable:!0, get:function() {
    return WindowIdleValue;
  }}, WindowIntervalTimer:{enumerable:!0, get:function() {
    return WindowIntervalTimer;
  }}, addDisposableGenericMouseDownListener:{enumerable:!0, get:function() {
    return addDisposableGenericMouseDownListener;
  }}, addDisposableGenericMouseUpListener:{enumerable:!0, get:function() {
    return addDisposableGenericMouseUpListener;
  }}, addDisposableListener:{enumerable:!0, get:function() {
    return addDisposableListener;
  }}, addStandardDisposableGenericMouseDownListener:{enumerable:!0, get:function() {
    return addStandardDisposableGenericMouseDownListener;
  }}, addStandardDisposableGenericMouseUpListener:{enumerable:!0, get:function() {
    return addStandardDisposableGenericMouseUpListener;
  }}, addStandardDisposableListener:{enumerable:!0, get:function() {
    return addStandardDisposableListener;
  }}, after:{enumerable:!0, get:function() {
    return after;
  }}, animate:{enumerable:!0, get:function() {
    return animate;
  }}, append:{enumerable:!0, get:function() {
    return append;
  }}, asCSSPropertyValue:{enumerable:!0, get:function() {
    return asCSSPropertyValue;
  }}, asCSSUrl:{enumerable:!0, get:function() {
    return asCSSUrl;
  }}, asCssValueWithDefault:{enumerable:!0, get:function() {
    return asCssValueWithDefault;
  }}, basicMarkupHtmlTags:{enumerable:!0, get:function() {
    return basicMarkupHtmlTags;
  }}, clearNode:{enumerable:!0, get:function() {
    return clearNode;
  }}, computeScreenAwareSize:{enumerable:!0, get:function() {
    return computeScreenAwareSize;
  }}, createCSSRule:{enumerable:!0, get:function() {
    return createCSSRule;
  }}, createStyleSheet:{enumerable:!0, get:function() {
    return createStyleSheet;
  }}, findParentWithClass:{enumerable:!0, get:function() {
    return findParentWithClass;
  }}, getActiveDocument:{enumerable:!0, get:function() {
    return getActiveDocument;
  }}, getActiveElement:{enumerable:!0, get:function() {
    return getActiveElement;
  }}, getActiveWindow:{enumerable:!0, get:function() {
    return getActiveWindow;
  }}, getClientArea:{enumerable:!0, get:function() {
    return getClientArea;
  }}, getComputedStyle:{enumerable:!0, get:function() {
    return getComputedStyle;
  }}, getContentHeight:{enumerable:!0, get:function() {
    return getContentHeight;
  }}, getContentWidth:{enumerable:!0, get:function() {
    return getContentWidth;
  }}, getDocument:{enumerable:!0, get:function() {
    return getDocument;
  }}, getDomNodePagePosition:{enumerable:!0, get:function() {
    return getDomNodePagePosition;
  }}, getDomNodeZoomLevel:{enumerable:!0, get:function() {
    return getDomNodeZoomLevel;
  }}, getShadowRoot:{enumerable:!0, get:function() {
    return getShadowRoot;
  }}, getTopLeftOffset:{enumerable:!0, get:function() {
    return getTopLeftOffset;
  }}, getTotalHeight:{enumerable:!0, get:function() {
    return getTotalHeight;
  }}, getTotalWidth:{enumerable:!0, get:function() {
    return getTotalWidth;
  }}, getWindow:{enumerable:!0, get:function() {
    return getWindow;
  }}, getWindowById:{enumerable:!0, get:function() {
    return getWindowById;
  }}, getWindowId:{enumerable:!0, get:function() {
    return getWindowId;
  }}, getWindows:{enumerable:!0, get:function() {
    return getWindows;
  }}, getWindowsCount:{enumerable:!0, get:function() {
    return getWindowsCount;
  }}, h:{enumerable:!0, get:function() {
    return h;
  }}, hasParentWithClass:{enumerable:!0, get:function() {
    return hasParentWithClass;
  }}, hasWindow:{enumerable:!0, get:function() {
    return hasWindow;
  }}, hide:{enumerable:!0, get:function() {
    return hide;
  }}, hookDomPurifyHrefAndSrcSanitizer:{enumerable:!0, get:function() {
    return hookDomPurifyHrefAndSrcSanitizer;
  }}, isActiveElement:{enumerable:!0, get:function() {
    return isActiveElement;
  }}, isAncestor:{enumerable:!0, get:function() {
    return isAncestor;
  }}, isAncestorOfActiveElement:{enumerable:!0, get:function() {
    return isAncestorOfActiveElement;
  }}, isEventLike:{enumerable:!0, get:function() {
    return isEventLike;
  }}, isInShadowDOM:{enumerable:!0, get:function() {
    return isInShadowDOM;
  }}, isKeyboardEvent:{enumerable:!0, get:function() {
    return isKeyboardEvent;
  }}, isMouseEvent:{enumerable:!0, get:function() {
    return isMouseEvent;
  }}, isShadowRoot:{enumerable:!0, get:function() {
    return isShadowRoot;
  }}, onDidRegisterWindow:{enumerable:!0, get:function() {
    return onDidRegisterWindow;
  }}, onDidUnregisterWindow:{enumerable:!0, get:function() {
    return onDidUnregisterWindow;
  }}, onWillUnregisterWindow:{enumerable:!0, get:function() {
    return onWillUnregisterWindow;
  }}, prepend:{enumerable:!0, get:function() {
    return prepend;
  }}, registerWindow:{enumerable:!0, get:function() {
    return registerWindow;
  }}, removeCSSRulesContainingSelector:{enumerable:!0, get:function() {
    return removeCSSRulesContainingSelector;
  }}, reset:{enumerable:!0, get:function() {
    return reset;
  }}, restoreParentsScrollTop:{enumerable:!0, get:function() {
    return restoreParentsScrollTop;
  }}, runAtThisOrScheduleAtNextAnimationFrame:{enumerable:!0, get:function() {
    return runAtThisOrScheduleAtNextAnimationFrame;
  }}, runWhenWindowIdle:{enumerable:!0, get:function() {
    return runWhenWindowIdle;
  }}, saveParentsScrollTop:{enumerable:!0, get:function() {
    return saveParentsScrollTop;
  }}, scheduleAtNextAnimationFrame:{enumerable:!0, get:function() {
    return scheduleAtNextAnimationFrame;
  }}, setVisibility:{enumerable:!0, get:function() {
    return setVisibility;
  }}, sharedMutationObserver:{enumerable:!0, get:function() {
    return sharedMutationObserver;
  }}, show:{enumerable:!0, get:function() {
    return show;
  }}, size:{enumerable:!0, get:function() {
    return size;
  }}, trackFocus:{enumerable:!0, get:function() {
    return trackFocus;
  }}, windowOpenNoOpener:{enumerable:!0, get:function() {
    return windowOpenNoOpener;
  }}});
  var browser = require("module$node_modules$monaco_editor$esm$vs$base$browser$browser"), require$_DOT__SLASH_canIUse_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$canIUse"), require$_DOT__SLASH_keyboardEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$keyboardEvent"), require$_DOT__SLASH_mouseEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$mouseEvent"), require$_DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), 
  require$_DOT__DOT__SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), event = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), dompurify = require("module$node_modules$monaco_editor$esm$vs$base$browser$dompurify$dompurify"), require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$network"), 
  platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), require$_DOT__DOT__SLASH_common_SLASH_hash_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$hash"), require$_DOT__SLASH_window_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$window");
  const {registerWindow, getWindow, getDocument, getWindows, getWindowsCount, getWindowId, getWindowById, hasWindow, onDidRegisterWindow, onWillUnregisterWindow, onDidUnregisterWindow} = function() {
    const windows = new Map();
    (0,require$_DOT__SLASH_window_DOT_js.ensureCodeWindow)(require$_DOT__SLASH_window_DOT_js.mainWindow, 1);
    windows.set(require$_DOT__SLASH_window_DOT_js.mainWindow.vscodeWindowId, {window:require$_DOT__SLASH_window_DOT_js.mainWindow, disposables:new require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore()});
    const onDidRegisterWindow = new event.Emitter(), onDidUnregisterWindow = new event.Emitter(), onWillUnregisterWindow = new event.Emitter();
    return {onDidRegisterWindow:onDidRegisterWindow.event, onWillUnregisterWindow:onWillUnregisterWindow.event, onDidUnregisterWindow:onDidUnregisterWindow.event, registerWindow(window) {
      if (windows.has(window.vscodeWindowId)) {
        return require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      }
      const disposables = new require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore(), registeredWindow = {window, disposables:disposables.add(new require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore())};
      windows.set(window.vscodeWindowId, registeredWindow);
      disposables.add((0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
        windows.delete(window.vscodeWindowId);
        onDidUnregisterWindow.fire(window);
      }));
      disposables.add(addDisposableListener(window, EventType.BEFORE_UNLOAD, () => {
        onWillUnregisterWindow.fire(window);
      }));
      onDidRegisterWindow.fire(registeredWindow);
      return disposables;
    }, getWindows() {
      return windows.values();
    }, getWindowsCount() {
      return windows.size;
    }, getWindowId(targetWindow) {
      return targetWindow.vscodeWindowId;
    }, hasWindow(windowId) {
      return windows.has(windowId);
    }, getWindowById(windowId) {
      return windows.get(windowId);
    }, getWindow(e) {
      var _a;
      return ((_a = e === null || e === void 0 ? void 0 : e.ownerDocument) === null || _a === void 0 ? 0 : _a.defaultView) ? e.ownerDocument.defaultView.window : (e === null || e === void 0 ? 0 : e.view) ? e.view.window : require$_DOT__SLASH_window_DOT_js.mainWindow;
    }, getDocument(e) {
      return getWindow(e).document;
    }};
  }();
  class DomListener {
    constructor(node, type, handler, options) {
      this._node = node;
      this._type = type;
      this._handler = handler;
      this._options = options || !1;
      this._node.addEventListener(this._type, this._handler, this._options);
    }
    dispose() {
      this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._handler = this._node = null);
    }
  }
  const addStandardDisposableListener = function(node, type, handler, useCapture) {
    let wrapHandler = handler;
    if (type === "click" || type === "mousedown") {
      wrapHandler = _wrapAsStandardMouseEvent(getWindow(node), handler);
    } else if (type === "keydown" || type === "keypress" || type === "keyup") {
      wrapHandler = _wrapAsStandardKeyboardEvent(handler);
    }
    return addDisposableListener(node, type, wrapHandler, useCapture);
  }, addStandardDisposableGenericMouseDownListener = function(node, handler, useCapture) {
    handler = _wrapAsStandardMouseEvent(getWindow(node), handler);
    return addDisposableGenericMouseDownListener(node, handler, useCapture);
  }, addStandardDisposableGenericMouseUpListener = function(node, handler, useCapture) {
    handler = _wrapAsStandardMouseEvent(getWindow(node), handler);
    return addDisposableGenericMouseUpListener(node, handler, useCapture);
  };
  class WindowIdleValue extends require$_DOT__DOT__SLASH_common_SLASH_async_DOT_js.AbstractIdleValue {
    constructor(targetWindow, executor) {
      super(targetWindow, executor);
    }
  }
  let runAtThisOrScheduleAtNextAnimationFrame, scheduleAtNextAnimationFrame;
  class WindowIntervalTimer extends require$_DOT__DOT__SLASH_common_SLASH_async_DOT_js.IntervalTimer {
    cancelAndSet(runner, interval, targetWindow) {
      return super.cancelAndSet(runner, interval, targetWindow);
    }
  }
  class AnimationFrameQueueItem {
    constructor(runner, priority = 0) {
      this._runner = runner;
      this.priority = priority;
      this._canceled = !1;
    }
    dispose() {
      this._canceled = !0;
    }
    execute() {
      if (!this._canceled) {
        try {
          this._runner();
        } catch (e) {
          (0,require$_DOT__DOT__SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e);
        }
      }
    }
    static sort(a, b) {
      return b.priority - a.priority;
    }
  }
  (function() {
    const NEXT_QUEUE = new Map(), CURRENT_QUEUE = new Map(), animFrameRequested = new Map(), inAnimationFrameRunner = new Map();
    scheduleAtNextAnimationFrame = (targetWindow, runner, priority = 0) => {
      const targetWindowId = getWindowId(targetWindow);
      runner = new AnimationFrameQueueItem(runner, priority);
      priority = NEXT_QUEUE.get(targetWindowId);
      priority || (priority = [], NEXT_QUEUE.set(targetWindowId, priority));
      priority.push(runner);
      animFrameRequested.get(targetWindowId) || (animFrameRequested.set(targetWindowId, !0), targetWindow.requestAnimationFrame(() => {
        var _a;
        animFrameRequested.set(targetWindowId, !1);
        const currentQueue = (_a = NEXT_QUEUE.get(targetWindowId)) !== null && _a !== void 0 ? _a : [];
        CURRENT_QUEUE.set(targetWindowId, currentQueue);
        NEXT_QUEUE.set(targetWindowId, []);
        for (inAnimationFrameRunner.set(targetWindowId, !0); currentQueue.length > 0;) {
          currentQueue.sort(AnimationFrameQueueItem.sort), currentQueue.shift().execute();
        }
        inAnimationFrameRunner.set(targetWindowId, !1);
      }));
      return runner;
    };
    runAtThisOrScheduleAtNextAnimationFrame = (targetWindow, runner, priority) => {
      const targetWindowId = getWindowId(targetWindow);
      return inAnimationFrameRunner.get(targetWindowId) ? (targetWindow = new AnimationFrameQueueItem(runner, priority), runner = CURRENT_QUEUE.get(targetWindowId), runner || (runner = [], CURRENT_QUEUE.set(targetWindowId, runner)), runner.push(targetWindow), targetWindow) : scheduleAtNextAnimationFrame(targetWindow, runner, priority);
    };
  })();
  class SizeUtils {
    static convertToPixels(element, value) {
      return parseFloat(value) || 0;
    }
    static getDimension(element, cssPropertyName, jsPropertyName) {
      cssPropertyName = (jsPropertyName = getComputedStyle(element)) ? jsPropertyName.getPropertyValue(cssPropertyName) : "0";
      return SizeUtils.convertToPixels(element, cssPropertyName);
    }
    static getBorderLeftWidth(element) {
      return SizeUtils.getDimension(element, "border-left-width", "borderLeftWidth");
    }
    static getBorderRightWidth(element) {
      return SizeUtils.getDimension(element, "border-right-width", "borderRightWidth");
    }
    static getBorderTopWidth(element) {
      return SizeUtils.getDimension(element, "border-top-width", "borderTopWidth");
    }
    static getBorderBottomWidth(element) {
      return SizeUtils.getDimension(element, "border-bottom-width", "borderBottomWidth");
    }
    static getPaddingLeft(element) {
      return SizeUtils.getDimension(element, "padding-left", "paddingLeft");
    }
    static getPaddingRight(element) {
      return SizeUtils.getDimension(element, "padding-right", "paddingRight");
    }
    static getPaddingTop(element) {
      return SizeUtils.getDimension(element, "padding-top", "paddingTop");
    }
    static getPaddingBottom(element) {
      return SizeUtils.getDimension(element, "padding-bottom", "paddingBottom");
    }
    static getMarginLeft(element) {
      return SizeUtils.getDimension(element, "margin-left", "marginLeft");
    }
    static getMarginTop(element) {
      return SizeUtils.getDimension(element, "margin-top", "marginTop");
    }
    static getMarginRight(element) {
      return SizeUtils.getDimension(element, "margin-right", "marginRight");
    }
    static getMarginBottom(element) {
      return SizeUtils.getDimension(element, "margin-bottom", "marginBottom");
    }
  }
  class Dimension {
    constructor(width, height) {
      this.width = width;
      this.height = height;
    }
    with(width = this.width, height = this.height) {
      return width !== this.width || height !== this.height ? new Dimension(width, height) : this;
    }
    static is(obj) {
      return typeof obj === "object" && typeof obj.height === "number" && typeof obj.width === "number";
    }
    static lift(obj) {
      return obj instanceof Dimension ? obj : new Dimension(obj.width, obj.height);
    }
    static equals(a, b) {
      return a === b ? !0 : a && b ? a.width === b.width && a.height === b.height : !1;
    }
  }
  Dimension.None = new Dimension(0, 0);
  const globalStylesheets = new Map(), sharedMutationObserver = new class {
    constructor() {
      this.mutationObservers = new Map();
    }
    observe(target, disposables, options) {
      let mutationObserversPerTarget = this.mutationObservers.get(target);
      mutationObserversPerTarget || (mutationObserversPerTarget = new Map(), this.mutationObservers.set(target, mutationObserversPerTarget));
      const optionsHash = (0,require$_DOT__DOT__SLASH_common_SLASH_hash_DOT_js.hash)(options);
      let mutationObserverPerOptions = mutationObserversPerTarget.get(optionsHash);
      if (mutationObserverPerOptions) {
        mutationObserverPerOptions.users += 1;
      } else {
        const onDidMutate = new event.Emitter(), observer = new MutationObserver(mutations => onDidMutate.fire(mutations));
        observer.observe(target, options);
        const resolvedMutationObserverPerOptions = mutationObserverPerOptions = {users:1, observer, onDidMutate:onDidMutate.event};
        disposables.add((0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
          --resolvedMutationObserverPerOptions.users;
          resolvedMutationObserverPerOptions.users === 0 && (onDidMutate.dispose(), observer.disconnect(), mutationObserversPerTarget === null || mutationObserversPerTarget === void 0 || mutationObserversPerTarget.delete(optionsHash), (mutationObserversPerTarget === null || mutationObserversPerTarget === void 0 ? void 0 : mutationObserversPerTarget.size) === 0 && this.mutationObservers.delete(target));
        }));
        mutationObserversPerTarget.set(optionsHash, mutationObserverPerOptions);
      }
      return mutationObserverPerOptions.onDidMutate;
    }
  }();
  let _sharedStyleSheet = null;
  const EventType = {CLICK:"click", AUXCLICK:"auxclick", DBLCLICK:"dblclick", MOUSE_UP:"mouseup", MOUSE_DOWN:"mousedown", MOUSE_OVER:"mouseover", MOUSE_MOVE:"mousemove", MOUSE_OUT:"mouseout", MOUSE_ENTER:"mouseenter", MOUSE_LEAVE:"mouseleave", MOUSE_WHEEL:"wheel", POINTER_UP:"pointerup", POINTER_DOWN:"pointerdown", POINTER_MOVE:"pointermove", POINTER_LEAVE:"pointerleave", CONTEXT_MENU:"contextmenu", WHEEL:"wheel", KEY_DOWN:"keydown", KEY_PRESS:"keypress", KEY_UP:"keyup", LOAD:"load", BEFORE_UNLOAD:"beforeunload", 
  UNLOAD:"unload", PAGE_SHOW:"pageshow", PAGE_HIDE:"pagehide", PASTE:"paste", ABORT:"abort", ERROR:"error", RESIZE:"resize", SCROLL:"scroll", FULLSCREEN_CHANGE:"fullscreenchange", WK_FULLSCREEN_CHANGE:"webkitfullscreenchange", SELECT:"select", CHANGE:"change", SUBMIT:"submit", RESET:"reset", FOCUS:"focus", FOCUS_IN:"focusin", FOCUS_OUT:"focusout", BLUR:"blur", INPUT:"input", STORAGE:"storage", DRAG_START:"dragstart", DRAG:"drag", DRAG_ENTER:"dragenter", DRAG_LEAVE:"dragleave", DRAG_OVER:"dragover", 
  DROP:"drop", DRAG_END:"dragend", ANIMATION_START:browser.isWebKit ? "webkitAnimationStart" : "animationstart", ANIMATION_END:browser.isWebKit ? "webkitAnimationEnd" : "animationend", ANIMATION_ITERATION:browser.isWebKit ? "webkitAnimationIteration" : "animationiteration"}, EventHelper = {stop:(e, cancelBubble) => {
    e.preventDefault();
    cancelBubble && e.stopPropagation();
    return e;
  }};
  class FocusTracker extends require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    static hasFocusWithin(element) {
      if (element instanceof HTMLElement) {
        const shadowRoot = getShadowRoot(element);
        return isAncestor(shadowRoot ? shadowRoot.activeElement : element.ownerDocument.activeElement, element);
      }
      return isAncestor(element.document.activeElement, element.document);
    }
    constructor(element) {
      super();
      this._onDidFocus = this._register(new event.Emitter());
      this.onDidFocus = this._onDidFocus.event;
      this._onDidBlur = this._register(new event.Emitter());
      this.onDidBlur = this._onDidBlur.event;
      let hasFocus = FocusTracker.hasFocusWithin(element), loosingFocus = !1;
      const onFocus = () => {
        loosingFocus = !1;
        hasFocus || (hasFocus = !0, this._onDidFocus.fire());
      }, onBlur = () => {
        hasFocus && (loosingFocus = !0, (element instanceof HTMLElement ? getWindow(element) : element).setTimeout(() => {
          loosingFocus && (hasFocus = loosingFocus = !1, this._onDidBlur.fire());
        }, 0));
      };
      this._refreshStateHandler = () => {
        FocusTracker.hasFocusWithin(element) !== hasFocus && (hasFocus ? onBlur() : onFocus());
      };
      this._register(addDisposableListener(element, EventType.FOCUS, onFocus, !0));
      this._register(addDisposableListener(element, EventType.BLUR, onBlur, !0));
      element instanceof HTMLElement && (this._register(addDisposableListener(element, EventType.FOCUS_IN, () => this._refreshStateHandler())), this._register(addDisposableListener(element, EventType.FOCUS_OUT, () => this._refreshStateHandler())));
    }
  }
  const SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
  var Namespace;
  (function(Namespace) {
    Namespace.HTML = "http://www.w3.org/1999/xhtml";
    Namespace.SVG = "http://www.w3.org/2000/svg";
  })(Namespace ||= {});
  $.SVG = function(description, attrs, ...children) {
    return _$(Namespace.SVG, description, attrs, ...children);
  };
  require$_DOT__DOT__SLASH_common_SLASH_network_DOT_js.RemoteAuthorities.setPreferredWebSchema(/^https:/.test(require$_DOT__SLASH_window_DOT_js.mainWindow.location.href) ? "https" : "http");
  const basicMarkupHtmlTags = Object.freeze("a abbr b bdo blockquote br caption cite code col colgroup dd del details dfn div dl dt em figcaption figure h1 h2 h3 h4 h5 h6 hr i img ins kbd label li mark ol p pre q rp rt ruby samp small small source span strike strong sub summary sup table tbody td tfoot th thead time tr tt u ul var video wbr".split(" "));
  Object.freeze({ALLOWED_TAGS:"a button blockquote code div h1 h2 h3 h4 h5 h6 hr input label li p pre select small span strong textarea ul ol".split(" "), ALLOWED_ATTR:"href data-href data-command target title name src alt class id role tabindex style data-code width height align x-dispatch required checked placeholder type start".split(" "), RETURN_DOM:!1, RETURN_DOM_FRAGMENT:!1, RETURN_TRUSTED_TYPE:!0});
  class ModifierKeyEmitter extends event.Emitter {
    constructor() {
      super();
      this._subscriptions = new require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._keyStatus = {altKey:!1, shiftKey:!1, ctrlKey:!1, metaKey:!1};
      this._subscriptions.add(event.Event.runAndSubscribe(onDidRegisterWindow, ({window, disposables}) => this.registerListeners(window, disposables), {window:require$_DOT__SLASH_window_DOT_js.mainWindow, disposables:this._subscriptions}));
    }
    registerListeners(window, disposables) {
      disposables.add(addDisposableListener(window, "keydown", e => {
        if (!e.defaultPrevented) {
          var event = new require$_DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e);
          if (event.keyCode !== 6 || !e.repeat) {
            if (e.altKey && !this._keyStatus.altKey) {
              this._keyStatus.lastKeyPressed = "alt";
            } else if (e.ctrlKey && !this._keyStatus.ctrlKey) {
              this._keyStatus.lastKeyPressed = "ctrl";
            } else if (e.metaKey && !this._keyStatus.metaKey) {
              this._keyStatus.lastKeyPressed = "meta";
            } else if (e.shiftKey && !this._keyStatus.shiftKey) {
              this._keyStatus.lastKeyPressed = "shift";
            } else if (event.keyCode !== 6) {
              this._keyStatus.lastKeyPressed = void 0;
            } else {
              return;
            }
            this._keyStatus.altKey = e.altKey;
            this._keyStatus.ctrlKey = e.ctrlKey;
            this._keyStatus.metaKey = e.metaKey;
            this._keyStatus.shiftKey = e.shiftKey;
            this._keyStatus.lastKeyPressed && (this._keyStatus.event = e, this.fire(this._keyStatus));
          }
        }
      }, !0));
      disposables.add(addDisposableListener(window, "keyup", e => {
        e.defaultPrevented || (this._keyStatus.lastKeyReleased = !e.altKey && this._keyStatus.altKey ? "alt" : !e.ctrlKey && this._keyStatus.ctrlKey ? "ctrl" : !e.metaKey && this._keyStatus.metaKey ? "meta" : !e.shiftKey && this._keyStatus.shiftKey ? "shift" : void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = 
        e.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = e, this.fire(this._keyStatus)));
      }, !0));
      disposables.add(addDisposableListener(window.document.body, "mousedown", () => {
        this._keyStatus.lastKeyPressed = void 0;
      }, !0));
      disposables.add(addDisposableListener(window.document.body, "mouseup", () => {
        this._keyStatus.lastKeyPressed = void 0;
      }, !0));
      disposables.add(addDisposableListener(window.document.body, "mousemove", e => {
        e.buttons && (this._keyStatus.lastKeyPressed = void 0);
      }, !0));
      disposables.add(addDisposableListener(window, "blur", () => {
        this.resetKeyStatus();
      }));
    }
    get keyStatus() {
      return this._keyStatus;
    }
    resetKeyStatus() {
      this.doResetKeyStatus();
      this.fire(this._keyStatus);
    }
    doResetKeyStatus() {
      this._keyStatus = {altKey:!1, shiftKey:!1, ctrlKey:!1, metaKey:!1};
    }
    static getInstance() {
      ModifierKeyEmitter.instance || (ModifierKeyEmitter.instance = new ModifierKeyEmitter());
      return ModifierKeyEmitter.instance;
    }
    dispose() {
      super.dispose();
      this._subscriptions.dispose();
    }
  }
  class DragAndDropObserver extends require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(element, callbacks) {
      super();
      this.element = element;
      this.callbacks = callbacks;
      this.dragStartTime = this.counter = 0;
      this.registerListeners();
    }
    registerListeners() {
      this.callbacks.onDragStart && this._register(addDisposableListener(this.element, EventType.DRAG_START, e => {
        var _a, _b;
        (_b = (_a = this.callbacks).onDragStart) === null || _b === void 0 || _b.call(_a, e);
      }));
      this.callbacks.onDrag && this._register(addDisposableListener(this.element, EventType.DRAG, e => {
        var _a, _b;
        (_b = (_a = this.callbacks).onDrag) === null || _b === void 0 || _b.call(_a, e);
      }));
      this._register(addDisposableListener(this.element, EventType.DRAG_ENTER, e => {
        var _a, _b;
        this.counter++;
        this.dragStartTime = e.timeStamp;
        (_b = (_a = this.callbacks).onDragEnter) === null || _b === void 0 || _b.call(_a, e);
      }));
      this._register(addDisposableListener(this.element, EventType.DRAG_OVER, e => {
        var _a, _b;
        e.preventDefault();
        (_b = (_a = this.callbacks).onDragOver) === null || _b === void 0 || _b.call(_a, e, e.timeStamp - this.dragStartTime);
      }));
      this._register(addDisposableListener(this.element, EventType.DRAG_LEAVE, e => {
        var _a, _b;
        this.counter--;
        this.counter === 0 && (this.dragStartTime = 0, (_b = (_a = this.callbacks).onDragLeave) === null || _b === void 0 || _b.call(_a, e));
      }));
      this._register(addDisposableListener(this.element, EventType.DRAG_END, e => {
        var _a, _b;
        this.dragStartTime = this.counter = 0;
        (_b = (_a = this.callbacks).onDragEnd) === null || _b === void 0 || _b.call(_a, e);
      }));
      this._register(addDisposableListener(this.element, EventType.DROP, e => {
        var _a, _b;
        this.dragStartTime = this.counter = 0;
        (_b = (_a = this.callbacks).onDrop) === null || _b === void 0 || _b.call(_a, e);
      }));
    }
  }
  const H_REGEX = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w_])+))?/;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$dom.js.map
