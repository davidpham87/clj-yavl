shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$widget$diffEditor$outlineModel = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, OutlineElement:{enumerable:!0, get:function() {
    return OutlineElement;
  }}, OutlineGroup:{enumerable:!0, get:function() {
    return OutlineGroup;
  }}, OutlineModel:{enumerable:!0, get:function() {
    return OutlineModel;
  }}, TreeElement:{enumerable:!0, get:function() {
    return TreeElement;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_cancellation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$cancellation"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class TreeElement {
    remove() {
      var _a;
      (_a = this.parent) === null || _a === void 0 || _a.children.delete(this.id);
    }
    static findId(candidate, container) {
      let candidateId;
      typeof candidate === "string" ? candidateId = `${container.id}/${candidate}` : (candidateId = `${container.id}/${candidate.name}`, container.children.get(candidateId) !== void 0 && (candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`));
      candidate = candidateId;
      for (let i = 0; container.children.get(candidate) !== void 0; i++) {
        candidate = `${candidateId}_${i}`;
      }
      return candidate;
    }
    static empty(element) {
      return element.children.size === 0;
    }
  }
  class OutlineElement extends TreeElement {
    constructor(id, parent, symbol) {
      super();
      this.id = id;
      this.parent = parent;
      this.symbol = symbol;
      this.children = new Map();
    }
  }
  class OutlineGroup extends TreeElement {
    constructor(id, parent, label, order) {
      super();
      this.id = id;
      this.parent = parent;
      this.label = label;
      this.order = order;
      this.children = new Map();
    }
  }
  class OutlineModel extends TreeElement {
    static create(registry, textModel, token) {
      const cts = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_cancellation_DOT_js.CancellationTokenSource(token), result = new OutlineModel(textModel.uri), provider = registry.ordered(textModel), promises = provider.map((provider, index) => {
        var _a;
        const id = TreeElement.findId(`provider_${index}`, result), group = new OutlineGroup(id, result, (_a = provider.displayName) !== null && _a !== void 0 ? _a : "Unknown Outline Provider", index);
        return Promise.resolve(provider.provideDocumentSymbols(textModel, cts.token)).then(result => {
          for (const info of result || []) {
            OutlineModel._makeOutlineElement(info, group);
          }
          return group;
        }, err => {
          (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedExternalError)(err);
          return group;
        }).then(group => {
          TreeElement.empty(group) ? group.remove() : result._groups.set(id, group);
        });
      }), listener = registry.onDidChange(() => {
        const newProvider = registry.ordered(textModel);
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.equals)(newProvider, provider) || cts.cancel();
      });
      return Promise.all(promises).then(() => cts.token.isCancellationRequested && !token.isCancellationRequested ? OutlineModel.create(registry, textModel, token) : result._compact()).finally(() => {
        cts.dispose();
        listener.dispose();
      });
    }
    static _makeOutlineElement(info, container) {
      var id = TreeElement.findId(info, container);
      id = new OutlineElement(id, container, info);
      if (info.children) {
        for (const childInfo of info.children) {
          OutlineModel._makeOutlineElement(childInfo, id);
        }
      }
      container.children.set(id.id, id);
    }
    constructor(uri) {
      super();
      this.uri = uri;
      this.id = "root";
      this.parent = void 0;
      this._groups = new Map();
      this.children = new Map();
      this.id = "root";
      this.parent = void 0;
    }
    _compact() {
      var count = 0;
      for (const [key, group] of this._groups) {
        group.children.size === 0 ? this._groups.delete(key) : count += 1;
      }
      if (count !== 1) {
        this.children = this._groups;
      } else {
        count = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.first(this._groups.values());
        for (const [, child] of count.children) {
          child.parent = this, this.children.set(child.id, child);
        }
      }
      return this;
    }
    getTopLevelSymbols() {
      const roots = [];
      for (const child of this.children.values()) {
        child instanceof OutlineElement ? roots.push(child.symbol) : roots.push(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.map(child.children.values(), child => child.symbol));
      }
      return roots.sort((a, b) => require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts(a.range, b.range));
    }
    asListOfDocumentSymbols() {
      const roots = this.getTopLevelSymbols(), bucket = [];
      OutlineModel._flattenDocumentSymbols(bucket, roots, "");
      return bucket.sort((a, b) => require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position.compare(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.getStartPosition(a.range), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.getStartPosition(b.range)) || require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position.compare(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.getEndPosition(b.range), 
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.getEndPosition(a.range)));
    }
    static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
      for (const entry of entries) {
        bucket.push({kind:entry.kind, tags:entry.tags, name:entry.name, detail:entry.detail, containerName:entry.containerName || overrideContainerLabel, range:entry.range, selectionRange:entry.selectionRange, children:void 0}), entry.children && OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$widget$diffEditor$outlineModel.js.map
