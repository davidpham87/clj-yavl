shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$services$unicodeTextModelHighlighter = function(require, module, exports) {
  function buildRegExpCharClassExpr(codePoints, flags) {
    return `[${strings.escapeRegExpCharacters(codePoints.map(i => String.fromCodePoint(i)).join(""))}]`;
  }
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "\t";
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, UnicodeTextModelHighlighter:{enumerable:!0, get:function() {
    return UnicodeTextModelHighlighter;
  }}});
  var require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_model_SLASH_textModelSearch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelSearch"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$assert"), 
  require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordHelper");
  class UnicodeTextModelHighlighter {
    static computeUnicodeHighlights(model, options, range) {
      var startLine = range ? range.startLineNumber : 1, endLine = range ? range.endLineNumber : model.getLineCount();
      options = new CodePointHighlighter(options);
      range = options.getCandidateCodePoints();
      range = range === "allNonBasicAscii" ? RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : new RegExp(`${buildRegExpCharClassExpr(Array.from(range))}`, "g");
      range = new require$_DOT__DOT__SLASH_model_SLASH_textModelSearch_DOT_js.Searcher(null, range);
      const ranges = [];
      let hasMore = !1, ambiguousCharacterCount = 0, invisibleCharacterCount = 0, nonBasicAsciiCharacterCount = 0;
      a: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
        endLine = model.getLineContent(lineNumber);
        const lineLength = endLine.length;
        range.reset(0);
        do {
          if (startLine = range.next(endLine)) {
            let startIndex = startLine.index, endIndex = startLine.index + startLine[0].length;
            if (startIndex > 0) {
              var charCodeBefore = endLine.charCodeAt(startIndex - 1);
              strings.isHighSurrogate(charCodeBefore) && startIndex--;
            }
            endIndex + 1 < lineLength && (charCodeBefore = endLine.charCodeAt(endIndex - 1), strings.isHighSurrogate(charCodeBefore) && endIndex++);
            charCodeBefore = endLine.substring(startIndex, endIndex);
            let word = (0,require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js.getWordAtText)(startIndex + 1, require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js.DEFAULT_WORD_REGEXP, endLine, 0);
            word && word.endColumn <= startIndex + 1 && (word = null);
            charCodeBefore = options.shouldHighlightNonBasicASCII(charCodeBefore, word ? word.word : null);
            if (charCodeBefore !== 0) {
              charCodeBefore === 3 ? ambiguousCharacterCount++ : charCodeBefore === 2 ? invisibleCharacterCount++ : charCodeBefore === 1 ? nonBasicAsciiCharacterCount++ : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.assertNever)(charCodeBefore);
              if (ranges.length >= 1000) {
                hasMore = !0;
                break a;
              }
              ranges.push(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
            }
          }
        } while (startLine);
      }
      return {ranges, hasMore, ambiguousCharacterCount, invisibleCharacterCount, nonBasicAsciiCharacterCount};
    }
    static computeUnicodeHighlightReason(char, options) {
      var codePointHighlighter = new CodePointHighlighter(options);
      switch(codePointHighlighter.shouldHighlightNonBasicASCII(char, null)) {
        case 0:
          return null;
        case 2:
          return {kind:1};
        case 3:
          const codePoint = char.codePointAt(0);
          char = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
          codePointHighlighter = strings.AmbiguousCharacters.getLocales().filter(l => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
          return {kind:0, confusableWith:String.fromCodePoint(char), notAmbiguousInLocales:codePointHighlighter};
        case 1:
          return {kind:2};
      }
    }
  }
  class CodePointHighlighter {
    constructor(options) {
      this.options = options;
      this.allowedCodePoints = new Set(options.allowedCodePoints);
      this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII) {
        return "allNonBasicAscii";
      }
      const set = new Set();
      if (this.options.invisibleCharacters) {
        for (const cp of strings.InvisibleCharacters.codePoints) {
          isAllowedInvisibleCharacter(String.fromCodePoint(cp)) || set.add(cp);
        }
      }
      if (this.options.ambiguousCharacters) {
        for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
          set.add(cp);
        }
      }
      for (const cp of this.allowedCodePoints) {
        set.delete(cp);
      }
      return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
      const codePoint = character.codePointAt(0);
      if (this.allowedCodePoints.has(codePoint)) {
        return 0;
      }
      if (this.options.nonBasicASCII) {
        return 1;
      }
      let hasBasicASCIICharacters = !1, hasNonConfusableNonBasicAsciiCharacter = !1;
      if (wordContext) {
        for (const char of wordContext) {
          wordContext = char.codePointAt(0);
          const isBasicASCII = strings.isBasicASCII(char);
          hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;
          isBasicASCII || this.ambiguousCharacters.isAmbiguous(wordContext) || strings.InvisibleCharacters.isInvisibleCharacter(wordContext) || (hasNonConfusableNonBasicAsciiCharacter = !0);
        }
      }
      return !hasBasicASCIICharacters && hasNonConfusableNonBasicAsciiCharacter ? 0 : this.options.invisibleCharacters && !isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(codePoint) ? 3 : 0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$services$unicodeTextModelHighlighter.js.map
