shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$keybinding$common$keybindingResolver = function(require, module, exports) {
  function printWhenExplanation(when) {
    return when ? `${when.serialize()}` : "no when condition";
  }
  function printSourceExplanation(kb) {
    return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? "built-in" : "user";
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, KeybindingResolver:{enumerable:!0, get:function() {
    return KeybindingResolver;
  }}, NoMatchingKb:{enumerable:!0, get:function() {
    return NoMatchingKb;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_contextkey_SLASH_common_SLASH_contextkey_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$contextkey$common$contextkey");
  const NoMatchingKb = {kind:0}, MoreChordsNeeded = {kind:1};
  class KeybindingResolver {
    constructor(defaultKeybindings, overrides, log) {
      var _a;
      this._log = log;
      this._defaultKeybindings = defaultKeybindings;
      this._defaultBoundCommands = new Map();
      for (const defaultKeybinding of defaultKeybindings) {
        (log = defaultKeybinding.command) && log.charAt(0) !== "-" && this._defaultBoundCommands.set(log, !0);
      }
      this._map = new Map();
      this._lookupMap = new Map();
      this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));
      for (let i = 0, len = this._keybindings.length; i < len; i++) {
        defaultKeybindings = this._keybindings[i], defaultKeybindings.chords.length !== 0 && ((overrides = (_a = defaultKeybindings.when) === null || _a === void 0 ? void 0 : _a.substituteConstants()) && overrides.type === 0 || this._addKeyPress(defaultKeybindings.chords[0], defaultKeybindings));
      }
    }
    static _isTargetedForRemoval(defaultKb, keypress, when) {
      if (keypress) {
        for (let i = 0; i < keypress.length; i++) {
          if (keypress[i] !== defaultKb.chords[i]) {
            return !1;
          }
        }
      }
      return !when || when.type === 1 || defaultKb.when && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_contextkey_SLASH_common_SLASH_contextkey_DOT_js.expressionsAreEqualWithConstantSubstitution)(when, defaultKb.when) ? !0 : !1;
    }
    static handleRemovals(rules) {
      const removals = new Map();
      for (let i = 0, len = rules.length; i < len; i++) {
        var rule = rules[i];
        if (rule.command && rule.command.charAt(0) === "-") {
          var command = rule.command.substring(1);
          removals.has(command) ? removals.get(command).push(rule) : removals.set(command, [rule]);
        }
      }
      if (removals.size === 0) {
        return rules;
      }
      rule = [];
      for (let i = 0, len = rules.length; i < len; i++) {
        command = rules[i];
        if (!command.command || command.command.length === 0) {
          rule.push(command);
          continue;
        }
        if (command.command.charAt(0) === "-") {
          continue;
        }
        const commandRemovals = removals.get(command.command);
        if (!commandRemovals || !command.isDefault) {
          rule.push(command);
          continue;
        }
        let isRemoved = !1;
        for (const commandRemoval of commandRemovals) {
          if (this._isTargetedForRemoval(command, commandRemoval.chords, commandRemoval.when)) {
            isRemoved = !0;
            break;
          }
        }
        isRemoved || rule.push(command);
      }
      return rule;
    }
    _addKeyPress(keypress, item) {
      const conflicts = this._map.get(keypress);
      if (typeof conflicts === "undefined") {
        this._map.set(keypress, [item]);
      } else {
        for (keypress = conflicts.length - 1; keypress >= 0; keypress--) {
          const conflict = conflicts[keypress];
          if (conflict.command === item.command) {
            continue;
          }
          let isShorterKbPrefix = !0;
          for (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {
            if (conflict.chords[i] !== item.chords[i]) {
              isShorterKbPrefix = !1;
              break;
            }
          }
          isShorterKbPrefix && KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when) && this._removeFromLookupMap(conflict);
        }
        conflicts.push(item);
      }
      this._addToLookupMap(item);
    }
    _addToLookupMap(item) {
      if (item.command) {
        var arr = this._lookupMap.get(item.command);
        typeof arr === "undefined" ? (arr = [item], this._lookupMap.set(item.command, arr)) : arr.push(item);
      }
    }
    _removeFromLookupMap(item) {
      if (item.command) {
        var arr = this._lookupMap.get(item.command);
        if (typeof arr !== "undefined") {
          for (let i = 0, len = arr.length; i < len; i++) {
            if (arr[i] === item) {
              arr.splice(i, 1);
              break;
            }
          }
        }
      }
    }
    static whenIsEntirelyIncluded(a, b) {
      return b && b.type !== 1 ? a && a.type !== 1 ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_contextkey_SLASH_common_SLASH_contextkey_DOT_js.implies)(a, b) : !1 : !0;
    }
    getKeybindings() {
      return this._keybindings;
    }
    lookupPrimaryKeybinding(commandId, context) {
      commandId = this._lookupMap.get(commandId);
      if (typeof commandId === "undefined" || commandId.length === 0) {
        return null;
      }
      if (commandId.length === 1) {
        return commandId[0];
      }
      for (let i = commandId.length - 1; i >= 0; i--) {
        const item = commandId[i];
        if (context.contextMatchesRules(item.when)) {
          return item;
        }
      }
      return commandId[commandId.length - 1];
    }
    resolve(context, currentChords, keypress) {
      currentChords = [...currentChords, keypress];
      this._log(`| Resolving ${currentChords}`);
      const kbCandidates = this._map.get(currentChords[0]);
      if (kbCandidates === void 0) {
        return this._log("\\ No keybinding entries."), NoMatchingKb;
      }
      if (currentChords.length < 2) {
        keypress = kbCandidates;
      } else {
        keypress = [];
        for (let i = 0, len = kbCandidates.length; i < len; i++) {
          const candidate = kbCandidates[i];
          if (currentChords.length > candidate.chords.length) {
            continue;
          }
          let prefixMatches = !0;
          for (let i = 1; i < currentChords.length; i++) {
            if (candidate.chords[i] !== currentChords[i]) {
              prefixMatches = !1;
              break;
            }
          }
          prefixMatches && keypress.push(candidate);
        }
      }
      context = this._findCommand(context, keypress);
      if (!context) {
        return this._log(`\\ From ${keypress.length} keybinding entries, no when clauses matched the context.`), NoMatchingKb;
      }
      if (currentChords.length < context.chords.length) {
        return this._log(`\\ From ${keypress.length} keybinding entries, awaiting ${context.chords.length - currentChords.length} more chord(s), when: ${printWhenExplanation(context.when)}, source: ${printSourceExplanation(context)}.`), MoreChordsNeeded;
      }
      this._log(`\\ From ${keypress.length} keybinding entries, matched ${context.command}, when: ${printWhenExplanation(context.when)}, source: ${printSourceExplanation(context)}.`);
      return {kind:2, commandId:context.command, commandArgs:context.commandArgs, isBubble:context.bubble};
    }
    _findCommand(context, matches) {
      for (let i = matches.length - 1; i >= 0; i--) {
        const k = matches[i];
        if (KeybindingResolver._contextMatchesRules(context, k.when)) {
          return k;
        }
      }
      return null;
    }
    static _contextMatchesRules(context, rules) {
      return rules ? rules.evaluate(context) : !0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$keybinding$common$keybindingResolver.js.map
