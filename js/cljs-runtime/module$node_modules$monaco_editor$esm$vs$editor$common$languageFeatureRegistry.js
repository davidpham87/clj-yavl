shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languageFeatureRegistry = function(require, module, exports) {
  function isExclusive(selector) {
    return typeof selector === "string" ? !1 : Array.isArray(selector) ? selector.every(isExclusive) : !!selector.exclusive;
  }
  function isBuiltinSelector(selector) {
    return typeof selector === "string" ? !1 : Array.isArray(selector) ? selector.some(isBuiltinSelector) : !!selector.isBuiltin;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LanguageFeatureRegistry:{enumerable:!0, get:function() {
    return LanguageFeatureRegistry;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__SLASH_model_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model"), require$_DOT__SLASH_languageSelector_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languageSelector");
  class MatchCandidate {
    constructor(uri, languageId, notebookUri, notebookType) {
      this.uri = uri;
      this.languageId = languageId;
      this.notebookUri = notebookUri;
      this.notebookType = notebookType;
    }
    equals(other) {
      var _a, _b;
      return this.notebookType === other.notebookType && this.languageId === other.languageId && this.uri.toString() === other.uri.toString() && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());
    }
  }
  class LanguageFeatureRegistry {
    constructor(_notebookInfoResolver) {
      this._notebookInfoResolver = _notebookInfoResolver;
      this._clock = 0;
      this._entries = [];
      this._onDidChange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChange = this._onDidChange.event;
    }
    register(selector, provider) {
      let entry = {selector, provider, _score:-1, _time:this._clock++};
      this._entries.push(entry);
      this._lastCandidate = void 0;
      this._onDidChange.fire(this._entries.length);
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
        if (entry) {
          const idx = this._entries.indexOf(entry);
          idx >= 0 && (this._entries.splice(idx, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), entry = void 0);
        }
      });
    }
    has(model) {
      return this.all(model).length > 0;
    }
    all(model) {
      if (!model) {
        return [];
      }
      this._updateScores(model);
      model = [];
      for (const entry of this._entries) {
        entry._score > 0 && model.push(entry.provider);
      }
      return model;
    }
    ordered(model) {
      const result = [];
      this._orderedForEach(model, entry => result.push(entry.provider));
      return result;
    }
    orderedGroups(model) {
      const result = [];
      let lastBucket, lastBucketScore;
      this._orderedForEach(model, entry => {
        lastBucket && lastBucketScore === entry._score ? lastBucket.push(entry.provider) : (lastBucketScore = entry._score, lastBucket = [entry.provider], result.push(lastBucket));
      });
      return result;
    }
    _orderedForEach(model, callback) {
      this._updateScores(model);
      for (const entry of this._entries) {
        entry._score > 0 && callback(entry);
      }
    }
    _updateScores(model) {
      var _a, _b;
      const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);
      _a = notebookInfo ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type) : new MatchCandidate(model.uri, model.getLanguageId(), void 0, void 0);
      if ((_b = this._lastCandidate) === null || _b === void 0 || !_b.equals(_a)) {
        this._lastCandidate = _a;
        for (const entry of this._entries) {
          if (entry._score = (0,require$_DOT__SLASH_languageSelector_DOT_js.score)(entry.selector, _a.uri, _a.languageId, (0,require$_DOT__SLASH_model_DOT_js.shouldSynchronizeModel)(model), _a.notebookUri, _a.notebookType), isExclusive(entry.selector) && entry._score > 0) {
            for (const entry of this._entries) {
              entry._score = 0;
            }
            entry._score = 1000;
            break;
          }
        }
        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
      }
    }
    static _compareByScoreAndTime(a, b) {
      return a._score < b._score ? 1 : a._score > b._score ? -1 : isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector) ? 1 : !isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector) ? -1 : a._time < b._time ? 1 : a._time > b._time ? -1 : 0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languageFeatureRegistry.js.map
