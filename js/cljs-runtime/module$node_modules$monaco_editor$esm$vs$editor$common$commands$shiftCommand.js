shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$commands$shiftCommand = function(require, module, exports) {
  function cachedStringRepeat(str, count) {
    if (count <= 0) {
      return "";
    }
    repeatCache[str] || (repeatCache[str] = ["", str]);
    const cache = repeatCache[str];
    for (let i = cache.length; i <= count; i++) {
      cache[i] = cache[i - 1] + str;
    }
    return cache[count];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ShiftCommand:{enumerable:!0, get:function() {
    return ShiftCommand;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$cursorColumns"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH_languages_SLASH_enterAction_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$enterAction");
  require = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfigurationRegistry");
  module = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  exports = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  var ShiftCommand_1;
  const repeatCache = Object.create(null);
  let ShiftCommand = ShiftCommand_1 = class {
    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {
      line = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(line, column, tabSize);
      if (insertSpaces) {
        return tabSize = cachedStringRepeat(" ", indentSize), insertSpaces = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.prevIndentTabStop(line, indentSize), cachedStringRepeat(tabSize, insertSpaces / indentSize);
      }
      indentSize = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.prevRenderTabStop(line, tabSize);
      return cachedStringRepeat("\t", indentSize / tabSize);
    }
    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {
      line = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(line, column, tabSize);
      if (insertSpaces) {
        return tabSize = cachedStringRepeat(" ", indentSize), insertSpaces = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.nextIndentTabStop(line, indentSize), cachedStringRepeat(tabSize, insertSpaces / indentSize);
      }
      indentSize = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.nextRenderTabStop(line, tabSize);
      return cachedStringRepeat("\t", indentSize / tabSize);
    }
    constructor(range, opts, _languageConfigurationService) {
      this._languageConfigurationService = _languageConfigurationService;
      this._opts = opts;
      this._selection = range;
      this._selectionId = null;
      this._selectionStartColumnStaysPut = this._useLastEditRangeForCursorEndPosition = !1;
    }
    _addEditOperation(builder, range, text) {
      this._useLastEditRangeForCursorEndPosition ? builder.addTrackedEditOperation(range, text) : builder.addEditOperation(range, text);
    }
    getEditOperations(model, builder) {
      const startLine = this._selection.startLineNumber;
      let endLine = this._selection.endLineNumber;
      this._selection.endColumn === 1 && startLine !== endLine && --endLine;
      const {tabSize, indentSize, insertSpaces} = this._opts, shouldIndentEmptyLines = startLine === endLine;
      if (this._opts.useTabStops) {
        this._selection.isEmpty() && /^\s*$/.test(model.getLineContent(startLine)) && (this._useLastEditRangeForCursorEndPosition = !0);
        var previousLineExtraSpaces = 0;
        for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {
          var extraSpaces = 0;
          var lineText = model.getLineContent(lineNumber), indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);
          if (!this._opts.isUnshift || lineText.length !== 0 && indentationEndIndex !== 0) {
            if (shouldIndentEmptyLines || this._opts.isUnshift || lineText.length !== 0) {
              indentationEndIndex === -1 && (indentationEndIndex = lineText.length);
              if (lineNumber > 1 && require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize) % indentSize !== 0 && model.tokenization.isCheapToTokenize(lineNumber - 1)) {
                const enterAction = (0,require$_DOT__DOT__SLASH_languages_SLASH_enterAction_DOT_js.getEnterAction)(this._opts.autoIndent, model, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);
                if (enterAction) {
                  extraSpaces = previousLineExtraSpaces;
                  if (enterAction.appendText) {
                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {
                      if (enterAction.appendText.charCodeAt(j) === 32) {
                        extraSpaces++;
                      } else {
                        break;
                      }
                    }
                  }
                  enterAction.removeText && (extraSpaces = Math.max(0, extraSpaces - enterAction.removeText));
                  for (previousLineExtraSpaces = 0; previousLineExtraSpaces < extraSpaces && indentationEndIndex !== 0 && lineText.charCodeAt(indentationEndIndex - 1) === 32; previousLineExtraSpaces++) {
                    indentationEndIndex--;
                  }
                }
              }
              this._opts.isUnshift && indentationEndIndex === 0 || (lineText = this._opts.isUnshift ? ShiftCommand_1.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces) : ShiftCommand_1.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces), this._addEditOperation(builder, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), lineText), lineNumber !== startLine || this._selection.isEmpty() || 
              (this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1));
            }
          }
        }
      } else {
        for (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0 && (this._useLastEditRangeForCursorEndPosition = !0), extraSpaces = insertSpaces ? cachedStringRepeat(" ", indentSize) : "\t", lineNumber = startLine; lineNumber <= endLine; lineNumber++) {
          if (indentationEndIndex = model.getLineContent(lineNumber), lineText = strings.firstNonWhitespaceIndex(indentationEndIndex), !this._opts.isUnshift || indentationEndIndex.length !== 0 && lineText !== 0) {
            if (shouldIndentEmptyLines || this._opts.isUnshift || indentationEndIndex.length !== 0) {
              if (lineText === -1 && (lineText = indentationEndIndex.length), !this._opts.isUnshift || lineText !== 0) {
                if (this._opts.isUnshift) {
                  lineText = Math.min(lineText, indentSize);
                  for (previousLineExtraSpaces = 0; previousLineExtraSpaces < lineText; previousLineExtraSpaces++) {
                    if (indentationEndIndex.charCodeAt(previousLineExtraSpaces) === 9) {
                      lineText = previousLineExtraSpaces + 1;
                      break;
                    }
                  }
                  this._addEditOperation(builder, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, 1, lineNumber, lineText + 1), "");
                } else {
                  this._addEditOperation(builder, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, 1, lineNumber, 1), extraSpaces), lineNumber !== startLine || this._selection.isEmpty() || (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
                }
              }
            }
          }
        }
      }
      this._selectionId = builder.trackSelection(this._selection);
    }
    computeCursorState(model, helper) {
      if (this._useLastEditRangeForCursorEndPosition) {
        return model = helper.getInverseEditOperations()[0], new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(model.range.endLineNumber, model.range.endColumn, model.range.endLineNumber, model.range.endColumn);
      }
      model = helper.getTrackedSelection(this._selectionId);
      return this._selectionStartColumnStaysPut ? (helper = this._selection.startColumn, model.startColumn <= helper ? model : model.getDirection() === 0 ? new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(model.startLineNumber, helper, model.endLineNumber, model.endColumn) : new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(model.endLineNumber, model.endColumn, model.startLineNumber, helper)) : model;
    }
  };
  ShiftCommand = ShiftCommand_1 = module([exports(2, require.ILanguageConfigurationService)], ShiftCommand);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$commands$shiftCommand.js.map
