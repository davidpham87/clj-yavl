shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$rbTreeBase = function(require, module, exports) {
  function leftest(node) {
    for (; node.left !== SENTINEL;) {
      node = node.left;
    }
    return node;
  }
  function righttest(node) {
    for (; node.right !== SENTINEL;) {
      node = node.right;
    }
    return node;
  }
  function calculateSize(node) {
    return node === SENTINEL ? 0 : node.size_left + node.piece.length + calculateSize(node.right);
  }
  function calculateLF(node) {
    return node === SENTINEL ? 0 : node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
  }
  function leftRotate(tree, x) {
    const y = x.right;
    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
    x.right = y.left;
    y.left !== SENTINEL && (y.left.parent = x);
    y.parent = x.parent;
    x.parent === SENTINEL ? tree.root = y : x.parent.left === x ? x.parent.left = y : x.parent.right = y;
    y.left = x;
    x.parent = y;
  }
  function rightRotate(tree, y) {
    const x = y.left;
    y.left = x.right;
    x.right !== SENTINEL && (x.right.parent = y);
    x.parent = y.parent;
    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
    y.parent === SENTINEL ? tree.root = x : y === y.parent.right ? y.parent.right = x : y.parent.left = x;
    x.right = y;
    y.parent = x;
  }
  function rbDelete(tree, z) {
    let x;
    if (z.left === SENTINEL) {
      var y = z;
      x = y.right;
    } else {
      z.right === SENTINEL ? (y = z, x = y.left) : (y = leftest(z.right), x = y.right);
    }
    if (y === tree.root) {
      tree.root = x, x.color = 0, z.detach(), SENTINEL.parent = SENTINEL, tree.root.parent = SENTINEL;
    } else {
      var yWasRed = y.color === 1;
      y === y.parent.left ? y.parent.left = x : y.parent.right = x;
      y === z ? (x.parent = y.parent, recomputeTreeMetadata(tree, x)) : (x.parent = y.parent === z ? y : y.parent, recomputeTreeMetadata(tree, x), y.left = z.left, y.right = z.right, y.parent = z.parent, y.color = z.color, z === tree.root ? tree.root = y : z === z.parent.left ? z.parent.left = y : z.parent.right = y, y.left !== SENTINEL && (y.left.parent = y), y.right !== SENTINEL && (y.right.parent = y), y.size_left = z.size_left, y.lf_left = z.lf_left, recomputeTreeMetadata(tree, y));
      z.detach();
      if (x.parent.left === x && (z = calculateSize(x), y = calculateLF(x), z !== x.parent.size_left || y !== x.parent.lf_left)) {
        const delta = z - x.parent.size_left, lf_delta = y - x.parent.lf_left;
        x.parent.size_left = z;
        x.parent.lf_left = y;
        updateTreeMetadata(tree, x.parent, delta, lf_delta);
      }
      recomputeTreeMetadata(tree, x.parent);
      if (!yWasRed) {
        for (; x !== tree.root && x.color === 0;) {
          x === x.parent.left ? (yWasRed = x.parent.right, yWasRed.color === 1 && (yWasRed.color = 0, x.parent.color = 1, leftRotate(tree, x.parent), yWasRed = x.parent.right), yWasRed.left.color === 0 && yWasRed.right.color === 0 ? (yWasRed.color = 1, x = x.parent) : (yWasRed.right.color === 0 && (yWasRed.left.color = 0, yWasRed.color = 1, rightRotate(tree, yWasRed), yWasRed = x.parent.right), yWasRed.color = x.parent.color, x.parent.color = 0, yWasRed.right.color = 0, leftRotate(tree, x.parent), 
          x = tree.root)) : (yWasRed = x.parent.left, yWasRed.color === 1 && (yWasRed.color = 0, x.parent.color = 1, rightRotate(tree, x.parent), yWasRed = x.parent.left), yWasRed.left.color === 0 && yWasRed.right.color === 0 ? (yWasRed.color = 1, x = x.parent) : (yWasRed.left.color === 0 && (yWasRed.right.color = 0, yWasRed.color = 1, leftRotate(tree, yWasRed), yWasRed = x.parent.left), yWasRed.color = x.parent.color, x.parent.color = 0, yWasRed.left.color = 0, rightRotate(tree, x.parent), x = tree.root));
        }
        x.color = 0;
      }
      SENTINEL.parent = SENTINEL;
    }
  }
  function fixInsert(tree, x) {
    for (recomputeTreeMetadata(tree, x); x !== tree.root && x.parent.color === 1;) {
      if (x.parent === x.parent.parent.left) {
        var y = x.parent.parent.right;
        y.color === 1 ? (x.parent.color = 0, y.color = 0, x.parent.parent.color = 1, x = x.parent.parent) : (x === x.parent.right && (x = x.parent, leftRotate(tree, x)), x.parent.color = 0, x.parent.parent.color = 1, rightRotate(tree, x.parent.parent));
      } else {
        y = x.parent.parent.left, y.color === 1 ? (x.parent.color = 0, y.color = 0, x.parent.parent.color = 1, x = x.parent.parent) : (x === x.parent.left && (x = x.parent, rightRotate(tree, x)), x.parent.color = 0, x.parent.parent.color = 1, leftRotate(tree, x.parent.parent));
      }
    }
    tree.root.color = 0;
  }
  function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
    for (; x !== tree.root && x !== SENTINEL;) {
      x.parent.left === x && (x.parent.size_left += delta, x.parent.lf_left += lineFeedCntDelta), x = x.parent;
    }
  }
  function recomputeTreeMetadata(tree, x) {
    let delta, lf_delta;
    if (x !== tree.root) {
      for (; x !== tree.root && x === x.parent.right;) {
        x = x.parent;
      }
      if (x !== tree.root) {
        for (x = x.parent, delta = calculateSize(x.left) - x.size_left, lf_delta = calculateLF(x.left) - x.lf_left, x.size_left += delta, x.lf_left += lf_delta; x !== tree.root && (delta !== 0 || lf_delta !== 0);) {
          x.parent.left === x && (x.parent.size_left += delta, x.parent.lf_left += lf_delta), x = x.parent;
        }
      }
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SENTINEL:{enumerable:!0, get:function() {
    return SENTINEL;
  }}, TreeNode:{enumerable:!0, get:function() {
    return TreeNode;
  }}, fixInsert:{enumerable:!0, get:function() {
    return fixInsert;
  }}, leftRotate:{enumerable:!0, get:function() {
    return leftRotate;
  }}, leftest:{enumerable:!0, get:function() {
    return leftest;
  }}, rbDelete:{enumerable:!0, get:function() {
    return rbDelete;
  }}, recomputeTreeMetadata:{enumerable:!0, get:function() {
    return recomputeTreeMetadata;
  }}, rightRotate:{enumerable:!0, get:function() {
    return rightRotate;
  }}, righttest:{enumerable:!0, get:function() {
    return righttest;
  }}, updateTreeMetadata:{enumerable:!0, get:function() {
    return updateTreeMetadata;
  }}});
  class TreeNode {
    constructor(piece, color) {
      this.piece = piece;
      this.color = color;
      this.lf_left = this.size_left = 0;
      this.parent = this;
      this.left = this;
      this.right = this;
    }
    next() {
      if (this.right !== SENTINEL) {
        return leftest(this.right);
      }
      let node = this;
      for (; node.parent !== SENTINEL && node.parent.left !== node;) {
        node = node.parent;
      }
      return node.parent === SENTINEL ? SENTINEL : node.parent;
    }
    prev() {
      if (this.left !== SENTINEL) {
        return righttest(this.left);
      }
      let node = this;
      for (; node.parent !== SENTINEL && node.parent.right !== node;) {
        node = node.parent;
      }
      return node.parent === SENTINEL ? SENTINEL : node.parent;
    }
    detach() {
      this.right = this.left = this.parent = null;
    }
  }
  const SENTINEL = new TreeNode(null, 0);
  SENTINEL.parent = SENTINEL;
  SENTINEL.left = SENTINEL;
  SENTINEL.right = SENTINEL;
  SENTINEL.color = 0;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$rbTreeBase.js.map
