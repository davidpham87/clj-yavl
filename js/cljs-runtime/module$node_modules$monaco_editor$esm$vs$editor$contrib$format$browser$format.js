shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$contrib$format$browser$format = function(require, module, exports) {
  function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {
    const result = [], seen = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_extensions_SLASH_common_SLASH_extensions_DOT_js.ExtensionIdentifierSet();
    documentFormattingEditProvider = documentFormattingEditProvider.ordered(model);
    for (const formatter of documentFormattingEditProvider) {
      result.push(formatter), formatter.extensionId && seen.add(formatter.extensionId);
    }
    documentRangeFormattingEditProvider = documentRangeFormattingEditProvider.ordered(model);
    for (const formatter of documentRangeFormattingEditProvider) {
      if (formatter.extensionId) {
        if (seen.has(formatter.extensionId)) {
          continue;
        }
        seen.add(formatter.extensionId);
      }
      result.push({displayName:formatter.displayName, extensionId:formatter.extensionId, provideDocumentFormattingEdits(model, options, token) {
        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);
      }});
    }
    return result;
  }
  async function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token, userGesture) {
    const instaService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_instantiation_SLASH_common_SLASH_instantiation_DOT_js.IInstantiationService);
    var {documentRangeFormattingEditProvider:documentRangeFormattingEditProviderRegistry} = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js.ILanguageFeaturesService);
    accessor = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js.isCodeEditor)(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    documentRangeFormattingEditProviderRegistry = documentRangeFormattingEditProviderRegistry.ordered(accessor);
    if (mode = await FormattingConflicts.select(documentRangeFormattingEditProviderRegistry, accessor, mode)) {
      progress.report(mode), await instaService.invokeFunction(formatDocumentRangesWithProvider, mode, editorOrModel, rangeOrRanges, token, userGesture);
    }
  }
  async function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token, userGesture) {
    var _a, _b;
    const workerService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorWorker_DOT_js.IEditorWorkerService), logService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.ILogService);
    accessor = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_accessibility_SLASH_common_SLASH_accessibility_DOT_js.IAccessibleNotificationService);
    let model, cts;
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js.isCodeEditor)(editorOrModel) ? (model = editorOrModel.getModel(), cts = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_editorState_SLASH_browser_SLASH_editorState_DOT_js.EditorStateCancellationTokenSource(editorOrModel, 5, void 0, token)) : (model = editorOrModel, cts = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_editorState_SLASH_browser_SLASH_editorState_DOT_js.TextModelCancellationTokenSource(editorOrModel, 
    token));
    token = [];
    var len = 0;
    for (var range$jscomp$0 of (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.asArray)(rangeOrRanges).sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts)) {
      len > 0 && require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.areIntersectingOrTouching(token[len - 1], range$jscomp$0) ? token[len - 1] = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(token[len - 1].getStartPosition(), range$jscomp$0.getEndPosition()) : len = token.push(range$jscomp$0);
    }
    range$jscomp$0 = async range => {
      var _a, _b;
      logService.trace("[format][provideDocumentRangeFormattingEdits] (request)", (_a = provider.extensionId) === null || _a === void 0 ? void 0 : _a.value, range);
      range = await provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token) || [];
      logService.trace("[format][provideDocumentRangeFormattingEdits] (response)", (_b = provider.extensionId) === null || _b === void 0 ? void 0 : _b.value, range);
      return range;
    };
    len = (a, b) => {
      if (!a.length || !b.length) {
        return !1;
      }
      const mergedA = a.reduce((acc, val) => require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.plusRange(acc, val.range), a[0].range);
      if (!b.some(x => require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.intersectRanges(mergedA, x.range))) {
        return !1;
      }
      for (const edit of a) {
        for (const otherEdit of b) {
          if (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.intersectRanges(edit.range, otherEdit.range)) {
            return !0;
          }
        }
      }
      return !1;
    };
    rangeOrRanges = [];
    const rawEditsList = [];
    try {
      if (typeof provider.provideDocumentRangesFormattingEdits === "function") {
        logService.trace("[format][provideDocumentRangeFormattingEdits] (request)", (_a = provider.extensionId) === null || _a === void 0 ? void 0 : _a.value, token);
        const result = await provider.provideDocumentRangesFormattingEdits(model, token, model.getFormattingOptions(), cts.token) || [];
        logService.trace("[format][provideDocumentRangeFormattingEdits] (response)", (_b = provider.extensionId) === null || _b === void 0 ? void 0 : _b.value, result);
        rawEditsList.push(result);
      } else {
        for (const range of token) {
          if (cts.token.isCancellationRequested) {
            return !0;
          }
          rawEditsList.push(await range$jscomp$0(range));
        }
        for (_a = 0; _a < token.length; ++_a) {
          for (_b = _a + 1; _b < token.length; ++_b) {
            if (cts.token.isCancellationRequested) {
              return !0;
            }
            if (len(rawEditsList[_a], rawEditsList[_b])) {
              const mergedRange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.plusRange(token[_a], token[_b]), edits = await range$jscomp$0(mergedRange);
              token.splice(_b, 1);
              token.splice(_a, 1);
              token.push(mergedRange);
              rawEditsList.splice(_b, 1);
              rawEditsList.splice(_a, 1);
              rawEditsList.push(edits);
              _b = _a = 0;
            }
          }
        }
      }
      for (const rawEdits of rawEditsList) {
        if (cts.token.isCancellationRequested) {
          return !0;
        }
        const minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
        minimalEdits && rangeOrRanges.push(...minimalEdits);
      }
    } finally {
      cts.dispose();
    }
    if (rangeOrRanges.length === 0) {
      return !1;
    }
    if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js.isCodeEditor)(editorOrModel)) {
      require$_DOT__SLASH_formattingEdit_DOT_js.FormattingEdit.execute(editorOrModel, rangeOrRanges, !0), editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1);
    } else {
      [{range:editorOrModel}] = rangeOrRanges;
      const initialSelection = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(editorOrModel.startLineNumber, editorOrModel.startColumn, editorOrModel.endLineNumber, editorOrModel.endColumn);
      model.pushEditOperations([initialSelection], rangeOrRanges.map(edit => ({text:edit.text, range:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.lift(edit.range), forceMoveMarkers:!0})), undoEdits => {
        for (const {range} of undoEdits) {
          if (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.areIntersectingOrTouching(range, initialSelection)) {
            return [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
          }
        }
        return null;
      });
    }
    accessor.notify("format", userGesture);
    return !0;
  }
  async function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token, userGesture) {
    const instaService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_instantiation_SLASH_common_SLASH_instantiation_DOT_js.IInstantiationService);
    var languageFeaturesService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js.ILanguageFeaturesService);
    accessor = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js.isCodeEditor)(editorOrModel) ? editorOrModel.getModel() : editorOrModel;
    languageFeaturesService = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, accessor);
    if (accessor = await FormattingConflicts.select(languageFeaturesService, accessor, mode)) {
      progress.report(accessor), await instaService.invokeFunction(formatDocumentWithProvider, accessor, editorOrModel, mode, token, userGesture);
    }
  }
  async function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token, userGesture) {
    const workerService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorWorker_DOT_js.IEditorWorkerService);
    accessor = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_accessibility_SLASH_common_SLASH_accessibility_DOT_js.IAccessibleNotificationService);
    let model;
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js.isCodeEditor)(editorOrModel) ? (model = editorOrModel.getModel(), token = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_editorState_SLASH_browser_SLASH_editorState_DOT_js.EditorStateCancellationTokenSource(editorOrModel, 5, void 0, token)) : (model = editorOrModel, token = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_editorState_SLASH_browser_SLASH_editorState_DOT_js.TextModelCancellationTokenSource(editorOrModel, 
    token));
    let edits;
    try {
      const rawEdits = await provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), token.token);
      edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
      if (token.token.isCancellationRequested) {
        return !0;
      }
    } finally {
      token.dispose();
    }
    if (!edits || edits.length === 0) {
      return !1;
    }
    if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js.isCodeEditor)(editorOrModel)) {
      require$_DOT__SLASH_formattingEdit_DOT_js.FormattingEdit.execute(editorOrModel, edits, mode !== 2), mode !== 2 && editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1);
    } else {
      [{range:provider}] = edits;
      const initialSelection = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(provider.startLineNumber, provider.startColumn, provider.endLineNumber, provider.endColumn);
      model.pushEditOperations([initialSelection], edits.map(edit => ({text:edit.text, range:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.lift(edit.range), forceMoveMarkers:!0})), undoEdits => {
        for (const {range} of undoEdits) {
          if (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.areIntersectingOrTouching(range, initialSelection)) {
            return [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];
          }
        }
        return null;
      });
    }
    accessor.notify("format", userGesture);
    return !0;
  }
  async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {
    languageFeaturesService = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);
    for (const provider of languageFeaturesService) {
      if (languageFeaturesService = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedExternalError), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.isNonEmptyArray)(languageFeaturesService)) {
        return await workerService.computeMoreMinimalEdits(model.uri, languageFeaturesService);
      }
    }
  }
  async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {
    languageFeaturesService = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
    for (const provider of languageFeaturesService) {
      if (languageFeaturesService = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedExternalError), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.isNonEmptyArray)(languageFeaturesService)) {
        return await workerService.computeMoreMinimalEdits(model.uri, languageFeaturesService);
      }
    }
  }
  function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {
    languageFeaturesService = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
    return languageFeaturesService.length === 0 || languageFeaturesService[0].autoFormatTriggerCharacters.indexOf(ch) < 0 ? Promise.resolve(void 0) : Promise.resolve(languageFeaturesService[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedExternalError).then(edits => workerService.computeMoreMinimalEdits(model.uri, edits));
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, FormattingConflicts:{enumerable:!0, get:function() {
    return FormattingConflicts;
  }}, formatDocumentRangesWithProvider:{enumerable:!0, get:function() {
    return formatDocumentRangesWithProvider;
  }}, formatDocumentRangesWithSelectedProvider:{enumerable:!0, get:function() {
    return formatDocumentRangesWithSelectedProvider;
  }}, formatDocumentWithProvider:{enumerable:!0, get:function() {
    return formatDocumentWithProvider;
  }}, formatDocumentWithSelectedProvider:{enumerable:!0, get:function() {
    return formatDocumentWithSelectedProvider;
  }}, getDocumentFormattingEditsUntilResult:{enumerable:!0, get:function() {
    return getDocumentFormattingEditsUntilResult;
  }}, getDocumentRangeFormattingEditsUntilResult:{enumerable:!0, get:function() {
    return getDocumentRangeFormattingEditsUntilResult;
  }}, getOnTypeFormattingEdits:{enumerable:!0, get:function() {
    return getOnTypeFormattingEdits;
  }}, getRealAndSyntheticDocumentFormattersOrdered:{enumerable:!0, get:function() {
    return getRealAndSyntheticDocumentFormattersOrdered;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_cancellation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$cancellation"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$linkedList");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$uri"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_editorState_SLASH_browser_SLASH_editorState_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$contrib$editorState$browser$editorState"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_browser_SLASH_editorBrowser_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$editorBrowser"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorWorker_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$editorWorker"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_resolverService_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$resolverService"), 
  require$_DOT__SLASH_formattingEdit_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$contrib$format$browser$formattingEdit");
  exports = require("module$node_modules$monaco_editor$esm$vs$platform$commands$common$commands");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_extensions_SLASH_common_SLASH_extensions_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$extensions$common$extensions"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_instantiation_SLASH_common_SLASH_instantiation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$instantiation"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$services$languageFeatures"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$log$common$log"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_accessibility_SLASH_common_SLASH_accessibility_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$accessibility$common$accessibility");
  class FormattingConflicts {
    static setFormatterSelector(selector) {
      return {dispose:FormattingConflicts._selectors.unshift(selector)};
    }
    static async select(formatter, document, mode) {
      if (formatter.length !== 0) {
        var selector = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.first(FormattingConflicts._selectors);
        if (selector) {
          return await selector(formatter, document, mode);
        }
      }
    }
  }
  FormattingConflicts._selectors = new module.LinkedList();
  exports.CommandsRegistry.registerCommand("_executeFormatRangeProvider", async function(accessor, ...args) {
    const [resource, range, options] = args;
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertType)(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(resource));
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertType)(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.isIRange(range));
    var resolverService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_resolverService_DOT_js.ITextModelService);
    args = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorWorker_DOT_js.IEditorWorkerService);
    accessor = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js.ILanguageFeaturesService);
    resolverService = await resolverService.createModelReference(resource);
    try {
      return getDocumentRangeFormattingEditsUntilResult(args, accessor, resolverService.object.textEditorModel, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.lift(range), options, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_cancellation_DOT_js.CancellationToken.None);
    } finally {
      resolverService.dispose();
    }
  });
  exports.CommandsRegistry.registerCommand("_executeFormatDocumentProvider", async function(accessor, ...args) {
    const [resource, options] = args;
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertType)(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(resource));
    var resolverService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_resolverService_DOT_js.ITextModelService);
    args = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorWorker_DOT_js.IEditorWorkerService);
    accessor = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js.ILanguageFeaturesService);
    resolverService = await resolverService.createModelReference(resource);
    try {
      return getDocumentFormattingEditsUntilResult(args, accessor, resolverService.object.textEditorModel, options, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_cancellation_DOT_js.CancellationToken.None);
    } finally {
      resolverService.dispose();
    }
  });
  exports.CommandsRegistry.registerCommand("_executeFormatOnTypeProvider", async function(accessor, ...args) {
    const [resource, position, ch, options] = args;
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertType)(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(resource));
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertType)(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position.isIPosition(position));
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertType)(typeof ch === "string");
    var resolverService = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_resolverService_DOT_js.ITextModelService);
    args = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_editorWorker_DOT_js.IEditorWorkerService);
    accessor = accessor.get(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_services_SLASH_languageFeatures_DOT_js.ILanguageFeaturesService);
    resolverService = await resolverService.createModelReference(resource);
    try {
      return getOnTypeFormattingEdits(args, accessor, resolverService.object.textEditorModel, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position.lift(position), ch, options, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_cancellation_DOT_js.CancellationToken.None);
    } finally {
      resolverService.dispose();
    }
  });
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$contrib$format$browser$format.js.map
