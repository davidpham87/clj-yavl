shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$controller$mouseHandler = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MouseHandler:{enumerable:!0, get:function() {
    return MouseHandler;
  }}});
  var dom = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_mouseEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$mouseEvent");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), require$_DOT__SLASH_mouseTarget_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$controller$mouseTarget"), require$_DOT__DOT__SLASH_editorDom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$editorDom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorZoom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$config$editorZoom"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection");
  exports = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewEventHandler");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_scrollbar_SLASH_scrollableElement_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$scrollbar$scrollableElement");
  class MouseHandler extends exports.ViewEventHandler {
    constructor(context, viewController, viewHelper) {
      super();
      this._mouseLeaveMonitor = null;
      this._context = context;
      this.viewController = viewController;
      this.viewHelper = viewHelper;
      this.mouseTargetFactory = new require$_DOT__SLASH_mouseTarget_DOT_js.MouseTargetFactory(this._context, viewHelper);
      this._mouseDownOperation = this._register(new MouseDownOperation(this._context, this.viewController, this.viewHelper, this.mouseTargetFactory, (e, testEventTarget) => this._createMouseTarget(e, testEventTarget), e => this._getMouseColumn(e)));
      this.lastMouseLeaveTime = -1;
      this._height = this._context.configuration.options.get(143).height;
      context = new require$_DOT__DOT__SLASH_editorDom_DOT_js.EditorMouseEventFactory(this.viewHelper.viewDomNode);
      this._register(context.onContextMenu(this.viewHelper.viewDomNode, e => this._onContextMenu(e, !0)));
      this._register(context.onMouseMove(this.viewHelper.viewDomNode, e => {
        this._onMouseMove(e);
        this._mouseLeaveMonitor || (this._mouseLeaveMonitor = dom.addDisposableListener(this.viewHelper.viewDomNode.ownerDocument, "mousemove", e => {
          this.viewHelper.viewDomNode.contains(e.target) || this._onMouseLeave(new require$_DOT__DOT__SLASH_editorDom_DOT_js.EditorMouseEvent(e, !1, this.viewHelper.viewDomNode));
        }));
      }));
      this._register(context.onMouseUp(this.viewHelper.viewDomNode, e => this._onMouseUp(e)));
      this._register(context.onMouseLeave(this.viewHelper.viewDomNode, e => this._onMouseLeave(e)));
      let capturePointerId = 0;
      this._register(context.onPointerDown(this.viewHelper.viewDomNode, (e, pointerId) => {
        capturePointerId = pointerId;
      }));
      this._register(dom.addDisposableListener(this.viewHelper.viewDomNode, dom.EventType.POINTER_UP, e => {
        this._mouseDownOperation.onPointerUp();
      }));
      this._register(context.onMouseDown(this.viewHelper.viewDomNode, e => this._onMouseDown(e, capturePointerId)));
      this._setupMouseWheelZoomListener();
      this._context.addEventHandler(this);
    }
    _setupMouseWheelZoomListener() {
      function hasMouseWheelZoomModifiers(browserEvent) {
        return platform.isMacintosh ? (browserEvent.metaKey || browserEvent.ctrlKey) && !browserEvent.shiftKey && !browserEvent.altKey : browserEvent.ctrlKey && !browserEvent.metaKey && !browserEvent.shiftKey && !browserEvent.altKey;
      }
      const classifier = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_scrollbar_SLASH_scrollableElement_DOT_js.MouseWheelClassifier.INSTANCE;
      let prevMouseWheelTime = 0, gestureStartZoomLevel = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorZoom_DOT_js.EditorZoom.getZoomLevel(), gestureHasZoomModifiers = !1, gestureAccumulatedDelta = 0;
      this._register(dom.addDisposableListener(this.viewHelper.viewDomNode, dom.EventType.MOUSE_WHEEL, browserEvent => {
        this.viewController.emitMouseWheel(browserEvent);
        if (this._context.configuration.options.get(75)) {
          var e = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_mouseEvent_DOT_js.StandardWheelEvent(browserEvent);
          classifier.acceptStandardWheelEvent(e);
          classifier.isPhysicalMouseWheel() ? hasMouseWheelZoomModifiers(browserEvent) && (browserEvent = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorZoom_DOT_js.EditorZoom.getZoomLevel(), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorZoom_DOT_js.EditorZoom.setZoomLevel(browserEvent + (e.deltaY > 0 ? 1 : -1)), e.preventDefault(), e.stopPropagation()) : (Date.now() - prevMouseWheelTime > 50 && (gestureStartZoomLevel = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorZoom_DOT_js.EditorZoom.getZoomLevel(), 
          gestureHasZoomModifiers = hasMouseWheelZoomModifiers(browserEvent), gestureAccumulatedDelta = 0), prevMouseWheelTime = Date.now(), gestureAccumulatedDelta += e.deltaY, gestureHasZoomModifiers && (require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorZoom_DOT_js.EditorZoom.setZoomLevel(gestureStartZoomLevel + gestureAccumulatedDelta / 5), e.preventDefault(), e.stopPropagation()));
        }
      }, {capture:!0, passive:!1}));
    }
    dispose() {
      this._context.removeEventHandler(this);
      this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null);
      super.dispose();
    }
    onConfigurationChanged(e) {
      e.hasChanged(143) && (e = this._context.configuration.options.get(143).height, this._height !== e && (this._height = e, this._mouseDownOperation.onHeightChanged()));
      return !1;
    }
    onCursorStateChanged(e) {
      this._mouseDownOperation.onCursorStateChanged(e);
      return !1;
    }
    onFocusChanged(e) {
      return !1;
    }
    getTargetAtClientPoint(clientX, clientY) {
      clientX = (new require$_DOT__DOT__SLASH_editorDom_DOT_js.ClientCoordinates(clientX, clientY)).toPageCoordinates(dom.getWindow(this.viewHelper.viewDomNode));
      clientY = (0,require$_DOT__DOT__SLASH_editorDom_DOT_js.createEditorPagePosition)(this.viewHelper.viewDomNode);
      if (clientX.y < clientY.y || clientX.y > clientY.y + clientY.height || clientX.x < clientY.x || clientX.x > clientY.x + clientY.width) {
        return null;
      }
      const relativePos = (0,require$_DOT__DOT__SLASH_editorDom_DOT_js.createCoordinatesRelativeToEditor)(this.viewHelper.viewDomNode, clientY, clientX);
      return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), clientY, clientX, relativePos, null);
    }
    _createMouseTarget(e, testEventTarget) {
      let target = e.target;
      if (!this.viewHelper.viewDomNode.contains(target)) {
        const shadowRoot = dom.getShadowRoot(this.viewHelper.viewDomNode);
        shadowRoot && (target = shadowRoot.elementsFromPoint(e.posx, e.posy).find(el => this.viewHelper.viewDomNode.contains(el)));
      }
      return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, testEventTarget ? target : null);
    }
    _getMouseColumn(e) {
      return this.mouseTargetFactory.getMouseColumn(e.relativePos);
    }
    _onContextMenu(e, testEventTarget) {
      this.viewController.emitContextMenu({event:e, target:this._createMouseTarget(e, testEventTarget)});
    }
    _onMouseMove(e) {
      this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault();
      this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime || this.viewController.emitMouseMove({event:e, target:this._createMouseTarget(e, !0)});
    }
    _onMouseLeave(e) {
      this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null);
      this.lastMouseLeaveTime = (new Date()).getTime();
      this.viewController.emitMouseLeave({event:e, target:null});
    }
    _onMouseUp(e) {
      this.viewController.emitMouseUp({event:e, target:this._createMouseTarget(e, !0)});
    }
    _onMouseDown(e, pointerId) {
      const t = this._createMouseTarget(e, !0);
      var targetIsContent = t.type === 6 || t.type === 7;
      const targetIsGutter = t.type === 2 || t.type === 3 || t.type === 4, targetIsLineNumbers = t.type === 3, selectOnLineNumbers = this._context.configuration.options.get(108), targetIsViewZone = t.type === 8 || t.type === 5, targetIsWidget = t.type === 9;
      let shouldHandle = e.leftButton || e.middleButton;
      platform.isMacintosh && e.leftButton && e.ctrlKey && (shouldHandle = !1);
      const focus = () => {
        e.preventDefault();
        this.viewHelper.focusTextArea();
      };
      shouldHandle && (targetIsContent || targetIsLineNumbers && selectOnLineNumbers) ? (focus(), this._mouseDownOperation.start(t.type, e, pointerId)) : targetIsGutter ? e.preventDefault() : targetIsViewZone ? (targetIsContent = t.detail, shouldHandle && this.viewHelper.shouldSuppressMouseDownOnViewZone(targetIsContent.viewZoneId) && (focus(), this._mouseDownOperation.start(t.type, e, pointerId), e.preventDefault())) : targetIsWidget && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail) && 
      (focus(), e.preventDefault());
      this.viewController.emitMouseDown({event:e, target:t});
    }
  }
  class MouseDownOperation extends module.Disposable {
    constructor(_context, _viewController, _viewHelper, _mouseTargetFactory, createMouseTarget, getMouseColumn) {
      super();
      this._context = _context;
      this._viewController = _viewController;
      this._viewHelper = _viewHelper;
      this._mouseTargetFactory = _mouseTargetFactory;
      this._createMouseTarget = createMouseTarget;
      this._getMouseColumn = getMouseColumn;
      this._mouseMoveMonitor = this._register(new require$_DOT__DOT__SLASH_editorDom_DOT_js.GlobalEditorPointerMoveMonitor(this._viewHelper.viewDomNode));
      this._topBottomDragScrolling = this._register(new TopBottomDragScrolling(this._context, this._viewHelper, this._mouseTargetFactory, (position, inSelectionMode, revealType) => this._dispatchMouse(position, inSelectionMode, revealType)));
      this._mouseState = new MouseDownState();
      this._currentSelection = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(1, 1, 1, 1);
      this._isActive = !1;
      this._lastMouseEvent = null;
    }
    dispose() {
      super.dispose();
    }
    isActive() {
      return this._isActive;
    }
    _onMouseDownThenMove(e) {
      this._lastMouseEvent = e;
      this._mouseState.setModifiers(e);
      const position = this._findMousePosition(e, !1);
      position && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({event:e, target:position}) : position.type !== 13 || position.outsidePosition !== "above" && position.outsidePosition !== "below" ? (this._topBottomDragScrolling.stop(), this._dispatchMouse(position, !0, 1)) : this._topBottomDragScrolling.start(position, e));
    }
    start(targetType, e, pointerId) {
      this._lastMouseEvent = e;
      this._mouseState.setStartedOnLineNumbers(targetType === 3);
      this._mouseState.setStartButtons(e);
      this._mouseState.setModifiers(e);
      if ((targetType = this._findMousePosition(e, !0)) && targetType.position) {
        this._mouseState.trySetCount(e.detail, targetType.position);
        e.detail = this._mouseState.count;
        var options = this._context.configuration.options;
        !options.get(90) && options.get(35) && !options.get(22) && !this._mouseState.altKey && e.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && targetType.type === 6 && targetType.position && this._currentSelection.containsPosition(targetType.position) ? (this._isActive = this._mouseState.isDragAndDrop = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, pointerId, e.buttons, e => this._onMouseDownThenMove(e), browserEvent => {
          const position = this._findMousePosition(this._lastMouseEvent, !1);
          dom.isKeyboardEvent(browserEvent) ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({event:this._lastMouseEvent, target:position ? this._createMouseTarget(this._lastMouseEvent, !0) : null});
          this._stop();
        })) : (this._mouseState.isDragAndDrop = !1, this._dispatchMouse(targetType, e.shiftKey, 1), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, pointerId, e.buttons, e => this._onMouseDownThenMove(e), () => this._stop())));
      }
    }
    _stop() {
      this._isActive = !1;
      this._topBottomDragScrolling.stop();
    }
    onHeightChanged() {
      this._mouseMoveMonitor.stopMonitoring();
    }
    onPointerUp() {
      this._mouseMoveMonitor.stopMonitoring();
    }
    onCursorStateChanged(e) {
      this._currentSelection = e.selections[0];
    }
    _getPositionOutsideEditor(e) {
      var editorContent = e.editorPos, model = this._context.viewModel, viewLayout = this._context.viewLayout;
      const mouseColumn = this._getMouseColumn(e);
      if (e.posy < editorContent.y) {
        model = editorContent.y - e.posy;
        editorContent = Math.max(viewLayout.getCurrentScrollTop() - model, 0);
        if (e = require$_DOT__SLASH_mouseTarget_DOT_js.HitTestContext.getZoneAtCoord(this._context, editorContent)) {
          if (e = this._helpPositionJumpOverViewZone(e)) {
            return require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(mouseColumn, e, "above", model);
          }
        }
        viewLayout = viewLayout.getLineNumberAtVerticalOffset(editorContent);
        return require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(mouseColumn, new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewLayout, 1), "above", model);
      }
      if (e.posy > editorContent.y + editorContent.height) {
        editorContent = e.posy - editorContent.y - editorContent.height;
        e = viewLayout.getCurrentScrollTop() + e.relativePos.y;
        var viewZoneData = require$_DOT__SLASH_mouseTarget_DOT_js.HitTestContext.getZoneAtCoord(this._context, e);
        if (viewZoneData && (viewZoneData = this._helpPositionJumpOverViewZone(viewZoneData))) {
          return require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(mouseColumn, viewZoneData, "below", editorContent);
        }
        viewLayout = viewLayout.getLineNumberAtVerticalOffset(e);
        return require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(mouseColumn, new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewLayout, model.getLineMaxColumn(viewLayout)), "below", editorContent);
      }
      viewLayout = viewLayout.getLineNumberAtVerticalOffset(viewLayout.getCurrentScrollTop() + e.relativePos.y);
      return e.posx < editorContent.x ? (model = editorContent.x - e.posx, require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(mouseColumn, new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewLayout, 1), "left", model)) : e.posx > editorContent.x + editorContent.width ? (editorContent = e.posx - editorContent.x - editorContent.width, require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(mouseColumn, new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewLayout, 
      model.getLineMaxColumn(viewLayout)), "right", editorContent)) : null;
    }
    _findMousePosition(e, testEventTarget) {
      const positionOutsideEditor = this._getPositionOutsideEditor(e);
      if (positionOutsideEditor) {
        return positionOutsideEditor;
      }
      e = this._createMouseTarget(e, testEventTarget);
      if (!e.position) {
        return null;
      }
      if (e.type === 8 || e.type === 5) {
        if (testEventTarget = this._helpPositionJumpOverViewZone(e.detail)) {
          return require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createViewZone(e.type, e.element, e.mouseColumn, testEventTarget, e.detail);
        }
      }
      return e;
    }
    _helpPositionJumpOverViewZone(viewZoneData) {
      const selectionStart = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), positionBefore = viewZoneData.positionBefore;
      viewZoneData = viewZoneData.positionAfter;
      return positionBefore && viewZoneData ? positionBefore.isBefore(selectionStart) ? positionBefore : viewZoneData : null;
    }
    _dispatchMouse(position, inSelectionMode, revealType) {
      position.position && this._viewController.dispatchMouse({position:position.position, mouseColumn:position.mouseColumn, startedOnLineNumbers:this._mouseState.startedOnLineNumbers, revealType, inSelectionMode, mouseDownCount:this._mouseState.count, altKey:this._mouseState.altKey, ctrlKey:this._mouseState.ctrlKey, metaKey:this._mouseState.metaKey, shiftKey:this._mouseState.shiftKey, leftButton:this._mouseState.leftButton, middleButton:this._mouseState.middleButton, onInjectedText:position.type === 
      6 && position.detail.injectedText !== null});
    }
  }
  class TopBottomDragScrolling extends module.Disposable {
    constructor(_context, _viewHelper, _mouseTargetFactory, _dispatchMouse) {
      super();
      this._context = _context;
      this._viewHelper = _viewHelper;
      this._mouseTargetFactory = _mouseTargetFactory;
      this._dispatchMouse = _dispatchMouse;
      this._operation = null;
    }
    dispose() {
      super.dispose();
      this.stop();
    }
    start(position, mouseEvent) {
      this._operation ? this._operation.setPosition(position, mouseEvent) : this._operation = new TopBottomDragScrollingOperation(this._context, this._viewHelper, this._mouseTargetFactory, this._dispatchMouse, position, mouseEvent);
    }
    stop() {
      this._operation && (this._operation.dispose(), this._operation = null);
    }
  }
  class TopBottomDragScrollingOperation extends module.Disposable {
    constructor(_context, _viewHelper, _mouseTargetFactory, _dispatchMouse, position, mouseEvent) {
      super();
      this._context = _context;
      this._viewHelper = _viewHelper;
      this._mouseTargetFactory = _mouseTargetFactory;
      this._dispatchMouse = _dispatchMouse;
      this._position = position;
      this._mouseEvent = mouseEvent;
      this._lastTime = Date.now();
      this._animationFrameDisposable = dom.scheduleAtNextAnimationFrame(dom.getWindow(mouseEvent.browserEvent), () => this._execute());
    }
    dispose() {
      this._animationFrameDisposable.dispose();
    }
    setPosition(position, mouseEvent) {
      this._position = position;
      this._mouseEvent = mouseEvent;
    }
    _tick() {
      const now = Date.now(), elapsed = now - this._lastTime;
      this._lastTime = now;
      return elapsed;
    }
    _getScrollSpeed() {
      var lineHeight = this._context.configuration.options.get(66);
      const viewportInLines = this._context.configuration.options.get(143).height / lineHeight;
      lineHeight = this._position.outsideDistance / lineHeight;
      return lineHeight <= 1.5 ? Math.max(30, viewportInLines * (1 + lineHeight)) : lineHeight <= 3 ? Math.max(60, viewportInLines * (2 + lineHeight)) : Math.max(200, viewportInLines * (7 + lineHeight));
    }
    _execute() {
      var lineHeight = this._context.configuration.options.get(66), scrollSpeedInLines = this._getScrollSpeed(), elapsed = this._tick();
      lineHeight *= elapsed / 1000 * scrollSpeedInLines;
      this._context.viewModel.viewLayout.deltaScrollNow(0, this._position.outsidePosition === "above" ? -lineHeight : lineHeight);
      this._viewHelper.renderNow();
      lineHeight = this._context.viewLayout.getLinesViewportData();
      lineHeight = this._position.outsidePosition === "above" ? lineHeight.startLineNumber : lineHeight.endLineNumber;
      scrollSpeedInLines = (0,require$_DOT__DOT__SLASH_editorDom_DOT_js.createEditorPagePosition)(this._viewHelper.viewDomNode);
      elapsed = this._context.configuration.options.get(143).horizontalScrollbarHeight;
      elapsed = new require$_DOT__DOT__SLASH_editorDom_DOT_js.PageCoordinates(this._mouseEvent.pos.x, scrollSpeedInLines.y + scrollSpeedInLines.height - elapsed - 0.1);
      const relativePos = (0,require$_DOT__DOT__SLASH_editorDom_DOT_js.createCoordinatesRelativeToEditor)(this._viewHelper.viewDomNode, scrollSpeedInLines, elapsed);
      scrollSpeedInLines = this._mouseTargetFactory.createMouseTarget(this._viewHelper.getLastRenderData(), scrollSpeedInLines, elapsed, relativePos, null);
      scrollSpeedInLines.position && scrollSpeedInLines.position.lineNumber === lineHeight || (scrollSpeedInLines = this._position.outsidePosition === "above" ? require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(this._position.mouseColumn, new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(lineHeight, 1), "above", this._position.outsideDistance) : require$_DOT__SLASH_mouseTarget_DOT_js.MouseTarget.createOutsideEditor(this._position.mouseColumn, 
      new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(lineHeight, this._context.viewModel.getLineMaxColumn(lineHeight)), "below", this._position.outsideDistance));
      this._dispatchMouse(scrollSpeedInLines, !0, 2);
      this._animationFrameDisposable = dom.scheduleAtNextAnimationFrame(dom.getWindow(scrollSpeedInLines.element), () => this._execute());
    }
  }
  class MouseDownState {
    get altKey() {
      return this._altKey;
    }
    get ctrlKey() {
      return this._ctrlKey;
    }
    get metaKey() {
      return this._metaKey;
    }
    get shiftKey() {
      return this._shiftKey;
    }
    get leftButton() {
      return this._leftButton;
    }
    get middleButton() {
      return this._middleButton;
    }
    get startedOnLineNumbers() {
      return this._startedOnLineNumbers;
    }
    constructor() {
      this._startedOnLineNumbers = this._middleButton = this._leftButton = this._shiftKey = this._metaKey = this._ctrlKey = this._altKey = !1;
      this._lastMouseDownPosition = null;
      this._lastSetMouseDownCountTime = this._lastMouseDownCount = this._lastMouseDownPositionEqualCount = 0;
      this.isDragAndDrop = !1;
    }
    get count() {
      return this._lastMouseDownCount;
    }
    setModifiers(source) {
      this._altKey = source.altKey;
      this._ctrlKey = source.ctrlKey;
      this._metaKey = source.metaKey;
      this._shiftKey = source.shiftKey;
    }
    setStartButtons(source) {
      this._leftButton = source.leftButton;
      this._middleButton = source.middleButton;
    }
    setStartedOnLineNumbers(startedOnLineNumbers) {
      this._startedOnLineNumbers = startedOnLineNumbers;
    }
    trySetCount(setMouseDownCount, newMouseDownPosition) {
      const currentTime = (new Date()).getTime();
      currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME && (setMouseDownCount = 1);
      this._lastSetMouseDownCountTime = currentTime;
      setMouseDownCount > this._lastMouseDownCount + 1 && (setMouseDownCount = this._lastMouseDownCount + 1);
      this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1;
      this._lastMouseDownPosition = newMouseDownPosition;
      this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
    }
  }
  MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$controller$mouseHandler.js.map
