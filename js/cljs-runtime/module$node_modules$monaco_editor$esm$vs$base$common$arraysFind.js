shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$arraysFind = function(require, module, exports) {
  function findLast(array, predicate, fromIdx) {
    predicate = findLastIdx(array, predicate);
    if (predicate !== -1) {
      return array[predicate];
    }
  }
  function findLastIdx(array, predicate, fromIndex = array.length - 1) {
    for (; fromIndex >= 0; fromIndex--) {
      if (predicate(array[fromIndex])) {
        return fromIndex;
      }
    }
    return -1;
  }
  function findLastMonotonous(array, predicate) {
    predicate = findLastIdxMonotonous(array, predicate);
    return predicate === -1 ? void 0 : array[predicate];
  }
  function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
    for (; startIdx < endIdxEx;) {
      const k = Math.floor((startIdx + endIdxEx) / 2);
      predicate(array[k]) ? startIdx = k + 1 : endIdxEx = k;
    }
    return startIdx - 1;
  }
  function findFirstMonotonous(array, predicate) {
    predicate = findFirstIdxMonotonousOrArrLen(array, predicate);
    return predicate === array.length ? void 0 : array[predicate];
  }
  function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
    for (; startIdx < endIdxEx;) {
      const k = Math.floor((startIdx + endIdxEx) / 2);
      predicate(array[k]) ? endIdxEx = k : startIdx = k + 1;
    }
    return startIdx;
  }
  function findFirstMaxBy(array, comparator) {
    if (array.length !== 0) {
      var max = array[0];
      for (let i = 1; i < array.length; i++) {
        const item = array[i];
        comparator(item, max) > 0 && (max = item);
      }
      return max;
    }
  }
  function findLastMaxBy(array, comparator) {
    if (array.length !== 0) {
      var max = array[0];
      for (let i = 1; i < array.length; i++) {
        const item = array[i];
        comparator(item, max) >= 0 && (max = item);
      }
      return max;
    }
  }
  function findFirstMinBy(array, comparator) {
    return findFirstMaxBy(array, (a, b) => -comparator(a, b));
  }
  function findMaxIdxBy(array, comparator) {
    if (array.length === 0) {
      return -1;
    }
    let maxIdx = 0;
    for (let i = 1; i < array.length; i++) {
      comparator(array[i], array[maxIdx]) > 0 && (maxIdx = i);
    }
    return maxIdx;
  }
  function mapFindFirst(items, mapFn) {
    for (const value of items) {
      if (items = mapFn(value), items !== void 0) {
        return items;
      }
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MonotonousArray:{enumerable:!0, get:function() {
    return MonotonousArray;
  }}, findFirstIdxMonotonousOrArrLen:{enumerable:!0, get:function() {
    return findFirstIdxMonotonousOrArrLen;
  }}, findFirstMaxBy:{enumerable:!0, get:function() {
    return findFirstMaxBy;
  }}, findFirstMinBy:{enumerable:!0, get:function() {
    return findFirstMinBy;
  }}, findFirstMonotonous:{enumerable:!0, get:function() {
    return findFirstMonotonous;
  }}, findLast:{enumerable:!0, get:function() {
    return findLast;
  }}, findLastIdx:{enumerable:!0, get:function() {
    return findLastIdx;
  }}, findLastIdxMonotonous:{enumerable:!0, get:function() {
    return findLastIdxMonotonous;
  }}, findLastMaxBy:{enumerable:!0, get:function() {
    return findLastMaxBy;
  }}, findLastMonotonous:{enumerable:!0, get:function() {
    return findLastMonotonous;
  }}, findMaxIdxBy:{enumerable:!0, get:function() {
    return findMaxIdxBy;
  }}, mapFindFirst:{enumerable:!0, get:function() {
    return mapFindFirst;
  }}});
  class MonotonousArray {
    constructor(_array) {
      this._array = _array;
      this._findLastMonotonousLastIdx = 0;
    }
    findLastMonotonous(predicate) {
      if (MonotonousArray.assertInvariants) {
        if (this._prevFindLastPredicate) {
          for (const item of this._array) {
            if (this._prevFindLastPredicate(item) && !predicate(item)) {
              throw Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
            }
          }
        }
        this._prevFindLastPredicate = predicate;
      }
      predicate = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
      this._findLastMonotonousLastIdx = predicate + 1;
      return predicate === -1 ? void 0 : this._array[predicate];
    }
  }
  MonotonousArray.assertInvariants = !1;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$arraysFind.js.map
