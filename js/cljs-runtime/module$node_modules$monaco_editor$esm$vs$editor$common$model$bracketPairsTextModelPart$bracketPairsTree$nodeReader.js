shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$nodeReader = function(require, module, exports) {
  function getNextChildIdx(node, curIdx = -1) {
    for (;;) {
      curIdx++;
      if (curIdx >= node.childrenLength) {
        return -1;
      }
      if (node.getChild(curIdx)) {
        return curIdx;
      }
    }
  }
  function lastOrUndefined(arr) {
    return arr.length > 0 ? arr[arr.length - 1] : void 0;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, NodeReader:{enumerable:!0, get:function() {
    return NodeReader;
  }}});
  var require$_DOT__SLASH_length_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$length");
  class NodeReader {
    constructor(node) {
      this.lastOffset = require$_DOT__SLASH_length_DOT_js.lengthZero;
      this.nextNodes = [node];
      this.offsets = [require$_DOT__SLASH_length_DOT_js.lengthZero];
      this.idxs = [];
    }
    readLongestNodeAt(offset, predicate) {
      if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThan)(offset, this.lastOffset)) {
        throw Error("Invalid offset");
      }
      for (this.lastOffset = offset;;) {
        const curNode = lastOrUndefined(this.nextNodes);
        if (!curNode) {
          break;
        }
        const curNodeOffset = lastOrUndefined(this.offsets);
        if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThan)(offset, curNodeOffset)) {
          break;
        }
        if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThan)(curNodeOffset, offset)) {
          if ((0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(curNodeOffset, curNode.length) <= offset) {
            this.nextNodeAfterCurrent();
          } else {
            var nextChildIdx = getNextChildIdx(curNode);
            nextChildIdx !== -1 ? (this.nextNodes.push(curNode.getChild(nextChildIdx)), this.offsets.push(curNodeOffset), this.idxs.push(nextChildIdx)) : this.nextNodeAfterCurrent();
          }
        } else {
          if (predicate(curNode)) {
            return this.nextNodeAfterCurrent(), curNode;
          }
          nextChildIdx = getNextChildIdx(curNode);
          if (nextChildIdx === -1) {
            this.nextNodeAfterCurrent();
            break;
          }
          this.nextNodes.push(curNode.getChild(nextChildIdx));
          this.offsets.push(curNodeOffset);
          this.idxs.push(nextChildIdx);
        }
      }
    }
    nextNodeAfterCurrent() {
      for (;;) {
        const currentOffset = lastOrUndefined(this.offsets), currentNode = lastOrUndefined(this.nextNodes);
        this.nextNodes.pop();
        this.offsets.pop();
        if (this.idxs.length === 0) {
          break;
        }
        const parent = lastOrUndefined(this.nextNodes), nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);
        if (nextChildIdx !== -1) {
          this.nextNodes.push(parent.getChild(nextChildIdx));
          this.offsets.push((0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(currentOffset, currentNode.length));
          this.idxs[this.idxs.length - 1] = nextChildIdx;
          break;
        } else {
          this.idxs.pop();
        }
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$nodeReader.js.map
