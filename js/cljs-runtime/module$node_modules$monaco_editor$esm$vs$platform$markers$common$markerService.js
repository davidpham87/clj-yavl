shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$markers$common$markerService = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MarkerService:{enumerable:!0, get:function() {
    return MarkerService;
  }}, unsupportedSchemas:{enumerable:!0, get:function() {
    return unsupportedSchemas;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$map");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$network");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$uri"), require$_DOT__SLASH_markers_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$markers$common$markers");
  const unsupportedSchemas = new Set([module.Schemas.inMemory, module.Schemas.vscodeSourceControl, module.Schemas.walkThrough, module.Schemas.walkThroughSnippet]);
  class DoubleResourceMap {
    constructor() {
      this._byResource = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js.ResourceMap();
      this._byOwner = new Map();
    }
    set(resource, owner, value) {
      var ownerMap = this._byResource.get(resource);
      ownerMap || (ownerMap = new Map(), this._byResource.set(resource, ownerMap));
      ownerMap.set(owner, value);
      ownerMap = this._byOwner.get(owner);
      ownerMap || (ownerMap = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js.ResourceMap(), this._byOwner.set(owner, ownerMap));
      ownerMap.set(resource, value);
    }
    get(resource, owner) {
      resource = this._byResource.get(resource);
      return resource === null || resource === void 0 ? void 0 : resource.get(owner);
    }
    delete(resource, owner) {
      let removedA = !1, removedB = !1;
      const ownerMap = this._byResource.get(resource);
      ownerMap && (removedA = ownerMap.delete(owner));
      (owner = this._byOwner.get(owner)) && (removedB = owner.delete(resource));
      if (removedA !== removedB) {
        throw Error("illegal state");
      }
      return removedA && removedB;
    }
    values(key) {
      var _a, _b, _c, _d;
      return typeof key === "string" ? (_b = (_a = this._byOwner.get(key)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.empty() : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(key) ? (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? 
      _d : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.empty() : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.map(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.concat(...this._byOwner.values()), map => map[1]);
    }
  }
  class MarkerStats {
    constructor(service) {
      this.unknowns = this.warnings = this.infos = this.errors = 0;
      this._data = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js.ResourceMap();
      this._service = service;
      this._subscription = service.onMarkerChanged(this._update, this);
    }
    dispose() {
      this._subscription.dispose();
    }
    _update(resources) {
      for (const resource of resources) {
        (resources = this._data.get(resource)) && this._substract(resources), resources = this._resourceStats(resource), this._add(resources), this._data.set(resource, resources);
      }
    }
    _resourceStats(resource) {
      const result = {errors:0, warnings:0, infos:0, unknowns:0};
      if (unsupportedSchemas.has(resource.scheme)) {
        return result;
      }
      for (const {severity} of this._service.read({resource})) {
        severity === require$_DOT__SLASH_markers_DOT_js.MarkerSeverity.Error ? result.errors += 1 : severity === require$_DOT__SLASH_markers_DOT_js.MarkerSeverity.Warning ? result.warnings += 1 : severity === require$_DOT__SLASH_markers_DOT_js.MarkerSeverity.Info ? result.infos += 1 : result.unknowns += 1;
      }
      return result;
    }
    _substract(op) {
      this.errors -= op.errors;
      this.warnings -= op.warnings;
      this.infos -= op.infos;
      this.unknowns -= op.unknowns;
    }
    _add(op) {
      this.errors += op.errors;
      this.warnings += op.warnings;
      this.infos += op.infos;
      this.unknowns += op.unknowns;
    }
  }
  class MarkerService {
    constructor() {
      this._onMarkerChanged = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.DebounceEmitter({delay:0, merge:MarkerService._merge});
      this.onMarkerChanged = this._onMarkerChanged.event;
      this._data = new DoubleResourceMap();
      this._stats = new MarkerStats(this);
    }
    dispose() {
      this._stats.dispose();
      this._onMarkerChanged.dispose();
    }
    remove(owner, resources) {
      for (const resource of resources || []) {
        this.changeOne(owner, resource, []);
      }
    }
    changeOne(owner, resource, markerData) {
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.isFalsyOrEmpty)(markerData)) {
        this._data.delete(resource, owner) && this._onMarkerChanged.fire([resource]);
      } else {
        const markers = [];
        for (const data of markerData) {
          (markerData = MarkerService._toMarker(owner, resource, data)) && markers.push(markerData);
        }
        this._data.set(resource, owner, markers);
        this._onMarkerChanged.fire([resource]);
      }
    }
    static _toMarker(owner, resource, data) {
      let {code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags} = data;
      if (message) {
        return startLineNumber = startLineNumber > 0 ? startLineNumber : 1, startColumn = startColumn > 0 ? startColumn : 1, {resource, owner, code, severity, message, source, startLineNumber, startColumn, endLineNumber:endLineNumber >= startLineNumber ? endLineNumber : startLineNumber, endColumn:endColumn > 0 ? endColumn : startColumn, relatedInformation, tags};
      }
    }
    changeAll(owner, data$jscomp$0) {
      const changes = [];
      var existing = this._data.values(owner);
      if (existing) {
        for (var data of existing) {
          if (existing = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.first(data)) {
            changes.push(existing.resource), this._data.delete(existing.resource, owner);
          }
        }
      }
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.isNonEmptyArray)(data$jscomp$0)) {
        data = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js.ResourceMap();
        for (const {resource, marker:markerData} of data$jscomp$0) {
          if (data$jscomp$0 = MarkerService._toMarker(owner, resource, markerData)) {
            (existing = data.get(resource)) ? existing.push(data$jscomp$0) : (data.set(resource, [data$jscomp$0]), changes.push(resource));
          }
        }
        for (const [resource, value] of data) {
          this._data.set(resource, owner, value);
        }
      }
      changes.length > 0 && this._onMarkerChanged.fire(changes);
    }
    read(filter = Object.create(null)) {
      let {owner, resource, severities, take} = filter;
      if (!take || take < 0) {
        take = -1;
      }
      if (owner && resource) {
        var data = this._data.get(resource, owner);
        if (data) {
          var result = [];
          for (var marker of data) {
            if (MarkerService._accept(marker, severities) && (data = result.push(marker), take > 0 && data === take)) {
              break;
            }
          }
          return result;
        }
        return [];
      }
      if (owner || resource) {
        var iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);
        marker = [];
        for (result of iterable) {
          for (data of result) {
            if (MarkerService._accept(data, severities) && (iterable = marker.push(data), take > 0 && iterable === take)) {
              return marker;
            }
          }
        }
        return marker;
      }
      marker = [];
      for (iterable of this._data.values()) {
        for (const data of iterable) {
          if (MarkerService._accept(data, severities) && (result = marker.push(data), take > 0 && result === take)) {
            return marker;
          }
        }
      }
      return marker;
    }
    static _accept(marker, severities) {
      return severities === void 0 || (severities & marker.severity) === marker.severity;
    }
    static _merge(all) {
      const set = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js.ResourceMap();
      for (const array of all) {
        for (const item of array) {
          set.set(item, !0);
        }
      }
      return Array.from(set.keys());
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$markers$common$markerService.js.map
