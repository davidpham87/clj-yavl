shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousTokensEditing = function(require, module, exports) {
  function toUint32Array(arr) {
    return arr instanceof Uint32Array ? arr : new Uint32Array(arr);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ContiguousTokensEditing:{enumerable:!0, get:function() {
    return ContiguousTokensEditing;
  }}, EMPTY_LINE_TOKENS:{enumerable:!0, get:function() {
    return EMPTY_LINE_TOKENS;
  }}, toUint32Array:{enumerable:!0, get:function() {
    return toUint32Array;
  }}});
  var require$_DOT__SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens");
  const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;
  class ContiguousTokensEditing {
    static deleteBeginning(lineTokens, toChIndex) {
      return lineTokens === null || lineTokens === EMPTY_LINE_TOKENS ? lineTokens : ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);
    }
    static deleteEnding(lineTokens, fromChIndex) {
      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
        return lineTokens;
      }
      const tokens = toUint32Array(lineTokens);
      return ContiguousTokensEditing.delete(lineTokens, fromChIndex, tokens[tokens.length - 2]);
    }
    static delete(lineTokens, fromChIndex, toChIndex) {
      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
        return lineTokens;
      }
      const tokens = toUint32Array(lineTokens), tokensCount = tokens.length >>> 1;
      if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
        return EMPTY_LINE_TOKENS;
      }
      var fromTokenIndex = require$_DOT__SLASH_lineTokens_DOT_js.LineTokens.findIndexInTokensArray(tokens, fromChIndex), fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;
      if (toChIndex < tokens[fromTokenIndex << 1]) {
        for (var delta = toChIndex - fromChIndex; fromTokenIndex < tokensCount; fromTokenIndex++) {
          tokens[fromTokenIndex << 1] -= delta;
        }
        return lineTokens;
      }
      fromTokenStartOffset !== fromChIndex ? (tokens[fromTokenIndex << 1] = fromChIndex, delta = fromTokenIndex + 1 << 1, fromTokenStartOffset = fromChIndex) : delta = fromTokenIndex << 1;
      fromChIndex = toChIndex - fromChIndex;
      for (fromTokenIndex += 1; fromTokenIndex < tokensCount; fromTokenIndex++) {
        toChIndex = tokens[fromTokenIndex << 1] - fromChIndex, toChIndex > fromTokenStartOffset && (tokens[delta++] = toChIndex, tokens[delta++] = tokens[(fromTokenIndex << 1) + 1], fromTokenStartOffset = toChIndex);
      }
      if (delta === tokens.length) {
        return lineTokens;
      }
      lineTokens = new Uint32Array(delta);
      lineTokens.set(tokens.subarray(0, delta), 0);
      return lineTokens.buffer;
    }
    static append(lineTokens, _otherTokens) {
      if (_otherTokens === EMPTY_LINE_TOKENS) {
        return lineTokens;
      }
      if (lineTokens === EMPTY_LINE_TOKENS) {
        return _otherTokens;
      }
      if (lineTokens === null) {
        return lineTokens;
      }
      if (_otherTokens === null) {
        return null;
      }
      var myTokens = toUint32Array(lineTokens);
      _otherTokens = toUint32Array(_otherTokens);
      lineTokens = _otherTokens.length >>> 1;
      const result = new Uint32Array(myTokens.length + _otherTokens.length);
      result.set(myTokens, 0);
      let dest = myTokens.length;
      myTokens = myTokens[myTokens.length - 2];
      for (let i = 0; i < lineTokens; i++) {
        result[dest++] = _otherTokens[i << 1] + myTokens, result[dest++] = _otherTokens[(i << 1) + 1];
      }
      return result.buffer;
    }
    static insert(lineTokens, chIndex, textLength) {
      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
        return lineTokens;
      }
      const tokens = toUint32Array(lineTokens), tokensCount = tokens.length >>> 1;
      let fromTokenIndex = require$_DOT__SLASH_lineTokens_DOT_js.LineTokens.findIndexInTokensArray(tokens, chIndex);
      fromTokenIndex > 0 && tokens[fromTokenIndex - 1 << 1] === chIndex && fromTokenIndex--;
      for (chIndex = fromTokenIndex; chIndex < tokensCount; chIndex++) {
        tokens[chIndex << 1] += textLength;
      }
      return lineTokens;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousTokensEditing.js.map
