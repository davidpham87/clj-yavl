shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$utils = function(require, module, exports) {
  function constObservable(value) {
    return new ConstObservable(value);
  }
  function waitForState(observable, predicate) {
    return new Promise(resolve => {
      let didRun = !1, shouldDispose = !1;
      const stateObs = observable.map(state => ({isFinished:predicate(state), state})), d = (0,require$_DOT__SLASH_autorun_DOT_js.autorun)(reader => {
        const {isFinished, state} = stateObs.read(reader);
        isFinished && (didRun ? d.dispose() : shouldDispose = !0, resolve(state));
      });
      didRun = !0;
      shouldDispose && d.dispose();
    });
  }
  function observableFromEvent(event, getValue) {
    return new FromEventObservable(event, getValue);
  }
  function observableSignalFromEvent(debugName, event) {
    return new FromEventObservableSignal(debugName, event);
  }
  function observableSignal(debugNameOrOwner) {
    return typeof debugNameOrOwner === "string" ? new ObservableSignal(debugNameOrOwner) : new ObservableSignal(void 0, debugNameOrOwner);
  }
  function recomputeInitiallyAndOnChange(observable, handleValue) {
    const o = new KeepAliveObserver(!0, handleValue);
    observable.addObserver(o);
    handleValue ? handleValue(observable.get()) : observable.reportChanges();
    return (0,require$_DOT__DOT__SLASH_lifecycle_DOT_js.toDisposable)(() => {
      observable.removeObserver(o);
    });
  }
  function derivedObservableWithCache(computeFn) {
    let lastValue = void 0;
    return (0,require$_DOT__SLASH_derived_DOT_js.derived)(reader => lastValue = computeFn(reader, lastValue));
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, FromEventObservable:{enumerable:!0, get:function() {
    return FromEventObservable;
  }}, constObservable:{enumerable:!0, get:function() {
    return constObservable;
  }}, derivedObservableWithCache:{enumerable:!0, get:function() {
    return derivedObservableWithCache;
  }}, observableFromEvent:{enumerable:!0, get:function() {
    return observableFromEvent;
  }}, observableSignal:{enumerable:!0, get:function() {
    return observableSignal;
  }}, observableSignalFromEvent:{enumerable:!0, get:function() {
    return observableSignalFromEvent;
  }}, recomputeInitiallyAndOnChange:{enumerable:!0, get:function() {
    return recomputeInitiallyAndOnChange;
  }}, waitForState:{enumerable:!0, get:function() {
    return waitForState;
  }}});
  var require$_DOT__DOT__SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__SLASH_autorun_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$autorun"), require$_DOT__SLASH_base_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$base"), require$_DOT__SLASH_derived_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$derived"), 
  require$_DOT__SLASH_logging_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$logging");
  class ConstObservable extends require$_DOT__SLASH_base_DOT_js.ConvenientObservable {
    constructor(value) {
      super();
      this.value = value;
    }
    get debugName() {
      return this.toString();
    }
    get() {
      return this.value;
    }
    addObserver(observer) {
    }
    removeObserver(observer) {
    }
    toString() {
      return `Const: ${this.value}`;
    }
  }
  class FromEventObservable extends require$_DOT__SLASH_base_DOT_js.BaseObservable {
    constructor(event, _getValue) {
      super();
      this.event = event;
      this._getValue = _getValue;
      this.hasValue = !1;
      this.handleEvent = args => {
        var _a;
        const newValue = this._getValue(args), oldValue = this.value, didChange = !this.hasValue || oldValue !== newValue;
        args = !1;
        didChange && (this.value = newValue, this.hasValue && (args = !0, (0,require$_DOT__SLASH_base_DOT_js.subtransaction)(FromEventObservable.globalTransaction, tx => {
          var _a;
          (_a = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _a === void 0 || _a.handleFromEventObservableTriggered(this, {oldValue, newValue, change:void 0, didChange, hadValue:this.hasValue});
          for (const o of this.observers) {
            tx.updateObserver(o, this), o.handleChange(this, void 0);
          }
        }, () => {
          const name = this.getDebugName();
          return "Event fired" + (name ? `: ${name}` : "");
        })), this.hasValue = !0);
        args || (_a = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _a === void 0 || _a.handleFromEventObservableTriggered(this, {oldValue, newValue, change:void 0, didChange, hadValue:this.hasValue});
      };
    }
    getDebugName() {
      return (0,require$_DOT__SLASH_base_DOT_js.getFunctionName)(this._getValue);
    }
    get debugName() {
      const name = this.getDebugName();
      return "From Event" + (name ? `: ${name}` : "");
    }
    onFirstObserverAdded() {
      this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
      this.subscription.dispose();
      this.subscription = void 0;
      this.hasValue = !1;
      this.value = void 0;
    }
    get() {
      return this.subscription ? (this.hasValue || this.handleEvent(void 0), this.value) : this._getValue(void 0);
    }
  }
  (function(observableFromEvent) {
    observableFromEvent.Observer = FromEventObservable;
    observableFromEvent.batchEventsGlobally = function(tx, fn) {
      let didSet = !1;
      FromEventObservable.globalTransaction === void 0 && (FromEventObservable.globalTransaction = tx, didSet = !0);
      try {
        fn();
      } finally {
        didSet && (FromEventObservable.globalTransaction = void 0);
      }
    };
  })(observableFromEvent ||= {});
  class FromEventObservableSignal extends require$_DOT__SLASH_base_DOT_js.BaseObservable {
    constructor(debugName, event) {
      super();
      this.debugName = debugName;
      this.event = event;
      this.handleEvent = () => {
        (0,require$_DOT__SLASH_base_DOT_js.transaction)(tx => {
          for (const o of this.observers) {
            tx.updateObserver(o, this), o.handleChange(this, void 0);
          }
        }, () => this.debugName);
      };
    }
    onFirstObserverAdded() {
      this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
      this.subscription.dispose();
      this.subscription = void 0;
    }
    get() {
    }
  }
  class ObservableSignal extends require$_DOT__SLASH_base_DOT_js.BaseObservable {
    get debugName() {
      var _a;
      return (_a = (0,require$_DOT__SLASH_base_DOT_js.getDebugName)(this, this._debugName, void 0, this._owner, this)) !== null && _a !== void 0 ? _a : "Observable Signal";
    }
    constructor(_debugName, _owner) {
      super();
      this._debugName = _debugName;
      this._owner = _owner;
    }
    trigger(tx, change) {
      if (tx) {
        for (const o of this.observers) {
          tx.updateObserver(o, this), o.handleChange(this, change);
        }
      } else {
        (0,require$_DOT__SLASH_base_DOT_js.transaction)(tx => {
          this.trigger(tx, change);
        }, () => `Trigger signal ${this.debugName}`);
      }
    }
    get() {
    }
  }
  (0,require$_DOT__SLASH_base_DOT_js._setRecomputeInitiallyAndOnChange)(recomputeInitiallyAndOnChange);
  class KeepAliveObserver {
    constructor(_forceRecompute, _handleValue) {
      this._forceRecompute = _forceRecompute;
      this._handleValue = _handleValue;
      this._counter = 0;
    }
    beginUpdate(observable) {
      this._counter++;
    }
    endUpdate(observable) {
      this._counter--;
      this._counter === 0 && this._forceRecompute && (this._handleValue ? this._handleValue(observable.get()) : observable.reportChanges());
    }
    handlePossibleChange(observable) {
    }
    handleChange(observable, change) {
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$utils.js.map
