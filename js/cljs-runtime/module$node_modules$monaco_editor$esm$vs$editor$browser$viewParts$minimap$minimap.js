shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimap = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Minimap:{enumerable:!0, get:function() {
    return Minimap;
  }}});
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimap_css");
  var dom = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_globalPointerMoveMonitor_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$globalPointerMoveMonitor");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewLayer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewLayer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$config$editorOptions"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_rgba_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$rgba"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_SLASH_minimapTokensColorTracker_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$minimapTokensColorTracker"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$colorRegistry"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_touch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$touch"), require$_DOT__SLASH_minimapCharRendererFactory_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimapCharRendererFactory"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_model_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_functional_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$functional");
  class MinimapOptions {
    constructor(configuration, theme, tokensColorTracker) {
      configuration = configuration.options;
      const pixelRatio = configuration.get(141), layoutInfo = configuration.get(143), minimapLayout = layoutInfo.minimap, fontInfo = configuration.get(50), minimapOpts = configuration.get(72);
      this.renderMinimap = minimapLayout.renderMinimap;
      this.size = minimapOpts.size;
      this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;
      this.scrollBeyondLastLine = configuration.get(104);
      this.paddingTop = configuration.get(83).top;
      this.paddingBottom = configuration.get(83).bottom;
      this.showSlider = minimapOpts.showSlider;
      this.autohide = minimapOpts.autohide;
      this.pixelRatio = pixelRatio;
      this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
      this.lineHeight = configuration.get(66);
      this.minimapLeft = minimapLayout.minimapLeft;
      this.minimapWidth = minimapLayout.minimapWidth;
      this.minimapHeight = layoutInfo.height;
      this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;
      this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;
      this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;
      this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;
      this.isSampling = minimapLayout.minimapIsSampling;
      this.editorHeight = layoutInfo.height;
      this.fontScale = minimapLayout.minimapScale;
      this.minimapLineHeight = minimapLayout.minimapLineHeight;
      this.minimapCharWidth = 1 * this.fontScale;
      this.charRenderer = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_functional_DOT_js.createSingleCallFunction)(() => require$_DOT__SLASH_minimapCharRendererFactory_DOT_js.MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));
      this.defaultBackgroundColor = tokensColorTracker.getColor(2);
      this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);
      this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);
    }
    static _getMinimapBackground(theme, defaultBackgroundColor) {
      return (theme = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js.minimapBackground)) ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_rgba_DOT_js.RGBA8(theme.rgba.r, theme.rgba.g, theme.rgba.b, Math.round(255 * theme.rgba.a)) : defaultBackgroundColor;
    }
    static _getMinimapForegroundOpacity(theme) {
      return (theme = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js.minimapForegroundOpacity)) ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_rgba_DOT_js.RGBA8._clamp(Math.round(255 * theme.rgba.a)) : 255;
    }
    equals(other) {
      return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.paddingTop === other.paddingTop && this.paddingBottom === other.paddingBottom && this.showSlider === other.showSlider && this.autohide === other.autohide && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && 
      this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && 
      this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor) && this.foregroundAlpha === other.foregroundAlpha;
    }
  }
  class MinimapLayout {
    constructor(scrollTop, scrollHeight, sliderNeeded, _computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber) {
      this.scrollTop = scrollTop;
      this.scrollHeight = scrollHeight;
      this.sliderNeeded = sliderNeeded;
      this._computedSliderRatio = _computedSliderRatio;
      this.sliderTop = sliderTop;
      this.sliderHeight = sliderHeight;
      this.topPaddingLineCount = topPaddingLineCount;
      this.startLineNumber = startLineNumber;
      this.endLineNumber = endLineNumber;
    }
    getDesiredScrollTopFromDelta(delta) {
      return Math.round(this.scrollTop + delta / this._computedSliderRatio);
    }
    getDesiredScrollTopFromTouchLocation(pageY) {
      return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);
    }
    intersectWithViewport(range) {
      const startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);
      range = Math.min(this.endLineNumber, range.endLineNumber);
      return startLineNumber > range ? null : [startLineNumber, range];
    }
    getYForLineNumber(lineNumber, minimapLineHeight) {
      return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;
    }
    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {
      var pixelRatio = options.pixelRatio, minimapLineHeight = options.minimapLineHeight;
      const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight), lineHeight = options.lineHeight;
      if (options.minimapHeightIsEditorHeight) {
        return viewportStartLineNumber = realLineCount * options.lineHeight + options.paddingTop + options.paddingBottom, options.scrollBeyondLastLine && (viewportStartLineNumber += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom)), viewportStartLineNumber = Math.max(1, Math.floor(viewportHeight * viewportHeight / viewportStartLineNumber)), pixelRatio = Math.max(0, options.minimapHeight - viewportStartLineNumber), minimapLineHeight = pixelRatio / (scrollHeight - viewportHeight), 
        new MinimapLayout(scrollTop, scrollHeight, pixelRatio > 0, minimapLineHeight, scrollTop * minimapLineHeight, viewportStartLineNumber, Math.floor(options.paddingTop / options.lineHeight), 1, Math.min(lineCount, Math.floor(options.canvasInnerHeight / options.minimapLineHeight)));
      }
      viewportEndLineNumber = viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount ? Math.floor((viewportEndLineNumber - viewportStartLineNumber + 1) * minimapLineHeight / pixelRatio) : Math.floor(viewportHeight / lineHeight * minimapLineHeight / pixelRatio);
      viewportContainsWhitespaceGaps = Math.floor(options.paddingTop / lineHeight);
      realLineCount = Math.floor(options.paddingBottom / lineHeight);
      options.scrollBeyondLastLine && (realLineCount = Math.max(realLineCount, viewportHeight / lineHeight - 1));
      var maxMinimapSliderTop = realLineCount > 0 ? (viewportContainsWhitespaceGaps + lineCount + realLineCount - viewportHeight / lineHeight - 1) * minimapLineHeight / pixelRatio : Math.max(0, (viewportContainsWhitespaceGaps + lineCount) * minimapLineHeight / pixelRatio - viewportEndLineNumber);
      maxMinimapSliderTop = Math.min(options.minimapHeight - viewportEndLineNumber, maxMinimapSliderTop);
      viewportHeight = maxMinimapSliderTop / (scrollHeight - viewportHeight);
      const sliderTop = scrollTop * viewportHeight;
      if (minimapLinesFitting >= viewportContainsWhitespaceGaps + lineCount + realLineCount) {
        return new MinimapLayout(scrollTop, scrollHeight, maxMinimapSliderTop > 0, viewportHeight, sliderTop, viewportEndLineNumber, viewportContainsWhitespaceGaps, 1, lineCount);
      }
      maxMinimapSliderTop = Math.max(1, Math.floor((viewportStartLineNumber > 1 ? viewportStartLineNumber + viewportContainsWhitespaceGaps : Math.max(1, scrollTop / lineHeight)) - sliderTop * pixelRatio / minimapLineHeight));
      maxMinimapSliderTop < viewportContainsWhitespaceGaps ? (realLineCount = viewportContainsWhitespaceGaps - maxMinimapSliderTop + 1, maxMinimapSliderTop = 1) : (realLineCount = 0, maxMinimapSliderTop = Math.max(1, maxMinimapSliderTop - viewportContainsWhitespaceGaps));
      previousLayout && previousLayout.scrollHeight === scrollHeight && (previousLayout.scrollTop > scrollTop && (maxMinimapSliderTop = Math.min(maxMinimapSliderTop, previousLayout.startLineNumber), realLineCount = Math.max(realLineCount, previousLayout.topPaddingLineCount)), previousLayout.scrollTop < scrollTop && (maxMinimapSliderTop = Math.max(maxMinimapSliderTop, previousLayout.startLineNumber), realLineCount = Math.min(realLineCount, previousLayout.topPaddingLineCount)));
      viewportStartLineNumberVerticalOffset = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;
      return new MinimapLayout(scrollTop, scrollHeight, !0, viewportHeight, scrollTop >= options.paddingTop ? (viewportStartLineNumber - maxMinimapSliderTop + realLineCount + viewportStartLineNumberVerticalOffset) * minimapLineHeight / pixelRatio : scrollTop / options.paddingTop * (realLineCount + viewportStartLineNumberVerticalOffset) * minimapLineHeight / pixelRatio, viewportEndLineNumber, realLineCount, maxMinimapSliderTop, Math.min(lineCount, maxMinimapSliderTop - realLineCount + minimapLinesFitting - 
      1));
    }
  }
  class MinimapLine {
    constructor(dy) {
      this.dy = dy;
    }
    onContentChanged() {
      this.dy = -1;
    }
    onTokensChanged() {
      this.dy = -1;
    }
  }
  MinimapLine.INVALID = new MinimapLine(-1);
  class RenderData {
    constructor(renderedLayout, imageData, lines) {
      this.renderedLayout = renderedLayout;
      this._imageData = imageData;
      this._renderedLines = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewLayer_DOT_js.RenderedLinesCollection(() => MinimapLine.INVALID);
      this._renderedLines._set(renderedLayout.startLineNumber, lines);
    }
    linesEquals(layout) {
      if (!this.scrollEquals(layout)) {
        return !1;
      }
      layout = this._renderedLines._get().lines;
      for (let i = 0, len = layout.length; i < len; i++) {
        if (layout[i].dy === -1) {
          return !1;
        }
      }
      return !0;
    }
    scrollEquals(layout) {
      return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;
    }
    _get() {
      const tmp = this._renderedLines._get();
      return {imageData:this._imageData, rendLineNumberStart:tmp.rendLineNumberStart, lines:tmp.lines};
    }
    onLinesChanged(changeFromLineNumber, changeCount) {
      return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);
    }
    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
      this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);
    }
    onLinesInserted(insertFromLineNumber, insertToLineNumber) {
      this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);
    }
    onTokensChanged(ranges) {
      return this._renderedLines.onTokensChanged(ranges);
    }
  }
  class MinimapBuffers {
    constructor(ctx, WIDTH, HEIGHT, background) {
      this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);
      this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];
      this._lastUsedBuffer = 0;
    }
    getBuffer() {
      this._lastUsedBuffer = 1 - this._lastUsedBuffer;
      const result = this._buffers[this._lastUsedBuffer];
      result.data.set(this._backgroundFillData);
      return result;
    }
    static _createBackgroundFillData(WIDTH, HEIGHT, background) {
      const backgroundR = background.r, backgroundG = background.g, backgroundB = background.b;
      background = background.a;
      const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);
      let offset = 0;
      for (let i = 0; i < HEIGHT; i++) {
        for (let j = 0; j < WIDTH; j++) {
          result[offset] = backgroundR, result[offset + 1] = backgroundG, result[offset + 2] = backgroundB, result[offset + 3] = background, offset += 4;
        }
      }
      return result;
    }
  }
  class MinimapSamplingState {
    static compute(options, viewLineCount, oldSamplingState) {
      if (options.renderMinimap === 0 || !options.isSampling) {
        return [null, []];
      }
      const {minimapLineCount} = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.EditorLayoutInfoComputer.computeContainedMinimapLineCount({viewLineCount, scrollBeyondLastLine:options.scrollBeyondLastLine, paddingTop:options.paddingTop, paddingBottom:options.paddingBottom, height:options.editorHeight, lineHeight:options.lineHeight, pixelRatio:options.pixelRatio});
      options = viewLineCount / minimapLineCount;
      const halfRatio = options / 2;
      if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {
        oldSamplingState = [1];
        if (minimapLineCount > 1) {
          for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {
            oldSamplingState[i] = Math.round(i * options + halfRatio);
          }
          oldSamplingState[minimapLineCount - 1] = viewLineCount;
        }
        return [new MinimapSamplingState(options, oldSamplingState), []];
      }
      const oldMinimapLines = oldSamplingState.minimapLines;
      oldSamplingState = oldMinimapLines.length;
      const result = [];
      let oldIndex = 0, oldDeltaLineCount = 0;
      var minViewLineNumber = 1;
      let events = [], lastEvent = null;
      for (let i = 0; i < minimapLineCount; i++) {
        minViewLineNumber = Math.max(minViewLineNumber, Math.round(i * options));
        for (var toViewLineNumber = Math.max(minViewLineNumber, Math.round((i + 1) * options)); oldIndex < oldSamplingState && oldMinimapLines[oldIndex] < minViewLineNumber;) {
          if (events.length < 10) {
            const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;
            lastEvent && lastEvent.type === "deleted" && lastEvent._oldIndex === oldIndex - 1 ? lastEvent.deleteToLineNumber++ : (lastEvent = {type:"deleted", _oldIndex:oldIndex, deleteFromLineNumber:oldMinimapLineNumber, deleteToLineNumber:oldMinimapLineNumber}, events.push(lastEvent));
            oldDeltaLineCount--;
          }
          oldIndex++;
        }
        oldIndex < oldSamplingState && oldMinimapLines[oldIndex] <= toViewLineNumber ? (minViewLineNumber = oldMinimapLines[oldIndex], oldIndex++) : (minViewLineNumber = i === 0 ? 1 : i + 1 === minimapLineCount ? viewLineCount : Math.round(i * options + halfRatio), events.length < 10 && (toViewLineNumber = oldIndex + 1 + oldDeltaLineCount, lastEvent && lastEvent.type === "inserted" && lastEvent._i === i - 1 ? lastEvent.insertToLineNumber++ : (lastEvent = {type:"inserted", _i:i, insertFromLineNumber:toViewLineNumber, 
        insertToLineNumber:toViewLineNumber}, events.push(lastEvent)), oldDeltaLineCount++));
        result[i] = minViewLineNumber;
      }
      if (events.length < 10) {
        for (; oldIndex < oldSamplingState;) {
          viewLineCount = oldIndex + 1 + oldDeltaLineCount, lastEvent && lastEvent.type === "deleted" && lastEvent._oldIndex === oldIndex - 1 ? lastEvent.deleteToLineNumber++ : (lastEvent = {type:"deleted", _oldIndex:oldIndex, deleteFromLineNumber:viewLineCount, deleteToLineNumber:viewLineCount}, events.push(lastEvent)), oldDeltaLineCount--, oldIndex++;
        }
      } else {
        events = [{type:"flush"}];
      }
      return [new MinimapSamplingState(options, result), events];
    }
    constructor(samplingRatio, minimapLines) {
      this.samplingRatio = samplingRatio;
      this.minimapLines = minimapLines;
    }
    modelLineToMinimapLine(lineNumber) {
      return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));
    }
    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {
      let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;
      for (; fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber;) {
        fromLineIndex--;
      }
      let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;
      for (; toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber;) {
        toLineIndex++;
      }
      if (fromLineIndex === toLineIndex) {
        const sampledLineNumber = this.minimapLines[fromLineIndex];
        if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {
          return null;
        }
      }
      return [fromLineIndex + 1, toLineIndex + 1];
    }
    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {
      let minimapLineStart = this.modelLineToMinimapLine(startLineNumber), minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);
      startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart && (minimapLineEnd === this.minimapLines.length ? minimapLineStart > 1 && minimapLineStart-- : minimapLineEnd++);
      return [minimapLineStart, minimapLineEnd];
    }
    onLinesDeleted(e) {
      const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;
      let changeStartIndex = this.minimapLines.length, changeEndIndex = 0;
      for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--) {
        this.minimapLines[i] <= e.toLineNumber ? (this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1), changeStartIndex = Math.min(changeStartIndex, i), changeEndIndex = Math.max(changeEndIndex, i)) : this.minimapLines[i] -= deletedLineCount;
      }
      return [changeStartIndex, changeEndIndex];
    }
    onLinesInserted(e) {
      const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;
      for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--) {
        this.minimapLines[i] += insertedLineCount;
      }
    }
  }
  class Minimap extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.ViewPart {
    constructor(context) {
      super(context);
      this.tokensColorTracker = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_SLASH_minimapTokensColorTracker_DOT_js.MinimapTokensColorTracker.getInstance();
      this._selections = [];
      this._minimapSelections = null;
      this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);
      const [samplingState] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);
      this._samplingState = samplingState;
      this._shouldCheckSampling = !1;
      this._actual = new InnerMinimap(context.theme, this);
    }
    dispose() {
      this._actual.dispose();
      super.dispose();
    }
    getDomNode() {
      return this._actual.getDomNode();
    }
    _onOptionsMaybeChanged() {
      const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);
      if (this.options.equals(opts)) {
        return !1;
      }
      this.options = opts;
      this._recreateLineSampling();
      this._actual.onDidChangeOptions();
      return !0;
    }
    onConfigurationChanged(e) {
      return this._onOptionsMaybeChanged();
    }
    onCursorStateChanged(e) {
      this._selections = e.selections;
      this._minimapSelections = null;
      return this._actual.onSelectionChanged();
    }
    onDecorationsChanged(e) {
      return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
    }
    onFlushed(e) {
      this._samplingState && (this._shouldCheckSampling = !0);
      return this._actual.onFlushed();
    }
    onLinesChanged(e) {
      return this._samplingState ? (e = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1)) ? this._actual.onLinesChanged(e[0], e[1] - e[0] + 1) : !1 : this._actual.onLinesChanged(e.fromLineNumber, e.count);
    }
    onLinesDeleted(e) {
      if (this._samplingState) {
        const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);
        if (changeStartIndex <= changeEndIndex) {
          this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);
        }
        return this._shouldCheckSampling = !0;
      }
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    }
    onLinesInserted(e) {
      return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    }
    onScrollChanged(e) {
      return this._actual.onScrollChanged();
    }
    onThemeChanged(e) {
      this._actual.onThemeChanged();
      this._onOptionsMaybeChanged();
      return !0;
    }
    onTokensChanged(e) {
      if (this._samplingState) {
        const ranges = [];
        for (const range of e.ranges) {
          (e = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber)) && ranges.push({fromLineNumber:e[0], toLineNumber:e[1]});
        }
        return ranges.length ? this._actual.onTokensChanged(ranges) : !1;
      }
      return this._actual.onTokensChanged(e.ranges);
    }
    onTokensColorsChanged(e) {
      this._onOptionsMaybeChanged();
      return this._actual.onTokensColorsChanged();
    }
    onZonesChanged(e) {
      return this._actual.onZonesChanged();
    }
    prepareRender(ctx) {
      this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
    }
    render(ctx) {
      let viewportStartLineNumber = ctx.visibleRange.startLineNumber, viewportEndLineNumber = ctx.visibleRange.endLineNumber;
      this._samplingState && (viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber), viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber));
      ctx = {viewportContainsWhitespaceGaps:ctx.viewportData.whitespaceViewportData.length > 0, scrollWidth:ctx.scrollWidth, scrollHeight:ctx.scrollHeight, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset:ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber), scrollTop:ctx.scrollTop, scrollLeft:ctx.scrollLeft, viewportWidth:ctx.viewportWidth, viewportHeight:ctx.viewportHeight};
      this._actual.render(ctx);
    }
    _recreateLineSampling() {
      this._minimapSelections = null;
      const wasSampling = !!this._samplingState, [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
      this._samplingState = samplingState;
      if (wasSampling && this._samplingState) {
        for (const event of events) {
          switch(event.type) {
            case "deleted":
              this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);
              break;
            case "inserted":
              this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);
              break;
            case "flush":
              this._actual.onFlushed();
          }
        }
      }
    }
    getLineCount() {
      return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
    }
    getRealLineCount() {
      return this._context.viewModel.getLineCount();
    }
    getLineContent(lineNumber) {
      return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]) : this._context.viewModel.getLineContent(lineNumber);
    }
    getLineMaxColumn(lineNumber) {
      return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]) : this._context.viewModel.getLineMaxColumn(lineNumber);
    }
    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {
      if (this._samplingState) {
        const result = [];
        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {
          result[lineIndex] = needed[lineIndex] ? this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]) : null;
        }
        return result;
      }
      return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;
    }
    getSelections() {
      if (this._minimapSelections === null) {
        if (this._samplingState) {
          this._minimapSelections = [];
          for (const selection of this._selections) {
            const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);
            this._minimapSelections.push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));
          }
        } else {
          this._minimapSelections = this._selections;
        }
      }
      return this._minimapSelections;
    }
    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {
      this._samplingState ? (endLineNumber = this._samplingState.minimapLines[endLineNumber - 1], startLineNumber = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(this._samplingState.minimapLines[startLineNumber - 1], 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber))) : startLineNumber = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, 1, endLineNumber, 
      this._context.viewModel.getLineMaxColumn(endLineNumber));
      endLineNumber = this._context.viewModel.getMinimapDecorationsInRange(startLineNumber);
      if (this._samplingState) {
        startLineNumber = [];
        for (const decoration of endLineNumber) {
          if (!decoration.options.minimap) {
            continue;
          }
          endLineNumber = decoration.range;
          const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(endLineNumber.startLineNumber), minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(endLineNumber.endLineNumber);
          startLineNumber.push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewModelDecoration(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(minimapStartLineNumber, endLineNumber.startColumn, minimapEndLineNumber, endLineNumber.endColumn), decoration.options));
        }
        return startLineNumber;
      }
      return endLineNumber;
    }
    getOptions() {
      return this._context.viewModel.model.getOptions();
    }
    revealLineNumber(lineNumber) {
      this._samplingState && (lineNumber = this._samplingState.minimapLines[lineNumber - 1]);
      this._context.viewModel.revealRange("mouse", !1, new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(lineNumber, 1, lineNumber, 1), 1, 0);
    }
    setScrollTop(scrollTop) {
      this._context.viewModel.viewLayout.setScrollPosition({scrollTop}, 1);
    }
  }
  class InnerMinimap extends module.Disposable {
    constructor(theme, model) {
      super();
      this._gestureInProgress = this._renderDecorations = !1;
      this._theme = theme;
      this._model = model;
      this._buffers = this._lastRenderData = null;
      this._selectionColor = this._theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js.minimapSelection);
      this._domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.write(this._domNode, 8);
      this._domNode.setClassName(this._getMinimapDomNodeClassName());
      this._domNode.setPosition("absolute");
      this._domNode.setAttribute("role", "presentation");
      this._domNode.setAttribute("aria-hidden", "true");
      this._shadow = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      this._shadow.setClassName("minimap-shadow-hidden");
      this._domNode.appendChild(this._shadow);
      this._canvas = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("canvas"));
      this._canvas.setPosition("absolute");
      this._canvas.setLeft(0);
      this._domNode.appendChild(this._canvas);
      this._decorationsCanvas = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("canvas"));
      this._decorationsCanvas.setPosition("absolute");
      this._decorationsCanvas.setClassName("minimap-decorations-layer");
      this._decorationsCanvas.setLeft(0);
      this._domNode.appendChild(this._decorationsCanvas);
      this._slider = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      this._slider.setPosition("absolute");
      this._slider.setClassName("minimap-slider");
      this._slider.setLayerHinting(!0);
      this._slider.setContain("strict");
      this._domNode.appendChild(this._slider);
      this._sliderHorizontal = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      this._sliderHorizontal.setPosition("absolute");
      this._sliderHorizontal.setClassName("minimap-slider-horizontal");
      this._slider.appendChild(this._sliderHorizontal);
      this._applyLayout();
      this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, e => {
        e.preventDefault();
        if (this._model.options.renderMinimap !== 0 && this._lastRenderData) {
          if (this._model.options.size !== "proportional") {
            if (e.button === 0 && this._lastRenderData) {
              const position = dom.getDomNodePagePosition(this._slider.domNode);
              this._startSliderDragging(e, position.top + position.height / 2, this._lastRenderData.renderedLayout);
            }
          } else {
            e = Math.floor(this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.offsetY / this._model.options.minimapLineHeight) + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount, e = Math.min(e, this._model.getLineCount()), this._model.revealLineNumber(e);
          }
        }
      });
      this._sliderPointerMoveMonitor = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_globalPointerMoveMonitor_DOT_js.GlobalPointerMoveMonitor();
      this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, e => {
        e.preventDefault();
        e.stopPropagation();
        e.button === 0 && this._lastRenderData && this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);
      });
      this._gestureDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_touch_DOT_js.Gesture.addTarget(this._domNode.domNode);
      this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_touch_DOT_js.EventType.Start, e => {
        e.preventDefault();
        e.stopPropagation();
        this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(e));
      }, {passive:!1});
      this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_touch_DOT_js.EventType.Change, e => {
        e.preventDefault();
        e.stopPropagation();
        this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(e);
      }, {passive:!1});
      this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_touch_DOT_js.EventType.End, e => {
        e.preventDefault();
        e.stopPropagation();
        this._gestureInProgress = !1;
        this._slider.toggleClassName("active", !1);
      });
    }
    _startSliderDragging(e, initialPosY, initialSliderState) {
      if (e.target && e.target instanceof Element) {
        var initialPosX = e.pageX;
        this._slider.toggleClassName("active", !0);
        var handlePointerMove = (posy, posx) => {
          const minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);
          posx = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));
          platform.isWindows && posx > 140 ? this._model.setScrollTop(initialSliderState.scrollTop) : this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(posy - initialPosY));
        };
        e.pageY !== initialPosY && handlePointerMove(e.pageY, initialPosX);
        this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {
          this._slider.toggleClassName("active", !1);
        });
      }
    }
    scrollDueToTouchEvent(touch) {
      const startY = this._domNode.domNode.getBoundingClientRect().top;
      touch = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);
      this._model.setScrollTop(touch);
    }
    dispose() {
      this._pointerDownListener.dispose();
      this._sliderPointerMoveMonitor.dispose();
      this._sliderPointerDownListener.dispose();
      this._gestureDisposable.dispose();
      this._sliderTouchStartListener.dispose();
      this._sliderTouchMoveListener.dispose();
      this._sliderTouchEndListener.dispose();
      super.dispose();
    }
    _getMinimapDomNodeClassName() {
      const class_ = ["minimap"];
      this._model.options.showSlider === "always" ? class_.push("slider-always") : class_.push("slider-mouseover");
      this._model.options.autohide && class_.push("autohide");
      return class_.join(" ");
    }
    getDomNode() {
      return this._domNode;
    }
    _applyLayout() {
      this._domNode.setLeft(this._model.options.minimapLeft);
      this._domNode.setWidth(this._model.options.minimapWidth);
      this._domNode.setHeight(this._model.options.minimapHeight);
      this._shadow.setHeight(this._model.options.minimapHeight);
      this._canvas.setWidth(this._model.options.canvasOuterWidth);
      this._canvas.setHeight(this._model.options.canvasOuterHeight);
      this._canvas.domNode.width = this._model.options.canvasInnerWidth;
      this._canvas.domNode.height = this._model.options.canvasInnerHeight;
      this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);
      this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);
      this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;
      this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;
      this._slider.setWidth(this._model.options.minimapWidth);
    }
    _getBuffer() {
      !this._buffers && this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new MinimapBuffers(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor));
      return this._buffers ? this._buffers.getBuffer() : null;
    }
    onDidChangeOptions() {
      this._buffers = this._lastRenderData = null;
      this._applyLayout();
      this._domNode.setClassName(this._getMinimapDomNodeClassName());
    }
    onSelectionChanged() {
      return this._renderDecorations = !0;
    }
    onDecorationsChanged() {
      return this._renderDecorations = !0;
    }
    onFlushed() {
      this._lastRenderData = null;
      return !0;
    }
    onLinesChanged(changeFromLineNumber, changeCount) {
      return this._lastRenderData ? this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount) : !1;
    }
    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
      var _a;
      (_a = this._lastRenderData) === null || _a === void 0 || _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);
      return !0;
    }
    onLinesInserted(insertFromLineNumber, insertToLineNumber) {
      var _a;
      (_a = this._lastRenderData) === null || _a === void 0 || _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);
      return !0;
    }
    onScrollChanged() {
      return this._renderDecorations = !0;
    }
    onThemeChanged() {
      this._selectionColor = this._theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js.minimapSelection);
      return this._renderDecorations = !0;
    }
    onTokensChanged(ranges) {
      return this._lastRenderData ? this._lastRenderData.onTokensChanged(ranges) : !1;
    }
    onTokensColorsChanged() {
      this._buffers = this._lastRenderData = null;
      return !0;
    }
    onZonesChanged() {
      this._lastRenderData = null;
      return !0;
    }
    render(renderingCtx) {
      this._model.options.renderMinimap === 0 ? (this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0)) : (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible"), renderingCtx = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, 
      renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null), this._slider.setDisplay(renderingCtx.sliderNeeded ? "block" : "none"), this._slider.setTop(renderingCtx.sliderTop), this._slider.setHeight(renderingCtx.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), 
      this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(renderingCtx.sliderHeight), this.renderDecorations(renderingCtx), this._lastRenderData = this.renderLines(renderingCtx));
    }
    renderDecorations(layout) {
      if (this._renderDecorations) {
        this._renderDecorations = !1;
        const selections = this._model.getSelections();
        selections.sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
        const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);
        decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));
        const {canvasInnerWidth, canvasInnerHeight} = this._model.options, minimapLineHeight = this._model.options.minimapLineHeight, minimapCharWidth = this._model.options.minimapCharWidth, tabSize = this._model.getOptions().tabSize, canvasContext = this._decorationsCanvas.domNode.getContext("2d");
        canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);
        var highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, !1);
        this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);
        this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);
        highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);
        this._renderSelectionsHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);
        this._renderDecorationsHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);
      }
    }
    _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {
      if (this._selectionColor && !this._selectionColor.isTransparent()) {
        canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();
        var y1 = 0, y2 = 0;
        for (const selection of selections) {
          selections = layout.intersectWithViewport(selection);
          if (!selections) {
            continue;
          }
          const [startLineNumber, endLineNumber] = selections;
          for (selections = startLineNumber; selections <= endLineNumber; selections++) {
            highlightedLines.set(selections, !0);
          }
          selections = layout.getYForLineNumber(startLineNumber, minimapLineHeight);
          const yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);
          y2 >= selections || (y2 > y1 && canvasContext.fillRect(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1), y1 = selections);
          y2 = yy2;
        }
        y2 > y1 && canvasContext.fillRect(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);
      }
    }
    _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {
      const highlightColors = new Map();
      for (let i = decorations.length - 1; i >= 0; i--) {
        var decoration = decorations[i], minimapOptions = decoration.options.minimap;
        if (!minimapOptions || minimapOptions.position !== require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_model_DOT_js.MinimapPosition.Inline) {
          continue;
        }
        decoration = layout.intersectWithViewport(decoration.range);
        if (!decoration) {
          continue;
        }
        const [startLineNumber, endLineNumber] = decoration;
        if ((minimapOptions = minimapOptions.getColor(this._theme.value)) && !minimapOptions.isTransparent()) {
          for (decoration = highlightColors.get(minimapOptions.toString()), decoration || (decoration = minimapOptions.transparent(0.5).toString(), highlightColors.set(minimapOptions.toString(), decoration)), canvasContext.fillStyle = decoration, minimapOptions = startLineNumber; minimapOptions <= endLineNumber; minimapOptions++) {
            highlightedLines.has(minimapOptions) || (highlightedLines.set(minimapOptions, !0), decoration = layout.getYForLineNumber(startLineNumber, minimapLineHeight), canvasContext.fillRect(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH, decoration, canvasContext.canvas.width, minimapLineHeight));
          }
        }
      }
    }
    _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {
      if (this._selectionColor && !this._selectionColor.isTransparent()) {
        for (const selection of selections) {
          selections = layout.intersectWithViewport(selection);
          if (!selections) {
            continue;
          }
          const [startLineNumber, endLineNumber] = selections;
          for (selections = startLineNumber; selections <= endLineNumber; selections++) {
            this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, selections, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);
          }
        }
      }
    }
    _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {
      for (const decoration of decorations) {
        decorations = decoration.options.minimap;
        if (!decorations) {
          continue;
        }
        var intersection = layout.intersectWithViewport(decoration.range);
        if (!intersection) {
          continue;
        }
        const [startLineNumber, endLineNumber] = intersection;
        if ((intersection = decorations.getColor(this._theme.value)) && !intersection.isTransparent()) {
          for (let line = startLineNumber; line <= endLineNumber; line++) {
            switch(decorations.position) {
              case require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_model_DOT_js.MinimapPosition.Inline:
                this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, intersection, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);
                continue;
              case require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_model_DOT_js.MinimapPosition.Gutter:
                const y = layout.getYForLineNumber(line, minimapLineHeight);
                this.renderDecoration(canvasContext, intersection, 2, y, 2, minimapLineHeight);
            }
          }
        }
      }
    }
    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {
      layout = layout.getYForLineNumber(lineNumber, minimapLineHeight);
      if (!(layout + height < 0 || layout > this._model.options.canvasInnerHeight)) {
        var {startLineNumber, endLineNumber} = decorationRange;
        minimapLineHeight = startLineNumber === lineNumber ? decorationRange.startColumn : 1;
        decorationRange = endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber);
        minimapLineHeight = this.getXOffsetForPosition(lineOffsetMap, lineNumber, minimapLineHeight, tabSize, charWidth, canvasInnerWidth);
        lineOffsetMap = this.getXOffsetForPosition(lineOffsetMap, lineNumber, decorationRange, tabSize, charWidth, canvasInnerWidth);
        this.renderDecoration(canvasContext, decorationColor, minimapLineHeight, layout, lineOffsetMap - minimapLineHeight, height);
      }
    }
    getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {
      if (column === 1) {
        return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH;
      }
      if ((column - 1) * charWidth >= canvasInnerWidth) {
        return canvasInnerWidth;
      }
      let lineIndexToXOffset = lineOffsetMap.get(lineNumber);
      if (!lineIndexToXOffset) {
        const lineData = this._model.getLineContent(lineNumber);
        lineIndexToXOffset = [require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH];
        var prevx = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH;
        for (let i = 1; i < lineData.length + 1; i++) {
          var charCode = lineData.charCodeAt(i - 1);
          charCode = charCode === 9 ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;
          prevx += charCode;
          if (prevx >= canvasInnerWidth) {
            lineIndexToXOffset[i] = canvasInnerWidth;
            break;
          }
          lineIndexToXOffset[i] = prevx;
        }
        lineOffsetMap.set(lineNumber, lineIndexToXOffset);
      }
      return column - 1 < lineIndexToXOffset.length ? lineIndexToXOffset[column - 1] : canvasInnerWidth;
    }
    renderDecoration(canvasContext, decorationColor, x, y, width, height) {
      canvasContext.fillStyle = decorationColor && decorationColor.toString() || "";
      canvasContext.fillRect(x, y, width, height);
    }
    renderLines(layout) {
      var startLineNumber = layout.startLineNumber, endLineNumber = layout.endLineNumber;
      const minimapLineHeight = this._model.options.minimapLineHeight;
      if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {
        var _lastData = this._lastRenderData._get();
        return new RenderData(layout, _lastData.imageData, _lastData.lines);
      }
      _lastData = this._getBuffer();
      if (!_lastData) {
        return null;
      }
      const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(_lastData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData), lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed), tabSize = this._model.getOptions().tabSize;
      var defaultBackground = this._model.options.defaultBackgroundColor;
      const background = this._model.options.backgroundColor, foregroundAlpha = this._model.options.foregroundAlpha, tokensColorTracker = this._model.tokensColorTracker, useLighterFont = tokensColorTracker.backgroundIsLight(), renderMinimap = this._model.options.renderMinimap, charRenderer = this._model.options.charRenderer(), fontScale = this._model.options.fontScale, minimapCharWidth = this._model.options.minimapCharWidth;
      var renderMinimapLineHeight = (renderMinimap === 1 ? 2 : 3) * fontScale;
      renderMinimapLineHeight = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;
      var backgroundA = background.a / 255;
      backgroundA = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_rgba_DOT_js.RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);
      let dy = layout.topPaddingLineCount * minimapLineHeight;
      defaultBackground = [];
      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {
        needed[lineIndex] && InnerMinimap._renderLine(_lastData, backgroundA, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, renderMinimapLineHeight, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight), defaultBackground[lineIndex] = new MinimapLine(dy), dy += minimapLineHeight;
      }
      startLineNumber = _dirtyY1 === -1 ? 0 : _dirtyY1;
      endLineNumber = (_dirtyY2 === -1 ? _lastData.height : _dirtyY2) - startLineNumber;
      this._canvas.domNode.getContext("2d").putImageData(_lastData, 0, 0, 0, startLineNumber, _lastData.width, endLineNumber);
      return new RenderData(layout, _lastData, defaultBackground);
    }
    static _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {
      const needed = [];
      if (!lastRenderData) {
        for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {
          needed[i] = !0;
        }
        return [-1, -1, needed];
      }
      var _lastData = lastRenderData._get();
      lastRenderData = _lastData.imageData.data;
      const lastStartLineNumber = _lastData.rendLineNumberStart;
      _lastData = _lastData.lines;
      const lastLinesLength = _lastData.length, WIDTH = target.width;
      target = target.data;
      const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;
      let dirtyPixel1 = -1, dirtyPixel2 = -1, copySourceStart = -1, copySourceEnd = -1, copyDestStart = -1, copyDestEnd = -1;
      topPaddingLineCount *= minimapLineHeight;
      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        const lineIndex = lineNumber - startLineNumber;
        var lastLineIndex = lineNumber - lastStartLineNumber, source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? _lastData[lastLineIndex].dy : -1;
        if (source_dy === -1) {
          needed[lineIndex] = !0;
          topPaddingLineCount += minimapLineHeight;
          continue;
        }
        lastLineIndex = source_dy * WIDTH * 4;
        source_dy = (source_dy + minimapLineHeight) * WIDTH * 4;
        const destStart = topPaddingLineCount * WIDTH * 4, destEnd = (topPaddingLineCount + minimapLineHeight) * WIDTH * 4;
        copySourceEnd === lastLineIndex && copyDestEnd === destStart ? copySourceEnd = source_dy : (copySourceStart !== -1 && (target.set(lastRenderData.subarray(copySourceStart, copySourceEnd), copyDestStart), dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart && (dirtyPixel1 = copySourceEnd), dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart && (dirtyPixel2 = copySourceStart)), copySourceStart = lastLineIndex, copySourceEnd = 
        source_dy, copyDestStart = destStart);
        copyDestEnd = destEnd;
        needed[lineIndex] = !1;
        topPaddingLineCount += minimapLineHeight;
      }
      copySourceStart !== -1 && (target.set(lastRenderData.subarray(copySourceStart, copySourceEnd), copyDestStart), dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart && (dirtyPixel1 = copySourceEnd), dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart && (dirtyPixel2 = copySourceStart));
      return [dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4), dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4), needed];
    }
    static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {
      const content = lineData.content;
      lineData = lineData.tokens;
      const maxDx = target.width - charWidth;
      minimapLineHeight = minimapLineHeight === 1;
      let dx = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.MINIMAP_GUTTER_WIDTH, charIndex = 0, tabsCharDelta = 0;
      for (let tokenIndex = 0, tokensLen = lineData.getCount(); tokenIndex < tokensLen; tokenIndex++) {
        const tokenEndIndex = lineData.getEndOffset(tokenIndex);
        var tokenColorId = lineData.getForeground(tokenIndex);
        for (tokenColorId = colorTracker.getColor(tokenColorId); charIndex < tokenEndIndex; charIndex++) {
          if (dx > maxDx) {
            return;
          }
          var charCode = content.charCodeAt(charIndex);
          if (charCode === 9) {
            charCode = tabSize - (charIndex + tabsCharDelta) % tabSize, tabsCharDelta += charCode - 1, dx += charCode * charWidth;
          } else if (charCode === 32) {
            dx += charWidth;
          } else {
            const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;
            for (let i = 0; i < count; i++) {
              if (renderMinimap === 2 ? minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColorId, foregroundAlpha, backgroundColor, backgroundAlpha, minimapLineHeight) : minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColorId, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, minimapLineHeight), dx += charWidth, dx > maxDx) {
                return;
              }
            }
          }
        }
      }
    }
  }
  class ContiguousLineMap {
    constructor(startLineNumber, endLineNumber, defaultValue) {
      this._startLineNumber = startLineNumber;
      this._endLineNumber = endLineNumber;
      this._defaultValue = defaultValue;
      this._values = [];
      for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {
        this._values[i] = defaultValue;
      }
    }
    has(lineNumber) {
      return this.get(lineNumber) !== this._defaultValue;
    }
    set(lineNumber, value) {
      lineNumber < this._startLineNumber || lineNumber > this._endLineNumber || (this._values[lineNumber - this._startLineNumber] = value);
    }
    get(lineNumber) {
      return lineNumber < this._startLineNumber || lineNumber > this._endLineNumber ? this._defaultValue : this._values[lineNumber - this._startLineNumber];
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimap.js.map
