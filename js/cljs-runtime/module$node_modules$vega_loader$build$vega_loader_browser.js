shadow$provide.module$node_modules$vega_loader$build$vega_loader_browser = function(require, module, exports) {
  var Buffer = require("module$node_modules$buffer$index").Buffer;
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega_util$build$vega_util"), require("module$node_modules$topojson_client$dist$topojson_client"), require("module$node_modules$vega_format$build$vega_format")) : typeof define === "function" && define.amd ? define(["exports", "vega-util", "topojson-client", "vega-format"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.vega = {}, global.vega, 
    global.topojson, global.vega));
  })(this, function(exports, vegaUtil, topojsonClient, vegaFormat) {
    async function load(uri, options) {
      uri = await this.sanitize(uri, options);
      const url = uri.href;
      return uri.localFile ? this.file(url) : this.http(url, options);
    }
    async function sanitize(uri, options) {
      options = vegaUtil.extend({}, this.options, options);
      const fileAccess = this.fileAccess, result = {href:null};
      var isFile;
      let loadFile;
      var isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
      uri != null && typeof uri === "string" && isAllowed || vegaUtil.error("Sanitize failure, invalid URI: " + vegaUtil.stringValue(uri));
      isAllowed = protocol_re.test(uri);
      (isFile = options.baseURL) && !isAllowed && (uri.startsWith("/") || isFile.endsWith("/") || (uri = "/" + uri), uri = isFile + uri);
      loadFile = (isFile = uri.startsWith("file://")) || options.mode === "file" || options.mode !== "http" && !isAllowed && fileAccess;
      isFile ? uri = uri.slice(7) : uri.startsWith("//") && (options.defaultProtocol === "file" ? (uri = uri.slice(2), loadFile = !0) : uri = (options.defaultProtocol || "http") + ":" + uri);
      Object.defineProperty(result, "localFile", {value:!!loadFile});
      result.href = uri;
      options.target && (result.target = options.target + "");
      options.rel && (result.rel = options.rel + "");
      options.context === "image" && options.crossOrigin && (result.crossOrigin = options.crossOrigin + "");
      return result;
    }
    async function fileReject() {
      vegaUtil.error("No file system access.");
    }
    function httpLoader(fetch) {
      return fetch ? async function(url, options) {
        const opt = vegaUtil.extend({}, this.options.http, options);
        options = options && options.response;
        url = await fetch(url, opt);
        return url.ok ? vegaUtil.isFunction(url[options]) ? url[options]() : url.text() : vegaUtil.error(url.status + "" + url.statusText);
      } : httpReject;
    }
    async function httpReject() {
      vegaUtil.error("No HTTP fetch method available.");
    }
    function inferType(values, field) {
      if (!values || !values.length) {
        return "unknown";
      }
      const n = values.length, m = typeTests.length, a = typeTests.map((_, i) => i + 1);
      for (let i = 0, t = 0, j, value; i < n; ++i) {
        for (value = field ? values[i][field] : values[i], j = 0; j < m; ++j) {
          if (a[j] && value != null && value === value && !typeTests[j](value) && (a[j] = 0, ++t, t === typeTests.length)) {
            return "string";
          }
        }
      }
      return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
    }
    function inferTypes(data, fields) {
      return fields.reduce((types, field) => {
        types[field] = inferType(data, field);
        return types;
      }, {});
    }
    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + '] || ""';
      }).join(",") + "}");
    }
    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }
    function inferColumns(rows) {
      var columnSet = Object.create(null), columns = [];
      rows.forEach(function(row) {
        for (var column in row) {
          column in columnSet || columns.push(columnSet[column] = column);
        }
      });
      return columns;
    }
    function pad(value, width) {
      value += "";
      var length = value.length;
      return length < width ? Array(width - length + 1).join(0) + value : value;
    }
    function dsvFormat(delimiter) {
      function parseRows(text, f) {
        function token() {
          if (eof) {
            return EOF;
          }
          if (eol) {
            return eol = !1, EOL;
          }
          var i, j = I, c;
          if (text.charCodeAt(j) === 34) {
            for (; I++ < N && text.charCodeAt(I) !== 34 || text.charCodeAt(++I) === 34;) {
            }
            (i = I) >= N ? eof = !0 : (c = text.charCodeAt(I++)) === 10 ? eol = !0 : c === 13 && (eol = !0, text.charCodeAt(I) === 10 && ++I);
            return text.slice(j + 1, i - 1).replace(/""/g, '"');
          }
          for (; I < N;) {
            if ((c = text.charCodeAt(i = I++)) === 10) {
              eol = !0;
            } else if (c === 13) {
              eol = !0, text.charCodeAt(I) === 10 && ++I;
            } else if (c !== DELIMITER) {
              continue;
            }
            return text.slice(j, i);
          }
          return eof = !0, text.slice(j, N);
        }
        var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = !1;
        text.charCodeAt(N - 1) === 10 && --N;
        for (text.charCodeAt(N - 1) === 13 && --N; (t = token()) !== EOF;) {
          for (var row = []; t !== EOL && t !== EOF;) {
            row.push(t), t = token();
          }
          f && (row = f(row, n++)) == null || rows.push(row);
        }
        return rows;
      }
      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }
      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }
      function formatValue(value) {
        if (value == null) {
          value = "";
        } else {
          if (value instanceof Date) {
            var JSCompiler_temp = value.getUTCHours();
            var minutes = value.getUTCMinutes(), seconds = value.getUTCSeconds(), milliseconds = value.getUTCMilliseconds();
            if (isNaN(value)) {
              value = "Invalid Date";
            } else {
              var year = value.getUTCFullYear();
              value = (year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4)) + "-" + pad(value.getUTCMonth() + 1, 2) + "-" + pad(value.getUTCDate(), 2) + (milliseconds ? "T" + pad(JSCompiler_temp, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(JSCompiler_temp, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || JSCompiler_temp ? "T" + pad(JSCompiler_temp, 2) + ":" + pad(minutes, 2) + "Z" : "");
            }
            JSCompiler_temp = value;
          } else {
            JSCompiler_temp = reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
          }
          value = JSCompiler_temp;
        }
        return value;
      }
      var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
      return {parse:function(text, f) {
        var convert, columns;
        text = parseRows(text, function(row, i) {
          if (convert) {
            return convert(row, i - 1);
          }
          columns = row;
          convert = f ? customConverter(row, f) : objectConverter(row);
        });
        text.columns = columns || [];
        return text;
      }, parseRows, format:function(rows, columns) {
        columns == null && (columns = inferColumns(rows));
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }, formatBody:function(rows, columns) {
        columns == null && (columns = inferColumns(rows));
        return preformatBody(rows, columns).join("\n");
      }, formatRows:function(rows) {
        return rows.map(formatRow).join("\n");
      }, formatRow, formatValue};
    }
    function delimitedFormat(delimiter) {
      const parse = function(data, format) {
        const delim = {delimiter};
        return dsv(data, format ? vegaUtil.extend(format, delim) : delim);
      };
      parse.responseType = "text";
      return parse;
    }
    function dsv(data, format) {
      format.header && (data = format.header.map(vegaUtil.stringValue).join(format.delimiter) + "\n" + data);
      return dsvFormat(format.delimiter).parse(data + "");
    }
    function json(data, format) {
      const prop = format && format.property ? vegaUtil.field(format.property) : vegaUtil.identity;
      var JSCompiler_temp;
      if (JSCompiler_temp = vegaUtil.isObject(data)) {
        JSCompiler_temp = !(typeof Buffer === "function" && vegaUtil.isFunction(Buffer.isBuffer) && Buffer.isBuffer(data));
      }
      JSCompiler_temp ? (data = prop(data), !vegaUtil.isArray(data) && vegaUtil.isIterable(data) && (data = [...data]), format = format && format.copy ? JSON.parse(JSON.stringify(data)) : data) : format = prop(JSON.parse(data));
      return format;
    }
    function topojson(data, format) {
      let method, object, property, filter;
      data = json(data, format);
      format && format.feature ? (method = topojsonClient.feature, property = format.feature) : format && format.mesh ? (method = topojsonClient.mesh, property = format.mesh, filter = filters[format.filter]) : vegaUtil.error("Missing TopoJSON feature or mesh parameter.");
      return (object = (object = data.objects[property]) ? method(data, object, filter) : vegaUtil.error("Invalid TopoJSON object: " + property)) && object.features || [object];
    }
    function formats(name, reader) {
      return arguments.length > 1 ? (format[name] = reader, this) : vegaUtil.hasOwnProperty(format, name) ? format[name] : null;
    }
    function parse(data, types, timeParser, utcParser) {
      if (data.length) {
        var locale = vegaFormat.timeFormatDefaultLocale();
        timeParser = timeParser || locale.timeParse;
        utcParser = utcParser || locale.utcParse;
        locale = data.columns || Object.keys(data[0]);
        var j, m;
        types === "auto" && (types = inferTypes(data, locale));
        locale = Object.keys(types);
        var parsers = locale.map(field => {
          var type = types[field];
          if (type && (type.startsWith("date:") || type.startsWith("utc:"))) {
            field = type.split(/:(.+)?/, 2);
            type = field[1];
            if (type[0] === "'" && type[type.length - 1] === "'" || type[0] === '"' && type[type.length - 1] === '"') {
              type = type.slice(1, -1);
            }
            return (field[0] === "utc" ? utcParser : timeParser)(type);
          }
          if (!typeParsers[type]) {
            throw Error("Illegal format pattern: " + field + ":" + type);
          }
          return typeParsers[type];
        });
        var i = 0;
        var n = data.length;
        for (m = locale.length; i < n; ++i) {
          var datum = data[i];
          for (j = 0; j < m; ++j) {
            var field = locale[j];
            datum[field] = parsers[j](datum[field]);
          }
        }
      }
    }
    const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/, allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date), typeParsers = {boolean:vegaUtil.toBoolean, integer:vegaUtil.toNumber, number:vegaUtil.toNumber, date:vegaUtil.toDate, string:vegaUtil.toString, unknown:vegaUtil.identity}, typeTests = [_ => _ === "true" || 
    _ === "false" || _ === !0 || _ === !1, _ => isNumber(_) && Number.isInteger(+_), isNumber, _ => !Number.isNaN(Date.parse(_))], typeList = ["boolean", "integer", "number", "date"];
    var EOL = {}, EOF = {};
    dsv.responseType = "text";
    json.responseType = "json";
    const filters = {interior:(a, b) => a !== b, exterior:(a, b) => a === b};
    topojson.responseType = "json";
    const format = {dsv, csv:delimitedFormat(","), tsv:delimitedFormat("\t"), json, topojson}, loader = function(fetch, fs) {
      return options => ({options:options || {}, sanitize, load, fileAccess:!1, file:fileReject, http:httpLoader(fetch)});
    }(typeof fetch !== "undefined" && fetch);
    exports.format = format;
    exports.formats = formats;
    exports.inferType = inferType;
    exports.inferTypes = inferTypes;
    exports.loader = loader;
    exports.read = function(data, schema, timeParser, utcParser) {
      schema = schema || {};
      const reader = formats(schema.type || "json");
      reader || vegaUtil.error("Unknown data format type: " + schema.type);
      data = reader(data, schema);
      schema.parse && parse(data, schema.parse, timeParser, utcParser);
      vegaUtil.hasOwnProperty(data, "columns") && delete data.columns;
      return data;
    };
    exports.responseType = function(type) {
      return (type = formats(type)) && type.responseType || "text";
    };
    exports.typeParsers = typeParsers;
  });
};

//# sourceMappingURL=module$node_modules$vega_loader$build$vega_loader_browser.js.map
