shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$bracketPairsTree = function(require, module, exports) {
  function getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {
    if (node.kind === 4 || node.kind === 2) {
      const lengths = [];
      for (const child of node.children) {
        nodeOffsetEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, child.length), lengths.push({nodeOffsetStart, nodeOffsetEnd}), nodeOffsetStart = nodeOffsetEnd;
      }
      for (nodeOffsetStart = lengths.length - 1; nodeOffsetStart >= 0; nodeOffsetStart--) {
        const {nodeOffsetStart:nodeOffsetStart$jscomp$0, nodeOffsetEnd:nodeOffsetEnd$jscomp$0} = lengths[nodeOffsetStart];
        if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThan)(nodeOffsetStart$jscomp$0, position) && (nodeOffsetEnd = getFirstBracketBefore(node.children[nodeOffsetStart], nodeOffsetStart$jscomp$0, nodeOffsetEnd$jscomp$0, position))) {
          return nodeOffsetEnd;
        }
      }
    } else if (node.kind !== 3 && node.kind === 1) {
      return position = (0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd), {bracketInfo:node.bracketInfo, range:position};
    }
    return null;
  }
  function getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {
    if (node.kind === 4 || node.kind === 2) {
      for (const child of node.children) {
        nodeOffsetEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, child.length);
        if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThan)(position, nodeOffsetEnd) && (node = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position))) {
          return node;
        }
        nodeOffsetStart = nodeOffsetEnd;
      }
    } else if (node.kind !== 3 && node.kind === 1) {
      return nodeOffsetEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd), {bracketInfo:node.bracketInfo, range:nodeOffsetEnd};
    }
    return null;
  }
  function collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = !1) {
    if (level > 200) {
      return !0;
    }
    a: for (;;) {
      switch(node.kind) {
        case 4:
          var childCount = node.childrenLength;
          for (var i = 0; i < childCount; i++) {
            var child$jscomp$0 = node.getChild(i);
            if (child$jscomp$0) {
              nodeOffsetEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, child$jscomp$0.length);
              if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThanEqual)(nodeOffsetStart, endOffset) && (0,require$_DOT__SLASH_length_DOT_js.lengthGreaterThanEqual)(nodeOffsetEnd, startOffset)) {
                if ((0,require$_DOT__SLASH_length_DOT_js.lengthGreaterThanEqual)(nodeOffsetEnd, endOffset)) {
                  node = child$jscomp$0;
                  continue a;
                }
                if (!collectBrackets(child$jscomp$0, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets)) {
                  return !1;
                }
              }
              nodeOffsetStart = nodeOffsetEnd;
            }
          }
          return !0;
        case 2:
          nestingLevelOfEqualBracketType = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);
          childCount = 0;
          levelPerBracketType && (nodeOffsetEnd = levelPerBracketType.get(node.openingBracket.text), nodeOffsetEnd === void 0 && (nodeOffsetEnd = 0), childCount = nodeOffsetEnd, nestingLevelOfEqualBracketType && (nodeOffsetEnd++, levelPerBracketType.set(node.openingBracket.text, nodeOffsetEnd)));
          i = node.childrenLength;
          for (child$jscomp$0 = 0; child$jscomp$0 < i; child$jscomp$0++) {
            const child = node.getChild(child$jscomp$0);
            if (child) {
              nodeOffsetEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, child.length);
              if ((0,require$_DOT__SLASH_length_DOT_js.lengthLessThanEqual)(nodeOffsetStart, endOffset) && (0,require$_DOT__SLASH_length_DOT_js.lengthGreaterThanEqual)(nodeOffsetEnd, startOffset)) {
                if ((0,require$_DOT__SLASH_length_DOT_js.lengthGreaterThanEqual)(nodeOffsetEnd, endOffset) && child.kind !== 1) {
                  node = child;
                  nestingLevelOfEqualBracketType ? (level++, nestingLevelOfEqualBracketType = childCount + 1) : nestingLevelOfEqualBracketType = childCount;
                  continue a;
                }
                if ((nestingLevelOfEqualBracketType || child.kind !== 1 || !node.closingBracket) && !collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, nestingLevelOfEqualBracketType ? level + 1 : level, nestingLevelOfEqualBracketType ? childCount + 1 : childCount, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket)) {
                  return !1;
                }
              }
              nodeOffsetStart = nodeOffsetEnd;
            }
          }
          levelPerBracketType === null || levelPerBracketType === void 0 || levelPerBracketType.set(node.openingBracket.text, childCount);
          return !0;
        case 3:
          return parentPairIsIncomplete = (0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd), push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_textModelBracketPairs_DOT_js.BracketInfo(parentPairIsIncomplete, level - 1, 0, !0));
        case 1:
          return node = (0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd), push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_textModelBracketPairs_DOT_js.BracketInfo(node, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));
        case 0:
          return !0;
      }
    }
  }
  function collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {
    var _a;
    if (level > 200) {
      return !0;
    }
    var shouldContinue = !0;
    if (node.kind === 2) {
      var levelPerBracket = 0;
      levelPerBracketType && (shouldContinue = levelPerBracketType.get(node.openingBracket.text), shouldContinue === void 0 && (shouldContinue = 0), levelPerBracket = shouldContinue, shouldContinue++, levelPerBracketType.set(node.openingBracket.text, shouldContinue));
      const openingBracketEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, node.openingBracket.length);
      let minIndentation = -1;
      context.includeMinIndentation && (minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel));
      shouldContinue = context.push(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_textModelBracketPairs_DOT_js.BracketPairWithMinIndentationInfo((0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)(nodeOffsetStart, nodeOffsetEnd), (0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)(nodeOffsetStart, openingBracketEnd), node.closingBracket ? (0,require$_DOT__SLASH_length_DOT_js.lengthsToRange)((0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(openingBracketEnd, ((_a = node.child) === 
      null || _a === void 0 ? void 0 : _a.length) || require$_DOT__SLASH_length_DOT_js.lengthZero), nodeOffsetEnd) : void 0, level, levelPerBracket, node, minIndentation));
      nodeOffsetStart = openingBracketEnd;
      if (shouldContinue && node.child && (_a = node.child, nodeOffsetEnd = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, _a.length), (0,require$_DOT__SLASH_length_DOT_js.lengthLessThanEqual)(nodeOffsetStart, endOffset) && (0,require$_DOT__SLASH_length_DOT_js.lengthGreaterThanEqual)(nodeOffsetEnd, startOffset) && (shouldContinue = collectBracketPairs(_a, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType), !shouldContinue))) {
        return !1;
      }
      levelPerBracketType === null || levelPerBracketType === void 0 || levelPerBracketType.set(node.openingBracket.text, levelPerBracket);
    } else {
      for (levelPerBracket of node.children) {
        if (node = nodeOffsetStart, nodeOffsetStart = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(nodeOffsetStart, levelPerBracket.length), (0,require$_DOT__SLASH_length_DOT_js.lengthLessThanEqual)(node, endOffset) && (0,require$_DOT__SLASH_length_DOT_js.lengthLessThanEqual)(startOffset, nodeOffsetStart) && (shouldContinue = collectBracketPairs(levelPerBracket, node, nodeOffsetStart, startOffset, endOffset, context, level, levelPerBracketType), !shouldContinue)) {
          return !1;
        }
      }
    }
    return shouldContinue;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BracketPairsTree:{enumerable:!0, get:function() {
    return BracketPairsTree;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_textModelBracketPairs_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelBracketPairs"), require$_DOT__SLASH_beforeEditPositionMapper_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$beforeEditPositionMapper"), require$_DOT__SLASH_brackets_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$brackets"), 
  require$_DOT__SLASH_length_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$length"), require$_DOT__SLASH_parser_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$parser"), require$_DOT__SLASH_smallImmutableSet_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$smallImmutableSet"), 
  require$_DOT__SLASH_tokenizer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$tokenizer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__SLASH_combineTextEditInfos_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$combineTextEditInfos");
  class BracketPairsTree extends module.Disposable {
    didLanguageChange(languageId) {
      return this.brackets.didLanguageChange(languageId);
    }
    constructor(textModel, getLanguageConfiguration) {
      super();
      this.textModel = textModel;
      this.getLanguageConfiguration = getLanguageConfiguration;
      this.didChangeEmitter = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter();
      this.denseKeyProvider = new require$_DOT__SLASH_smallImmutableSet_DOT_js.DenseKeyProvider();
      this.brackets = new require$_DOT__SLASH_brackets_DOT_js.LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);
      this.onDidChange = this.didChangeEmitter.event;
      this.queuedTextEditsForInitialAstWithoutTokens = [];
      this.queuedTextEdits = [];
      textModel.tokenization.hasTokens ? textModel.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : this.astWithTokens = this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0) : (textModel = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), textModel = new require$_DOT__SLASH_tokenizer_DOT_js.FastTokenizer(this.textModel.getValue(), 
      textModel), this.astWithTokens = this.initialAstWithoutTokens = (0,require$_DOT__SLASH_parser_DOT_js.parseDocument)(textModel, [], void 0, !0));
    }
    handleDidChangeBackgroundTokenizationState() {
      if (this.textModel.tokenization.backgroundTokenizationState === 2) {
        const wasUndefined = this.initialAstWithoutTokens === void 0;
        this.initialAstWithoutTokens = void 0;
        wasUndefined || this.didChangeEmitter.fire();
      }
    }
    handleDidChangeTokens({ranges}) {
      ranges = ranges.map(r => new require$_DOT__SLASH_beforeEditPositionMapper_DOT_js.TextEditInfo((0,require$_DOT__SLASH_length_DOT_js.toLength)(r.fromLineNumber - 1, 0), (0,require$_DOT__SLASH_length_DOT_js.toLength)(r.toLineNumber, 0), (0,require$_DOT__SLASH_length_DOT_js.toLength)(r.toLineNumber - r.fromLineNumber + 1, 0)));
      this.handleEdits(ranges, !0);
      this.initialAstWithoutTokens || this.didChangeEmitter.fire();
    }
    handleContentChanged(change) {
      change = require$_DOT__SLASH_beforeEditPositionMapper_DOT_js.TextEditInfo.fromModelContentChanges(change.changes);
      this.handleEdits(change, !1);
    }
    handleEdits(edits, tokenChange) {
      this.queuedTextEdits = (0,require$_DOT__SLASH_combineTextEditInfos_DOT_js.combineTextEditInfos)(this.queuedTextEdits, edits);
      this.initialAstWithoutTokens && !tokenChange && (this.queuedTextEditsForInitialAstWithoutTokens = (0,require$_DOT__SLASH_combineTextEditInfos_DOT_js.combineTextEditInfos)(this.queuedTextEditsForInitialAstWithoutTokens, edits));
    }
    flushQueue() {
      this.queuedTextEdits.length > 0 && (this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, !1), this.queuedTextEdits = []);
      this.queuedTextEditsForInitialAstWithoutTokens.length > 0 && (this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, !1)), this.queuedTextEditsForInitialAstWithoutTokens = []);
    }
    parseDocumentFromTextBuffer(edits, previousAst, immutable) {
      const tokenizer = new require$_DOT__SLASH_tokenizer_DOT_js.TextBufferTokenizer(this.textModel, this.brackets);
      return (0,require$_DOT__SLASH_parser_DOT_js.parseDocument)(tokenizer, edits, previousAst, immutable);
    }
    getBracketsInRange(range, onlyColorizedBrackets) {
      this.flushQueue();
      const startOffset = (0,require$_DOT__SLASH_length_DOT_js.toLength)(range.startLineNumber - 1, range.startColumn - 1), endOffset = (0,require$_DOT__SLASH_length_DOT_js.toLength)(range.endLineNumber - 1, range.endColumn - 1);
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.CallbackIterable(cb => {
        const node = this.initialAstWithoutTokens || this.astWithTokens;
        collectBrackets(node, require$_DOT__SLASH_length_DOT_js.lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);
      });
    }
    getBracketPairsInRange(range, includeMinIndentation) {
      this.flushQueue();
      const startLength = (0,require$_DOT__SLASH_length_DOT_js.positionToLength)(range.getStartPosition()), endLength = (0,require$_DOT__SLASH_length_DOT_js.positionToLength)(range.getEndPosition());
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.CallbackIterable(cb => {
        const node = this.initialAstWithoutTokens || this.astWithTokens;
        cb = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);
        collectBracketPairs(node, require$_DOT__SLASH_length_DOT_js.lengthZero, node.length, startLength, endLength, cb, 0, new Map());
      });
    }
    getFirstBracketAfter(position) {
      this.flushQueue();
      const node = this.initialAstWithoutTokens || this.astWithTokens;
      return getFirstBracketAfter(node, require$_DOT__SLASH_length_DOT_js.lengthZero, node.length, (0,require$_DOT__SLASH_length_DOT_js.positionToLength)(position));
    }
    getFirstBracketBefore(position) {
      this.flushQueue();
      const node = this.initialAstWithoutTokens || this.astWithTokens;
      return getFirstBracketBefore(node, require$_DOT__SLASH_length_DOT_js.lengthZero, node.length, (0,require$_DOT__SLASH_length_DOT_js.positionToLength)(position));
    }
  }
  class CollectBracketPairsContext {
    constructor(push, includeMinIndentation, textModel) {
      this.push = push;
      this.includeMinIndentation = includeMinIndentation;
      this.textModel = textModel;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$bracketPairsTree.js.map
