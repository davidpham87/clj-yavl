shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorMoveOperations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CursorPosition:{enumerable:!0, get:function() {
    return CursorPosition;
  }}, MoveOperations:{enumerable:!0, get:function() {
    return MoveOperations;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$cursorColumns"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__SLASH_cursorAtomicMoveOperations_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorAtomicMoveOperations"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon");
  class CursorPosition {
    constructor(lineNumber, column, leftoverVisibleColumns) {
      this._cursorPositionBrand = void 0;
      this.lineNumber = lineNumber;
      this.column = column;
      this.leftoverVisibleColumns = leftoverVisibleColumns;
    }
  }
  class MoveOperations {
    static leftPosition(model, position) {
      return position.column > model.getLineMinColumn(position.lineNumber) ? position.delta(void 0, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1)) : position.lineNumber > 1 ? (position = position.lineNumber - 1, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(position, model.getLineMaxColumn(position))) : position;
    }
    static leftPositionAtomicSoftTabs(model, position, tabSize) {
      if (position.column <= model.getLineIndentColumn(position.lineNumber)) {
        const minColumn = model.getLineMinColumn(position.lineNumber), lineContent = model.getLineContent(position.lineNumber);
        tabSize = require$_DOT__SLASH_cursorAtomicMoveOperations_DOT_js.AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0);
        if (tabSize !== -1 && tabSize + 1 >= minColumn) {
          return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(position.lineNumber, tabSize + 1);
        }
      }
      return this.leftPosition(model, position);
    }
    static left(config, model, position) {
      config = config.stickyTabStops ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize) : MoveOperations.leftPosition(model, position);
      return new CursorPosition(config.lineNumber, config.column, 0);
    }
    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {
      cursor.hasSelection() && !inSelectionMode ? (config = cursor.selection.startLineNumber, model = cursor.selection.startColumn) : (noOfColumns = cursor.position.delta(void 0, -(noOfColumns - 1)), noOfColumns = model.normalizePosition(MoveOperations.clipPositionColumn(noOfColumns, model), 0), model = MoveOperations.left(config, model, noOfColumns), config = model.lineNumber, model = model.column);
      return cursor.move(inSelectionMode, config, model, 0);
    }
    static clipPositionColumn(position, model) {
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));
    }
    static clipRange(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }
    static rightPosition(model, lineNumber, column) {
      column < model.getLineMaxColumn(lineNumber) ? column += strings.nextCharLength(model.getLineContent(lineNumber), column - 1) : lineNumber < model.getLineCount() && (lineNumber += 1, column = model.getLineMinColumn(lineNumber));
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, column);
    }
    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {
      return column < model.getLineIndentColumn(lineNumber) && (indentSize = model.getLineContent(lineNumber), tabSize = require$_DOT__SLASH_cursorAtomicMoveOperations_DOT_js.AtomicTabMoveOperations.atomicPosition(indentSize, column - 1, tabSize, 1), tabSize !== -1) ? new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, tabSize + 1) : this.rightPosition(model, lineNumber, column);
    }
    static right(config, model, position) {
      config = config.stickyTabStops ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize) : MoveOperations.rightPosition(model, position.lineNumber, position.column);
      return new CursorPosition(config.lineNumber, config.column, 0);
    }
    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {
      cursor.hasSelection() && !inSelectionMode ? (config = cursor.selection.endLineNumber, model = cursor.selection.endColumn) : (noOfColumns = cursor.position.delta(void 0, noOfColumns - 1), noOfColumns = model.normalizePosition(MoveOperations.clipPositionColumn(noOfColumns, model), 1), model = MoveOperations.right(config, model, noOfColumns), config = model.lineNumber, model = model.column);
      return cursor.move(inSelectionMode, config, model, 0);
    }
    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {
      leftoverVisibleColumns = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
      const lineCount = model.getLineCount();
      var wasOnFirstPosition = lineNumber === 1 && column === 1;
      const wasOnLastPosition = lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber);
      wasOnFirstPosition = newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition;
      lineNumber = newLineNumber;
      lineNumber < 1 ? (lineNumber = 1, column = allowMoveOnEdgeLine ? model.getLineMinColumn(lineNumber) : Math.min(model.getLineMaxColumn(lineNumber), column)) : lineNumber > lineCount ? (lineNumber = lineCount, column = allowMoveOnEdgeLine ? model.getLineMaxColumn(lineNumber) : Math.min(model.getLineMaxColumn(lineNumber), column)) : column = config.columnFromVisibleColumn(model, lineNumber, leftoverVisibleColumns);
      leftoverVisibleColumns = wasOnFirstPosition ? 0 : leftoverVisibleColumns - require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);
      normalizationAffinity !== void 0 && (lineNumber = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, column), model = model.normalizePosition(lineNumber, normalizationAffinity), leftoverVisibleColumns += column - model.column, lineNumber = model.lineNumber, column = model.column);
      return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
    }
    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
      return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4);
    }
    static moveDown(config, model, cursor, inSelectionMode, linesCount) {
      let lineNumber, column;
      cursor.hasSelection() && !inSelectionMode ? (lineNumber = cursor.selection.endLineNumber, column = cursor.selection.endColumn) : (lineNumber = cursor.position.lineNumber, column = cursor.position.column);
      let i = 0, r;
      do {
        if (r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, !0), model.normalizePosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(r.lineNumber, r.column), 2).lineNumber > lineNumber) {
          break;
        }
      } while (i++ < 10 && lineNumber + i < model.getLineCount());
      return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);
    }
    static translateDown(config, model, cursor) {
      const selection = cursor.selection, selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, !1);
      config = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, !1);
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0, selectionStart.leftoverVisibleColumns, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(config.lineNumber, config.column), config.leftoverVisibleColumns);
    }
    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
      return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3);
    }
    static moveUp(config, model, cursor, inSelectionMode, linesCount) {
      let lineNumber, column;
      cursor.hasSelection() && !inSelectionMode ? (lineNumber = cursor.selection.startLineNumber, column = cursor.selection.startColumn) : (lineNumber = cursor.position.lineNumber, column = cursor.position.column);
      config = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, !0);
      return cursor.move(inSelectionMode, config.lineNumber, config.column, config.leftoverVisibleColumns);
    }
    static translateUp(config, model, cursor) {
      const selection = cursor.selection, selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, !1);
      config = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, !1);
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0, selectionStart.leftoverVisibleColumns, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(config.lineNumber, config.column), config.leftoverVisibleColumns);
    }
    static _isBlankLine(model, lineNumber) {
      return model.getLineFirstNonWhitespaceColumn(lineNumber) === 0 ? !0 : !1;
    }
    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {
      for (config = cursor.position.lineNumber; config > 1 && this._isBlankLine(model, config);) {
        config--;
      }
      for (; config > 1 && !this._isBlankLine(model, config);) {
        config--;
      }
      return cursor.move(inSelectionMode, config, model.getLineMinColumn(config), 0);
    }
    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {
      config = model.getLineCount();
      let lineNumber = cursor.position.lineNumber;
      for (; lineNumber < config && this._isBlankLine(model, lineNumber);) {
        lineNumber++;
      }
      for (; lineNumber < config && !this._isBlankLine(model, lineNumber);) {
        lineNumber++;
      }
      return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);
    }
    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {
      config = cursor.position.lineNumber;
      const minColumn = model.getLineMinColumn(config);
      model = model.getLineFirstNonWhitespaceColumn(config) || minColumn;
      return cursor.move(inSelectionMode, config, cursor.position.column === model ? minColumn : model, 0);
    }
    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {
      config = cursor.position.lineNumber;
      model = model.getLineMaxColumn(config);
      return cursor.move(inSelectionMode, config, model, sticky ? 1073741824 - model : 0);
    }
    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {
      return cursor.move(inSelectionMode, 1, 1, 0);
    }
    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {
      config = model.getLineCount();
      model = model.getLineMaxColumn(config);
      return cursor.move(inSelectionMode, config, model, 0);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorMoveOperations.js.map
