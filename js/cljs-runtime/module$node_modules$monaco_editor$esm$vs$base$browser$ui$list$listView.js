shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listView = function(require, module, exports) {
  function equalsDragFeedback(f1, f2) {
    return Array.isArray(f1) && Array.isArray(f2) ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.equals)(f1, f2) : f1 === f2;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ElementsDragAndDropData:{enumerable:!0, get:function() {
    return ElementsDragAndDropData;
  }}, ExternalElementsDragAndDropData:{enumerable:!0, get:function() {
    return ExternalElementsDragAndDropData;
  }}, ListView:{enumerable:!0, get:function() {
    return ListView;
  }}, NativeDragAndDropData:{enumerable:!0, get:function() {
    return NativeDragAndDropData;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dnd_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dnd"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$touch"), 
  require$_DOT__DOT__SLASH_scrollbar_SLASH_scrollableElement_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$scrollbar$scrollableElement"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$decorators");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_scrollable_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$scrollable"), require$_DOT__SLASH_rangeMap_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$rangeMap"), require$_DOT__SLASH_rowCache_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$rowCache"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors");
  require = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var JSCompiler_object_inline_CurrentDragAndDropData_2337 = void 0;
  const DefaultOptions = {useShadows:!0, verticalScrollMode:1, setRowLineHeight:!0, setRowHeight:!0, supportDynamicHeights:!1, dnd:{getDragElements(e) {
    return [e];
  }, getDragURI() {
    return null;
  }, onDragStart() {
  }, onDragOver() {
    return !1;
  }, drop() {
  }, dispose() {
  }}, horizontalScrolling:!1, transformOptimization:!0, alwaysConsumeMouseWheel:!0};
  class ElementsDragAndDropData {
    constructor(elements) {
      this.elements = elements;
    }
    update() {
    }
    getData() {
      return this.elements;
    }
  }
  class ExternalElementsDragAndDropData {
    constructor(elements) {
      this.elements = elements;
    }
    update() {
    }
    getData() {
      return this.elements;
    }
  }
  class NativeDragAndDropData {
    constructor() {
      this.types = [];
      this.files = [];
    }
    update(dataTransfer) {
      dataTransfer.types && this.types.splice(0, this.types.length, ...dataTransfer.types);
      if (dataTransfer.files) {
        this.files.splice(0, this.files.length);
        for (let i = 0; i < dataTransfer.files.length; i++) {
          const file = dataTransfer.files.item(i);
          file && (file.size || file.type) && this.files.push(file);
        }
      }
    }
    getData() {
      return {types:this.types, files:this.files};
    }
  }
  class ListViewAccessibilityProvider {
    constructor(accessibilityProvider) {
      this.getSetSize = (accessibilityProvider === null || accessibilityProvider === void 0 ? 0 : accessibilityProvider.getSetSize) ? accessibilityProvider.getSetSize.bind(accessibilityProvider) : (e, i, l) => l;
      this.getPosInSet = (accessibilityProvider === null || accessibilityProvider === void 0 ? 0 : accessibilityProvider.getPosInSet) ? accessibilityProvider.getPosInSet.bind(accessibilityProvider) : (e, i) => i + 1;
      this.getRole = (accessibilityProvider === null || accessibilityProvider === void 0 ? 0 : accessibilityProvider.getRole) ? accessibilityProvider.getRole.bind(accessibilityProvider) : _ => "listitem";
      this.isChecked = (accessibilityProvider === null || accessibilityProvider === void 0 ? 0 : accessibilityProvider.isChecked) ? accessibilityProvider.isChecked.bind(accessibilityProvider) : _ => {
      };
    }
  }
  class ListView {
    get contentHeight() {
      return this.rangeMap.size;
    }
    get onDidScroll() {
      return this.scrollableElement.onScroll;
    }
    get scrollableElementDomNode() {
      return this.scrollableElement.getDomNode();
    }
    get horizontalScrolling() {
      return this._horizontalScrolling;
    }
    set horizontalScrolling(value) {
      if (value !== this._horizontalScrolling) {
        if (value && this.supportDynamicHeights) {
          throw Error("Horizontal scrolling and dynamic heights not supported simultaneously");
        }
        this._horizontalScrolling = value;
        this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling);
        if (this._horizontalScrolling) {
          for (const item of this.items) {
            this.measureItemWidth(item);
          }
          this.updateScrollWidth();
          this.scrollableElement.setScrollDimensions({width:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getContentWidth)(this.domNode)});
          this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
        } else {
          this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({width:this.renderWidth, scrollWidth:this.renderWidth}), this.rowsContainer.style.width = "";
        }
      }
    }
    constructor(container, virtualDelegate, renderers, options = DefaultOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      this.virtualDelegate = virtualDelegate;
      this.domId = `list_id_${++ListView.InstanceCount}`;
      this.renderers = new Map();
      this._scrollHeight = this.renderWidth = 0;
      this.scrollableElementUpdateDisposable = null;
      this.scrollableElementWidthDelayer = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.Delayer(50);
      this.splicing = !1;
      this.dragOverAnimationStopDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      this.dragOverMouseY = 0;
      this.canDrop = !1;
      this.onDragLeaveTimeout = this.currentDragFeedbackDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._onDidChangeContentHeight = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this._onDidChangeContentWidth = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeContentHeight = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.latch(this._onDidChangeContentHeight.event, void 0, this.disposables);
      this._horizontalScrolling = !1;
      if (options.horizontalScrolling && options.supportDynamicHeights) {
        throw Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      }
      this.items = [];
      this.itemId = 0;
      this.rangeMap = new require$_DOT__SLASH_rangeMap_DOT_js.RangeMap((_a = options.paddingTop) !== null && _a !== void 0 ? _a : 0);
      for (const renderer of renderers) {
        this.renderers.set(renderer.templateId, renderer);
      }
      this.cache = this.disposables.add(new require$_DOT__SLASH_rowCache_DOT_js.RowCache(this.renderers));
      this.lastRenderHeight = this.lastRenderTop = 0;
      this.domNode = document.createElement("div");
      this.domNode.className = "monaco-list";
      this.domNode.classList.add(this.domId);
      this.domNode.tabIndex = 0;
      this.domNode.classList.toggle("mouse-support", typeof options.mouseSupport === "boolean" ? options.mouseSupport : !0);
      this._horizontalScrolling = (_b = options.horizontalScrolling) !== null && _b !== void 0 ? _b : DefaultOptions.horizontalScrolling;
      this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling);
      this.paddingBottom = typeof options.paddingBottom === "undefined" ? 0 : options.paddingBottom;
      this.accessibilityProvider = new ListViewAccessibilityProvider(options.accessibilityProvider);
      this.rowsContainer = document.createElement("div");
      this.rowsContainer.className = "monaco-list-rows";
      if ((_c = options.transformOptimization) !== null && _c !== void 0 ? _c : DefaultOptions.transformOptimization) {
        this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)", this.rowsContainer.style.overflow = "hidden", this.rowsContainer.style.contain = "strict";
      }
      this.disposables.add(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js.Gesture.addTarget(this.rowsContainer));
      this.scrollable = this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_scrollable_DOT_js.Scrollable({forceIntegerValues:!0, smoothScrollDuration:(_d = options.smoothScrolling) !== null && _d !== void 0 && _d ? 125 : 0, scheduleAtNextAnimationFrame:cb => (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.scheduleAtNextAnimationFrame)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(this.domNode), cb)}));
      this.scrollableElement = this.disposables.add(new require$_DOT__DOT__SLASH_scrollbar_SLASH_scrollableElement_DOT_js.SmoothScrollableElement(this.rowsContainer, {alwaysConsumeMouseWheel:(_e = options.alwaysConsumeMouseWheel) !== null && _e !== void 0 ? _e : DefaultOptions.alwaysConsumeMouseWheel, horizontal:1, vertical:(_f = options.verticalScrollMode) !== null && _f !== void 0 ? _f : DefaultOptions.verticalScrollMode, useShadows:(_g = options.useShadows) !== null && _g !== void 0 ? _g : DefaultOptions.useShadows, 
      mouseWheelScrollSensitivity:options.mouseWheelScrollSensitivity, fastScrollSensitivity:options.fastScrollSensitivity, scrollByPage:options.scrollByPage}, this.scrollable));
      this.domNode.appendChild(this.scrollableElement.getDomNode());
      container.appendChild(this.domNode);
      this.scrollableElement.onScroll(this.onScroll, this, this.disposables);
      this.disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.rowsContainer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js.EventType.Change, e => this.onTouchChange(e)));
      this.disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.scrollableElement.getDomNode(), "scroll", e => e.target.scrollTop = 0));
      this.disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.domNode, "dragover", e => this.onDragOver(this.toDragEvent(e))));
      this.disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.domNode, "drop", e => this.onDrop(this.toDragEvent(e))));
      this.disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.domNode, "dragleave", e => this.onDragLeave(this.toDragEvent(e))));
      this.disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.domNode, "dragend", e => this.onDragEnd(e)));
      this.setRowLineHeight = (_h = options.setRowLineHeight) !== null && _h !== void 0 ? _h : DefaultOptions.setRowLineHeight;
      this.setRowHeight = (_j = options.setRowHeight) !== null && _j !== void 0 ? _j : DefaultOptions.setRowHeight;
      this.supportDynamicHeights = (_k = options.supportDynamicHeights) !== null && _k !== void 0 ? _k : DefaultOptions.supportDynamicHeights;
      this.dnd = (_l = options.dnd) !== null && _l !== void 0 ? _l : this.disposables.add(DefaultOptions.dnd);
      this.layout((_m = options.initialSize) === null || _m === void 0 ? void 0 : _m.height, (_o = options.initialSize) === null || _o === void 0 ? void 0 : _o.width);
    }
    updateOptions(options) {
      options.paddingBottom !== void 0 && (this.paddingBottom = options.paddingBottom, this.scrollableElement.setScrollDimensions({scrollHeight:this.scrollHeight}));
      options.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(options.smoothScrolling ? 125 : 0);
      options.horizontalScrolling !== void 0 && (this.horizontalScrolling = options.horizontalScrolling);
      var scrollableOptions;
      options.scrollByPage !== void 0 && (scrollableOptions = {...(scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {}), scrollByPage:options.scrollByPage});
      options.mouseWheelScrollSensitivity !== void 0 && (scrollableOptions = {...(scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {}), mouseWheelScrollSensitivity:options.mouseWheelScrollSensitivity});
      options.fastScrollSensitivity !== void 0 && (scrollableOptions = {...(scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {}), fastScrollSensitivity:options.fastScrollSensitivity});
      scrollableOptions && this.scrollableElement.updateOptions(scrollableOptions);
      if (options.paddingTop !== void 0 && options.paddingTop !== this.rangeMap.paddingTop) {
        scrollableOptions = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
        const offset = options.paddingTop - this.rangeMap.paddingTop;
        this.rangeMap.paddingTop = options.paddingTop;
        this.render(scrollableOptions, Math.max(0, this.lastRenderTop + offset), this.lastRenderHeight, void 0, void 0, !0);
        this.setScrollTop(this.lastRenderTop);
        this.eventuallyUpdateScrollDimensions();
        this.supportDynamicHeights && this._rerender(this.lastRenderTop, this.lastRenderHeight);
      }
    }
    splice(start, deleteCount, elements = []) {
      if (this.splicing) {
        throw Error("Can't run recursive splices.");
      }
      this.splicing = !0;
      try {
        return this._splice(start, deleteCount, elements);
      } finally {
        this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
      }
    }
    _splice(start, deleteCount, elements = []) {
      var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), removeRange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.intersect(previousRenderRange, {start, end:start + deleteCount});
      const rowsToDispose = new Map();
      for (var i = removeRange.end - 1; i >= removeRange.start; i--) {
        var item = this.items[i];
        item.dragStartDisposable.dispose();
        item.checkedDisposable.dispose();
        if (item.row) {
          let rows = rowsToDispose.get(item.templateId);
          rows || (rows = [], rowsToDispose.set(item.templateId, rows));
          const renderer = this.renderers.get(item.templateId);
          renderer && renderer.disposeElement && renderer.disposeElement(item.element, i, item.row.templateData, item.size);
          rows.push(item.row);
        }
        item.row = null;
      }
      removeRange = {start:start + deleteCount, end:this.items.length};
      i = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.intersect(removeRange, previousRenderRange);
      removeRange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.relativeComplement(removeRange, previousRenderRange);
      item = elements.map(element => ({id:String(this.itemId++), element, templateId:this.virtualDelegate.getTemplateId(element), size:this.virtualDelegate.getHeight(element), width:void 0, hasDynamicHeight:!!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(element), lastDynamicHeightWidth:void 0, row:null, uri:void 0, dropTarget:!1, dragStartDisposable:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None, checkedDisposable:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None}));
      start === 0 && deleteCount >= this.items.length ? (this.rangeMap = new require$_DOT__SLASH_rangeMap_DOT_js.RangeMap(this.rangeMap.paddingTop), this.rangeMap.splice(0, 0, item), previousRenderRange = this.items, this.items = item) : (this.rangeMap.splice(start, deleteCount, item), previousRenderRange = this.items.splice(start, deleteCount, ...item));
      const delta = elements.length - deleteCount, renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      deleteCount = (0,require$_DOT__SLASH_rangeMap_DOT_js.shift)(i, delta);
      i = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.intersect(renderRange, deleteCount);
      for (item = i.start; item < i.end; item++) {
        this.updateItemInDOM(this.items[item], item);
      }
      deleteCount = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.relativeComplement(deleteCount, renderRange);
      for (var range$jscomp$0 of deleteCount) {
        for (deleteCount = range$jscomp$0.start; deleteCount < range$jscomp$0.end; deleteCount++) {
          this.removeItemFromDOM(deleteCount);
        }
      }
      range$jscomp$0 = removeRange.map(r => (0,require$_DOT__SLASH_rangeMap_DOT_js.shift)(r, delta));
      elements = [{start, end:start + elements.length}, ...range$jscomp$0].map(r => require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.intersect(renderRange, r));
      start = this.getNextToLastElement(elements);
      for (const range of elements) {
        for (elements = range.start; elements < range.end; elements++) {
          range$jscomp$0 = rowsToDispose.get(this.items[elements].templateId), range$jscomp$0 = range$jscomp$0 === null || range$jscomp$0 === void 0 ? void 0 : range$jscomp$0.pop(), this.insertItemInDOM(elements, start, range$jscomp$0);
        }
      }
      for (const rows of rowsToDispose.values()) {
        for (const row of rows) {
          this.cache.release(row);
        }
      }
      this.eventuallyUpdateScrollDimensions();
      this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight);
      return previousRenderRange.map(i => i.element);
    }
    eventuallyUpdateScrollDimensions() {
      this._scrollHeight = this.contentHeight;
      this.rowsContainer.style.height = `${this._scrollHeight}px`;
      this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.scheduleAtNextAnimationFrame)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(this.domNode), () => {
        this.scrollableElement.setScrollDimensions({scrollHeight:this.scrollHeight});
        this.updateScrollWidth();
        this.scrollableElementUpdateDisposable = null;
      }));
    }
    eventuallyUpdateScrollWidth() {
      this.horizontalScrolling ? this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth()) : this.scrollableElementWidthDelayer.cancel();
    }
    updateScrollWidth() {
      if (this.horizontalScrolling) {
        var scrollWidth = 0;
        for (const item of this.items) {
          typeof item.width !== "undefined" && (scrollWidth = Math.max(scrollWidth, item.width));
        }
        this.scrollWidth = scrollWidth;
        this.scrollableElement.setScrollDimensions({scrollWidth:scrollWidth === 0 ? 0 : scrollWidth + 10});
        this._onDidChangeContentWidth.fire(this.scrollWidth);
      }
    }
    rerender() {
      if (this.supportDynamicHeights) {
        for (const item of this.items) {
          item.lastDynamicHeightWidth = void 0;
        }
        this._rerender(this.lastRenderTop, this.lastRenderHeight);
      }
    }
    get length() {
      return this.items.length;
    }
    get renderHeight() {
      return this.scrollableElement.getScrollDimensions().height;
    }
    get firstVisibleIndex() {
      return this.getRenderRange(this.lastRenderTop, this.lastRenderHeight).start;
    }
    element(index) {
      return this.items[index].element;
    }
    indexOf(element) {
      return this.items.findIndex(item => item.element === element);
    }
    domElement(index) {
      return (index = this.items[index].row) && index.domNode;
    }
    elementHeight(index) {
      return this.items[index].size;
    }
    elementTop(index) {
      return this.rangeMap.positionAt(index);
    }
    indexAt(position) {
      return this.rangeMap.indexAt(position);
    }
    indexAfter(position) {
      return this.rangeMap.indexAfter(position);
    }
    layout(height, width) {
      height = {height:typeof height === "number" ? height : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getContentHeight)(this.domNode)};
      this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, height.scrollHeight = this.scrollHeight);
      this.scrollableElement.setScrollDimensions(height);
      typeof width !== "undefined" && (this.renderWidth = width, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight));
      this.horizontalScrolling && this.scrollableElement.setScrollDimensions({width:typeof width === "number" ? width : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getContentWidth)(this.domNode)});
    }
    render(previousRenderRange, renderTop, renderHeight, renderLeft, scrollWidth, updateItemsInDOM = !1) {
      const renderRange = this.getRenderRange(renderTop, renderHeight), rangesToInsert = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.relativeComplement(renderRange, previousRenderRange), rangesToRemove = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.relativeComplement(previousRenderRange, renderRange), beforeElement = this.getNextToLastElement(rangesToInsert);
      if (updateItemsInDOM) {
        for (previousRenderRange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.intersect(previousRenderRange, renderRange), updateItemsInDOM = previousRenderRange.start; updateItemsInDOM < previousRenderRange.end; updateItemsInDOM++) {
          this.updateItemInDOM(this.items[updateItemsInDOM], updateItemsInDOM);
        }
      }
      this.cache.transact(() => {
        for (var range$jscomp$0 of rangesToRemove) {
          for (let i = range$jscomp$0.start; i < range$jscomp$0.end; i++) {
            this.removeItemFromDOM(i);
          }
        }
        for (const range of rangesToInsert) {
          for (range$jscomp$0 = range.start; range$jscomp$0 < range.end; range$jscomp$0++) {
            this.insertItemInDOM(range$jscomp$0, beforeElement);
          }
        }
      });
      renderLeft !== void 0 && (this.rowsContainer.style.left = `-${renderLeft}px`);
      this.rowsContainer.style.top = `-${renderTop}px`;
      this.horizontalScrolling && scrollWidth !== void 0 && (this.rowsContainer.style.width = `${Math.max(scrollWidth, this.renderWidth)}px`);
      this.lastRenderTop = renderTop;
      this.lastRenderHeight = renderHeight;
    }
    insertItemInDOM(index, beforeElement, row) {
      const item = this.items[index];
      var isStale = !1;
      item.row || (row ? item.row = row : (isStale = this.cache.alloc(item.templateId), item.row = isStale.row, isStale = isStale.isReusingConnectedDomNode));
      row = this.accessibilityProvider.getRole(item.element) || "listitem";
      item.row.domNode.setAttribute("role", row);
      row = this.accessibilityProvider.isChecked(item.element);
      if (typeof row === "boolean") {
        item.row.domNode.setAttribute("aria-checked", String(!!row));
      } else if (row) {
        const update = checked => item.row.domNode.setAttribute("aria-checked", String(!!checked));
        update(row.value);
        item.checkedDisposable = row.onDidChange(update);
      }
      if (isStale || !item.row.domNode.parentElement) {
        beforeElement ? this.rowsContainer.insertBefore(item.row.domNode, beforeElement) : this.rowsContainer.appendChild(item.row.domNode);
      }
      this.updateItemInDOM(item, index);
      beforeElement = this.renderers.get(item.templateId);
      if (!beforeElement) {
        throw Error(`No renderer found for template id ${item.templateId}`);
      }
      beforeElement === null || beforeElement === void 0 || beforeElement.renderElement(item.element, index, item.row.templateData, item.size);
      const uri = this.dnd.getDragURI(item.element);
      item.dragStartDisposable.dispose();
      item.row.domNode.draggable = !!uri;
      uri && (item.dragStartDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(item.row.domNode, "dragstart", event => this.onDragStart(item.element, uri, event)));
      this.horizontalScrolling && (this.measureItemWidth(item), this.eventuallyUpdateScrollWidth());
    }
    measureItemWidth(item) {
      if (item.row && item.row.domNode) {
        item.row.domNode.style.width = "fit-content";
        item.width = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getContentWidth)(item.row.domNode);
        var style = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(item.row.domNode).getComputedStyle(item.row.domNode);
        style.paddingLeft && (item.width += parseFloat(style.paddingLeft));
        style.paddingRight && (item.width += parseFloat(style.paddingRight));
        item.row.domNode.style.width = "";
      }
    }
    updateItemInDOM(item, index) {
      item.row.domNode.style.top = `${this.elementTop(index)}px`;
      this.setRowHeight && (item.row.domNode.style.height = `${item.size}px`);
      this.setRowLineHeight && (item.row.domNode.style.lineHeight = `${item.size}px`);
      item.row.domNode.setAttribute("data-index", `${index}`);
      item.row.domNode.setAttribute("data-last-element", index === this.length - 1 ? "true" : "false");
      item.row.domNode.setAttribute("data-parity", index % 2 === 0 ? "even" : "odd");
      item.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(item.element, index, this.length)));
      item.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(item.element, index)));
      item.row.domNode.setAttribute("id", this.getElementDomId(index));
      item.row.domNode.classList.toggle("drop-target", item.dropTarget);
    }
    removeItemFromDOM(index) {
      const item = this.items[index];
      item.dragStartDisposable.dispose();
      item.checkedDisposable.dispose();
      if (item.row) {
        const renderer = this.renderers.get(item.templateId);
        renderer && renderer.disposeElement && renderer.disposeElement(item.element, index, item.row.templateData, item.size);
        this.cache.release(item.row);
        item.row = null;
      }
      this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
    }
    getScrollTop() {
      return this.scrollableElement.getScrollPosition().scrollTop;
    }
    setScrollTop(scrollTop, reuseAnimation) {
      this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({scrollHeight:this.scrollHeight}));
      this.scrollableElement.setScrollPosition({scrollTop, reuseAnimation});
    }
    get scrollTop() {
      return this.getScrollTop();
    }
    set scrollTop(scrollTop) {
      this.setScrollTop(scrollTop);
    }
    get scrollHeight() {
      return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
    }
    get onMouseClick() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "click")).event, e => this.toMouseEvent(e), this.disposables);
    }
    get onMouseDblClick() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "dblclick")).event, e => this.toMouseEvent(e), this.disposables);
    }
    get onMouseMiddleClick() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.filter(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "auxclick")).event, e => this.toMouseEvent(e), this.disposables), e => e.browserEvent.button === 1, this.disposables);
    }
    get onMouseDown() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "mousedown")).event, e => this.toMouseEvent(e), this.disposables);
    }
    get onMouseOver() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "mouseover")).event, e => this.toMouseEvent(e), this.disposables);
    }
    get onMouseOut() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "mouseout")).event, e => this.toMouseEvent(e), this.disposables);
    }
    get onContextMenu() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.any(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "contextmenu")).event, e => this.toMouseEvent(e), this.disposables), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, 
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js.EventType.Contextmenu)).event, e => this.toGestureEvent(e), this.disposables));
    }
    get onTouchStart() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.domNode, "touchstart")).event, e => this.toTouchEvent(e), this.disposables);
    }
    get onTap() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.rowsContainer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js.EventType.Tap)).event, e => this.toGestureEvent(e), this.disposables);
    }
    toMouseEvent(browserEvent) {
      const index = this.getItemIndexFromEventTarget(browserEvent.target || null), item = typeof index === "undefined" ? void 0 : this.items[index];
      return {browserEvent, index, element:item && item.element};
    }
    toTouchEvent(browserEvent) {
      const index = this.getItemIndexFromEventTarget(browserEvent.target || null), item = typeof index === "undefined" ? void 0 : this.items[index];
      return {browserEvent, index, element:item && item.element};
    }
    toGestureEvent(browserEvent) {
      const index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null), item = typeof index === "undefined" ? void 0 : this.items[index];
      return {browserEvent, index, element:item && item.element};
    }
    toDragEvent(browserEvent) {
      const index = this.getItemIndexFromEventTarget(browserEvent.target || null), item = typeof index === "undefined" ? void 0 : this.items[index];
      return {browserEvent, index, element:item && item.element};
    }
    onScroll(e) {
      try {
        const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
        this.render(previousRenderRange, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);
        this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
      } catch (err) {
        throw console.error("Got bad scroll event:", e), err;
      }
    }
    onTouchChange(event) {
      event.preventDefault();
      event.stopPropagation();
      this.scrollTop -= event.translationY;
    }
    onDragStart(element, uri, event) {
      var _a, _b;
      if (event.dataTransfer) {
        element = this.dnd.getDragElements(element);
        event.dataTransfer.effectAllowed = "copyMove";
        event.dataTransfer.setData(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dnd_DOT_js.DataTransfers.TEXT, uri);
        if (event.dataTransfer.setDragImage) {
          let label;
          this.dnd.getDragLabel && (label = this.dnd.getDragLabel(element, event));
          typeof label === "undefined" && (label = String(element.length));
          const dragImage = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-drag-image");
          dragImage.textContent = label;
          const container = (e => {
            for (; e && !e.classList.contains("monaco-workbench");) {
              e = e.parentElement;
            }
            return e || this.domNode.ownerDocument;
          })(this.domNode);
          container.appendChild(dragImage);
          event.dataTransfer.setDragImage(dragImage, -10, -10);
          setTimeout(() => container.removeChild(dragImage), 0);
        }
        this.domNode.classList.add("dragging");
        this.currentDragData = new ElementsDragAndDropData(element);
        JSCompiler_object_inline_CurrentDragAndDropData_2337 = new ExternalElementsDragAndDropData(element);
        (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 || _b.call(_a, this.currentDragData, event);
      }
    }
    onDragOver(event) {
      var _a;
      event.browserEvent.preventDefault();
      this.onDragLeaveTimeout.dispose();
      if (JSCompiler_object_inline_CurrentDragAndDropData_2337 && JSCompiler_object_inline_CurrentDragAndDropData_2337.getData() === "vscode-ui") {
        return !1;
      }
      this.setupDragAndDropScrollTopAnimation(event.browserEvent);
      if (!event.browserEvent.dataTransfer) {
        return !1;
      }
      if (!this.currentDragData) {
        if (JSCompiler_object_inline_CurrentDragAndDropData_2337) {
          this.currentDragData = JSCompiler_object_inline_CurrentDragAndDropData_2337;
        } else {
          if (!event.browserEvent.dataTransfer.types) {
            return !1;
          }
          this.currentDragData = new NativeDragAndDropData();
        }
      }
      const result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.browserEvent);
      this.canDrop = typeof result === "boolean" ? result : result.accept;
      if (!this.canDrop) {
        return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
      }
      event.browserEvent.dataTransfer.dropEffect = typeof result !== "boolean" && result.effect === 0 ? "copy" : "move";
      let feedback;
      feedback = typeof result !== "boolean" && result.feedback ? result.feedback : typeof event.index === "undefined" ? [-1] : [event.index];
      feedback = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.distinct)(feedback).filter(i => i >= -1 && i < this.length).sort((a, b) => a - b);
      feedback = feedback[0] === -1 ? [-1] : feedback;
      if (equalsDragFeedback(this.currentDragFeedback, feedback)) {
        return !0;
      }
      this.currentDragFeedback = feedback;
      this.currentDragFeedbackDisposable.dispose();
      if (feedback[0] === -1) {
        this.domNode.classList.add("drop-target"), this.rowsContainer.classList.add("drop-target"), this.currentDragFeedbackDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
          this.domNode.classList.remove("drop-target");
          this.rowsContainer.classList.remove("drop-target");
        });
      } else {
        for (const index of feedback) {
          event = this.items[index], event.dropTarget = !0, (_a = event.row) === null || _a === void 0 || _a.domNode.classList.add("drop-target");
        }
        this.currentDragFeedbackDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
          var _a;
          for (const index of feedback) {
            const item = this.items[index];
            item.dropTarget = !1;
            (_a = item.row) === null || _a === void 0 || _a.domNode.classList.remove("drop-target");
          }
        });
      }
      return !0;
    }
    onDragLeave(event) {
      var _a, _b;
      this.onDragLeaveTimeout.dispose();
      this.onDragLeaveTimeout = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.disposableTimeout)(() => this.clearDragOverFeedback(), 100, this.disposables);
      this.currentDragData && ((_b = (_a = this.dnd).onDragLeave) === null || _b === void 0 || _b.call(_a, this.currentDragData, event.element, event.index, event.browserEvent));
    }
    onDrop(event) {
      if (this.canDrop) {
        var dragData = this.currentDragData;
        this.teardownDragAndDropScrollTopAnimation();
        this.clearDragOverFeedback();
        this.domNode.classList.remove("dragging");
        JSCompiler_object_inline_CurrentDragAndDropData_2337 = this.currentDragData = void 0;
        dragData && event.browserEvent.dataTransfer && (event.browserEvent.preventDefault(), dragData.update(event.browserEvent.dataTransfer), this.dnd.drop(dragData, event.element, event.index, event.browserEvent));
      }
    }
    onDragEnd(event) {
      var _a, _b;
      this.canDrop = !1;
      this.teardownDragAndDropScrollTopAnimation();
      this.clearDragOverFeedback();
      this.domNode.classList.remove("dragging");
      JSCompiler_object_inline_CurrentDragAndDropData_2337 = this.currentDragData = void 0;
      (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 || _b.call(_a, event);
    }
    clearDragOverFeedback() {
      this.currentDragFeedback = void 0;
      this.currentDragFeedbackDisposable.dispose();
      this.currentDragFeedbackDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
    }
    setupDragAndDropScrollTopAnimation(event) {
      if (!this.dragOverAnimationDisposable) {
        const viewTop = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getTopLeftOffset)(this.domNode).top;
        this.dragOverAnimationDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.animate)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(this.domNode), this.animateDragAndDropScrollTop.bind(this, viewTop));
      }
      this.dragOverAnimationStopDisposable.dispose();
      this.dragOverAnimationStopDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.disposableTimeout)(() => {
        this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
      }, 1000, this.disposables);
      this.dragOverMouseY = event.pageY;
    }
    animateDragAndDropScrollTop(viewTop) {
      if (this.dragOverMouseY !== void 0) {
        viewTop = this.dragOverMouseY - viewTop;
        var upperLimit = this.renderHeight - 35;
        viewTop < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (viewTop - 35))) : viewTop > upperLimit && (this.scrollTop += Math.min(14, Math.floor(0.3 * (viewTop - upperLimit))));
      }
    }
    teardownDragAndDropScrollTopAnimation() {
      this.dragOverAnimationStopDisposable.dispose();
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }
    getItemIndexFromEventTarget(target) {
      const scrollableElement = this.scrollableElement.getDomNode();
      for (; target instanceof HTMLElement && target !== this.rowsContainer && scrollableElement.contains(target);) {
        var rawIndex = target.getAttribute("data-index");
        if (rawIndex && (rawIndex = Number(rawIndex), !isNaN(rawIndex))) {
          return rawIndex;
        }
        target = target.parentElement;
      }
    }
    getRenderRange(renderTop, renderHeight) {
      return {start:this.rangeMap.indexAt(renderTop), end:this.rangeMap.indexAfter(renderTop + renderHeight - 1)};
    }
    _rerender(renderTop, renderHeight, inSmoothScrolling) {
      var previousRenderRange = this.getRenderRange(renderTop, renderHeight);
      let anchorElementTopDelta;
      if (renderTop === this.elementTop(previousRenderRange.start)) {
        var anchorElementIndex = previousRenderRange.start;
        anchorElementTopDelta = 0;
      } else {
        previousRenderRange.end - previousRenderRange.start > 1 && (anchorElementIndex = previousRenderRange.start + 1, anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop);
      }
      let heightDiff = 0;
      for (;;) {
        const renderRange = this.getRenderRange(renderTop, renderHeight);
        let didChange = !1;
        for (let i = renderRange.start; i < renderRange.end; i++) {
          const diff = this.probeDynamicHeight(i);
          diff !== 0 && this.rangeMap.splice(i, 1, [this.items[i]]);
          heightDiff += diff;
          didChange = didChange || diff !== 0;
        }
        if (!didChange) {
          heightDiff !== 0 && this.eventuallyUpdateScrollDimensions();
          renderHeight = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.relativeComplement(previousRenderRange, renderRange);
          for (var range of renderHeight) {
            for (renderHeight = range.start; renderHeight < range.end; renderHeight++) {
              this.items[renderHeight].row && this.removeItemFromDOM(renderHeight);
            }
          }
          previousRenderRange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.relativeComplement(renderRange, previousRenderRange);
          for (var range$jscomp$0 of previousRenderRange) {
            for (previousRenderRange = range$jscomp$0.start; previousRenderRange < range$jscomp$0.end; previousRenderRange++) {
              range = previousRenderRange + 1, range = range < this.items.length ? this.items[range].row : null, this.insertItemInDOM(previousRenderRange, range ? range.domNode : null);
            }
          }
          for (range$jscomp$0 = renderRange.start; range$jscomp$0 < renderRange.end; range$jscomp$0++) {
            this.items[range$jscomp$0].row && this.updateItemInDOM(this.items[range$jscomp$0], range$jscomp$0);
          }
          typeof anchorElementIndex === "number" && (renderTop = this.scrollable.getFutureScrollPosition().scrollTop - renderTop, anchorElementIndex = this.elementTop(anchorElementIndex) - anchorElementTopDelta + renderTop, this.setScrollTop(anchorElementIndex, inSmoothScrolling));
          this._onDidChangeContentHeight.fire(this.contentHeight);
          break;
        }
      }
    }
    probeDynamicHeight(index) {
      var _a, _b, _c;
      const item = this.items[index];
      if (this.virtualDelegate.getDynamicHeight) {
        var newSize = this.virtualDelegate.getDynamicHeight(item.element);
        if (newSize !== null) {
          return index = item.size, item.size = newSize, item.lastDynamicHeightWidth = this.renderWidth, newSize - index;
        }
      }
      if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(item.element)) {
        return 0;
      }
      newSize = item.size;
      if (item.row) {
        return item.row.domNode.style.height = "", item.size = item.row.domNode.offsetHeight, item.lastDynamicHeightWidth = this.renderWidth, item.size - newSize;
      }
      const {row} = this.cache.alloc(item.templateId);
      row.domNode.style.height = "";
      this.rowsContainer.appendChild(row.domNode);
      const renderer = this.renderers.get(item.templateId);
      if (!renderer) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Missing renderer for templateId: " + item.templateId);
      }
      renderer.renderElement(item.element, index, row.templateData, void 0);
      item.size = row.domNode.offsetHeight;
      (_a = renderer.disposeElement) === null || _a === void 0 || _a.call(renderer, item.element, index, row.templateData, void 0);
      (_c = (_b = this.virtualDelegate).setDynamicHeight) === null || _c === void 0 || _c.call(_b, item.element, item.size);
      item.lastDynamicHeightWidth = this.renderWidth;
      this.rowsContainer.removeChild(row.domNode);
      this.cache.release(row);
      return item.size - newSize;
    }
    getNextToLastElement(ranges) {
      ranges = ranges[ranges.length - 1];
      return ranges ? (ranges = this.items[ranges.end]) && ranges.row ? ranges.row.domNode : null : null;
    }
    getElementDomId(index) {
      return `${this.domId}_${index}`;
    }
    dispose() {
      var _a, _b;
      for (const item of this.items) {
        if (item.dragStartDisposable.dispose(), item.checkedDisposable.dispose(), item.row) {
          const renderer = this.renderers.get(item.row.templateId);
          renderer && ((_a = renderer.disposeElement) === null || _a === void 0 || _a.call(renderer, item.element, -1, item.row.templateData, void 0), renderer.disposeTemplate(item.row.templateData));
        }
      }
      this.items = [];
      this.domNode && this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode);
      (_b = this.dragOverAnimationDisposable) === null || _b === void 0 || _b.dispose();
      this.disposables.dispose();
    }
  }
  ListView.InstanceCount = 0;
  require([module.memoize], ListView.prototype, "onMouseClick", null);
  require([module.memoize], ListView.prototype, "onMouseDblClick", null);
  require([module.memoize], ListView.prototype, "onMouseMiddleClick", null);
  require([module.memoize], ListView.prototype, "onMouseDown", null);
  require([module.memoize], ListView.prototype, "onMouseOver", null);
  require([module.memoize], ListView.prototype, "onMouseOut", null);
  require([module.memoize], ListView.prototype, "onContextMenu", null);
  require([module.memoize], ListView.prototype, "onTouchStart", null);
  require([module.memoize], ListView.prototype, "onTap", null);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listView.js.map
