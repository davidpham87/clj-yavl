shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder = function(require, module, exports) {
  function getUTF16LE_TextDecoder() {
    _utf16LE_TextDecoder ||= new TextDecoder("UTF-16LE");
    return _utf16LE_TextDecoder;
  }
  function getPlatformTextDecoder() {
    if (!_platformTextDecoder) {
      if (platform.isLittleEndian()) {
        var JSCompiler_temp = getUTF16LE_TextDecoder();
      } else {
        _utf16BE_TextDecoder ||= new TextDecoder("UTF-16BE"), JSCompiler_temp = _utf16BE_TextDecoder;
      }
      _platformTextDecoder = JSCompiler_temp;
    }
    return _platformTextDecoder;
  }
  function decodeUTF16LE(source, offset, len) {
    var view = new Uint16Array(source.buffer, offset, len);
    if (len > 0 && (view[0] === 65279 || view[0] === 65534)) {
      view = [];
      let resultLen = 0;
      for (let i = 0; i < len; i++) {
        const charCode = buffer.readUInt16LE(source, offset);
        offset += 2;
        view[resultLen++] = String.fromCharCode(charCode);
      }
      return view.join("");
    }
    return getUTF16LE_TextDecoder().decode(view);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, StringBuilder:{enumerable:!0, get:function() {
    return StringBuilder;
  }}, decodeUTF16LE:{enumerable:!0, get:function() {
    return decodeUTF16LE;
  }}, getPlatformTextDecoder:{enumerable:!0, get:function() {
    return getPlatformTextDecoder;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), buffer = require("module$node_modules$monaco_editor$esm$vs$base$common$buffer");
  let _utf16LE_TextDecoder, _utf16BE_TextDecoder, _platformTextDecoder;
  class StringBuilder {
    constructor(capacity) {
      this._capacity = capacity | 0;
      this._buffer = new Uint16Array(this._capacity);
      this._completedStrings = null;
      this._bufferLength = 0;
    }
    reset() {
      this._completedStrings = null;
      this._bufferLength = 0;
    }
    build() {
      return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
    }
    _buildBuffer() {
      if (this._bufferLength === 0) {
        return "";
      }
      const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
      return getPlatformTextDecoder().decode(view);
    }
    _flushBuffer() {
      const bufferString = this._buildBuffer();
      this._bufferLength = 0;
      this._completedStrings === null ? this._completedStrings = [bufferString] : this._completedStrings[this._completedStrings.length] = bufferString;
    }
    appendCharCode(charCode) {
      const remainingSpace = this._capacity - this._bufferLength;
      remainingSpace <= 1 && (remainingSpace === 0 || strings.isHighSurrogate(charCode)) && this._flushBuffer();
      this._buffer[this._bufferLength++] = charCode;
    }
    appendASCIICharCode(charCode) {
      this._bufferLength === this._capacity && this._flushBuffer();
      this._buffer[this._bufferLength++] = charCode;
    }
    appendString(str) {
      const strLen = str.length;
      if (this._bufferLength + strLen >= this._capacity) {
        this._flushBuffer(), this._completedStrings[this._completedStrings.length] = str;
      } else {
        for (let i = 0; i < strLen; i++) {
          this._buffer[this._bufferLength++] = str.charCodeAt(i);
        }
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder.js.map
