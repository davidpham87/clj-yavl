{
"version":3,
"file":"module$node_modules$monaco_editor$esm$vs$editor$standalone$common$monarch$monarchCompile.js",
"lineCount":338,
"mappings":"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",
"sources":["node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$monaco_editor$esm$vs$editor$standalone$common$monarch$monarchCompile\"] = function(require,module,exports) {\nObject.defineProperties(exports, {__esModule:{enumerable:true, value:true}, compile:{enumerable:true, get:function() {\n  return compile;\n}}});\nvar monarchCommon = require(\"./monarchCommon.js\");\nfunction isArrayOf(elemType, obj) {\n  if (!obj) {\n    return false;\n  }\n  if (!Array.isArray(obj)) {\n    return false;\n  }\n  for (const el of obj) {\n    if (!elemType(el)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction bool(prop, defValue) {\n  if (typeof prop === \"boolean\") {\n    return prop;\n  }\n  return defValue;\n}\nfunction string(prop, defValue) {\n  if (typeof prop === \"string\") {\n    return prop;\n  }\n  return defValue;\n}\nfunction arrayToHash(array) {\n  const result = {};\n  for (const e of array) {\n    result[e] = true;\n  }\n  return result;\n}\nfunction createKeywordMatcher(arr, caseInsensitive = false) {\n  if (caseInsensitive) {\n    arr = arr.map(function(x) {\n      return x.toLowerCase();\n    });\n  }\n  const hash = arrayToHash(arr);\n  if (caseInsensitive) {\n    return function(word) {\n      return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n    };\n  } else {\n    return function(word) {\n      return hash[word] !== undefined && hash.hasOwnProperty(word);\n    };\n  }\n}\nfunction compileRegExp(lexer, str) {\n  str = str.replace(/@@/g, `\\x01`);\n  let n = 0;\n  let hadExpansion;\n  do {\n    hadExpansion = false;\n    str = str.replace(/@(\\w+)/g, function(s, attr) {\n      hadExpansion = true;\n      let sub = \"\";\n      if (typeof lexer[attr] === \"string\") {\n        sub = lexer[attr];\n      } else if (lexer[attr] && lexer[attr] instanceof RegExp) {\n        sub = lexer[attr].source;\n      } else {\n        if (lexer[attr] === undefined) {\n          throw monarchCommon.createError(lexer, \"language definition does not contain attribute '\" + attr + \"', used at: \" + str);\n        } else {\n          throw monarchCommon.createError(lexer, \"attribute reference '\" + attr + \"' must be a string, used at: \" + str);\n        }\n      }\n      return monarchCommon.empty(sub) ? \"\" : \"(?:\" + sub + \")\";\n    });\n    n++;\n  } while (hadExpansion && n < 5);\n  str = str.replace(/\\x01/g, \"@\");\n  const flags = (lexer.ignoreCase ? \"i\" : \"\") + (lexer.unicode ? \"u\" : \"\");\n  return new RegExp(str, flags);\n}\nfunction selectScrutinee(id, matches, state, num) {\n  if (num < 0) {\n    return id;\n  }\n  if (num < matches.length) {\n    return matches[num];\n  }\n  if (num >= 100) {\n    num = num - 100;\n    const parts = state.split(\".\");\n    parts.unshift(state);\n    if (num < parts.length) {\n      return parts[num];\n    }\n  }\n  return null;\n}\nfunction createGuard(lexer, ruleName, tkey, val) {\n  let scrut = -1;\n  let oppat = tkey;\n  let matches = tkey.match(/^\\$(([sS]?)(\\d\\d?)|#)(.*)$/);\n  if (matches) {\n    if (matches[3]) {\n      scrut = parseInt(matches[3]);\n      if (matches[2]) {\n        scrut = scrut + 100;\n      }\n    }\n    oppat = matches[4];\n  }\n  let op = \"~\";\n  let pat = oppat;\n  if (!oppat || oppat.length === 0) {\n    op = \"!\\x3d\";\n    pat = \"\";\n  } else if (/^\\w*$/.test(pat)) {\n    op = \"\\x3d\\x3d\";\n  } else {\n    matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);\n    if (matches) {\n      op = matches[1];\n      pat = matches[2];\n    }\n  }\n  let tester;\n  if ((op === \"~\" || op === \"!~\") && /^(\\w|\\|)*$/.test(pat)) {\n    const inWords = createKeywordMatcher(pat.split(\"|\"), lexer.ignoreCase);\n    tester = function(s) {\n      return op === \"~\" ? inWords(s) : !inWords(s);\n    };\n  } else if (op === \"@\" || op === \"!@\") {\n    const words = lexer[pat];\n    if (!words) {\n      throw monarchCommon.createError(lexer, \"the @ match target '\" + pat + \"' is not defined, in rule: \" + ruleName);\n    }\n    if (!isArrayOf(function(elem) {\n      return typeof elem === \"string\";\n    }, words)) {\n      throw monarchCommon.createError(lexer, \"the @ match target '\" + pat + \"' must be an array of strings, in rule: \" + ruleName);\n    }\n    const inWords = createKeywordMatcher(words, lexer.ignoreCase);\n    tester = function(s) {\n      return op === \"@\" ? inWords(s) : !inWords(s);\n    };\n  } else if (op === \"~\" || op === \"!~\") {\n    if (pat.indexOf(\"$\") < 0) {\n      const re = compileRegExp(lexer, \"^\" + pat + \"$\");\n      tester = function(s) {\n        return op === \"~\" ? re.test(s) : !re.test(s);\n      };\n    } else {\n      tester = function(s, id, matches, state) {\n        const re = compileRegExp(lexer, \"^\" + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + \"$\");\n        return re.test(s);\n      };\n    }\n  } else {\n    if (pat.indexOf(\"$\") < 0) {\n      const patx = monarchCommon.fixCase(lexer, pat);\n      tester = function(s) {\n        return op === \"\\x3d\\x3d\" ? s === patx : s !== patx;\n      };\n    } else {\n      const patx = monarchCommon.fixCase(lexer, pat);\n      tester = function(s, id, matches, state, eos) {\n        const patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);\n        return op === \"\\x3d\\x3d\" ? s === patexp : s !== patexp;\n      };\n    }\n  }\n  if (scrut === -1) {\n    return {name:tkey, value:val, test:function(id, matches, state, eos) {\n      return tester(id, id, matches, state, eos);\n    }};\n  } else {\n    return {name:tkey, value:val, test:function(id, matches, state, eos) {\n      const scrutinee = selectScrutinee(id, matches, state, scrut);\n      return tester(!scrutinee ? \"\" : scrutinee, id, matches, state, eos);\n    }};\n  }\n}\nfunction compileAction(lexer, ruleName, action) {\n  if (!action) {\n    return {token:\"\"};\n  } else if (typeof action === \"string\") {\n    return action;\n  } else if (action.token || action.token === \"\") {\n    if (typeof action.token !== \"string\") {\n      throw monarchCommon.createError(lexer, \"a 'token' attribute must be of type string, in rule: \" + ruleName);\n    } else {\n      const newAction = {token:action.token};\n      if (action.token.indexOf(\"$\") >= 0) {\n        newAction.tokenSubst = true;\n      }\n      if (typeof action.bracket === \"string\") {\n        if (action.bracket === \"@open\") {\n          newAction.bracket = 1;\n        } else if (action.bracket === \"@close\") {\n          newAction.bracket = -1;\n        } else {\n          throw monarchCommon.createError(lexer, \"a 'bracket' attribute must be either '@open' or '@close', in rule: \" + ruleName);\n        }\n      }\n      if (action.next) {\n        if (typeof action.next !== \"string\") {\n          throw monarchCommon.createError(lexer, \"the next state must be a string value in rule: \" + ruleName);\n        } else {\n          let next = action.next;\n          if (!/^(@pop|@push|@popall)$/.test(next)) {\n            if (next[0] === \"@\") {\n              next = next.substr(1);\n            }\n            if (next.indexOf(\"$\") < 0) {\n              if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, \"\", [], \"\"))) {\n                throw monarchCommon.createError(lexer, \"the next state '\" + action.next + \"' is not defined in rule: \" + ruleName);\n              }\n            }\n          }\n          newAction.next = next;\n        }\n      }\n      if (typeof action.goBack === \"number\") {\n        newAction.goBack = action.goBack;\n      }\n      if (typeof action.switchTo === \"string\") {\n        newAction.switchTo = action.switchTo;\n      }\n      if (typeof action.log === \"string\") {\n        newAction.log = action.log;\n      }\n      if (typeof action.nextEmbedded === \"string\") {\n        newAction.nextEmbedded = action.nextEmbedded;\n        lexer.usesEmbedded = true;\n      }\n      return newAction;\n    }\n  } else if (Array.isArray(action)) {\n    const results = [];\n    for (let i = 0, len = action.length; i < len; i++) {\n      results[i] = compileAction(lexer, ruleName, action[i]);\n    }\n    return {group:results};\n  } else if (action.cases) {\n    const cases = [];\n    for (const tkey in action.cases) {\n      if (action.cases.hasOwnProperty(tkey)) {\n        const val = compileAction(lexer, ruleName, action.cases[tkey]);\n        if (tkey === \"@default\" || tkey === \"@\" || tkey === \"\") {\n          cases.push({test:undefined, value:val, name:tkey});\n        } else if (tkey === \"@eos\") {\n          cases.push({test:function(id, matches, state, eos) {\n            return eos;\n          }, value:val, name:tkey});\n        } else {\n          cases.push(createGuard(lexer, ruleName, tkey, val));\n        }\n      }\n    }\n    const def = lexer.defaultToken;\n    return {test:function(id, matches, state, eos) {\n      for (const _case of cases) {\n        const didmatch = !_case.test || _case.test(id, matches, state, eos);\n        if (didmatch) {\n          return _case.value;\n        }\n      }\n      return def;\n    }};\n  } else {\n    throw monarchCommon.createError(lexer, \"an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: \" + ruleName);\n  }\n}\nclass Rule {\n  constructor(name) {\n    this.regex = new RegExp(\"\");\n    this.action = {token:\"\"};\n    this.matchOnlyAtLineStart = false;\n    this.name = \"\";\n    this.name = name;\n  }\n  setRegex(lexer, re) {\n    let sregex;\n    if (typeof re === \"string\") {\n      sregex = re;\n    } else if (re instanceof RegExp) {\n      sregex = re.source;\n    } else {\n      throw monarchCommon.createError(lexer, \"rules must start with a match string or regular expression: \" + this.name);\n    }\n    this.matchOnlyAtLineStart = sregex.length > 0 && sregex[0] === \"^\";\n    this.name = this.name + \": \" + sregex;\n    this.regex = compileRegExp(lexer, \"^(?:\" + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + \")\");\n  }\n  setAction(lexer, act) {\n    this.action = compileAction(lexer, this.name, act);\n  }\n}\nfunction compile(languageId, json) {\n  if (!json || typeof json !== \"object\") {\n    throw new Error(\"Monarch: expecting a language definition object\");\n  }\n  const lexer = {};\n  lexer.languageId = languageId;\n  lexer.includeLF = bool(json.includeLF, false);\n  lexer.noThrow = false;\n  lexer.maxStack = 100;\n  lexer.start = typeof json.start === \"string\" ? json.start : null;\n  lexer.ignoreCase = bool(json.ignoreCase, false);\n  lexer.unicode = bool(json.unicode, false);\n  lexer.tokenPostfix = string(json.tokenPostfix, \".\" + lexer.languageId);\n  lexer.defaultToken = string(json.defaultToken, \"source\");\n  lexer.usesEmbedded = false;\n  const lexerMin = json;\n  lexerMin.languageId = languageId;\n  lexerMin.includeLF = lexer.includeLF;\n  lexerMin.ignoreCase = lexer.ignoreCase;\n  lexerMin.unicode = lexer.unicode;\n  lexerMin.noThrow = lexer.noThrow;\n  lexerMin.usesEmbedded = lexer.usesEmbedded;\n  lexerMin.stateNames = json.tokenizer;\n  lexerMin.defaultToken = lexer.defaultToken;\n  function addRules(state, newrules, rules) {\n    for (const rule of rules) {\n      let include = rule.include;\n      if (include) {\n        if (typeof include !== \"string\") {\n          throw monarchCommon.createError(lexer, \"an 'include' attribute must be a string at: \" + state);\n        }\n        if (include[0] === \"@\") {\n          include = include.substr(1);\n        }\n        if (!json.tokenizer[include]) {\n          throw monarchCommon.createError(lexer, \"include target '\" + include + \"' is not defined at: \" + state);\n        }\n        addRules(state + \".\" + include, newrules, json.tokenizer[include]);\n      } else {\n        const newrule = new Rule(state);\n        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {\n          newrule.setRegex(lexerMin, rule[0]);\n          if (rule.length >= 3) {\n            if (typeof rule[1] === \"string\") {\n              newrule.setAction(lexerMin, {token:rule[1], next:rule[2]});\n            } else if (typeof rule[1] === \"object\") {\n              const rule1 = rule[1];\n              rule1.next = rule[2];\n              newrule.setAction(lexerMin, rule1);\n            } else {\n              throw monarchCommon.createError(lexer, \"a next state as the last element of a rule can only be given if the action is either an object or a string, at: \" + state);\n            }\n          } else {\n            newrule.setAction(lexerMin, rule[1]);\n          }\n        } else {\n          if (!rule.regex) {\n            throw monarchCommon.createError(lexer, \"a rule must either be an array, or an object with a 'regex' or 'include' field at: \" + state);\n          }\n          if (rule.name) {\n            if (typeof rule.name === \"string\") {\n              newrule.name = rule.name;\n            }\n          }\n          if (rule.matchOnlyAtStart) {\n            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);\n          }\n          newrule.setRegex(lexerMin, rule.regex);\n          newrule.setAction(lexerMin, rule.action);\n        }\n        newrules.push(newrule);\n      }\n    }\n  }\n  if (!json.tokenizer || typeof json.tokenizer !== \"object\") {\n    throw monarchCommon.createError(lexer, \"a language definition must define the 'tokenizer' attribute as an object\");\n  }\n  lexer.tokenizer = [];\n  for (const key in json.tokenizer) {\n    if (json.tokenizer.hasOwnProperty(key)) {\n      if (!lexer.start) {\n        lexer.start = key;\n      }\n      const rules = json.tokenizer[key];\n      lexer.tokenizer[key] = new Array();\n      addRules(\"tokenizer.\" + key, lexer.tokenizer[key], rules);\n    }\n  }\n  lexer.usesEmbedded = lexerMin.usesEmbedded;\n  if (json.brackets) {\n    if (!Array.isArray(json.brackets)) {\n      throw monarchCommon.createError(lexer, \"the 'brackets' attribute must be defined as an array\");\n    }\n  } else {\n    json.brackets = [{open:\"{\", close:\"}\", token:\"delimiter.curly\"}, {open:\"[\", close:\"]\", token:\"delimiter.square\"}, {open:\"(\", close:\")\", token:\"delimiter.parenthesis\"}, {open:\"\\x3c\", close:\"\\x3e\", token:\"delimiter.angle\"}];\n  }\n  const brackets = [];\n  for (const el of json.brackets) {\n    let desc = el;\n    if (desc && Array.isArray(desc) && desc.length === 3) {\n      desc = {token:desc[2], open:desc[0], close:desc[1]};\n    }\n    if (desc.open === desc.close) {\n      throw monarchCommon.createError(lexer, \"open and close brackets in a 'brackets' attribute must be different: \" + desc.open + \"\\n hint: use the 'bracket' attribute if matching on equal brackets is required.\");\n    }\n    if (typeof desc.open === \"string\" && typeof desc.token === \"string\" && typeof desc.close === \"string\") {\n      brackets.push({token:desc.token + lexer.tokenPostfix, open:monarchCommon.fixCase(lexer, desc.open), close:monarchCommon.fixCase(lexer, desc.close)});\n    } else {\n      throw monarchCommon.createError(lexer, \"every element in the 'brackets' array must be a '{open,close,token}' object or array\");\n    }\n  }\n  lexer.brackets = brackets;\n  lexer.noThrow = true;\n  return lexer;\n}\n\n};"],
"names":["shadow$provide","require","module","exports","isArrayOf","elemType","obj","Array","isArray","el","bool","prop","defValue","string","arrayToHash","array","result","e","createKeywordMatcher","arr","caseInsensitive","map","x","toLowerCase","hash","word","undefined","hasOwnProperty","compileRegExp","lexer","str","replace","n","hadExpansion","s","attr","sub","RegExp","source","monarchCommon","createError","empty","ignoreCase","unicode","createGuard","ruleName","tkey","val","scrut","oppat","matches","match","parseInt","op","pat","length","test","tester","words","elem","inWords","indexOf","re","id","state","substituteMatches","patx","fixCase","eos","patexp","split","name","value","num","parts","unshift","scrutinee","compileAction","action","token","newAction","tokenSubst","bracket","next","substr","stateExists","goBack","switchTo","log","nextEmbedded","usesEmbedded","results","i","len","group","cases","push","def","defaultToken","_case","compile","languageId","json","addRules","newrules","rules","rule","include","tokenizer","newrule","Rule","setRegex","lexerMin","setAction","rule1","regex","matchOnlyAtStart","matchOnlyAtLineStart","Error","includeLF","noThrow","maxStack","start","tokenPostfix","stateNames","key","brackets","open","close","desc","Object","defineProperties","__esModule","enumerable","get","constructor","sregex","act"]
}
