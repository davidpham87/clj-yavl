shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelTokens = function(require, module, exports) {
  function safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {
    let r = null;
    if (tokenizationSupport) {
      try {
        r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());
      } catch (e) {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e);
      }
    }
    r ||= (0,require$_DOT__DOT__SLASH_languages_SLASH_nullTokenize_DOT_js.nullTokenizeEncoded)(languageIdCodec.encodeLanguageId(languageId), state);
    require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens.convertToEndOffset(r.tokens, text.length);
    return r;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DefaultBackgroundTokenizer:{enumerable:!0, get:function() {
    return DefaultBackgroundTokenizer;
  }}, RangePriorityQueueImpl:{enumerable:!0, get:function() {
    return RangePriorityQueueImpl;
  }}, TokenizationStateStore:{enumerable:!0, get:function() {
    return TokenizationStateStore;
  }}, TokenizerWithStateStore:{enumerable:!0, get:function() {
    return TokenizerWithStateStore;
  }}, TokenizerWithStateStoreAndTextModel:{enumerable:!0, get:function() {
    return TokenizerWithStateStoreAndTextModel;
  }}, TrackingTokenizationStateStore:{enumerable:!0, get:function() {
    return TrackingTokenizationStateStore;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_platform_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_stopwatch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$stopwatch"), require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$eolCounter"), require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange"), require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange"), require$_DOT__DOT__SLASH_languages_SLASH_nullTokenize_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$nullTokenize"), require$_DOT__SLASH_fixedArray_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$fixedArray"), require$_DOT__DOT__SLASH_tokens_SLASH_contiguousMultilineTokensBuilder_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousMultilineTokensBuilder"), 
  require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens");
  class TokenizerWithStateStore {
    constructor(lineCount, tokenizationSupport) {
      this.tokenizationSupport = tokenizationSupport;
      this.initialState = this.tokenizationSupport.getInitialState();
      this.store = new TrackingTokenizationStateStore(lineCount);
    }
    getStartState(lineNumber) {
      return this.store.getStartState(lineNumber, this.initialState);
    }
    getFirstInvalidLine() {
      return this.store.getFirstInvalidLine(this.initialState);
    }
  }
  class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {
    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {
      super(lineCount, tokenizationSupport);
      this._textModel = _textModel;
      this._languageIdCodec = _languageIdCodec;
    }
    updateTokensUntilLine(builder, lineNumber) {
      const languageId = this._textModel.getLanguageId();
      for (;;) {
        const lineToTokenize = this.getFirstInvalidLine();
        if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {
          break;
        }
        var text = this._textModel.getLineContent(lineToTokenize.lineNumber);
        text = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, !0, lineToTokenize.startState);
        builder.add(lineToTokenize.lineNumber, text.tokens);
        this.store.setEndState(lineToTokenize.lineNumber, text.endState);
      }
    }
    getTokenTypeIfInsertingCharacter(position, character) {
      var lineStartState = this.getStartState(position.lineNumber);
      if (!lineStartState) {
        return 0;
      }
      const languageId = this._textModel.getLanguageId(), lineContent = this._textModel.getLineContent(position.lineNumber);
      character = lineContent.substring(0, position.column - 1) + character + lineContent.substring(position.column - 1);
      lineStartState = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, character, !0, lineStartState);
      lineStartState = new require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens(lineStartState.tokens, character, this._languageIdCodec);
      if (lineStartState.getCount() === 0) {
        return 0;
      }
      position = lineStartState.findTokenIndexAtOffset(position.column - 1);
      return lineStartState.getStandardTokenType(position);
    }
    tokenizeLineWithEdit(position, length, newText) {
      var lineNumber = position.lineNumber;
      const column = position.column;
      position = this.getStartState(lineNumber);
      if (!position) {
        return null;
      }
      const curLineContent = this._textModel.getLineContent(lineNumber);
      length = curLineContent.substring(0, column - 1) + newText + curLineContent.substring(column - 1 + length);
      lineNumber = this._textModel.getLanguageIdAtPosition(lineNumber, 0);
      lineNumber = safeTokenize(this._languageIdCodec, lineNumber, this.tokenizationSupport, length, !0, position);
      return new require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens(lineNumber.tokens, length, this._languageIdCodec);
    }
    isCheapToTokenize(lineNumber) {
      const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();
      return lineNumber < firstInvalidLineNumber || lineNumber === firstInvalidLineNumber && this._textModel.getLineLength(lineNumber) < 2048 ? !0 : !1;
    }
    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {
      if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
        return {heuristicTokens:!1};
      }
      if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
        return this.updateTokensUntilLine(builder, endLineNumber), {heuristicTokens:!1};
      }
      var state = this.guessStartState(startLineNumber);
      const languageId = this._textModel.getLanguageId();
      for (; startLineNumber <= endLineNumber; startLineNumber++) {
        const text = this._textModel.getLineContent(startLineNumber);
        state = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, !0, state);
        builder.add(startLineNumber, state.tokens);
        state = state.endState;
      }
      return {heuristicTokens:!0};
    }
    guessStartState(lineNumber) {
      var nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);
      const likelyRelevantLines = [];
      var initialState = null;
      for (--lineNumber; nonWhitespaceColumn > 1 && lineNumber >= 1; lineNumber--) {
        const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);
        if (newNonWhitespaceIndex !== 0 && newNonWhitespaceIndex < nonWhitespaceColumn && (likelyRelevantLines.push(this._textModel.getLineContent(lineNumber)), nonWhitespaceColumn = newNonWhitespaceIndex, initialState = this.getStartState(lineNumber))) {
          break;
        }
      }
      initialState ||= this.tokenizationSupport.getInitialState();
      likelyRelevantLines.reverse();
      nonWhitespaceColumn = this._textModel.getLanguageId();
      for (const line of likelyRelevantLines) {
        initialState = safeTokenize(this._languageIdCodec, nonWhitespaceColumn, this.tokenizationSupport, line, !1, initialState).endState;
      }
      return initialState;
    }
  }
  class TrackingTokenizationStateStore {
    constructor(lineCount) {
      this.lineCount = lineCount;
      this._tokenizationStateStore = new TokenizationStateStore();
      this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();
      this._invalidEndStatesLineNumbers.addRange(new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(1, lineCount + 1));
    }
    getEndState(lineNumber) {
      return this._tokenizationStateStore.getEndState(lineNumber);
    }
    setEndState(lineNumber, state) {
      if (!state) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Cannot set null/undefined state");
      }
      this._invalidEndStatesLineNumbers.delete(lineNumber);
      (state = this._tokenizationStateStore.setEndState(lineNumber, state)) && lineNumber < this.lineCount && this._invalidEndStatesLineNumbers.addRange(new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(lineNumber + 1, lineNumber + 2));
      return state;
    }
    acceptChange(range, newLineCount) {
      this.lineCount += newLineCount - range.length;
      this._tokenizationStateStore.acceptChange(range, newLineCount);
      this._invalidEndStatesLineNumbers.addRangeAndResize(new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);
    }
    acceptChanges(changes) {
      for (const c of changes) {
        [changes] = (0,require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(c.text), this.acceptChange(new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), changes + 1);
      }
    }
    invalidateEndStateRange(range) {
      this._invalidEndStatesLineNumbers.addRange(new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(range.startLineNumber, range.endLineNumberExclusive));
    }
    getFirstInvalidEndStateLineNumber() {
      return this._invalidEndStatesLineNumbers.min;
    }
    getFirstInvalidEndStateLineNumberOrMax() {
      return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
    }
    allStatesValid() {
      return this._invalidEndStatesLineNumbers.min === null;
    }
    getStartState(lineNumber, initialState) {
      return lineNumber === 1 ? initialState : this.getEndState(lineNumber - 1);
    }
    getFirstInvalidLine(initialState) {
      const lineNumber = this.getFirstInvalidEndStateLineNumber();
      if (lineNumber === null) {
        return null;
      }
      initialState = this.getStartState(lineNumber, initialState);
      if (!initialState) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Start state must be defined");
      }
      return {lineNumber, startState:initialState};
    }
  }
  class TokenizationStateStore {
    constructor() {
      this._lineEndStates = new require$_DOT__SLASH_fixedArray_DOT_js.FixedArray(null);
    }
    getEndState(lineNumber) {
      return this._lineEndStates.get(lineNumber);
    }
    setEndState(lineNumber, state) {
      const oldState = this._lineEndStates.get(lineNumber);
      if (oldState && oldState.equals(state)) {
        return !1;
      }
      this._lineEndStates.set(lineNumber, state);
      return !0;
    }
    acceptChange(range, newLineCount) {
      let length = range.length;
      newLineCount > 0 && length > 0 && (length--, newLineCount--);
      this._lineEndStates.replace(range.startLineNumber, length, newLineCount);
    }
  }
  class RangePriorityQueueImpl {
    constructor() {
      this._ranges = [];
    }
    get min() {
      return this._ranges.length === 0 ? null : this._ranges[0].start;
    }
    delete(value) {
      const idx = this._ranges.findIndex(r => r.contains(value));
      if (idx !== -1) {
        const range = this._ranges[idx];
        range.start === value ? range.endExclusive === value + 1 ? this._ranges.splice(idx, 1) : this._ranges[idx] = new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(value + 1, range.endExclusive) : range.endExclusive === value + 1 ? this._ranges[idx] = new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(range.start, value) : this._ranges.splice(idx, 1, new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(range.start, value), new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(value + 
        1, range.endExclusive));
      }
    }
    addRange(range) {
      require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange.addRange(range, this._ranges);
    }
    addRangeAndResize(range, newLength) {
      let idxFirstMightBeIntersecting = 0;
      for (; !(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive);) {
        idxFirstMightBeIntersecting++;
      }
      for (var idxFirstIsAfter = idxFirstMightBeIntersecting; !(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start);) {
        idxFirstIsAfter++;
      }
      const delta = newLength - range.length;
      for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {
        this._ranges[i] = this._ranges[i].delta(delta);
      }
      idxFirstMightBeIntersecting === idxFirstIsAfter ? (idxFirstIsAfter = new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(range.start, range.start + newLength), idxFirstIsAfter.isEmpty || this._ranges.splice(idxFirstMightBeIntersecting, 0, idxFirstIsAfter)) : (range = new require$_DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start), Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive) + 
      delta), range.isEmpty ? this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting) : this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, range));
    }
    toString() {
      return this._ranges.map(r => r.toString()).join(" + ");
    }
  }
  class DefaultBackgroundTokenizer {
    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {
      this._tokenizerWithStateStore = _tokenizerWithStateStore;
      this._backgroundTokenStore = _backgroundTokenStore;
      this._isScheduled = this._isDisposed = !1;
    }
    dispose() {
      this._isDisposed = !0;
    }
    handleChanges() {
      this._beginBackgroundTokenization();
    }
    _beginBackgroundTokenization() {
      !this._isScheduled && this._tokenizerWithStateStore._textModel.isAttachedToEditor() && this._hasLinesToTokenize() && (this._isScheduled = !0, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.runWhenGlobalIdle)(deadline => {
        this._isScheduled = !1;
        this._backgroundTokenizeWithDeadline(deadline);
      }));
    }
    _backgroundTokenizeWithDeadline(deadline) {
      const endTime = Date.now() + deadline.timeRemaining(), execute = () => {
        !this._isDisposed && this._tokenizerWithStateStore._textModel.isAttachedToEditor() && this._hasLinesToTokenize() && (this._backgroundTokenizeForAtLeast1ms(), Date.now() < endTime ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_platform_DOT_js.setTimeout0)(execute) : this._beginBackgroundTokenization());
      };
      execute();
    }
    _backgroundTokenizeForAtLeast1ms() {
      const lineCount = this._tokenizerWithStateStore._textModel.getLineCount(), builder = new require$_DOT__DOT__SLASH_tokens_SLASH_contiguousMultilineTokensBuilder_DOT_js.ContiguousMultilineTokensBuilder(), sw = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_stopwatch_DOT_js.StopWatch.create(!1);
      do {
        if (sw.elapsed() > 1) {
          break;
        }
        if (this._tokenizeOneInvalidLine(builder) >= lineCount) {
          break;
        }
      } while (this._hasLinesToTokenize());
      this._backgroundTokenStore.setTokens(builder.finalize());
      this.checkFinished();
    }
    _hasLinesToTokenize() {
      return this._tokenizerWithStateStore ? !this._tokenizerWithStateStore.store.allStatesValid() : !1;
    }
    _tokenizeOneInvalidLine(builder) {
      var _a;
      const firstInvalidLine = (_a = this._tokenizerWithStateStore) === null || _a === void 0 ? void 0 : _a.getFirstInvalidLine();
      if (!firstInvalidLine) {
        return this._tokenizerWithStateStore._textModel.getLineCount() + 1;
      }
      this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);
      return firstInvalidLine.lineNumber;
    }
    checkFinished() {
      this._isDisposed || this._tokenizerWithStateStore.store.allStatesValid() && this._backgroundTokenStore.backgroundTokenizationFinished();
    }
    requestTokens(startLineNumber, endLineNumberExclusive) {
      this._tokenizerWithStateStore.store.invalidateEndStateRange(new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(startLineNumber, endLineNumberExclusive));
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelTokens.js.map
