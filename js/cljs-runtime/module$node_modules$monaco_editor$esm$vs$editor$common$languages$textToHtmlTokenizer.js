shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$textToHtmlTokenizer = function(require, module, exports) {
  async function tokenizeToString(languageService, text, languageId) {
    if (!languageId) {
      return _tokenizeToString(text, languageService.languageIdCodec, fallback);
    }
    languageId = await require$_DOT__DOT__SLASH_languages_DOT_js.TokenizationRegistry.getOrCreate(languageId);
    return _tokenizeToString(text, languageService.languageIdCodec, languageId || fallback);
  }
  function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {
    let result = "\x3cdiv\x3e", charIndex = startOffset, tabsCharDelta = 0, prevIsSpace = !0;
    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {
      const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);
      if (tokenEndIndex <= startOffset) {
        continue;
      }
      let partContent = "";
      for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {
        var charCode = text.charCodeAt(charIndex);
        switch(charCode) {
          case 9:
            charCode = tabSize - (charIndex + tabsCharDelta) % tabSize;
            for (tabsCharDelta += charCode - 1; charCode > 0;) {
              useNbsp && prevIsSpace ? (partContent += "\x26#160;", prevIsSpace = !1) : (partContent += " ", prevIsSpace = !0), charCode--;
            }
            break;
          case 60:
            partContent += "\x26lt;";
            prevIsSpace = !1;
            break;
          case 62:
            partContent += "\x26gt;";
            prevIsSpace = !1;
            break;
          case 38:
            partContent += "\x26amp;";
            prevIsSpace = !1;
            break;
          case 0:
            partContent += "\x26#00;";
            prevIsSpace = !1;
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            partContent += "ï¿½";
            prevIsSpace = !1;
            break;
          case 13:
            partContent += "\x26#8203";
            prevIsSpace = !1;
            break;
          case 32:
            useNbsp && prevIsSpace ? (partContent += "\x26#160;", prevIsSpace = !1) : (partContent += " ", prevIsSpace = !0);
            break;
          default:
            partContent += String.fromCharCode(charCode), prevIsSpace = !1;
        }
      }
      result += `<span style="${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}">${partContent}</span>`;
      if (tokenEndIndex > endOffset || charIndex >= endOffset) {
        break;
      }
    }
    return result + "\x3c/div\x3e";
  }
  function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {
    let result = '\x3cdiv class\x3d"monaco-tokenized-source"\x3e';
    text = strings.splitLines(text);
    var currentState = tokenizationSupport.getInitialState();
    for (let i = 0, len = text.length; i < len; i++) {
      const line = text[i];
      i > 0 && (result += "\x3cbr/\x3e");
      currentState = tokenizationSupport.tokenizeEncoded(line, !0, currentState);
      require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens.convertToEndOffset(currentState.tokens, line.length);
      const viewLineTokens = (new require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens(currentState.tokens, line, languageIdCodec)).inflate();
      let startOffset = 0;
      for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {
        const type = viewLineTokens.getClassName(j), endIndex = viewLineTokens.getEndOffset(j);
        result += `<span class="${type}">${strings.escape(line.substring(startOffset, endIndex))}</span>`;
        startOffset = endIndex;
      }
      currentState = currentState.endState;
    }
    return result + "\x3c/div\x3e";
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, _tokenizeToString:{enumerable:!0, get:function() {
    return _tokenizeToString;
  }}, tokenizeLineToHTML:{enumerable:!0, get:function() {
    return tokenizeLineToHTML;
  }}, tokenizeToString:{enumerable:!0, get:function() {
    return tokenizeToString;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens"), require$_DOT__DOT__SLASH_languages_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages"), require$_DOT__SLASH_nullTokenize_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$nullTokenize");
  const fallback = {getInitialState:() => require$_DOT__SLASH_nullTokenize_DOT_js.NullState, tokenizeEncoded:(buffer, hasEOL, state) => (0,require$_DOT__SLASH_nullTokenize_DOT_js.nullTokenizeEncoded)(0, state)};
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$textToHtmlTokenizer.js.map
