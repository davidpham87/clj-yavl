shadow$provide.module$node_modules$vega_geo$build$vega_geo = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega_dataflow$build$vega_dataflow"), require("module$node_modules$vega_util$build$vega_util"), require("module$node_modules$vega_statistics$build$vega_statistics"), require("module$node_modules$vega_projection$build$vega_projection"), require("module$node_modules$vega_canvas$build$vega_canvas_browser")) : typeof define === "function" && define.amd ? define("exports vega-dataflow vega-util vega-statistics vega-projection vega-canvas".split(" "), 
    factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.vega, global.vega));
  })(this, function(exports, vegaDataflow, vegaUtil, vegaStatistics, vegaProjection, vegaCanvas) {
    function tickSpec(start, stop, count) {
      var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step));
      step /= Math.pow(10, power);
      step = step >= e10 ? 10 : step >= e5 ? 5 : step >= e2 ? 2 : 1;
      let inc;
      power < 0 ? (inc = Math.pow(10, -power) / step, power = Math.round(start * inc), step = Math.round(stop * inc), power / inc < start && ++power, step / inc > stop && --step, inc = -inc) : (inc = Math.pow(10, power) * step, power = Math.round(start / inc), step = Math.round(stop / inc), power * inc < start && ++power, step * inc > stop && --step);
      return step < power && 0.5 <= count && count < 2 ? tickSpec(start, stop, count * 2) : [power, step, inc];
    }
    function tickIncrement(start, stop, count) {
      return tickSpec(+start, +stop, +count)[2];
    }
    function max(values, valueof) {
      let max;
      for (const value of values) {
        value != null && (max < value || max === void 0 && value >= value) && (max = value);
      }
      return max;
    }
    function range(start, stop, step) {
      start = +start;
      stop = +stop;
      step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
      for (var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = Array(n); ++i < n;) {
        range[i] = start + i * step;
      }
      return range;
    }
    function sum(values, valueof) {
      valueof = 0;
      for (let value of values) {
        if (value = +value) {
          valueof += value;
        }
      }
      return valueof;
    }
    function noop() {
    }
    function contours() {
      function contours(values, tz) {
        return tz.map(value => contour(values, value));
      }
      function contour(values, value) {
        var polygons = [], holes = [];
        isorings(values, value, ring => {
          smooth(ring, values, value);
          for (var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1]; ++i < n;) {
            area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
          }
          area > 0 ? polygons.push([ring]) : holes.push(ring);
        });
        holes.forEach(hole => {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            a: {
              var JSCompiler_inline_result = (polygon = polygons[i])[0];
              for (var hole$jscomp$0 = hole, i$jscomp$0 = -1, n$jscomp$0 = hole$jscomp$0.length; ++i$jscomp$0 < n$jscomp$0;) {
                b: {
                  var c = JSCompiler_inline_result;
                  for (var point = hole$jscomp$0[i$jscomp$0], x = point[0], y = point[1], contains = -1, i$jscomp$1 = 0, n$jscomp$1 = c.length, j = n$jscomp$1 - 1; i$jscomp$1 < n$jscomp$1; j = i$jscomp$1++) {
                    var pi = c[i$jscomp$1], xi = pi[0], yi = pi[1], pj = c[j];
                    j = pj[0];
                    var yj = pj[1], i$jscomp$2, a = pi;
                    pi = pj;
                    pj = point;
                    if (i$jscomp$2 = (pi[0] - a[0]) * (pj[1] - a[1]) === (pj[0] - a[0]) * (pi[1] - a[1])) {
                      a = a[i$jscomp$2 = +(a[0] === pi[0])], pj = pj[i$jscomp$2], pi = pi[i$jscomp$2], i$jscomp$2 = a <= pj && pj <= pi || pi <= pj && pj <= a;
                    }
                    if (i$jscomp$2) {
                      c = 0;
                      break b;
                    }
                    yi > y !== yj > y && x < (j - xi) * (y - yi) / (yj - yi) + xi && (contains = -contains);
                  }
                  c = contains;
                }
                if (c) {
                  JSCompiler_inline_result = c;
                  break a;
                }
              }
              JSCompiler_inline_result = 0;
            }
            if (JSCompiler_inline_result !== -1) {
              polygon.push(hole);
              break;
            }
          }
        });
        return {type:"MultiPolygon", value, coordinates:polygons};
      }
      function isorings(values, value, callback) {
        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y];
          line = [line[1][0] + x, line[1][1] + y];
          var startIndex = start[0] * 2 + start[1] * (dx + 1) * 4, endIndex = line[0] * 2 + line[1] * (dx + 1) * 4, f, g;
          (f = fragmentByEnd[startIndex]) ? (g = fragmentByStart[endIndex]) ? (delete fragmentByEnd[f.end], delete fragmentByStart[g.start], f === g ? (f.ring.push(line), callback(f.ring)) : fragmentByStart[f.start] = fragmentByEnd[g.end] = {start:f.start, end:g.end, ring:f.ring.concat(g.ring)}) : (delete fragmentByEnd[f.end], f.ring.push(line), fragmentByEnd[f.end = endIndex] = f) : (f = fragmentByStart[endIndex]) ? (g = fragmentByEnd[startIndex]) ? (delete fragmentByStart[f.start], delete fragmentByEnd[g.end], 
          f === g ? (f.ring.push(line), callback(f.ring)) : fragmentByStart[g.start] = fragmentByEnd[f.end] = {start:g.start, end:f.end, ring:g.ring.concat(f.ring)}) : (delete fragmentByStart[f.start], f.ring.unshift(start), fragmentByStart[f.start = startIndex] = f) : fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start:startIndex, end:endIndex, ring:[start, line]};
        }
        var fragmentByStart = [], fragmentByEnd = [], y;
        var x = y = -1;
        var t1 = values[0] >= value;
        for (cases[t1 << 1].forEach(stitch); ++x < dx - 1;) {
          var t0 = t1;
          t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        for (cases[t1 << 0].forEach(stitch); ++y < dy - 1;) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          var t2 = values[y * dx] >= value;
          for (cases[t1 << 1 | t2 << 2].forEach(stitch); ++x < dx - 1;) {
            t0 = t1;
            t1 = values[y * dx + dx + x + 1] >= value;
            var t3 = t2;
            t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }
        x = -1;
        t2 = values[y * dx] >= value;
        for (cases[t2 << 2].forEach(stitch); ++x < dx - 1;) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value, cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);
      }
      function smoothLinear(ring, values, value) {
        ring.forEach(point => {
          var x = point[0], y = point[1], xt = x | 0, yt = y | 0, v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            var v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          y > 0 && y < dy && yt === y && (v0 = values[(yt - 1) * dx + xt], point[1] = y + (value - v0) / (v1 - v0) - 0.5);
        });
      }
      var dx = 1, dy = 1, smooth = smoothLinear;
      contours.contour = contour;
      contours.size = function(_) {
        if (!arguments.length) {
          return [dx, dy];
        }
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        _0 >= 0 && _1 >= 0 || vegaUtil.error("invalid size");
        return dx = _0, dy = _1, contours;
      };
      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
      };
      return contours;
    }
    function quantize(k, nice, zero) {
      return function(values) {
        var ex = vegaUtil.extent(values);
        values = zero ? Math.min(ex[0], 0) : ex[0];
        ex = ex[1];
        var span = ex - values;
        if (nice) {
          var count = k;
          var stop = +ex;
          var start = +values;
          count = +count;
          start = (span = stop < start) ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
          span = (span ? -1 : 1) * (start < 0 ? 1 / -start : start);
        } else {
          span /= k + 1;
        }
        return range(values + span, ex, span);
      };
    }
    function Isocontour(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function levels(values, f, _) {
      const q = quantize(_.levels || 10, _.nice, _.zero !== !1);
      return _.resolve !== "shared" ? q : q(values.map(t => max(f(t).values)));
    }
    function transformPaths(paths, grid, datum, _) {
      var s = _.scale || grid.scale;
      let t = _.translate || grid.translate;
      vegaUtil.isFunction(s) && (s = s(datum, _));
      vegaUtil.isFunction(t) && (t = t(datum, _));
      if (s !== 1 && s != null || t) {
        datum = (vegaUtil.isNumber(s) ? s : s[0]) || 1, s = (vegaUtil.isNumber(s) ? s : s[1]) || 1, paths.forEach(transform(grid, datum, s, t && t[0] || 0, t && t[1] || 0));
      }
    }
    function transform(grid, sx, sy, tx, ty) {
      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }
      function transformRing(coordinates) {
        flip && coordinates.reverse();
        coordinates.forEach(transformPoint);
      }
      function transformPoint(coordinates) {
        coordinates[0] = (coordinates[0] - x1) * sx + tx;
        coordinates[1] = (coordinates[1] - y1) * sy + ty;
      }
      const x1 = grid.x1 || 0, y1 = grid.y1 || 0, flip = sx * sy < 0;
      return function(geometry) {
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      };
    }
    function radius(bw, data, f) {
      bw = bw >= 0 ? bw : vegaStatistics.bandwidthNRD(data, f);
      return Math.round((Math.sqrt(4 * bw * bw + 1) - 1) / 2);
    }
    function number(_) {
      return vegaUtil.isFunction(_) ? _ : vegaUtil.constant(+_);
    }
    function density2D() {
      function density(data, counts) {
        const rx = radius(bandwidth[0], data, x) >> k, ry = radius(bandwidth[1], data, y) >> k, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k), m = 2 * oy + (dy >> k), values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
        let values = values0;
        data.forEach(d => {
          const xi = ox + (+x(d) >> k), yi = oy + (+y(d) >> k);
          xi >= 0 && xi < n && yi >= 0 && yi < m && (values0[xi + yi * n] += +weight(d));
        });
        rx > 0 && ry > 0 ? (blurX(n, m, values0, values1, rx), blurY(n, m, values1, values0, ry), blurX(n, m, values0, values1, rx), blurY(n, m, values1, values0, ry), blurX(n, m, values0, values1, rx), blurY(n, m, values1, values0, ry)) : rx > 0 ? (blurX(n, m, values0, values1, rx), blurX(n, m, values1, values0, rx), blurX(n, m, values0, values1, rx), values = values1) : ry > 0 && (blurY(n, m, values0, values1, ry), blurY(n, m, values1, values0, ry), blurY(n, m, values0, values1, ry), values = values1);
        data = counts ? Math.pow(2, -2 * k) : 1 / sum(values);
        for (let i = 0, sz = n * m; i < sz; ++i) {
          values[i] *= data;
        }
        return {values, scale:1 << k, width:n, height:m, x1:ox, y1:oy, x2:ox + (dx >> k), y2:oy + (dy >> k)};
      }
      var x = d => d[0], y = d => d[1], weight = vegaUtil.one, bandwidth = [-1, -1], dx = 960, dy = 500, k = 2;
      density.x = function(_) {
        return arguments.length ? (x = number(_), density) : x;
      };
      density.y = function(_) {
        return arguments.length ? (y = number(_), density) : y;
      };
      density.weight = function(_) {
        return arguments.length ? (weight = number(_), density) : weight;
      };
      density.size = function(_) {
        if (!arguments.length) {
          return [dx, dy];
        }
        var _0 = +_[0], _1 = +_[1];
        _0 >= 0 && _1 >= 0 || vegaUtil.error("invalid size");
        return dx = _0, dy = _1, density;
      };
      density.cellSize = function(_) {
        if (!arguments.length) {
          return 1 << k;
        }
        (_ = +_) >= 1 || vegaUtil.error("invalid cell size");
        k = Math.floor(Math.log(_) / Math.LN2);
        return density;
      };
      density.bandwidth = function(_) {
        if (!arguments.length) {
          return bandwidth;
        }
        _ = vegaUtil.array(_);
        _.length === 1 && (_ = [+_[0], +_[0]]);
        _.length !== 2 && vegaUtil.error("invalid bandwidth");
        return bandwidth = _, density;
      };
      return density;
    }
    function blurX(n, m, source, target, r) {
      const w = (r << 1) + 1;
      for (let j = 0; j < m; ++j) {
        for (let i = 0, sr = 0; i < n + r; ++i) {
          i < n && (sr += source[i + j * n]), i >= r && (i >= w && (sr -= source[i - w + j * n]), target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w));
        }
      }
    }
    function blurY(n, m, source, target, r) {
      const w = (r << 1) + 1;
      for (let i = 0; i < n; ++i) {
        for (let j = 0, sr = 0; j < m + r; ++j) {
          j < m && (sr += source[i + j * n]), j >= r && (j >= w && (sr -= source[i + (j - w) * n]), target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w));
        }
      }
    }
    function KDE2D(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function params(obj, _) {
      PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);
      return obj;
    }
    function partition(data, groupby) {
      var groups = [], get = f => f(t), n;
      if (groupby == null) {
        groups.push(data);
      } else {
        var map = {};
        var i = 0;
        for (n = data.length; i < n; ++i) {
          var t = data[i];
          var k = groupby.map(get);
          var g = map[k];
          g || (map[k] = g = [], g.dims = k, groups.push(g));
          g.push(t);
        }
      }
      return groups;
    }
    function Contour(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function GeoJSON(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function GeoPath(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function initPath(path, pointRadius) {
      const prev = path.pointRadius();
      path.context(null);
      pointRadius != null && path.pointRadius(pointRadius);
      return prev;
    }
    function GeoPoint(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function GeoShape(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function shapeGenerator(path, field, pointRadius) {
      const shape = pointRadius == null ? _ => path(field(_)) : _ => {
        var prev = path.pointRadius();
        _ = path.pointRadius(pointRadius)(field(_));
        path.pointRadius(prev);
        return _;
      };
      shape.context = _ => {
        path.context(_);
        return shape;
      };
      return shape;
    }
    function graticuleX(y0, y1, dy) {
      var y = range(y0, y1 - 1e-6, dy).concat(y1);
      return function(x) {
        return y.map(function(y) {
          return [x, y];
        });
      };
    }
    function graticuleY(x0, x1, dx) {
      var x = range(x0, x1 - 1e-6, dx).concat(x1);
      return function(y) {
        return x.map(function(x) {
          return [x, y];
        });
      };
    }
    function graticule() {
      function graticule() {
        return {type:"MultiLineString", coordinates:lines()};
      }
      function lines() {
        return range(ceil(X0 / DX) * DX, X1, DX).map(X).concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
          return abs(x % DX) > 1e-6;
        }).map(x)).concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
          return abs(y % DY) > 1e-6;
        }).map(y));
      }
      var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
      graticule.lines = function() {
        return lines().map(function(coordinates) {
          return {type:"LineString", coordinates};
        });
      };
      graticule.outline = function() {
        return {type:"Polygon", coordinates:[X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]};
      };
      graticule.extent = function(_) {
        return arguments.length ? graticule.extentMajor(_).extentMinor(_) : graticule.extentMinor();
      };
      graticule.extentMajor = function(_) {
        if (!arguments.length) {
          return [[X0, Y0], [X1, Y1]];
        }
        X0 = +_[0][0];
        X1 = +_[1][0];
        Y0 = +_[0][1];
        Y1 = +_[1][1];
        X0 > X1 && (_ = X0, X0 = X1, X1 = _);
        Y0 > Y1 && (_ = Y0, Y0 = Y1, Y1 = _);
        return graticule.precision(precision);
      };
      graticule.extentMinor = function(_) {
        if (!arguments.length) {
          return [[x0, y0], [x1, y1]];
        }
        x0 = +_[0][0];
        x1 = +_[1][0];
        y0 = +_[0][1];
        y1 = +_[1][1];
        x0 > x1 && (_ = x0, x0 = x1, x1 = _);
        y0 > y1 && (_ = y0, y0 = y1, y1 = _);
        return graticule.precision(precision);
      };
      graticule.step = function(_) {
        return arguments.length ? graticule.stepMajor(_).stepMinor(_) : graticule.stepMinor();
      };
      graticule.stepMajor = function(_) {
        if (!arguments.length) {
          return [DX, DY];
        }
        DX = +_[0];
        DY = +_[1];
        return graticule;
      };
      graticule.stepMinor = function(_) {
        if (!arguments.length) {
          return [dx, dy];
        }
        dx = +_[0];
        dy = +_[1];
        return graticule;
      };
      graticule.precision = function(_) {
        if (!arguments.length) {
          return precision;
        }
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };
      return graticule.extentMajor([[-180, -89.999999], [180, 89.999999]]).extentMinor([[-180, -80.000001], [180, 80.000001]]);
    }
    function Graticule(params) {
      vegaDataflow.Transform.call(this, [], params);
      this.generator = graticule();
    }
    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      parent = Object.create(parent.prototype);
      for (var key in definition) {
        parent[key] = definition[key];
      }
      return parent;
    }
    function Color() {
    }
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? 
      new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : 
      null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
    }
    function rgba(r, g, b, a) {
      a <= 0 && (r = g = b = NaN);
      return new Rgb(r, g, b, a);
    }
    function rgb(r, g, b, opacity) {
      if (arguments.length === 1) {
        var JSCompiler_temp = r;
        JSCompiler_temp instanceof Color || (JSCompiler_temp = color(JSCompiler_temp));
        JSCompiler_temp ? (JSCompiler_temp = JSCompiler_temp.rgb(), JSCompiler_temp = new Rgb(JSCompiler_temp.r, JSCompiler_temp.g, JSCompiler_temp.b, JSCompiler_temp.opacity)) : JSCompiler_temp = new Rgb();
      } else {
        JSCompiler_temp = new Rgb(r, g, b, opacity == null ? 1 : opacity);
      }
      return JSCompiler_temp;
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }
    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h, s, l, a) {
      a <= 0 ? h = s = l = NaN : l <= 0 || l >= 1 ? h = s = NaN : s <= 0 && (h = NaN);
      return new Hsl(h, s, l, a);
    }
    function hslConvert(o) {
      if (o instanceof Hsl) {
        return new Hsl(o.h, o.s, o.l, o.opacity);
      }
      o instanceof Color || (o = color(o));
      if (!o) {
        return new Hsl();
      }
      if (o instanceof Hsl) {
        return o;
      }
      o = o.rgb();
      var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
      s ? (h = r === max ? (g - b) / s + (g < b) * 6 : g === max ? (b - r) / s + 2 : (r - g) / s + 4, s /= l < 0.5 ? max + min : 2 - max - min, h *= 60) : s = l > 0 && l < 1 ? 0 : h;
      return new Hsl(h, s, l, o.opacity);
    }
    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }
    function Heatmap(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function color_(color, _) {
      let f;
      vegaUtil.isFunction(color) ? (f = obj => rgb(color(obj, _)), f.dep = dependency(color)) : f = vegaUtil.constant(rgb(color || "#888"));
      return f;
    }
    function opacity_(opacity, _) {
      let f;
      vegaUtil.isFunction(opacity) ? (f = obj => opacity(obj, _), f.dep = dependency(opacity)) : opacity ? f = vegaUtil.constant(opacity) : (f = obj => obj.$value / obj.$max || 0, f.dep = !0);
      return f;
    }
    function dependency(f) {
      if (!vegaUtil.isFunction(f)) {
        return !1;
      }
      f = vegaUtil.toSet(vegaUtil.accessorFields(f));
      return f.$x || f.$y || f.$value || f.$max;
    }
    function toCanvas(grid, obj, color, opacity) {
      const n = grid.width;
      var m = grid.height;
      const x1 = grid.x1 || 0, y1 = grid.y1 || 0, x2 = grid.x2 || n;
      m = grid.y2 || m;
      const val = grid.values;
      grid = val ? i => val[i] : vegaUtil.zero;
      const can = vegaCanvas.canvas(x2 - x1, m - y1), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x2 - x1, m - y1), pix = img.data;
      for (let j = y1, k = 0; j < m; ++j) {
        obj.$y = j - y1;
        for (let i = x1, r = j * n; i < x2; ++i, k += 4) {
          obj.$x = i - x1;
          obj.$value = grid(i + r);
          const v = color(obj);
          pix[k + 0] = v.r;
          pix[k + 1] = v.g;
          pix[k + 2] = v.b;
          pix[k + 3] = ~~(255 * opacity(obj));
        }
      }
      ctx.putImageData(img, 0, 0);
      return can;
    }
    function Projection(params) {
      vegaDataflow.Transform.call(this, null, params);
      this.modified(!0);
    }
    function fit(proj, _) {
      const data = collectGeoJSON(_.fit);
      _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;
    }
    function create(type) {
      const constructor = vegaProjection.projection((type || "mercator").toLowerCase());
      constructor || vegaUtil.error("Unrecognized projection type: " + type);
      return constructor();
    }
    function collectGeoJSON(data) {
      data = vegaUtil.array(data);
      return data.length === 1 ? data[0] : {type:"FeatureCollection", features:data.reduce((a, f) => a.concat(featurize(f)), [])};
    }
    function featurize(f) {
      return f.type === "FeatureCollection" ? f.features : vegaUtil.array(f).filter(d => d != null).map(d => d.type === "Feature" ? d : {type:"Feature", geometry:d});
    }
    const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2), cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 
    1.0], [1.0, 1.5]]], []];
    Isocontour.Definition = {type:"Isocontour", metadata:{generates:!0}, params:[{name:"field", type:"field"}, {name:"thresholds", type:"number", array:!0}, {name:"levels", type:"number"}, {name:"nice", type:"boolean", "default":!1}, {name:"resolve", type:"enum", values:["shared", "independent"], "default":"independent"}, {name:"zero", type:"boolean", "default":!0}, {name:"smooth", type:"boolean", "default":!0}, {name:"scale", type:"number", expr:!0}, {name:"translate", type:"number", array:!0, expr:!0}, 
    {name:"as", type:"string", "null":!0, "default":"contour"}]};
    vegaUtil.inherits(Isocontour, vegaDataflow.Transform, {transform(_, pulse) {
      if (this.value && !pulse.changed() && !_.modified()) {
        return pulse.StopPropagation;
      }
      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      pulse = pulse.materialize(pulse.SOURCE).source;
      var field = _.field || vegaUtil.identity, contour = contours().smooth(_.smooth !== !1), tz = _.thresholds || levels(pulse, field, _), as = _.as === null ? null : _.as || "contour", values = [];
      pulse.forEach(t => {
        const grid = field(t), paths = contour.size([grid.width, grid.height])(grid.values, vegaUtil.isArray(tz) ? tz : tz(grid.values));
        transformPaths(paths, grid, t, _);
        paths.forEach(p => {
          values.push(vegaDataflow.rederive(t, vegaDataflow.ingest(as != null ? {[as]:p} : p)));
        });
      });
      this.value && (out.rem = this.value);
      this.value = out.source = out.add = values;
      return out;
    }});
    KDE2D.Definition = {type:"KDE2D", metadata:{generates:!0}, params:[{name:"size", type:"number", array:!0, length:2, required:!0}, {name:"x", type:"field", required:!0}, {name:"y", type:"field", required:!0}, {name:"weight", type:"field"}, {name:"groupby", type:"field", array:!0}, {name:"cellSize", type:"number"}, {name:"bandwidth", type:"number", array:!0, length:2}, {name:"counts", type:"boolean", "default":!1}, {name:"as", type:"string", "default":"grid"}]};
    const PARAMS = "x y weight size cellSize bandwidth".split(" ");
    vegaUtil.inherits(KDE2D, vegaDataflow.Transform, {transform(_, pulse) {
      if (this.value && !pulse.changed() && !_.modified()) {
        return pulse.StopPropagation;
      }
      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      pulse = pulse.materialize(pulse.SOURCE).source;
      pulse = partition(pulse, _.groupby);
      var names = (_.groupby || []).map(vegaUtil.accessorName), kde = params(density2D(), _), as = _.as || "grid", values = [];
      values = pulse.map(g => {
        var JSCompiler_temp_const = vegaDataflow.ingest, t = {[as]:kde(g, _.counts)};
        g = g.dims;
        for (let i = 0; i < names.length; ++i) {
          t[names[i]] = g[i];
        }
        return JSCompiler_temp_const.call(vegaDataflow, t);
      });
      this.value && (out.rem = this.value);
      this.value = out.source = out.add = values;
      return out;
    }});
    Contour.Definition = {type:"Contour", metadata:{generates:!0}, params:[{name:"size", type:"number", array:!0, length:2, required:!0}, {name:"values", type:"number", array:!0}, {name:"x", type:"field"}, {name:"y", type:"field"}, {name:"weight", type:"field"}, {name:"cellSize", type:"number"}, {name:"bandwidth", type:"number"}, {name:"count", type:"number"}, {name:"nice", type:"boolean", "default":!1}, {name:"thresholds", type:"number", array:!0}, {name:"smooth", type:"boolean", "default":!0}]};
    vegaUtil.inherits(Contour, vegaDataflow.Transform, {transform(_, pulse) {
      if (this.value && !pulse.changed() && !_.modified()) {
        return pulse.StopPropagation;
      }
      var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS), contour = contours().smooth(_.smooth !== !1), values = _.values, thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values), size = _.size;
      if (!values) {
        values = pulse.materialize(pulse.SOURCE).source;
        _ = params(density2D(), _)(values, !0);
        var post = transform(_, _.scale || 1, _.scale || 1, 0, 0);
        size = [_.width, _.height];
        values = _.values;
      }
      thresh = vegaUtil.isArray(thresh) ? thresh : thresh(values);
      values = contour.size(size)(values, thresh);
      post && values.forEach(post);
      this.value && (out.rem = this.value);
      this.value = out.source = out.add = (values || []).map(vegaDataflow.ingest);
      return out;
    }});
    GeoJSON.Definition = {type:"GeoJSON", metadata:{}, params:[{name:"fields", type:"field", array:!0, length:2}, {name:"geojson", type:"field"}]};
    vegaUtil.inherits(GeoJSON, vegaDataflow.Transform, {transform(_, pulse) {
      var features = this._features, points = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && vegaUtil.identity;
      fields = pulse.ADD;
      _ = _.modified() || pulse.changed(pulse.REM) || pulse.modified(vegaUtil.accessorFields(geojson)) || lon && pulse.modified(vegaUtil.accessorFields(lon)) || lat && pulse.modified(vegaUtil.accessorFields(lat));
      if (!this.value || _) {
        fields = pulse.SOURCE, this._features = features = [], this._points = points = [];
      }
      geojson && pulse.visit(fields, t => features.push(geojson(t)));
      lon && lat && (pulse.visit(fields, t => {
        var x = lon(t);
        t = lat(t);
        x != null && t != null && (x = +x) === x && (t = +t) === t && points.push([x, t]);
      }), features = features.concat({type:"Feature", geometry:{type:"MultiPoint", coordinates:points}}));
      this.value = {type:"FeatureCollection", features};
    }});
    GeoPath.Definition = {type:"GeoPath", metadata:{modifies:!0}, params:[{name:"projection", type:"projection"}, {name:"field", type:"field"}, {name:"pointRadius", type:"number", expr:!0}, {name:"as", type:"string", "default":"path"}]};
    vegaUtil.inherits(GeoPath, vegaDataflow.Transform, {transform(_, pulse) {
      var out = pulse.fork(pulse.ALL), path = this.value, field = _.field || vegaUtil.identity, as = _.as || "path", flag = out.SOURCE;
      !path || _.modified() ? (this.value = path = vegaProjection.getProjectionPath(_.projection), out.materialize().reflow()) : flag = field === vegaUtil.identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;
      _ = initPath(path, _.pointRadius);
      out.visit(flag, t => t[as] = path(field(t)));
      path.pointRadius(_);
      return out.modifies(as);
    }});
    GeoPoint.Definition = {type:"GeoPoint", metadata:{modifies:!0}, params:[{name:"projection", type:"projection", required:!0}, {name:"fields", type:"field", array:!0, required:!0, length:2}, {name:"as", type:"string", array:!0, length:2, "default":["x", "y"]}]};
    vegaUtil.inherits(GeoPoint, vegaDataflow.Transform, {transform(_, pulse) {
      function set(t) {
        const xy = proj([lon(t), lat(t)]);
        xy ? (t[x] = xy[0], t[y] = xy[1]) : (t[x] = void 0, t[y] = void 0);
      }
      var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x = as[0], y = as[1];
      _.modified() ? pulse = pulse.materialize().reflow(!0).visit(pulse.SOURCE, set) : (_ = pulse.modified(lon.fields) || pulse.modified(lat.fields), pulse.visit(_ ? pulse.ADD_MOD : pulse.ADD, set));
      return pulse.modifies(as);
    }});
    GeoShape.Definition = {type:"GeoShape", metadata:{modifies:!0, nomod:!0}, params:[{name:"projection", type:"projection"}, {name:"field", type:"field", "default":"datum"}, {name:"pointRadius", type:"number", expr:!0}, {name:"as", type:"string", "default":"shape"}]};
    vegaUtil.inherits(GeoShape, vegaDataflow.Transform, {transform(_, pulse) {
      pulse = pulse.fork(pulse.ALL);
      var shape = this.value, as = _.as || "shape", flag = pulse.ADD;
      if (!shape || _.modified()) {
        this.value = shape = shapeGenerator(vegaProjection.getProjectionPath(_.projection), _.field || vegaUtil.field("datum"), _.pointRadius), pulse.materialize().reflow(), flag = pulse.SOURCE;
      }
      pulse.visit(flag, t => t[as] = shape);
      return pulse.modifies(as);
    }});
    var abs = Math.abs, ceil = Math.ceil;
    Graticule.Definition = {type:"Graticule", metadata:{changes:!0, generates:!0}, params:[{name:"extent", type:"array", array:!0, length:2, content:{type:"number", array:!0, length:2}}, {name:"extentMajor", type:"array", array:!0, length:2, content:{type:"number", array:!0, length:2}}, {name:"extentMinor", type:"array", array:!0, length:2, content:{type:"number", array:!0, length:2}}, {name:"step", type:"number", array:!0, length:2}, {name:"stepMajor", type:"number", array:!0, length:2, "default":[90, 
    360]}, {name:"stepMinor", type:"number", array:!0, length:2, "default":[10, 10]}, {name:"precision", type:"number", "default":2.5}]};
    vegaUtil.inherits(Graticule, vegaDataflow.Transform, {transform(_, pulse) {
      var src = this.value, gen = this.generator;
      if (!src.length || _.modified()) {
        for (const prop in _) {
          if (vegaUtil.isFunction(gen[prop])) {
            gen[prop](_[prop]);
          }
        }
      }
      _ = gen();
      src.length ? pulse.mod.push(vegaDataflow.replace(src[0], _)) : pulse.add.push(vegaDataflow.ingest(_));
      src[0] = _;
      return pulse;
    }});
    var brighter = 1 / 0.7, reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = RegExp("^rgb\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*\\)$"), reRgbPercent = RegExp("^rgb\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*\\)$"), reRgbaInteger = RegExp("^rgba\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"), reRgbaPercent = 
    RegExp("^rgba\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"), reHslPercent = RegExp("^hsl\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*\\)$"), reHslaPercent = RegExp("^hsla\\(\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*,\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*\\)$"), 
    named = {aliceblue:15792383, antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, darkkhaki:12433259, 
    darkmagenta:9109643, darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, goldenrod:14329120, 
    gray:8421504, green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, lightslategray:7833753, 
    lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, oldlace:16643558, olive:8421376, 
    olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, rebeccapurple:6697881, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, silver:12632256, skyblue:8900331, 
    slateblue:6970061, slategray:7372944, slategrey:7372944, snow:16775930, springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074};
    define(Color, color, {copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    }, displayable() {
      return this.rgb().displayable();
    }, hex:color_formatHex, formatHex:color_formatHex, formatHex8:function() {
      return this.rgb().formatHex8();
    }, formatHsl:function() {
      return hslConvert(this).formatHsl();
    }, formatRgb:color_formatRgb, toString:color_formatRgb});
    define(Rgb, rgb, extend(Color, {brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    }, darker(k) {
      k = k == null ? 0.7 : Math.pow(0.7, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    }, rgb() {
      return this;
    }, clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    }, displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    }, hex:rgb_formatHex, formatHex:rgb_formatHex, formatHex8:function() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }, formatRgb:rgb_formatRgb, toString:rgb_formatRgb}));
    define(Hsl, function(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }, extend(Color, {brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    }, darker(k) {
      k = k == null ? 0.7 : Math.pow(0.7, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    }, rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l;
      s = l + (l < 0.5 ? l : 1 - l) * s;
      l = 2 * l - s;
      return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, l, s), hsl2rgb(h, l, s), hsl2rgb(h < 120 ? h + 240 : h - 120, l, s), this.opacity);
    }, clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    }, displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    }, formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }}));
    Heatmap.Definition = {type:"heatmap", metadata:{modifies:!0}, params:[{name:"field", type:"field"}, {name:"color", type:"string", expr:!0}, {name:"opacity", type:"number", expr:!0}, {name:"resolve", type:"enum", values:["shared", "independent"], "default":"independent"}, {name:"as", type:"string", "default":"image"}]};
    vegaUtil.inherits(Heatmap, vegaDataflow.Transform, {transform(_, pulse) {
      if (!pulse.changed() && !_.modified()) {
        return pulse.StopPropagation;
      }
      var source = pulse.materialize(pulse.SOURCE).source, shared = _.resolve === "shared", field = _.field || vegaUtil.identity, opacity = opacity_(_.opacity, _), color = color_(_.color, _), as = _.as || "image", obj = {$x:0, $y:0, $value:0, $max:shared ? max(source.map(t => max(field(t).values))) : 0};
      source.forEach(t => {
        const v = field(t), o = vegaUtil.extend({}, t, obj);
        shared || (o.$max = max(v.values || []));
        t[as] = toCanvas(v, o, color.dep ? color : vegaUtil.constant(color(o)), opacity.dep ? opacity : vegaUtil.constant(opacity(o)));
      });
      return pulse.reflow(!0).modifies(as);
    }});
    vegaUtil.inherits(Projection, vegaDataflow.Transform, {transform(_, pulse) {
      let proj$jscomp$0 = this.value;
      !proj$jscomp$0 || _.modified("type") ? (this.value = proj$jscomp$0 = create(_.type), vegaProjection.projectionProperties.forEach(prop => {
        if (_[prop] != null) {
          var proj = proj$jscomp$0, value = _[prop];
          if (vegaUtil.isFunction(proj[prop])) {
            proj[prop](value);
          }
        }
      })) : vegaProjection.projectionProperties.forEach(prop => {
        if (_.modified(prop)) {
          var proj = proj$jscomp$0, value = _[prop];
          if (vegaUtil.isFunction(proj[prop])) {
            proj[prop](value);
          }
        }
      });
      _.pointRadius != null && proj$jscomp$0.path.pointRadius(_.pointRadius);
      _.fit && fit(proj$jscomp$0, _);
      return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    }});
    exports.contour = Contour;
    exports.geojson = GeoJSON;
    exports.geopath = GeoPath;
    exports.geopoint = GeoPoint;
    exports.geoshape = GeoShape;
    exports.graticule = Graticule;
    exports.heatmap = Heatmap;
    exports.isocontour = Isocontour;
    exports.kde2d = KDE2D;
    exports.projection = Projection;
  });
};

//# sourceMappingURL=module$node_modules$vega_geo$build$vega_geo.js.map
