shadow$provide.module$node_modules$vega_lite$build$vega_lite = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega$build$vega_node")) : typeof define === "function" && define.amd ? define(["exports", "vega"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.vegaLite = {}, global.vega));
  })(this, function(exports, vega) {
    function forEachLeaf(op, fn) {
      if (hasProperty(op, "not")) {
        forEachLeaf(op.not, fn);
      } else if (hasProperty(op, "and")) {
        for (const subop of op.and) {
          forEachLeaf(subop, fn);
        }
      } else if (hasProperty(op, "or")) {
        for (const subop of op.or) {
          forEachLeaf(subop, fn);
        }
      } else {
        fn(op);
      }
    }
    function normalizeLogicalComposition(op, normalizer) {
      return hasProperty(op, "not") ? {not:normalizeLogicalComposition(op.not, normalizer)} : hasProperty(op, "and") ? {and:op.and.map(o => normalizeLogicalComposition(o, normalizer))} : hasProperty(op, "or") ? {or:op.or.map(o => normalizeLogicalComposition(o, normalizer))} : normalizer(op);
    }
    function never(message) {
      throw Error(message);
    }
    function pick(obj, props) {
      const copy = {};
      for (const prop of props) {
        vega.hasOwnProperty(obj, prop) && (copy[prop] = obj[prop]);
      }
      return copy;
    }
    function omit(obj, props) {
      obj = {...obj};
      for (const prop of props) {
        delete obj[prop];
      }
      return obj;
    }
    function hash(a) {
      if (vega.isNumber(a)) {
        return a;
      }
      a = vega.isString(a) ? a : stringify(a);
      if (a.length < 250) {
        return a;
      }
      let h = 0;
      for (let i = 0; i < a.length; i++) {
        const char = a.charCodeAt(i);
        h = (h << 5) - h + char;
        h &= h;
      }
      return h;
    }
    function isNullOrFalse(x) {
      return x === !1 || x === null;
    }
    function contains(array, item) {
      return array.includes(item);
    }
    function some(arr, f) {
      let i = 0;
      for (const [k, a] of arr.entries()) {
        if (f(a, k, i++)) {
          return !0;
        }
      }
      return !1;
    }
    function every(arr, f) {
      let i = 0;
      for (const [k, a] of arr.entries()) {
        if (!f(a, k, i++)) {
          return !1;
        }
      }
      return !0;
    }
    function mergeDeep(dest) {
      for (var _len = arguments.length, src = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        src[_key - 1] = arguments[_key];
      }
      for (const s of src) {
        _len = dest;
        src = s ?? {};
        for (const property of keys(src)) {
          vega.writeConfig(_len, property, src[property], !0);
        }
      }
      return dest;
    }
    function unique(values, f) {
      const results = [], u = {};
      for (const val of values) {
        values = f(val), values in u || (u[values] = 1, results.push(val));
      }
      return results;
    }
    function setEqual(a, b) {
      if (a.size !== b.size) {
        return !1;
      }
      for (const e of a) {
        if (!b.has(e)) {
          return !1;
        }
      }
      return !0;
    }
    function hasIntersection(a, b) {
      for (const key of a) {
        if (b.has(key)) {
          return !0;
        }
      }
      return !1;
    }
    function prefixGenerator(a) {
      const prefixes = new Set();
      for (const x of a) {
        const wrappedWithAccessors = vega.splitAccessPath(x).map((y, i) => i === 0 ? y : `[${y}]`);
        a = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
        for (const y of a) {
          prefixes.add(y);
        }
      }
      return prefixes;
    }
    function fieldIntersection(a, b) {
      return a === void 0 || b === void 0 ? !0 : hasIntersection(prefixGenerator(a), prefixGenerator(b));
    }
    function isEmpty(obj) {
      return keys(obj).length === 0;
    }
    function isBoolean(b) {
      return b === !0 || b === !1;
    }
    function varName(s) {
      const alphanumericS = s.replace(/\W/g, "_");
      return (s.match(/^\d+/) ? "_" : "") + alphanumericS;
    }
    function logicalExpr(op, cb) {
      return hasProperty(op, "not") ? `!(${logicalExpr(op.not, cb)})` : hasProperty(op, "and") ? `(${op.and.map(and => logicalExpr(and, cb)).join(") \x26\x26 (")})` : hasProperty(op, "or") ? `(${op.or.map(or => logicalExpr(or, cb)).join(") || (")})` : cb(op);
    }
    function deleteNestedProperty(obj, orderedProps) {
      if (orderedProps.length === 0) {
        return !0;
      }
      const prop = orderedProps.shift();
      prop in obj && deleteNestedProperty(obj[prop], orderedProps) && delete obj[prop];
      return isEmpty(obj);
    }
    function titleCase(s) {
      return s.charAt(0).toUpperCase() + s.substr(1);
    }
    function accessPathWithDatum(path) {
      let datum = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "datum";
      const pieces = vega.splitAccessPath(path), prefixes = [];
      for (let i = 1; i <= pieces.length; i++) {
        const prefix = `[${pieces.slice(0, i).map(vega.stringValue).join("][")}]`;
        prefixes.push(`${datum}${prefix}`);
      }
      return prefixes.join(" \x26\x26 ");
    }
    function flatAccessWithDatum(path) {
      return `${arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "datum"}[${vega.stringValue(vega.splitAccessPath(path).join("."))}]`;
    }
    function accessWithDatumToUnescapedPath(unescapedPath) {
      return `datum['${unescapedPath.replaceAll("'", "\\'")}']`;
    }
    function escapePathAccess(string) {
      return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
    }
    function replacePathInField(path) {
      return `${vega.splitAccessPath(path).map(escapePathAccess).join("\\.")}`;
    }
    function replaceAll(string, find, replacement) {
      return string.replace(new RegExp(find.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$\x26"), "g"), replacement);
    }
    function removePathFromField(path) {
      return `${vega.splitAccessPath(path).join(".")}`;
    }
    function accessPathDepth(path) {
      return path ? vega.splitAccessPath(path).length : 0;
    }
    function getFirstDefined() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return args.find(a => a !== void 0);
    }
    function uniqueId(prefix) {
      const id = ++idCounter;
      return prefix ? String(prefix) + id : id;
    }
    function internalField(name) {
      return isInternalField(name) ? name : `__${name}`;
    }
    function isInternalField(name) {
      return name.startsWith("__");
    }
    function normalizeAngle(angle) {
      if (angle !== void 0) {
        return (angle % 360 + 360) % 360;
      }
    }
    function isNumeric(value) {
      return vega.isNumber(value) ? !0 : !isNaN(value) && !isNaN(parseFloat(value));
    }
    function deepEqual(a, b) {
      if (a === b) {
        return !0;
      }
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor.name !== b.constructor.name) {
          return !1;
        }
        var i;
        if (Array.isArray(a)) {
          var length = a.length;
          if (length != b.length) {
            return !1;
          }
          for (i = length; i-- !== 0;) {
            if (!deepEqual(a[i], b[i])) {
              return !1;
            }
          }
          return !0;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size) {
            return !1;
          }
          for (i of a.entries()) {
            if (!b.has(i[0])) {
              return !1;
            }
          }
          for (var e of a.entries()) {
            if (!deepEqual(e[1], b.get(e[0]))) {
              return !1;
            }
          }
          return !0;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size) {
            return !1;
          }
          for (length of a.entries()) {
            if (!b.has(length[0])) {
              return !1;
            }
          }
          return !0;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length) {
            return !1;
          }
          for (i = length; i-- !== 0;) {
            if (a[i] !== b[i]) {
              return !1;
            }
          }
          return !0;
        }
        if (a.constructor === RegExp) {
          return a.source === b.source && a.flags === b.flags;
        }
        if (a.valueOf !== Object.prototype.valueOf && a.valueOf !== clonedProto.valueOf) {
          return a.valueOf() === b.valueOf();
        }
        if (a.toString !== Object.prototype.toString && a.toString !== clonedProto.toString) {
          return a.toString() === b.toString();
        }
        e = Object.keys(a);
        length = e.length;
        if (length !== Object.keys(b).length) {
          return !1;
        }
        for (i = length; i-- !== 0;) {
          if (!Object.prototype.hasOwnProperty.call(b, e[i])) {
            return !1;
          }
        }
        for (i = length; i-- !== 0;) {
          if (length = e[i], !deepEqual(a[length], b[length])) {
            return !1;
          }
        }
        return !0;
      }
      return a !== a && b !== b;
    }
    function stringify(data) {
      const seen = [];
      return function _stringify(node) {
        node && node.toJSON && typeof node.toJSON === "function" && (node = node.toJSON());
        if (node !== void 0) {
          if (typeof node == "number") {
            return isFinite(node) ? "" + node : "null";
          }
          if (typeof node !== "object") {
            return JSON.stringify(node);
          }
          var i;
          if (Array.isArray(node)) {
            var out = "[";
            for (i = 0; i < node.length; i++) {
              i && (out += ","), out += _stringify(node[i]) || "null";
            }
            return out + "]";
          }
          if (node === null) {
            return "null";
          }
          if (seen.includes(node)) {
            throw new TypeError("Converting circular structure to JSON");
          }
          var seenIndex = seen.push(node) - 1, ks = Object.keys(node).sort();
          out = "";
          for (i = 0; i < ks.length; i++) {
            const key = ks[i], value = _stringify(node[key]);
            value && (out && (out += ","), out += JSON.stringify(key) + ":" + value);
          }
          seen.splice(seenIndex, 1);
          return `{${out}}`;
        }
      }(data);
    }
    function hasProperty(obj, key) {
      return vega.isObject(obj) && vega.hasOwnProperty(obj, key) && obj[key] !== void 0;
    }
    function getPositionChannelFromLatLong(channel) {
      switch(channel) {
        case "latitude":
          return "y";
        case "latitude2":
          return "y2";
        case "longitude":
          return "x";
        case "longitude2":
          return "x2";
      }
    }
    function isColorChannel(channel) {
      return channel === "color" || channel === "fill" || channel === "stroke";
    }
    function isSecondaryRangeChannel(c) {
      return getMainRangeChannel(c) !== c;
    }
    function getMainRangeChannel(channel) {
      switch(channel) {
        case "x2":
          return "x";
        case "y2":
          return "y";
        case "latitude2":
          return "latitude";
        case "longitude2":
          return "longitude";
        case "theta2":
          return "theta";
        case "radius2":
          return "radius";
      }
      return channel;
    }
    function getVgPositionChannel(channel) {
      if (vega.hasOwnProperty(POLAR_POSITION_CHANNEL_INDEX, channel)) {
        switch(channel) {
          case "theta":
            return "startAngle";
          case "theta2":
            return "endAngle";
          case "radius":
            return "outerRadius";
          case "radius2":
            return "innerRadius";
        }
      }
      return channel;
    }
    function getSecondaryRangeChannel(channel) {
      switch(channel) {
        case "x":
          return "x2";
        case "y":
          return "y2";
        case "latitude":
          return "latitude2";
        case "longitude":
          return "longitude2";
        case "theta":
          return "theta2";
        case "radius":
          return "radius2";
      }
    }
    function getSizeChannel(channel) {
      switch(channel) {
        case "x":
        case "x2":
          return "width";
        case "y":
        case "y2":
          return "height";
      }
    }
    function getOffsetChannel(channel) {
      switch(channel) {
        case "x":
          return "xOffset";
        case "y":
          return "yOffset";
        case "x2":
          return "x2Offset";
        case "y2":
          return "y2Offset";
        case "theta":
          return "thetaOffset";
        case "radius":
          return "radiusOffset";
        case "theta2":
          return "theta2Offset";
        case "radius2":
          return "radius2Offset";
      }
    }
    function getOffsetScaleChannel(channel) {
      switch(channel) {
        case "x":
          return "xOffset";
        case "y":
          return "yOffset";
      }
    }
    function isXorY(channel) {
      return vega.hasOwnProperty(POSITION_SCALE_CHANNEL_INDEX, channel);
    }
    function getPositionScaleChannel(sizeType) {
      return sizeType === "width" ? "x" : "y";
    }
    function isScaleChannel(channel) {
      return vega.hasOwnProperty(SCALE_CHANNEL_INDEX, channel);
    }
    function getSupportedMark(channel) {
      switch(channel) {
        case "color":
        case "fill":
        case "stroke":
        case "description":
        case "detail":
        case "key":
        case "tooltip":
        case "href":
        case "order":
        case "opacity":
        case "fillOpacity":
        case "strokeOpacity":
        case "strokeWidth":
        case "facet":
        case "row":
        case "column":
          return ALL_MARKS;
        case "x":
        case "y":
        case "xOffset":
        case "yOffset":
        case "latitude":
        case "longitude":
        case "time":
          return ALL_MARKS_EXCEPT_GEOSHAPE;
        case "x2":
        case "y2":
        case "latitude2":
        case "longitude2":
          return {area:"always", bar:"always", image:"always", rect:"always", rule:"always", circle:"binned", point:"binned", square:"binned", tick:"binned", line:"binned", trail:"binned"};
        case "size":
          return {point:"always", tick:"always", rule:"always", circle:"always", square:"always", bar:"always", text:"always", line:"always", trail:"always"};
        case "strokeDash":
          return {line:"always", point:"always", tick:"always", rule:"always", circle:"always", square:"always", bar:"always", geoshape:"always"};
        case "shape":
          return {point:"always", geoshape:"always"};
        case "text":
          return {text:"always"};
        case "angle":
          return {point:"always", square:"always", text:"always"};
        case "url":
          return {image:"always"};
        case "theta":
          return {text:"always", arc:"always"};
        case "radius":
          return {text:"always", arc:"always"};
        case "theta2":
        case "radius2":
          return {arc:"always"};
      }
    }
    function rangeType(channel) {
      switch(channel) {
        case "facet":
        case "row":
        case "column":
        case "shape":
        case "strokeDash":
        case "text":
        case "tooltip":
        case "href":
        case "url":
        case "description":
          return "discrete";
        case "color":
        case "fill":
        case "stroke":
          return "flexible";
      }
    }
    function isArgminDef(a) {
      return hasProperty(a, "argmin");
    }
    function isArgmaxDef(a) {
      return hasProperty(a, "argmax");
    }
    function isAggregateOp(a) {
      return vega.isString(a) && vega.hasOwnProperty(AGGREGATE_OP_INDEX, a);
    }
    function isCountingAggregateOp(aggregate) {
      return vega.isString(aggregate) && COUNTING_OPS.has(aggregate);
    }
    function binToString(bin) {
      vega.isBoolean(bin) && (bin = normalizeBin(bin, void 0));
      return "bin" + keys(bin).map(p => hasProperty(bin[p], "param") ? varName(`_${p}_${entries$1(bin[p])}`) : varName(`_${p}_${bin[p]}`)).join("");
    }
    function isBinning(bin) {
      return bin === !0 || vega.isObject(bin) && !bin.binned;
    }
    function isBinned(bin) {
      return bin === "binned" || vega.isObject(bin) && bin.binned === !0;
    }
    function autoMaxBins(channel) {
      switch(channel) {
        case "row":
        case "column":
        case "size":
        case "color":
        case "fill":
        case "stroke":
        case "strokeWidth":
        case "opacity":
        case "fillOpacity":
        case "strokeOpacity":
        case "shape":
          return 6;
        case "strokeDash":
          return 4;
        default:
          return 10;
      }
    }
    function replaceExprRef(index) {
      let {level} = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {level:0};
      const props = keys(index || {}), newIndex = {};
      for (const prop of props) {
        newIndex[prop] = level === 0 ? signalRefOrValue(index[prop]) : replaceExprRef(index[prop], {level:level - 1});
      }
      return newIndex;
    }
    function extractTitleConfig(titleConfig) {
      const {anchor, frame, offset, orient, angle, limit, color, subtitleColor, subtitleFont, subtitleFontSize, subtitleFontStyle, subtitleFontWeight, subtitleLineHeight, subtitlePadding, ...rest} = titleConfig, titleMarkConfig = {...rest, ...(color ? {fill:color} : {})}, nonMarkTitleProperties = {...(anchor ? {anchor} : {}), ...(frame ? {frame} : {}), ...(offset ? {offset} : {}), ...(orient ? {orient} : {}), ...(angle !== void 0 ? {angle} : {}), ...(limit !== void 0 ? {limit} : {})}, subtitle = 
      {...(subtitleColor ? {subtitleColor} : {}), ...(subtitleFont ? {subtitleFont} : {}), ...(subtitleFontSize ? {subtitleFontSize} : {}), ...(subtitleFontStyle ? {subtitleFontStyle} : {}), ...(subtitleFontWeight ? {subtitleFontWeight} : {}), ...(subtitleLineHeight ? {subtitleLineHeight} : {}), ...(subtitlePadding ? {subtitlePadding} : {})};
      titleConfig = pick(titleConfig, ["align", "baseline", "dx", "dy", "limit"]);
      return {titleMarkConfig, subtitleMarkConfig:titleConfig, nonMarkTitleProperties, subtitle};
    }
    function isText(v) {
      return vega.isString(v) || vega.isArray(v) && vega.isString(v[0]);
    }
    function isSignalRef(o) {
      return hasProperty(o, "signal");
    }
    function isVgRangeStep(range) {
      return hasProperty(range, "step");
    }
    function isDataRefDomain(domain) {
      return vega.isArray(domain) ? !1 : hasProperty(domain, "field") && hasProperty(domain, "data");
    }
    function signalOrValueRefWithCondition(val) {
      const condition = vega.isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);
      return {...signalRefOrValue(val), condition};
    }
    function signalRefOrValue(value) {
      if (hasProperty(value, "expr")) {
        const {expr, ...rest} = value;
        return {signal:expr, ...rest};
      }
      return value;
    }
    function conditionalSignalRefOrValue(value) {
      if (hasProperty(value, "expr")) {
        const {expr, ...rest} = value;
        return {signal:expr, ...rest};
      }
      return value;
    }
    function signalOrValueRef(value) {
      if (hasProperty(value, "expr")) {
        const {expr, ...rest} = value;
        return {signal:expr, ...rest};
      }
      return isSignalRef(value) ? value : value !== void 0 ? {value} : void 0;
    }
    function signalOrStringValue(v) {
      return isSignalRef(v) ? v.signal : v == null ? null : vega.stringValue(v);
    }
    function getMarkPropOrConfig(channel, mark, config) {
      let opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const {vgChannel, ignoreVgConfig} = opt;
      if (vgChannel && hasProperty(mark, vgChannel)) {
        return mark[vgChannel];
      }
      if (mark[channel] !== void 0) {
        return mark[channel];
      }
      if (!ignoreVgConfig || vgChannel && vgChannel !== channel) {
        return getMarkConfig(channel, mark, config, opt);
      }
    }
    function getMarkConfig(channel, mark, config) {
      let {vgChannel} = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const cfg = getMarkStyleConfig(channel, mark, config.style);
      return getFirstDefined(vgChannel ? cfg : void 0, cfg, vgChannel ? config[mark.type][vgChannel] : void 0, config[mark.type][channel], vgChannel ? config.mark[vgChannel] : config.mark[channel]);
    }
    function getMarkStyleConfig(prop, mark, styleConfigIndex) {
      return getStyleConfig(prop, [].concat(mark.type, mark.style ?? []), styleConfigIndex);
    }
    function getStyleConfig(p, styles, styleConfigIndex) {
      styles = vega.array(styles);
      let value;
      for (const style of styles) {
        styles = styleConfigIndex[style], hasProperty(styles, p) && (value = styles[p]);
      }
      return value;
    }
    function sortParams(orderDef, fieldRefOption) {
      return vega.array(orderDef).reduce((s, orderChannelDef) => {
        s.field.push(vgField(orderChannelDef, fieldRefOption));
        s.order.push(orderChannelDef.sort ?? "ascending");
        return s;
      }, {field:[], order:[]});
    }
    function mergeTitleFieldDefs(f1, f2) {
      const merged = [...f1];
      f2.forEach(fdToMerge => {
        for (const fieldDef1 of merged) {
          if (deepEqual(fieldDef1, fdToMerge)) {
            return;
          }
        }
        merged.push(fdToMerge);
      });
      return merged;
    }
    function mergeTitle(title1, title2) {
      return deepEqual(title1, title2) || !title2 ? title1 : title1 ? [...vega.array(title1), ...vega.array(title2)].join(", ") : title2;
    }
    function mergeTitleComponent(v1, v2) {
      const v1Val = v1.value;
      v2 = v2.value;
      if (v1Val == null || v2 === null) {
        return {explicit:v1.explicit, value:null};
      }
      if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2) || isSignalRef(v2))) {
        return {explicit:v1.explicit, value:mergeTitle(v1Val, v2)};
      }
      if (isText(v1Val) || isSignalRef(v1Val)) {
        return {explicit:v1.explicit, value:v1Val};
      }
      if (isText(v2) || isSignalRef(v2)) {
        return {explicit:v1.explicit, value:v2};
      }
      if (!(isText(v1Val) || isSignalRef(v1Val) || isText(v2) || isSignalRef(v2))) {
        return {explicit:v1.explicit, value:mergeTitleFieldDefs(v1Val, v2)};
      }
      throw Error("It should never reach here");
    }
    function invalidSpec(spec) {
      return `Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
    }
    function containerSizeNonSingle(name) {
      return `${name == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
    }
    function containerSizeNotCompatibleWithAutosize(name) {
      return `${name == "width" ? "Width" : "Height"} "container" only works well with autosize "fit" or "fit-${name == "width" ? "x" : "y"}".`;
    }
    function droppingFit(channel) {
      return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : 'Dropping "fit" because spec has discrete size.';
    }
    function unknownField(channel) {
      return `Unknown field for ${channel}. Cannot calculate view size.`;
    }
    function cannotProjectOnChannelWithoutField(channel) {
      return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
    }
    function selectionNotSupported(mark) {
      return `Selection not supported for ${mark} yet.`;
    }
    function columnsNotSupportByRowCol(type) {
      return `The "columns" property cannot be used when "${type}" has nested row/column.`;
    }
    function selectionAsScaleDomainWrongEncodings(encodings, encoding, extent, field) {
      return (encodings.length ? "Multiple " : "No ") + `matching ${vega.stringValue(encoding)} encoding found for selection ${vega.stringValue(extent.param)}. ` + `Using "field": ${vega.stringValue(field)}.`;
    }
    function differentParse(field, local, ancestor) {
      return `An ancestor parsed field "${field}" as ${ancestor} but a child wants to parse the field as ${local}.`;
    }
    function customFormatTypeNotAllowed(channel) {
      return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
    }
    function droppingColor(type, opt) {
      const {fill, stroke} = opt;
      return `Dropping color ${type} as the plot also has ${fill && stroke ? "fill and stroke" : fill ? "fill" : "stroke"}.`;
    }
    function emptyFieldDef(fieldDef, channel) {
      return `Dropping ${stringify(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
    }
    function incompatibleChannel(channel, markOrFacet, when) {
      return `${channel} dropped as it is incompatible with "${markOrFacet}"${""}.`;
    }
    function discreteChannelCannotEncode(channel, type) {
      return `Using discrete channel "${channel}" to encode "${type}" field can be misleading as it does not encode ${type === "ordinal" ? "order" : "magnitude"}.`;
    }
    function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {
      return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType} scale.`;
    }
    function stepDropped(channel) {
      return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
    }
    function invalidTimeUnit(unitName, value) {
      return `Invalid ${unitName}: ${stringify(value)}.`;
    }
    function errorBand1DNotSupport(property) {
      return `1D error band does not support ${property}.`;
    }
    function channelRequiredForBinned(channel) {
      return `Channel ${channel} is required for "binned" bin.`;
    }
    function error() {
      current.error(...arguments);
    }
    function warn() {
      current.warn(...arguments);
    }
    function debug() {
      current.debug(...arguments);
    }
    function isDateTime(o) {
      if (o && vega.isObject(o)) {
        for (const part of TIMEUNIT_PARTS) {
          if (hasProperty(o, part)) {
            return !0;
          }
        }
      }
      return !1;
    }
    function normalizeMonth(m) {
      isNumeric(m) && (m = +m);
      if (vega.isNumber(m)) {
        return m - 1;
      }
      var lowerM = m.toLowerCase();
      const monthIndex = MONTHS.indexOf(lowerM);
      if (monthIndex !== -1) {
        return monthIndex;
      }
      lowerM = lowerM.substr(0, 3);
      lowerM = SHORT_MONTHS.indexOf(lowerM);
      if (lowerM !== -1) {
        return lowerM;
      }
      throw Error(invalidTimeUnit("month", m));
    }
    function normalizeDay(d) {
      isNumeric(d) && (d = +d);
      if (vega.isNumber(d)) {
        return d % 7;
      }
      var lowerD = d.toLowerCase();
      const dayIndex = DAYS.indexOf(lowerD);
      if (dayIndex !== -1) {
        return dayIndex;
      }
      lowerD = lowerD.substr(0, 3);
      lowerD = SHORT_DAYS.indexOf(lowerD);
      if (lowerD !== -1) {
        return lowerD;
      }
      throw Error(invalidTimeUnit("day", d));
    }
    function dateTimeParts(d, normalize) {
      const parts = [];
      normalize && d.day !== void 0 && keys(d).length > 1 && (warn(`Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`), d = duplicate(d), delete d.day);
      d.year !== void 0 ? parts.push(d.year) : parts.push(2012);
      if (d.month !== void 0) {
        var month = normalize ? normalizeMonth(d.month) : d.month;
        parts.push(month);
      } else if (d.quarter !== void 0) {
        if (normalize) {
          if (month = d.quarter, isNumeric(month) && (month = +month), vega.isNumber(month)) {
            month > 4 && warn(invalidTimeUnit("quarter", month)), --month;
          } else {
            throw Error(invalidTimeUnit("quarter", month));
          }
        } else {
          month = d.quarter;
        }
        parts.push(vega.isNumber(month) ? month * 3 : `${month}*3`);
      } else {
        parts.push(0);
      }
      d.date !== void 0 ? parts.push(d.date) : d.day !== void 0 ? (normalize = normalize ? normalizeDay(d.day) : d.day, parts.push(vega.isNumber(normalize) ? normalize + 1 : `${normalize}+1`)) : parts.push(1);
      for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
        normalize = d[timeUnit], parts.push(typeof normalize === "undefined" ? 0 : normalize);
      }
      return parts;
    }
    function dateTimeToExpr(d) {
      const string = dateTimeParts(d, !0).join(", ");
      return d.utc ? `utc(${string})` : `datetime(${string})`;
    }
    function dateTimeToTimestamp(d) {
      const parts = dateTimeParts(d, !0);
      return d.utc ? +new Date(Date.UTC(...parts)) : +new Date(...parts);
    }
    function isBinnedTimeUnit(timeUnit) {
      return vega.isObject(timeUnit) ? timeUnit.binned : timeUnit && timeUnit.startsWith("binned");
    }
    function getTimeUnitParts(timeUnit) {
      return TIMEUNIT_PARTS.filter(part => containsTimeUnit(timeUnit, part));
    }
    function getSmallestTimeUnitPart(timeUnit) {
      timeUnit = getTimeUnitParts(timeUnit);
      return timeUnit[timeUnit.length - 1];
    }
    function containsTimeUnit(fullTimeUnit, timeUnit) {
      const index = fullTimeUnit.indexOf(timeUnit);
      return index < 0 || index > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index - 1) === "i" || fullTimeUnit.length > index + 3 && timeUnit === "day" && fullTimeUnit.charAt(index + 3) === "o" || index > 0 && timeUnit === "year" && fullTimeUnit.charAt(index - 1) === "f" ? !1 : !0;
    }
    function fieldExpr(fullTimeUnit, field) {
      var {end} = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {end:!1};
      const fieldRef = accessPathWithDatum(field), utc = fullTimeUnit.startsWith("utc") ? "utc" : "";
      const dateExpr = {};
      for (const part of TIMEUNIT_PARTS) {
        if (containsTimeUnit(fullTimeUnit, part)) {
          var lastTimeUnit = part === "quarter" ? `(${utc}quarter(${fieldRef})-1)` : `${utc}${part}(${fieldRef})`;
          dateExpr[part] = lastTimeUnit;
          lastTimeUnit = part;
        }
      }
      end && (dateExpr[lastTimeUnit] += "+1");
      end = dateTimeParts(dateExpr, !1).join(", ");
      return dateExpr.utc ? `utc(${end})` : `datetime(${end})`;
    }
    function timeUnitSpecifierExpression(timeUnit) {
      if (timeUnit) {
        return timeUnit = getTimeUnitParts(timeUnit), `timeUnitSpecifier(${stringify(timeUnit)}, ${stringify(VEGALITE_TIMEFORMAT)})`;
      }
    }
    function normalizeTimeUnit(timeUnit) {
      if (timeUnit) {
        var params;
        vega.isString(timeUnit) ? params = timeUnit && timeUnit.startsWith("binned") ? {unit:timeUnit.substring(6), binned:!0} : {unit:timeUnit} : vega.isObject(timeUnit) && (params = {...timeUnit, ...(timeUnit.unit ? {unit:timeUnit.unit} : {})});
        params.unit.startsWith("utc") && (params.utc = !0, params.unit = params.unit.substring(3));
        return params;
      }
    }
    function timeUnitToString(tu) {
      const {utc, ...rest} = normalizeTimeUnit(tu);
      return rest.unit ? (utc ? "utc" : "") + keys(rest).map(p => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("") : (utc ? "utc" : "") + "timeunit" + keys(rest).map(p => varName(`_${p}_${rest[p]}`)).join("");
    }
    function durationExpr(timeUnit) {
      let wrap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x => x;
      const normalizedTimeUnit = normalizeTimeUnit(timeUnit), smallestUnitPart = getSmallestTimeUnitPart(normalizedTimeUnit.unit);
      if (smallestUnitPart && smallestUnitPart !== "day") {
        const startDate = {year:2001, month:1, date:1, hours:0, minutes:0, seconds:0, milliseconds:0}, {step, part} = getDateTimePartAndStep(smallestUnitPart, normalizedTimeUnit.step);
        return `${wrap(dateTimeToExpr({...startDate, [part]:+startDate[part] + step}))} - ${wrap(dateTimeToExpr(startDate))}`;
      }
    }
    function getDateTimePartAndStep(timeUnit) {
      let step = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (vega.hasOwnProperty(DATE_PARTS, timeUnit)) {
        return {part:timeUnit, step};
      }
      switch(timeUnit) {
        case "day":
        case "dayofyear":
          return {part:"date", step};
        case "quarter":
          return {part:"month", step:step * 3};
        case "week":
          return {part:"date", step:step * 7};
      }
    }
    function isFieldRangePredicate(predicate) {
      return predicate?.field && (vega.isArray(predicate.range) && predicate.range.length === 2 || isSignalRef(predicate.range)) ? !0 : !1;
    }
    function isFieldOneOfPredicate(predicate) {
      return !!predicate?.field && (vega.isArray(predicate.oneOf) || vega.isArray(predicate.in));
    }
    function isFieldPredicate(predicate) {
      return isFieldOneOfPredicate(predicate) || !!predicate?.field && predicate.equal !== void 0 || isFieldRangePredicate(predicate) || !!predicate?.field && predicate.lt !== void 0 || !!predicate?.field && predicate.gt !== void 0 || !!predicate?.field && predicate.lte !== void 0 || !!predicate?.field && predicate.gte !== void 0;
    }
    function predicateValueExpr(v, timeUnit) {
      return valueExpr(v, {timeUnit, wrapTime:!0});
    }
    function predicateValuesExpr(vals, timeUnit) {
      return vals.map(v => predicateValueExpr(v, timeUnit));
    }
    function fieldFilterExpression(predicate) {
      var useInRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, {field} = predicate, normalizedTimeUnit = normalizeTimeUnit(predicate.timeUnit);
      const {unit, binned} = normalizedTimeUnit || {};
      normalizedTimeUnit = vgField(predicate, {expr:"datum"});
      field = unit ? `time(${binned ? normalizedTimeUnit : fieldExpr(unit, field)})` : normalizedTimeUnit;
      if (predicate?.field && predicate.equal !== void 0) {
        return `${field}===${predicateValueExpr(predicate.equal, unit)}`;
      }
      if (predicate?.field && predicate.lt !== void 0) {
        return `${field}<${predicateValueExpr(predicate.lt, unit)}`;
      }
      if (predicate?.field && predicate.gt !== void 0) {
        return `${field}>${predicateValueExpr(predicate.gt, unit)}`;
      }
      if (predicate?.field && predicate.lte !== void 0) {
        return `${field}<=${predicateValueExpr(predicate.lte, unit)}`;
      }
      if (predicate?.field && predicate.gte !== void 0) {
        return `${field}>=${predicateValueExpr(predicate.gte, unit)}`;
      }
      if (isFieldOneOfPredicate(predicate)) {
        return `indexof([${predicateValuesExpr(predicate.oneOf, unit).join(",")}], ${field}) !== -1`;
      }
      if (predicate?.field && predicate.valid !== void 0) {
        return fieldValidPredicate(field, predicate.valid);
      }
      if (isFieldRangePredicate(predicate)) {
        var {range} = replaceExprRef(predicate);
        normalizedTimeUnit = isSignalRef(range) ? {signal:`${range.signal}[0]`} : range[0];
        range = isSignalRef(range) ? {signal:`${range.signal}[1]`} : range[1];
        if (normalizedTimeUnit !== null && range !== null && useInRange) {
          return "inrange(" + field + ", [" + predicateValueExpr(normalizedTimeUnit, unit) + ", " + predicateValueExpr(range, unit) + "])";
        }
        useInRange = [];
        normalizedTimeUnit !== null && useInRange.push(`${field} >= ${predicateValueExpr(normalizedTimeUnit, unit)}`);
        range !== null && useInRange.push(`${field} <= ${predicateValueExpr(range, unit)}`);
        return useInRange.length > 0 ? useInRange.join(" \x26\x26 ") : "true";
      }
      throw Error(`Invalid field predicate: ${stringify(predicate)}`);
    }
    function fieldValidPredicate(fieldExpr) {
      return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1) ? `isValid(${fieldExpr}) && isFinite(+${fieldExpr})` : `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;
    }
    function normalizePredicate$1(f) {
      return isFieldPredicate(f) && f.timeUnit ? {...f, timeUnit:normalizeTimeUnit(f.timeUnit)} : f;
    }
    function isContinuous(type) {
      return type === "quantitative" || type === "temporal";
    }
    function isDiscrete$1(type) {
      return type === "ordinal" || type === "nominal";
    }
    function getFullName(type) {
      if (type) {
        switch(type = type.toLowerCase(), type) {
          case "q":
          case "quantitative":
            return "quantitative";
          case "t":
          case "temporal":
            return "temporal";
          case "o":
          case "ordinal":
            return "ordinal";
          case "n":
          case "nominal":
            return "nominal";
          case "geojson":
            return "geojson";
        }
      }
    }
    function hasDiscreteDomain(type) {
      return DISCRETE_DOMAIN_SCALES.has(type);
    }
    function hasContinuousDomain(type) {
      return CONTINUOUS_DOMAIN_SCALES.has(type);
    }
    function scaleTypeSupportProperty(scaleType, propName) {
      switch(propName) {
        case "type":
        case "domain":
        case "reverse":
        case "range":
          return !0;
        case "scheme":
        case "interpolate":
          return !["point", "band", "identity"].includes(scaleType);
        case "bins":
          return !["point", "band", "identity", "ordinal"].includes(scaleType);
        case "round":
          return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType) || scaleType === "band" || scaleType === "point";
        case "padding":
        case "rangeMin":
        case "rangeMax":
          return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType) || ["point", "band"].includes(scaleType);
        case "paddingOuter":
        case "align":
          return ["point", "band"].includes(scaleType);
        case "paddingInner":
          return scaleType === "band";
        case "domainMax":
        case "domainMid":
        case "domainMin":
        case "domainRaw":
        case "clamp":
          return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType);
        case "nice":
          return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType) || scaleType === "quantize" || scaleType === "threshold";
        case "exponent":
          return scaleType === "pow";
        case "base":
          return scaleType === "log";
        case "constant":
          return scaleType === "symlog";
        case "zero":
          return hasContinuousDomain(scaleType) && !contains(["log", "time", "utc", "threshold", "quantile"], scaleType);
      }
    }
    function channelScalePropertyIncompatability(channel, propName) {
      switch(propName) {
        case "interpolate":
        case "scheme":
        case "domainMid":
          if (!isColorChannel(channel)) {
            return `Cannot use the scale property "${propName}" with non-color channel.`;
          }
      }
    }
    function channelSupportScaleType(channel, scaleType) {
      let hasNestedOffsetScale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      if (!isScaleChannel(channel)) {
        return !1;
      }
      switch(channel) {
        case "x":
        case "y":
        case "xOffset":
        case "yOffset":
        case "theta":
        case "radius":
          return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType) || scaleType === "band" ? !0 : scaleType === "point" ? !hasNestedOffsetScale : !1;
        case "time":
          return contains(["linear", "band"], scaleType);
        case "size":
        case "strokeWidth":
        case "opacity":
        case "fillOpacity":
        case "strokeOpacity":
        case "angle":
          return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType) || CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType) || contains(["band", "point", "ordinal"], scaleType);
        case "color":
        case "fill":
        case "stroke":
          return scaleType !== "band";
        case "strokeDash":
        case "shape":
          return scaleType === "ordinal" || CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType);
      }
    }
    function isPathMark(m) {
      return ["line", "area", "trail"].includes(m);
    }
    function isRectBasedMark(m) {
      return ["rect", "bar", "image", "arc", "tick"].includes(m);
    }
    function isMarkDef(mark) {
      return hasProperty(mark, "type");
    }
    function isRelativeBandSize(o) {
      return hasProperty(o, "band");
    }
    function normalizeInvalidDataMode(mode, _ref) {
      ({isPath:_ref} = _ref);
      return mode === void 0 || mode === "break-paths-show-path-domains" ? _ref ? "break-paths-show-domains" : "filter" : mode === null ? "show" : mode;
    }
    function getScaleInvalidDataMode(_ref) {
      let {markDef, config, scaleChannel, scaleType, isCountAggregate} = _ref;
      if (!scaleType || !hasContinuousDomain(scaleType) || isCountAggregate) {
        return "always-valid";
      }
      _ref = normalizeInvalidDataMode(getMarkPropOrConfig("invalid", markDef, config), {isPath:isPathMark(markDef.type)});
      return config.scale?.invalid?.[scaleChannel] !== void 0 ? "show" : _ref;
    }
    function scaledZeroOrMinOrMax(_ref) {
      let {scaleName, scale, mode} = _ref;
      _ref = `domain('${scaleName}')`;
      if (scale && scaleName) {
        var min = `${_ref}[0]`, max = `peek(${_ref})`, domainHasZero = scale.domainHasZero();
        return domainHasZero === "definitely" ? {scale:scaleName, value:0} : domainHasZero === "maybe" ? {signal:`scale('${scaleName}', inrange(0, ${_ref}) ? 0 : ${mode === "zeroOrMin" ? min : max})`} : {signal:`scale('${scaleName}', ${mode === "zeroOrMin" ? min : max})`};
      }
    }
    function getConditionalValueRefForIncludingInvalidValue(_ref) {
      let {scaleChannel, channelDef, scale, scaleName, markDef, config} = _ref;
      var scaleType = scale?.get("type");
      _ref = getFieldDef(channelDef);
      const isCountAggregate = isCountingAggregateOp(_ref?.aggregate);
      scaleType = getScaleInvalidDataMode({scaleChannel, markDef, config, scaleType, isCountAggregate});
      if (_ref && scaleType === "show") {
        return scaleType = config.scale.invalid?.[scaleChannel] ?? "zero-or-min", _ref = fieldValidPredicate(vgField(_ref, {expr:"datum"}), !1), vega.isObject(scaleType) && "value" in scaleType ? ({value:scaleType} = scaleType, scaleType = isSignalRef(scaleType) ? {signal:scaleType.signal} : {value:scaleType}) : scaleType = scaledZeroOrMinOrMax({scale, scaleName, mode:"zeroOrMin"}), {test:_ref, ...scaleType};
      }
    }
    function midPointRefWithPositionInvalidTest(params) {
      const {channel, channelDef, markDef, scale, scaleName, config} = params;
      var scaleChannel = getMainRangeChannel(channel);
      params = midPoint(params);
      scaleChannel = getConditionalValueRefForIncludingInvalidValue({scaleChannel, channelDef, scale, scaleName, markDef, config});
      return scaleChannel !== void 0 ? [scaleChannel, params] : params;
    }
    function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {
      const ref = {};
      scaleName && (ref.scale = scaleName);
      isDatumDef(fieldDef) ? ({datum:fieldDef} = fieldDef, isDateTime(fieldDef) ? ref.signal = dateTimeToExpr(fieldDef) : isSignalRef(fieldDef) ? ref.signal = fieldDef.signal : hasProperty(fieldDef, "expr") ? ref.signal = fieldDef.expr : ref.value = fieldDef) : ref.field = vgField(fieldDef, opt);
      if (encode) {
        const {offset, band} = encode;
        offset && (ref.offset = offset);
        band && (ref.band = band);
      }
      return ref;
    }
    function interpolatedSignalRef(_ref) {
      let {scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset, startSuffix, endSuffix = "end", bandPosition = 0.5} = _ref;
      var expr = !isSignalRef(bandPosition) && 0 < bandPosition && bandPosition < 1 ? "datum" : void 0;
      _ref = vgField(fieldOrDatumDef, {expr, suffix:startSuffix});
      const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, {expr}) : vgField(fieldOrDatumDef, {suffix:endSuffix, expr});
      expr = {};
      bandPosition === 0 || bandPosition === 1 ? (expr.scale = scaleName, expr.field = bandPosition === 0 ? _ref : end) : (_ref = isSignalRef(bandPosition) ? `(1-${bandPosition.signal}) * ${_ref} + ${bandPosition.signal} * ${end}` : `${1 - bandPosition} * ${_ref} + ${bandPosition} * ${end}`, expr.signal = `scale("${scaleName}", ${_ref})`);
      offset && (expr.offset = offset);
      return expr;
    }
    function midPoint(_ref3) {
      let {channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef, bandPosition} = _ref3;
      if (channelDef) {
        if (isFieldOrDatumDef(channelDef)) {
          _ref3 = scale?.get("type");
          if (isTypedFieldDef(channelDef)) {
            bandPosition ??= getBandPosition({fieldDef:channelDef, fieldDef2:channel2Def, markDef, config});
            const {bin, timeUnit, type} = channelDef;
            if (isBinning(bin) || bandPosition && timeUnit && type === "temporal") {
              return stack?.impute ? valueRefForFieldOrDatumDef(channelDef, scaleName, {binSuffix:"mid"}, {offset}) : bandPosition && !hasDiscreteDomain(_ref3) ? interpolatedSignalRef({scaleName, fieldOrDatumDef:channelDef, bandPosition, offset}) : valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix:"range"} : {}, {offset});
            }
            if (isBinned(bin)) {
              if (isFieldDef(channel2Def)) {
                return interpolatedSignalRef({scaleName, fieldOrDatumDef:channelDef, fieldOrDatumDef2:channel2Def, bandPosition, offset});
              }
              warn(channelRequiredForBinned(channel === "x" ? "x2" : "y2"));
            }
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(_ref3) ? {binSuffix:"range"} : {}, {offset, band:_ref3 === "band" ? bandPosition ?? channelDef.bandPosition ?? 0.5 : void 0});
        }
        if (isValueDef(channelDef)) {
          return _ref3 = offset ? {offset} : {}, {...widthHeightValueOrSignalRef(channel, channelDef.value), ..._ref3};
        }
      }
      vega.isFunction(defaultRef) && (defaultRef = defaultRef());
      return defaultRef ? {...defaultRef, ...(offset ? {offset} : {})} : defaultRef;
    }
    function widthHeightValueOrSignalRef(channel, value) {
      return contains(["x", "x2"], channel) && value === "width" ? {field:{group:"width"}} : contains(["y", "y2"], channel) && value === "height" ? {field:{group:"height"}} : signalOrValueRef(value);
    }
    function isCustomFormatType(formatType) {
      return formatType && formatType !== "number" && formatType !== "time";
    }
    function formatSignalRef(_ref) {
      let {fieldOrDatumDef, format:format$jscomp$0, formatType, expr, normalizeStack, config} = _ref;
      if (isCustomFormatType(formatType)) {
        return formatCustomType({fieldOrDatumDef, format:format$jscomp$0, formatType, expr, config});
      }
      _ref = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);
      var type = fieldOrDatumDef?.type;
      if (format$jscomp$0 === void 0 && formatType === void 0 && config.customFormatTypes) {
        if (type === "quantitative") {
          if (normalizeStack && config.normalizedNumberFormatType) {
            return formatCustomType({fieldOrDatumDef, format:config.normalizedNumberFormat, formatType:config.normalizedNumberFormatType, expr, config});
          }
          if (config.numberFormatType) {
            return formatCustomType({fieldOrDatumDef, format:config.numberFormat, formatType:config.numberFormatType, expr, config});
          }
        }
        if (type === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
          return formatCustomType({fieldOrDatumDef, format:config.timeFormat, formatType:config.timeFormatType, expr, config});
        }
      }
      if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
        {
          _ref = {field:_ref, timeUnit:isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : void 0, format:format$jscomp$0, formatType:config.timeFormatType, rawTimeFormat:config.timeFormat, isUTCScale:isScaleFieldDef(fieldOrDatumDef) && fieldOrDatumDef.scale?.type === ScaleType.UTC};
          let {field, timeUnit, format, formatType, rawTimeFormat, isUTCScale} = _ref;
          if (!timeUnit || format) {
            !timeUnit && formatType ? _ref = `${formatType}(${field}, '${format}')` : (format = vega.isString(format) ? format : rawTimeFormat, _ref = `${isUTCScale ? "utc" : "time"}Format(${field}, '${format}')`);
          } else {
            _ref = timeUnit;
            type = field;
            var isUTCScale$jscomp$0 = isUTCScale;
            if (_ref) {
              var expr$jscomp$0 = timeUnitSpecifierExpression(_ref);
              _ref = `${isUTCScale$jscomp$0 || _ref.startsWith("utc") ? "utc" : "time"}Format(${type}, ${expr$jscomp$0})`;
            } else {
              _ref = void 0;
            }
          }
        }
        return _ref ? {signal:_ref} : void 0;
      }
      format$jscomp$0 = numberFormat({type, specifiedFormat:format$jscomp$0, config, normalizeStack});
      return isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin) ? (type = vgField(fieldOrDatumDef, {expr, binSuffix:"end"}), {signal:binFormatExpression(_ref, type, format$jscomp$0, formatType, config)}) : format$jscomp$0 || fieldOrDatumDef?.type === "quantitative" ? {signal:`${`format(${_ref}, "${format$jscomp$0 || ""}")`}`} : {signal:`isValid(${_ref}) ? ${_ref} : ""+${_ref}`};
    }
    function fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {
      if (isFieldDef(fieldOrDatumDef)) {
        return normalizeStack ? `${vgField(fieldOrDatumDef, {expr, suffix:"end"})}-${vgField(fieldOrDatumDef, {expr, suffix:"start"})}` : vgField(fieldOrDatumDef, {expr});
      }
      ({datum:fieldOrDatumDef} = fieldOrDatumDef);
      fieldOrDatumDef = isDateTime(fieldOrDatumDef) ? dateTimeToExpr(fieldOrDatumDef) : `${stringify(fieldOrDatumDef)}`;
      return fieldOrDatumDef;
    }
    function formatCustomType(_ref2) {
      let {fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field} = _ref2;
      field ??= fieldToFormat(fieldOrDatumDef, expr, normalizeStack);
      return field !== "datum.value" && isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin) ? (_ref2 = vgField(fieldOrDatumDef, {expr, binSuffix:"end"}), {signal:binFormatExpression(field, _ref2, format, formatType, config)}) : {signal:`${formatType}(${field}${format ? `, ${stringify(format)}` : ""})`};
    }
    function guideFormat(fieldOrDatumDef, type, format, formatType, config$jscomp$0, omitTimeFormatConfig) {
      if (!vega.isString(formatType) || !isCustomFormatType(formatType)) {
        if (format !== void 0 || formatType !== void 0 || !config$jscomp$0.customFormatTypes || fieldOrDatumDef?.type !== "quantitative" || !(config$jscomp$0.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" || config$jscomp$0.numberFormatType)) {
          if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config$jscomp$0.normalizedNumberFormat) {
            return numberFormat({type:"quantitative", config:config$jscomp$0, normalizeStack:!0});
          }
          if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
            fieldOrDatumDef = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : void 0;
            if (fieldOrDatumDef === void 0 && config$jscomp$0.customFormatTypes && config$jscomp$0.timeFormatType) {
              return;
            }
            {
              let {specifiedFormat, timeUnit, config, omitTimeFormatConfig:omitTimeFormatConfig$jscomp$0} = {specifiedFormat:format, timeUnit:fieldOrDatumDef, config:config$jscomp$0, omitTimeFormatConfig};
              format = specifiedFormat ? specifiedFormat : timeUnit ? {signal:timeUnitSpecifierExpression(timeUnit)} : omitTimeFormatConfig$jscomp$0 ? void 0 : config.timeFormat;
            }
            return format;
          }
          return numberFormat({type, specifiedFormat:format, config:config$jscomp$0});
        }
      }
    }
    function guideFormatType(formatType, fieldOrDatumDef, scaleType) {
      if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
        return formatType;
      }
      if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== "time" && scaleType !== "utc") {
        return isFieldDef(fieldOrDatumDef) && normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc ? "utc" : "time";
      }
    }
    function numberFormat(_ref3) {
      let {type, specifiedFormat, config, normalizeStack} = _ref3;
      if (vega.isString(specifiedFormat)) {
        return specifiedFormat;
      }
      if (type === "quantitative") {
        return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;
      }
    }
    function binNumberFormatExpr(field, format, formatType, config) {
      if (isCustomFormatType(formatType)) {
        return `${formatType}(${field}${format ? `, ${stringify(format)}` : ""})`;
      }
      format = (vega.isString(format) ? format : void 0) ?? config.numberFormat;
      return `format(${field}, "${format || ""}")`;
    }
    function binFormatExpression(startField, endField, format, formatType, config) {
      if (format === void 0 && formatType === void 0 && config.customFormatTypes && config.numberFormatType) {
        return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);
      }
      const start = binNumberFormatExpr(startField, format, formatType, config);
      endField = binNumberFormatExpr(endField, format, formatType, config);
      return `${fieldValidPredicate(startField, !1)} ? "null" : ${start} + "${"  "}" + ${endField}`;
    }
    function isSortField(sort) {
      return sort && (sort.op === "count" || hasProperty(sort, "field"));
    }
    function isSortArray(sort) {
      return sort && vega.isArray(sort);
    }
    function isFacetMapping(f) {
      return hasProperty(f, "row") || hasProperty(f, "column");
    }
    function toFieldDefBase(fieldDef) {
      const {field, timeUnit, bin, aggregate} = fieldDef;
      return {...(timeUnit ? {timeUnit} : {}), ...(bin ? {bin} : {}), ...(aggregate ? {aggregate} : {}), field};
    }
    function getBandPosition(_ref) {
      let {fieldDef, fieldDef2, markDef:mark, config} = _ref;
      if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== void 0) {
        return fieldDef.bandPosition;
      }
      if (isFieldDef(fieldDef)) {
        const {timeUnit, bin} = fieldDef;
        if (timeUnit && !fieldDef2) {
          return getMarkConfig("timeUnitBandPosition", mark, config);
        }
        if (isBinning(bin)) {
          return 0.5;
        }
      }
    }
    function getBandSize(_ref2) {
      let {channel, fieldDef, fieldDef2, markDef:mark, config, scaleType, useVlSizeChannel} = _ref2;
      _ref2 = getSizeChannel(channel);
      _ref2 = getMarkPropOrConfig(useVlSizeChannel ? "size" : _ref2, mark, config, {vgChannel:_ref2});
      if (_ref2 !== void 0) {
        return _ref2;
      }
      if (isFieldDef(fieldDef)) {
        const {timeUnit, bin} = fieldDef;
        if (timeUnit && !fieldDef2) {
          return {band:getMarkConfig("timeUnitBandSize", mark, config)};
        }
        if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {
          return {band:1};
        }
      }
      if (isRectBasedMark(mark.type)) {
        return scaleType ? hasDiscreteDomain(scaleType) ? config[mark.type]?.discreteBandSize || {band:1} : config[mark.type]?.continuousBandSize : config[mark.type]?.discreteBandSize;
      }
    }
    function hasBandEnd(fieldDef, fieldDef2, markDef, config) {
      return isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal" ? getBandPosition({fieldDef, fieldDef2, markDef, config}) !== void 0 : !1;
    }
    function isConditionalDef(channelDef) {
      return hasProperty(channelDef, "condition");
    }
    function hasConditionalFieldDef(channelDef) {
      channelDef = channelDef?.condition;
      return !!channelDef && !vega.isArray(channelDef) && isFieldDef(channelDef);
    }
    function hasConditionalFieldOrDatumDef(channelDef) {
      channelDef = channelDef?.condition;
      return !!channelDef && !vega.isArray(channelDef) && isFieldOrDatumDef(channelDef);
    }
    function isFieldDef(channelDef) {
      return hasProperty(channelDef, "field") || channelDef?.aggregate === "count";
    }
    function isDatumDef(channelDef) {
      return hasProperty(channelDef, "datum");
    }
    function isContinuousFieldOrDatumDef(cd) {
      return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);
    }
    function isUnbinnedQuantitativeFieldOrDatumDef(cd) {
      return isTypedFieldDef(cd) && cd.type === "quantitative" && !cd.bin || isNumericDataDef(cd);
    }
    function isNumericDataDef(cd) {
      return isDatumDef(cd) && vega.isNumber(cd.datum);
    }
    function isFieldOrDatumDef(channelDef) {
      return isFieldDef(channelDef) || isDatumDef(channelDef);
    }
    function isTypedFieldDef(channelDef) {
      return channelDef && (hasProperty(channelDef, "field") || channelDef.aggregate === "count") && hasProperty(channelDef, "type");
    }
    function isValueDef(channelDef) {
      return hasProperty(channelDef, "value");
    }
    function isScaleFieldDef(channelDef) {
      return hasProperty(channelDef, "scale") || hasProperty(channelDef, "sort");
    }
    function isPositionFieldOrDatumDef(channelDef) {
      return hasProperty(channelDef, "axis") || hasProperty(channelDef, "stack") || hasProperty(channelDef, "impute");
    }
    function isStringFieldOrDatumDef(channelDef) {
      return hasProperty(channelDef, "format") || hasProperty(channelDef, "formatType");
    }
    function toStringFieldDef(fieldDef) {
      return omit(fieldDef, ["legend", "axis", "header", "scale"]);
    }
    function vgField(fieldDef) {
      let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, field = fieldDef.field;
      const prefix = opt.prefix;
      let suffix = opt.suffix, argAccessor = "";
      if (fieldDef.aggregate === "count") {
        field = internalField("count");
      } else {
        let fn;
        if (!opt.nofn) {
          if (hasProperty(fieldDef, "op")) {
            fn = fieldDef.op;
          } else {
            const {bin, aggregate, timeUnit} = fieldDef;
            isBinning(bin) ? (fn = binToString(bin), suffix = (opt.binSuffix ?? "") + (opt.suffix ?? "")) : aggregate ? isArgmaxDef(aggregate) ? (argAccessor = `["${field}"]`, field = `argmax_${aggregate.argmax}`) : isArgminDef(aggregate) ? (argAccessor = `["${field}"]`, field = `argmin_${aggregate.argmin}`) : fn = String(aggregate) : timeUnit && !isBinnedTimeUnit(timeUnit) && (fn = timeUnitToString(timeUnit), suffix = (!["range", "mid"].includes(opt.binSuffix) && opt.binSuffix || "") + (opt.suffix ?? 
            ""));
          }
        }
        fn && (field = field ? `${fn}_${field}` : fn);
      }
      suffix && (field = `${field}_${suffix}`);
      prefix && (field = `${prefix}_${field}`);
      return opt.forAs ? removePathFromField(field) : opt.expr ? flatAccessWithDatum(field, opt.expr) + argAccessor : replacePathInField(field) + argAccessor;
    }
    function isDiscrete(def) {
      switch(def.type) {
        case "nominal":
        case "ordinal":
        case "geojson":
          return !0;
        case "quantitative":
          return isFieldDef(def) && !!def.bin;
        case "temporal":
          return !1;
      }
      throw Error(`Invalid field type "${def.type}".`);
    }
    function verbalTitleFormatter(fieldDef, config) {
      const {field, bin, timeUnit, aggregate} = fieldDef;
      if (aggregate === "count") {
        return config.countTitle;
      }
      if (isBinning(bin)) {
        return `${field} (binned)`;
      }
      if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
        if (fieldDef = normalizeTimeUnit(timeUnit)?.unit) {
          return `${field} (${getTimeUnitParts(fieldDef).join("-")})`;
        }
      } else if (aggregate) {
        return isArgmaxDef(aggregate) ? `${field} for max ${aggregate.argmax}` : isArgminDef(aggregate) ? `${field} for min ${aggregate.argmin}` : `${titleCase(aggregate)} of ${field}`;
      }
      return field;
    }
    function title(fieldOrDatumDef, config, _ref3) {
      let {allowDisabling, includeDefault = !0} = _ref3;
      _ref3 = getGuide(fieldOrDatumDef)?.title;
      if (!isFieldDef(fieldOrDatumDef)) {
        return _ref3 ?? fieldOrDatumDef.title;
      }
      config = includeDefault ? titleFormatter(fieldOrDatumDef, config) : void 0;
      return allowDisabling ? getFirstDefined(_ref3, fieldOrDatumDef.title, config) : _ref3 ?? fieldOrDatumDef.title ?? config;
    }
    function getGuide(fieldDef) {
      if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
        return fieldDef.axis;
      }
      if (hasProperty(fieldDef, "legend") && fieldDef.legend) {
        return fieldDef.legend;
      }
      if (hasProperty(fieldDef, "header") && fieldDef.header) {
        return fieldDef.header;
      }
    }
    function getFormatMixins(fieldDef) {
      if (isStringFieldOrDatumDef(fieldDef)) {
        const {format, formatType} = fieldDef;
        return {format, formatType};
      }
      fieldDef = getGuide(fieldDef) ?? {};
      const {format, formatType} = fieldDef;
      return {format, formatType};
    }
    function defaultType$2(fieldDef, channel) {
      switch(channel) {
        case "latitude":
        case "longitude":
          return "quantitative";
        case "row":
        case "column":
        case "facet":
        case "shape":
        case "strokeDash":
          return "nominal";
        case "order":
          return "ordinal";
      }
      if (hasProperty(fieldDef, "sort") && vega.isArray(fieldDef.sort)) {
        return "ordinal";
      }
      const {aggregate, bin, timeUnit} = fieldDef;
      if (timeUnit) {
        return "temporal";
      }
      if (bin || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
        return "quantitative";
      }
      if (isScaleFieldDef(fieldDef) && fieldDef.scale?.type) {
        switch(SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {
          case "numeric":
          case "discretizing":
            return "quantitative";
          case "time":
            return "temporal";
        }
      }
      return "nominal";
    }
    function getFieldDef(channelDef) {
      if (isFieldDef(channelDef)) {
        return channelDef;
      }
      if (hasConditionalFieldDef(channelDef)) {
        return channelDef.condition;
      }
    }
    function getFieldOrDatumDef(channelDef) {
      if (isFieldOrDatumDef(channelDef)) {
        return channelDef;
      }
      if (hasConditionalFieldOrDatumDef(channelDef)) {
        return channelDef.condition;
      }
    }
    function initChannelDef(channelDef, channel, config) {
      var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return vega.isString(channelDef) || vega.isNumber(channelDef) || vega.isBoolean(channelDef) ? (opt = vega.isString(channelDef) ? "string" : vega.isNumber(channelDef) ? "number" : "boolean", warn(`Channel ${channel} is a ${opt}. Converted to {value: ${stringify(channelDef)}}.`), {value:channelDef}) : isFieldOrDatumDef(channelDef) ? initFieldOrDatumDef(channelDef, channel, config, opt) : hasConditionalFieldOrDatumDef(channelDef) ? {...channelDef, condition:initFieldOrDatumDef(channelDef.condition, 
      channel, config, opt)} : channelDef;
    }
    function initFieldOrDatumDef(fd, channel, config, opt) {
      if (isStringFieldOrDatumDef(fd)) {
        const {format, formatType, ...rest} = fd;
        if (isCustomFormatType(formatType) && !config.customFormatTypes) {
          return warn(customFormatTypeNotAllowed(channel)), initFieldOrDatumDef(rest, channel, config, opt);
        }
      } else {
        const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : hasProperty(fd, "legend") ? "legend" : hasProperty(fd, "header") ? "header" : null;
        if (guideType && fd[guideType]) {
          const {format, formatType, ...newGuide} = fd[guideType];
          if (isCustomFormatType(formatType) && !config.customFormatTypes) {
            return warn(customFormatTypeNotAllowed(channel)), initFieldOrDatumDef({...fd, [guideType]:newGuide}, channel, config, opt);
          }
        }
      }
      if (isFieldDef(fd)) {
        return initFieldDef(fd, channel, opt);
      }
      channel = fd.type;
      channel || ({datum:channel} = fd, channel = vega.isNumber(channel) ? "quantitative" : vega.isString(channel) ? "nominal" : isDateTime(channel) ? "temporal" : void 0, fd = {...fd, type:channel});
      return fd;
    }
    function initFieldDef(fd, channel) {
      var {compositeMark = !1} = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const {aggregate, timeUnit, bin, field} = fd, fieldDef = {...fd};
      compositeMark || !aggregate || isAggregateOp(aggregate) || isArgmaxDef(aggregate) || isArgminDef(aggregate) || (warn(`Invalid aggregation operator "${aggregate}".`), delete fieldDef.aggregate);
      timeUnit && (fieldDef.timeUnit = normalizeTimeUnit(timeUnit));
      field && (fieldDef.field = `${field}`);
      isBinning(bin) && (fieldDef.bin = normalizeBin(bin, channel));
      isBinned(bin) && !isXorY(channel) && warn(`Channel ${channel} should not be used with "binned" bin.`);
      if (isTypedFieldDef(fieldDef)) {
        ({type:compositeMark} = fieldDef);
        var fullType = getFullName(compositeMark);
        compositeMark !== fullType && (fieldDef.type = fullType);
        compositeMark !== "quantitative" && isCountingAggregateOp(aggregate) && (warn(`Invalid field type "${compositeMark}" for aggregate: "${aggregate}", using "quantitative" instead.`), fieldDef.type = "quantitative");
      } else {
        isSecondaryRangeChannel(channel) || (compositeMark = defaultType$2(fieldDef, channel), fieldDef.type = compositeMark);
      }
      if (isTypedFieldDef(fieldDef)) {
        const {compatible, warning} = channelCompatibility(fieldDef, channel) || {};
        compatible === !1 && warn(warning);
      }
      if (hasProperty(fieldDef, "sort") && vega.isString(fieldDef.sort)) {
        ({sort:compositeMark} = fieldDef);
        if (vega.hasOwnProperty(SORT_BY_CHANNEL_INDEX, compositeMark)) {
          return {...fieldDef, sort:{encoding:compositeMark}};
        }
        fullType = compositeMark.substring(1);
        if (compositeMark.charAt(0) === "-" && vega.hasOwnProperty(SORT_BY_CHANNEL_INDEX, fullType)) {
          return {...fieldDef, sort:{encoding:fullType, order:"descending"}};
        }
      }
      if (hasProperty(fieldDef, "header") && ({header:compositeMark} = fieldDef, compositeMark)) {
        const {orient, ...rest} = compositeMark;
        if (orient) {
          return {...fieldDef, header:{...rest, labelOrient:compositeMark.labelOrient || orient, titleOrient:compositeMark.titleOrient || orient}};
        }
      }
      return fieldDef;
    }
    function normalizeBin(bin, channel) {
      return vega.isBoolean(bin) ? {maxbins:autoMaxBins(channel)} : bin === "binned" ? {binned:!0} : bin.maxbins || bin.step ? bin : {...bin, maxbins:autoMaxBins(channel)};
    }
    function channelCompatibility(fieldDef, channel) {
      var type = fieldDef.type;
      if (type === "geojson" && channel !== "shape") {
        return {compatible:!1, warning:`Channel ${channel} should not be used with a geojson data.`};
      }
      switch(channel) {
        case "row":
        case "column":
        case "facet":
          return isDiscrete(fieldDef) ? COMPATIBLE : {compatible:!1, warning:`${channel} encoding should be discrete (ordinal / nominal / binned).`};
        case "x":
        case "y":
        case "xOffset":
        case "yOffset":
        case "color":
        case "fill":
        case "stroke":
        case "text":
        case "detail":
        case "key":
        case "tooltip":
        case "href":
        case "url":
        case "angle":
        case "theta":
        case "radius":
        case "description":
          return COMPATIBLE;
        case "longitude":
        case "longitude2":
        case "latitude":
        case "latitude2":
          return type !== "quantitative" ? {compatible:!1, warning:`Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`} : COMPATIBLE;
        case "opacity":
        case "fillOpacity":
        case "strokeOpacity":
        case "strokeWidth":
        case "size":
        case "theta2":
        case "radius2":
        case "x2":
        case "y2":
        case "time":
          return type !== "nominal" || fieldDef.sort ? COMPATIBLE : {compatible:!1, warning:`Channel ${channel} should not be used with an unsorted discrete field.`};
        case "shape":
        case "strokeDash":
          if (type = !isDiscrete(fieldDef)) {
            type = !(isScaleFieldDef(fieldDef) && CONTINUOUS_TO_DISCRETE_SCALES.has(fieldDef.scale?.type));
          }
          return type ? {compatible:!1, warning:`${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`} : COMPATIBLE;
        case "order":
          return fieldDef.type !== "nominal" || "sort" in fieldDef ? COMPATIBLE : {compatible:!1, warning:"Channel order is inappropriate for nominal field, which has no inherent order."};
      }
    }
    function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
      var {formatType} = getFormatMixins(fieldOrDatumDef), JSCompiler_temp;
      if (!(JSCompiler_temp = formatType === "time")) {
        if (formatType = !formatType) {
          formatType = fieldOrDatumDef && (fieldOrDatumDef.type === "temporal" || isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit);
        }
        JSCompiler_temp = formatType;
      }
      return JSCompiler_temp;
    }
    function valueExpr(v, _ref4) {
      let {timeUnit, type, wrapTime, undefinedIfExprNotRequired} = _ref4, isTime = (_ref4 = timeUnit && normalizeTimeUnit(timeUnit)?.unit) || type === "temporal", expr;
      hasProperty(v, "expr") ? expr = v.expr : isSignalRef(v) ? expr = v.signal : isDateTime(v) ? (isTime = !0, expr = dateTimeToExpr(v)) : (vega.isString(v) || vega.isNumber(v)) && isTime && (expr = `datetime(${stringify(v)})`, vega.hasOwnProperty(LOCAL_SINGLE_TIMEUNIT_INDEX, _ref4) && (vega.isNumber(v) && v < 10000 || vega.isString(v) && isNaN(Date.parse(v))) && (expr = dateTimeToExpr({[_ref4]:v})));
      return expr ? wrapTime && isTime ? `time(${expr})` : expr : undefinedIfExprNotRequired ? void 0 : stringify(v);
    }
    function valueArray(fieldOrDatumDef, values) {
      const {type} = fieldOrDatumDef;
      return values.map(v => {
        var timeUnit = isFieldDef(fieldOrDatumDef) && !isBinnedTimeUnit(fieldOrDatumDef.timeUnit) ? fieldOrDatumDef.timeUnit : void 0;
        timeUnit = valueExpr(v, {timeUnit, type, undefinedIfExprNotRequired:!0});
        return timeUnit !== void 0 ? {signal:timeUnit} : v;
      });
    }
    function binRequiresRange(fieldDef, channel) {
      return isBinning(fieldDef.bin) ? isScaleChannel(channel) && ["ordinal", "nominal"].includes(fieldDef.type) : (console.warn("Only call this method for binned field defs."), !1);
    }
    function isUnitSpec(spec) {
      return hasProperty(spec, "mark");
    }
    function channelHasField(encoding, channel) {
      return (encoding = encoding && encoding[channel]) ? vega.isArray(encoding) ? some(encoding, fieldDef => !!fieldDef.field) : isFieldDef(encoding) || hasConditionalFieldDef(encoding) : !1;
    }
    function channelHasFieldOrDatum(encoding, channel) {
      return (encoding = encoding && encoding[channel]) ? vega.isArray(encoding) ? some(encoding, fieldDef => !!fieldDef.field) : isFieldDef(encoding) || isDatumDef(encoding) || hasConditionalFieldOrDatumDef(encoding) : !1;
    }
    function channelHasNestedOffsetScale(encoding, channel) {
      if (isXorY(channel)) {
        const fieldDef = encoding[channel];
        if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && (isDiscrete$1(fieldDef.type) || isFieldDef(fieldDef) && fieldDef.timeUnit)) {
          return channel = getOffsetScaleChannel(channel), channelHasFieldOrDatum(encoding, channel);
        }
      }
      return !1;
    }
    function isAggregate$1(encoding) {
      return some(CHANNELS, channel => channelHasField(encoding, channel) ? (channel = encoding[channel], vega.isArray(channel) ? some(channel, fieldDef => !!fieldDef.aggregate) : (channel = getFieldDef(channel)) && !!channel.aggregate) : !1);
    }
    function extractTransformsFromEncoding(oldEncoding, config) {
      const groupby = [], bins = [], timeUnits = [], aggregate = [], encoding = {};
      forEach(oldEncoding, (channelDef, channel) => {
        if (isFieldDef(channelDef)) {
          const {field, aggregate:aggOp, bin, timeUnit, ...remaining} = channelDef;
          if (aggOp || timeUnit || bin) {
            var isTitleDefined = getGuide(channelDef)?.title;
            let newField = vgField(channelDef, {forAs:!0});
            isTitleDefined = {...(isTitleDefined ? [] : {title:title(channelDef, config, {allowDisabling:!0})}), ...remaining, field:newField};
            if (aggOp) {
              let op;
              isArgmaxDef(aggOp) ? (op = "argmax", newField = vgField({op:"argmax", field:aggOp.argmax}, {forAs:!0}), isTitleDefined.field = `${newField}.${field}`) : isArgminDef(aggOp) ? (op = "argmin", newField = vgField({op:"argmin", field:aggOp.argmin}, {forAs:!0}), isTitleDefined.field = `${newField}.${field}`) : aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband" && (op = aggOp);
              op && (channelDef = {op, as:newField}, field && (channelDef.field = field), aggregate.push(channelDef));
            } else {
              groupby.push(newField), isTypedFieldDef(channelDef) && isBinning(bin) ? (bins.push({bin, field, as:newField}), groupby.push(vgField(channelDef, {binSuffix:"end"})), binRequiresRange(channelDef, channel) && groupby.push(vgField(channelDef, {binSuffix:"range"})), isXorY(channel) && (encoding[`${channel}2`] = {field:`${newField}_end`}), isTitleDefined.bin = "binned", isSecondaryRangeChannel(channel) || (isTitleDefined.type = "quantitative")) : timeUnit && !isBinnedTimeUnit(timeUnit) && 
              (timeUnits.push({timeUnit, field, as:newField}), (channelDef = isTypedFieldDef(channelDef) && channelDef.type !== "temporal" && "time") && (channel === "text" || channel === "tooltip" ? isTitleDefined.formatType = channelDef : vega.hasOwnProperty(NONPOSITION_CHANNEL_INDEX, channel) ? isTitleDefined.legend = {formatType:channelDef, ...isTitleDefined.legend} : isXorY(channel) && (isTitleDefined.axis = {formatType:channelDef, ...isTitleDefined.axis})));
            }
            encoding[channel] = isTitleDefined;
          } else {
            groupby.push(field), encoding[channel] = oldEncoding[channel];
          }
        } else {
          encoding[channel] = oldEncoding[channel];
        }
      });
      return {bins, timeUnits, aggregate, groupby, encoding};
    }
    function markChannelCompatible(encoding, channel, mark) {
      mark = getSupportedMark(channel)[mark];
      return mark && (mark !== "binned" || (mark = encoding[channel === "x2" ? "x" : "y"], isFieldDef(mark) && isFieldDef(encoding[channel]) && isBinned(mark.bin))) ? !0 : !1;
    }
    function initEncoding(encoding, mark, filled, config) {
      const normalizedEncoding = {};
      for (var key of keys(encoding)) {
        vega.hasOwnProperty(CHANNEL_INDEX, key) || warn(`${key}-encoding is dropped as ${key} is not a valid encoding channel.`);
      }
      for (let channel of UNIT_CHANNELS) {
        if (encoding[channel]) {
          key = encoding[channel];
          if (vega.hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel)) {
            a: {
              switch(channel) {
                case "xOffset":
                  var JSCompiler_inline_result = "x";
                  break a;
                case "yOffset":
                  JSCompiler_inline_result = "y";
                  break a;
              }
              JSCompiler_inline_result = void 0;
            }
            const positionDef = normalizedEncoding[JSCompiler_inline_result];
            if (isFieldDef(positionDef) && isContinuous(positionDef.type) && isFieldDef(key) && !positionDef.timeUnit) {
              warn(`${JSCompiler_inline_result}Offset dropped because ${JSCompiler_inline_result} is continuous`);
              continue;
            }
          }
          channel !== "angle" || mark !== "arc" || encoding.theta || (warn("Arc marks uses theta channel rather than angle, replacing angle with theta."), channel = "theta");
          if (markChannelCompatible(encoding, channel, mark)) {
            if (channel === "size" && mark === "line" && getFieldDef(encoding[channel])?.aggregate) {
              warn("Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.");
            } else {
              if (channel === "color" && (filled ? "fill" in encoding : "stroke" in encoding)) {
                warn(droppingColor("encoding", {fill:"fill" in encoding, stroke:"stroke" in encoding}));
              } else {
                if (channel === "detail" || channel === "order" && !vega.isArray(key) && !isValueDef(key) || channel === "tooltip" && vega.isArray(key)) {
                  if (key) {
                    if (channel === "order" && (JSCompiler_inline_result = encoding[channel], hasProperty(JSCompiler_inline_result, "sort") && !hasProperty(JSCompiler_inline_result, "field"))) {
                      normalizedEncoding[channel] = JSCompiler_inline_result;
                      continue;
                    }
                    normalizedEncoding[channel] = vega.array(key).reduce((defs, fieldDef) => {
                      isFieldDef(fieldDef) ? defs.push(initFieldDef(fieldDef, channel)) : warn(emptyFieldDef(fieldDef, channel));
                      return defs;
                    }, []);
                  }
                } else {
                  if (channel === "tooltip" && key === null) {
                    normalizedEncoding[channel] = null;
                  } else if (!(isFieldDef(key) || isDatumDef(key) || isValueDef(key) || isConditionalDef(key) || isSignalRef(key))) {
                    warn(emptyFieldDef(key, channel));
                    continue;
                  }
                  normalizedEncoding[channel] = initChannelDef(key, channel, config);
                }
              }
            }
          } else {
            warn(incompatibleChannel(channel, mark));
          }
        }
      }
      return normalizedEncoding;
    }
    function normalizeEncoding(encoding, config) {
      const normalizedEncoding = {};
      for (const channel of keys(encoding)) {
        const newChannelDef = initChannelDef(encoding[channel], channel, config, {compositeMark:!0});
        normalizedEncoding[channel] = newChannelDef;
      }
      return normalizedEncoding;
    }
    function fieldDefs(encoding) {
      const arr = [];
      for (const channel of keys(encoding)) {
        if (channelHasField(encoding, channel)) {
          const channelDefArray = vega.array(encoding[channel]);
          for (const def of channelDefArray) {
            isFieldDef(def) ? arr.push(def) : hasConditionalFieldDef(def) && arr.push(def.condition);
          }
        }
      }
      return arr;
    }
    function forEach(mapping, f, thisArg) {
      if (mapping) {
        for (const channel of keys(mapping)) {
          const el = mapping[channel];
          if (vega.isArray(el)) {
            for (const channelDef of el) {
              f.call(thisArg, channelDef, channel);
            }
          } else {
            f.call(thisArg, el, channel);
          }
        }
      }
    }
    function reduce(mapping, f, init, thisArg) {
      return mapping ? keys(mapping).reduce((r, channel) => {
        const map = mapping[channel];
        return vega.isArray(map) ? map.reduce((r1, channelDef) => f.call(thisArg, r1, channelDef, channel), r) : f.call(thisArg, r, map, channel);
      }, init) : init;
    }
    function pathGroupingFields(mark, encoding) {
      return keys(encoding).reduce((details, channel) => {
        switch(channel) {
          case "x":
          case "y":
          case "href":
          case "description":
          case "url":
          case "x2":
          case "y2":
          case "xOffset":
          case "yOffset":
          case "theta":
          case "theta2":
          case "radius":
          case "radius2":
          case "time":
          case "latitude":
          case "longitude":
          case "latitude2":
          case "longitude2":
          case "text":
          case "shape":
          case "angle":
          case "tooltip":
            return details;
          case "order":
            if (mark === "line" || mark === "trail") {
              return details;
            }
          case "detail":
          case "key":
            channel = encoding[channel];
            if (vega.isArray(channel) || isFieldDef(channel)) {
              for (var fieldDef of vega.array(channel)) {
                fieldDef.aggregate || details.push(vgField(fieldDef, {}));
              }
            }
            return details;
          case "size":
            if (mark === "trail") {
              return details;
            }
          case "color":
          case "fill":
          case "stroke":
          case "opacity":
          case "fillOpacity":
          case "strokeOpacity":
          case "strokeDash":
          case "strokeWidth":
            return (fieldDef = getFieldDef(encoding[channel])) && !fieldDef.aggregate && details.push(vgField(fieldDef, {})), details;
        }
      }, []);
    }
    function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis) {
      let withFieldName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
      if ("tooltip" in encodingWithoutContinuousAxis) {
        return {tooltip:encodingWithoutContinuousAxis.tooltip};
      }
      const fiveSummaryTooltip = tooltipSummary.map(_ref => {
        let {fieldPrefix, titlePrefix} = _ref;
        _ref = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : "";
        return {field:fieldPrefix + continuousAxisChannelDef.field, type:continuousAxisChannelDef.type, title:isSignalRef(titlePrefix) ? {signal:`${titlePrefix}"${escape(_ref)}"`} : titlePrefix + _ref};
      }), tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);
      return {tooltip:[...fiveSummaryTooltip, ...unique(tooltipFieldDefs, hash)]};
    }
    function getTitle(continuousAxisChannelDef) {
      const {title, field} = continuousAxisChannelDef;
      return getFirstDefined(title, field);
    }
    function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
      const {scale, axis} = continuousAxisChannelDef;
      return _ref2 => {
        let {partName, mark, positionPrefix, endPositionPrefix, extraEncoding = {}} = _ref2;
        _ref2 = getTitle(continuousAxisChannelDef);
        return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {mark, encoding:{[continuousAxis]:{field:`${positionPrefix}_${continuousAxisChannelDef.field}`, type:continuousAxisChannelDef.type, ...(_ref2 !== void 0 ? {title:_ref2} : {}), ...(scale !== void 0 ? {scale} : {}), ...(axis !== void 0 ? {axis} : {})}, ...(vega.isString(endPositionPrefix) ? {[`${continuousAxis}2`]:{field:`${endPositionPrefix}_${continuousAxisChannelDef.field}`}} : {}), ...sharedEncoding, ...extraEncoding}});
      };
    }
    function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {
      const {clip, color, opacity} = markDef, mark = markDef.type;
      return markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part] ? [{...partBaseSpec, mark:{...compositeMarkConfig[part], ...(clip ? {clip} : {}), ...(color ? {color} : {}), ...(opacity ? {opacity} : {}), ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type:partBaseSpec.mark}), style:`${mark}-${String(part)}`, ...(vega.isBoolean(markDef[part]) ? {} : markDef[part])}}] : [];
    }
    function compositeMarkContinuousAxis(spec, orient, compositeMark) {
      ({encoding:spec} = spec);
      orient = orient === "vertical" ? "y" : "x";
      const continuousAxisChannelDef2 = spec[`${orient}2`], continuousAxisChannelDefError = spec[`${orient}Error`], continuousAxisChannelDefError2 = spec[`${orient}Error2`];
      return {continuousAxisChannelDef:filterAggregateFromChannelDef(spec[orient], compositeMark), continuousAxisChannelDef2:filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark), continuousAxisChannelDefError:filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark), continuousAxisChannelDefError2:filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark), continuousAxis:orient};
    }
    function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
      if (continuousAxisChannelDef?.aggregate) {
        const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;
        aggregate !== compositeMark && warn(`Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`);
        return continuousAxisWithoutAggregate;
      }
      return continuousAxisChannelDef;
    }
    function compositeMarkOrient(spec, compositeMark) {
      const {mark, encoding} = spec, {x, y} = encoding;
      if (isMarkDef(mark) && mark.orient) {
        return mark.orient;
      }
      if (isContinuousFieldOrDatumDef(x)) {
        if (isContinuousFieldOrDatumDef(y)) {
          spec = isFieldDef(x) && x.aggregate;
          const yAggregate = isFieldDef(y) && y.aggregate;
          if (!spec && yAggregate === compositeMark) {
            return "vertical";
          }
          if (yAggregate || spec !== compositeMark) {
            if (spec === compositeMark && yAggregate === compositeMark) {
              throw Error("Both x and y cannot have aggregate");
            }
            return isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x) ? "horizontal" : "vertical";
          }
        }
        return "horizontal";
      }
      if (isContinuousFieldOrDatumDef(y)) {
        return "vertical";
      }
      throw Error(`Need a valid continuous axis for ${compositeMark}s`);
    }
    function normalizeBoxPlot(spec$jscomp$0, _ref) {
      ({config:_ref} = _ref);
      spec$jscomp$0 = {...spec$jscomp$0, encoding:normalizeEncoding(spec$jscomp$0.encoding, _ref)};
      const {mark, encoding:_encoding, params, projection:_p, ...outerSpec} = spec$jscomp$0;
      var markDef = isMarkDef(mark) ? mark : {type:mark};
      params && warn(selectionNotSupported("boxplot"));
      var extent = markDef.extent ?? _ref.boxplot.extent, sizeValue = getMarkPropOrConfig("size", markDef, _ref), invalid = markDef.invalid, boxPlotType = vega.isNumber(extent) ? "tukey" : extent, spec = spec$jscomp$0;
      spec$jscomp$0 = compositeMarkOrient(spec, "boxplot");
      const {continuousAxisChannelDef, continuousAxis} = compositeMarkContinuousAxis(spec, spec$jscomp$0, "boxplot");
      var continuousFieldName = continuousAxisChannelDef.field, aliasedFieldName = removePathFromField(continuousFieldName);
      const boxPlotType$jscomp$0 = vega.isNumber(extent) ? "tukey" : extent;
      continuousFieldName = [...boxParamsQuartiles(continuousFieldName), {op:"median", field:continuousFieldName, as:`mid_box_${aliasedFieldName}`}, {op:"min", field:continuousFieldName, as:(boxPlotType$jscomp$0 === "min-max" ? "lower_whisker_" : "min_") + aliasedFieldName}, {op:"max", field:continuousFieldName, as:(boxPlotType$jscomp$0 === "min-max" ? "upper_whisker_" : "max_") + aliasedFieldName}];
      aliasedFieldName = boxPlotType$jscomp$0 === "min-max" || boxPlotType$jscomp$0 === "tukey" ? [] : [{calculate:`${accessWithDatumToUnescapedPath(`upper_box_${aliasedFieldName}`)} - ${accessWithDatumToUnescapedPath(`lower_box_${aliasedFieldName}`)}`, as:`iqr_${aliasedFieldName}`}, {calculate:`min(${accessWithDatumToUnescapedPath(`upper_box_${aliasedFieldName}`)} + ${accessWithDatumToUnescapedPath(`iqr_${aliasedFieldName}`)} * ${extent}, ${accessWithDatumToUnescapedPath(`max_${aliasedFieldName}`)})`, 
      as:`upper_whisker_${aliasedFieldName}`}, {calculate:`max(${accessWithDatumToUnescapedPath(`lower_box_${aliasedFieldName}`)} - ${accessWithDatumToUnescapedPath(`iqr_${aliasedFieldName}`)} * ${extent}, ${accessWithDatumToUnescapedPath(`min_${aliasedFieldName}`)})`, as:`lower_whisker_${aliasedFieldName}`}];
      const {[continuousAxis]:oldContinuousAxisChannelDef, ...oldEncodingWithoutContinuousAxis} = spec.encoding;
      {
        const {tooltip, ...filteredEncoding} = oldEncodingWithoutContinuousAxis;
        if (tooltip) {
          var customTooltipWithoutAggregatedField;
          if (vega.isArray(tooltip)) {
            for (var t of tooltip) {
              t.aggregate ? (JSCompiler_inline_result ||= [], JSCompiler_inline_result.push(t)) : (customTooltipWithoutAggregatedField ||= [], customTooltipWithoutAggregatedField.push(t));
            }
            JSCompiler_inline_result && (filteredEncoding.tooltip = JSCompiler_inline_result);
          } else {
            tooltip.aggregate ? filteredEncoding.tooltip = tooltip : customTooltipWithoutAggregatedField = tooltip;
          }
          vega.isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1 && (customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0]);
          var JSCompiler_inline_result = {customTooltipWithoutAggregatedField, filteredEncoding};
        } else {
          JSCompiler_inline_result = {filteredEncoding};
        }
      }
      const {customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0, filteredEncoding} = JSCompiler_inline_result, {bins, timeUnits, aggregate, groupby, encoding:encodingWithoutContinuousAxis} = extractTransformsFromEncoding(filteredEncoding, _ref);
      JSCompiler_inline_result = [...bins, ...timeUnits, {aggregate:[...aggregate, ...continuousFieldName], groupby}, ...aliasedFieldName];
      const {bins:bins$jscomp$0, timeUnits:timeUnits$jscomp$0, transform, continuousAxisChannelDef:continuousAxisChannelDef$jscomp$0, continuousAxis:continuousAxis$jscomp$0, groupby:groupby$jscomp$0, aggregate:aggregate$jscomp$0, encodingWithoutContinuousAxis:encodingWithoutContinuousAxis$jscomp$0, ticksOrient, boxOrient, customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$1} = {bins, timeUnits, transform:JSCompiler_inline_result, groupby, aggregate, continuousAxisChannelDef, 
      continuousAxis, encodingWithoutContinuousAxis, ticksOrient:spec$jscomp$0 === "vertical" ? "horizontal" : "vertical", boxOrient:spec$jscomp$0, customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0};
      spec$jscomp$0 = removePathFromField(continuousAxisChannelDef$jscomp$0.field);
      const {color, size, ...encodingWithoutSizeColorAndContinuousAxis} = encodingWithoutContinuousAxis$jscomp$0;
      JSCompiler_inline_result = makeCompositeAggregatePartFactory(markDef, continuousAxis$jscomp$0, continuousAxisChannelDef$jscomp$0, encodingWithoutSizeColorAndContinuousAxis, _ref.boxplot);
      customTooltipWithoutAggregatedField = makeCompositeAggregatePartFactory(markDef, continuousAxis$jscomp$0, continuousAxisChannelDef$jscomp$0, encodingWithoutContinuousAxis$jscomp$0, _ref.boxplot);
      t = (vega.isObject(_ref.boxplot.box) ? _ref.boxplot.box.color : _ref.mark.color) || "#4c78a8";
      t = {...encodingWithoutSizeColorAndContinuousAxis, ...(size ? {size} : {}), color:{condition:{test:`${accessWithDatumToUnescapedPath(`lower_box_${continuousAxisChannelDef$jscomp$0.field}`)} >= ${accessWithDatumToUnescapedPath(`upper_box_${continuousAxisChannelDef$jscomp$0.field}`)}`, ...(color || {value:t})}}};
      t = makeCompositeAggregatePartFactory(markDef, continuousAxis$jscomp$0, continuousAxisChannelDef$jscomp$0, t, _ref.boxplot);
      spec = getCompositeMarkTooltip([{fieldPrefix:boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix:"Max"}, {fieldPrefix:"upper_box_", titlePrefix:"Q3"}, {fieldPrefix:"mid_box_", titlePrefix:"Median"}, {fieldPrefix:"lower_box_", titlePrefix:"Q1"}, {fieldPrefix:boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix:"Min"}], continuousAxisChannelDef$jscomp$0, encodingWithoutContinuousAxis$jscomp$0);
      continuousFieldName = {type:"tick", color:"black", opacity:1, orient:ticksOrient, invalid, aria:!1};
      aliasedFieldName = boxPlotType === "min-max" ? spec : getCompositeMarkTooltip([{fieldPrefix:"upper_whisker_", titlePrefix:"Upper Whisker"}, {fieldPrefix:"lower_whisker_", titlePrefix:"Lower Whisker"}], continuousAxisChannelDef$jscomp$0, encodingWithoutContinuousAxis$jscomp$0);
      JSCompiler_inline_result = [...JSCompiler_inline_result({partName:"rule", mark:{type:"rule", invalid, aria:!1}, positionPrefix:"lower_whisker", endPositionPrefix:"lower_box", extraEncoding:aliasedFieldName}), ...JSCompiler_inline_result({partName:"rule", mark:{type:"rule", invalid, aria:!1}, positionPrefix:"upper_box", endPositionPrefix:"upper_whisker", extraEncoding:aliasedFieldName}), ...JSCompiler_inline_result({partName:"ticks", mark:continuousFieldName, positionPrefix:"lower_whisker", 
      extraEncoding:aliasedFieldName}), ...JSCompiler_inline_result({partName:"ticks", mark:continuousFieldName, positionPrefix:"upper_whisker", extraEncoding:aliasedFieldName})];
      sizeValue = [...(boxPlotType !== "tukey" ? JSCompiler_inline_result : []), ...customTooltipWithoutAggregatedField({partName:"box", mark:{type:"bar", ...(sizeValue ? {size:sizeValue} : {}), orient:boxOrient, invalid, ariaRoleDescription:"box"}, positionPrefix:"lower_box", endPositionPrefix:"upper_box", extraEncoding:spec}), ...t({partName:"median", mark:{type:"tick", invalid, ...(vega.isObject(_ref.boxplot.median) && _ref.boxplot.median.color ? {color:_ref.boxplot.median.color} : {}), ...(sizeValue ? 
      {size:sizeValue} : {}), orient:ticksOrient, aria:!1}, positionPrefix:"mid_box", extraEncoding:spec})];
      if (boxPlotType === "min-max") {
        return {...outerSpec, transform:(outerSpec.transform ?? []).concat(transform), layer:sizeValue};
      }
      boxPlotType = accessWithDatumToUnescapedPath(`lower_box_${continuousAxisChannelDef$jscomp$0.field}`);
      invalid = accessWithDatumToUnescapedPath(`upper_box_${continuousAxisChannelDef$jscomp$0.field}`);
      customTooltipWithoutAggregatedField = `(${invalid} - ${boxPlotType})`;
      boxPlotType = `${boxPlotType} - ${extent} * ${customTooltipWithoutAggregatedField}`;
      invalid = `${invalid} + ${extent} * ${customTooltipWithoutAggregatedField}`;
      customTooltipWithoutAggregatedField = accessWithDatumToUnescapedPath(continuousAxisChannelDef$jscomp$0.field);
      extent = {joinaggregate:boxParamsQuartiles(continuousAxisChannelDef$jscomp$0.field), groupby:groupby$jscomp$0};
      spec$jscomp$0 = {transform:[{filter:`(${boxPlotType} <= ${customTooltipWithoutAggregatedField}) && (${customTooltipWithoutAggregatedField} <= ${invalid})`}, {aggregate:[{op:"min", field:continuousAxisChannelDef$jscomp$0.field, as:`lower_whisker_${spec$jscomp$0}`}, {op:"max", field:continuousAxisChannelDef$jscomp$0.field, as:`upper_whisker_${spec$jscomp$0}`}, {op:"min", field:`lower_box_${continuousAxisChannelDef$jscomp$0.field}`, as:`lower_box_${spec$jscomp$0}`}, {op:"max", field:`upper_box_${continuousAxisChannelDef$jscomp$0.field}`, 
      as:`upper_box_${spec$jscomp$0}`}, ...aggregate$jscomp$0], groupby:groupby$jscomp$0}], layer:JSCompiler_inline_result};
      const {tooltip, ...encodingWithoutSizeColorContinuousAxisAndTooltip} = encodingWithoutSizeColorAndContinuousAxis, {scale, axis} = continuousAxisChannelDef$jscomp$0;
      JSCompiler_inline_result = getTitle(continuousAxisChannelDef$jscomp$0);
      t = omit(axis, ["title"]);
      _ref = partLayerMixins(markDef, "outliers", _ref.boxplot, {transform:[{filter:`(${customTooltipWithoutAggregatedField} < ${boxPlotType}) || (${customTooltipWithoutAggregatedField} > ${invalid})`}], mark:"point", encoding:{[continuousAxis$jscomp$0]:{field:continuousAxisChannelDef$jscomp$0.field, type:continuousAxisChannelDef$jscomp$0.type, ...(JSCompiler_inline_result !== void 0 ? {title:JSCompiler_inline_result} : {}), ...(scale !== void 0 ? {scale} : {}), ...(isEmpty(t) ? {} : {axis:t})}, 
      ...encodingWithoutSizeColorContinuousAxisAndTooltip, ...(color ? {color} : {}), ...(customTooltipWithoutAggregatedField$jscomp$1 ? {tooltip:customTooltipWithoutAggregatedField$jscomp$1} : {})}})[0];
      markDef = [...bins$jscomp$0, ...timeUnits$jscomp$0, extent];
      _ref ? _ref = {transform:markDef, layer:[_ref, spec$jscomp$0]} : (_ref = spec$jscomp$0, _ref.transform.unshift(...markDef));
      return {...outerSpec, layer:[_ref, {transform, layer:sizeValue}]};
    }
    function boxParamsQuartiles(continousAxisField) {
      const aliasedFieldName = removePathFromField(continousAxisField);
      return [{op:"q1", field:continousAxisField, as:`lower_box_${aliasedFieldName}`}, {op:"q3", field:continousAxisField, as:`upper_box_${aliasedFieldName}`}];
    }
    function normalizeErrorBar(spec, _ref) {
      ({config:_ref} = _ref);
      spec = {...spec, encoding:normalizeEncoding(spec.encoding, _ref)};
      const {transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding} = errorBarParams(spec, "errorbar", _ref);
      delete encodingWithoutContinuousAxis.size;
      spec = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, _ref.errorbar);
      _ref = markDef.thickness;
      var size = markDef.size;
      size = {type:"tick", orient:ticksOrient, aria:!1, ...(_ref !== void 0 ? {thickness:_ref} : {}), ...(size !== void 0 ? {size} : {})};
      spec = [...spec({partName:"ticks", mark:size, positionPrefix:"lower", extraEncoding:tooltipEncoding}), ...spec({partName:"ticks", mark:size, positionPrefix:"upper", extraEncoding:tooltipEncoding}), ...spec({partName:"rule", mark:{type:"rule", ariaRoleDescription:"errorbar", ...(_ref !== void 0 ? {size:_ref} : {})}, positionPrefix:"lower", endPositionPrefix:"upper", extraEncoding:tooltipEncoding})];
      return {...outerSpec, transform, ...(spec.length > 1 ? {layer:spec} : {...spec[0]})};
    }
    function errorBarOrientAndInputType(spec, compositeMark) {
      var {encoding} = spec;
      if (!(!isFieldOrDatumDef(encoding.x) && !isFieldOrDatumDef(encoding.y) || isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2) || isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2))) {
        return {orient:compositeMarkOrient(spec, compositeMark), inputType:"raw"};
      }
      var isTypeAggregatedUpperLower = isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2), isTypeAggregatedError = isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
      spec = encoding.x;
      const y = encoding.y;
      if (isTypeAggregatedUpperLower) {
        if (isTypeAggregatedError) {
          throw Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
        }
        isTypeAggregatedUpperLower = encoding.x2;
        encoding = encoding.y2;
        if (isFieldOrDatumDef(isTypeAggregatedUpperLower) && isFieldOrDatumDef(encoding)) {
          throw Error(`${compositeMark} cannot have both x2 and y2`);
        }
        if (isFieldOrDatumDef(isTypeAggregatedUpperLower)) {
          if (isContinuousFieldOrDatumDef(spec)) {
            return {orient:"horizontal", inputType:"aggregated-upper-lower"};
          }
          throw Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
        }
        if (isFieldOrDatumDef(encoding)) {
          if (isContinuousFieldOrDatumDef(y)) {
            return {orient:"vertical", inputType:"aggregated-upper-lower"};
          }
          throw Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
        }
      } else {
        isTypeAggregatedUpperLower = encoding.xError;
        isTypeAggregatedError = encoding.yError;
        const yError2 = encoding.yError2;
        if (isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(isTypeAggregatedUpperLower)) {
          throw Error(`${compositeMark} cannot have xError2 without xError`);
        }
        if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(isTypeAggregatedError)) {
          throw Error(`${compositeMark} cannot have yError2 without yError`);
        }
        if (isFieldOrDatumDef(isTypeAggregatedUpperLower) && isFieldOrDatumDef(isTypeAggregatedError)) {
          throw Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
        }
        if (isFieldOrDatumDef(isTypeAggregatedUpperLower)) {
          if (isContinuousFieldOrDatumDef(spec)) {
            return {orient:"horizontal", inputType:"aggregated-error"};
          }
          throw Error("All x, xError, and xError2 (if exist) have to be quantitative");
        }
        if (isFieldOrDatumDef(isTypeAggregatedError)) {
          if (isContinuousFieldOrDatumDef(y)) {
            return {orient:"vertical", inputType:"aggregated-error"};
          }
          throw Error("All y, yError, and yError2 (if exist) have to be quantitative");
        }
      }
      throw Error("No ranged axis");
    }
    function errorBarParams(spec, compositeMark, config) {
      const {mark, encoding, params, projection:_p, ...outerSpec} = spec, markDef = isMarkDef(mark) ? mark : {type:mark};
      params && warn(selectionNotSupported(compositeMark));
      const {orient, inputType} = errorBarOrientAndInputType(spec, compositeMark), {continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis} = compositeMarkContinuousAxis(spec, orient, compositeMark);
      spec = [];
      var postAggregateCalculates = [];
      const continuousFieldName = continuousAxisChannelDef.field;
      let tooltipTitleWithFieldName$jscomp$0 = !1;
      if (inputType === "raw") {
        var tooltipSummary = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
        var extent = markDef.extent ? markDef.extent : tooltipSummary === "mean" ? "stderr" : "iqr";
        tooltipSummary === "median" !== (extent === "iqr") && warn(`${tooltipSummary} is not usually used with ${extent} for ${compositeMark}.`);
        extent === "stderr" || extent === "stdev" ? (spec = [{op:extent, field:continuousFieldName, as:`extent_${continuousFieldName}`}, {op:tooltipSummary, field:continuousFieldName, as:`center_${continuousFieldName}`}], postAggregateCalculates = [{calculate:`${accessWithDatumToUnescapedPath(`center_${continuousFieldName}`)} + ${accessWithDatumToUnescapedPath(`extent_${continuousFieldName}`)}`, as:`upper_${continuousFieldName}`}, {calculate:`${accessWithDatumToUnescapedPath(`center_${continuousFieldName}`)} - ${accessWithDatumToUnescapedPath(`extent_${continuousFieldName}`)}`, 
        as:`lower_${continuousFieldName}`}], tooltipSummary = [{fieldPrefix:"center_", titlePrefix:titleCase(tooltipSummary)}, {fieldPrefix:"upper_", titlePrefix:`${titleCase(tooltipSummary)} ${"+"} ${extent}`}, {fieldPrefix:"lower_", titlePrefix:`${titleCase(tooltipSummary)} ${"-"} ${extent}`}], tooltipTitleWithFieldName$jscomp$0 = !0) : (extent === "ci" ? (compositeMark = "mean", tooltipSummary = "ci0", extent = "ci1") : (compositeMark = "median", tooltipSummary = "q1", extent = "q3"), spec = [{op:tooltipSummary, 
        field:continuousFieldName, as:`lower_${continuousFieldName}`}, {op:extent, field:continuousFieldName, as:`upper_${continuousFieldName}`}, {op:compositeMark, field:continuousFieldName, as:`center_${continuousFieldName}`}], tooltipSummary = [{fieldPrefix:"upper_", titlePrefix:title({field:continuousFieldName, aggregate:extent, type:"quantitative"}, config, {allowDisabling:!1})}, {fieldPrefix:"lower_", titlePrefix:title({field:continuousFieldName, aggregate:tooltipSummary, type:"quantitative"}, 
        config, {allowDisabling:!1})}, {fieldPrefix:"center_", titlePrefix:title({field:continuousFieldName, aggregate:compositeMark, type:"quantitative"}, config, {allowDisabling:!1})}]);
      } else {
        if (markDef.center || markDef.extent) {
          compositeMark = markDef.center;
          var extent$jscomp$0 = markDef.extent;
          warn(`${extent$jscomp$0 ? "extent " : ""}${extent$jscomp$0 && compositeMark ? "and " : ""}${compositeMark ? "center " : ""}${extent$jscomp$0 && compositeMark ? "are " : "is "}not needed when data are aggregated.`);
        }
        inputType === "aggregated-upper-lower" ? (tooltipSummary = [], postAggregateCalculates = [{calculate:accessWithDatumToUnescapedPath(continuousAxisChannelDef2.field), as:`upper_${continuousFieldName}`}, {calculate:accessWithDatumToUnescapedPath(continuousFieldName), as:`lower_${continuousFieldName}`}]) : inputType === "aggregated-error" && (tooltipSummary = [{fieldPrefix:"", titlePrefix:continuousFieldName}], postAggregateCalculates = [{calculate:`${accessWithDatumToUnescapedPath(continuousFieldName)} + ${accessWithDatumToUnescapedPath(continuousAxisChannelDefError.field)}`, 
        as:`upper_${continuousFieldName}`}], continuousAxisChannelDefError2 ? postAggregateCalculates.push({calculate:`${accessWithDatumToUnescapedPath(continuousFieldName)} + ${accessWithDatumToUnescapedPath(continuousAxisChannelDefError2.field)}`, as:`lower_${continuousFieldName}`}) : postAggregateCalculates.push({calculate:`${accessWithDatumToUnescapedPath(continuousFieldName)} - ${accessWithDatumToUnescapedPath(continuousAxisChannelDefError.field)}`, as:`lower_${continuousFieldName}`}));
        for (extent of postAggregateCalculates) {
          tooltipSummary.push({fieldPrefix:extent.as.substring(0, 6), titlePrefix:replaceAll(replaceAll(extent.calculate, "datum['", ""), "']", "")});
        }
      }
      const {errorBarSpecificAggregate, postAggregateCalculates:postAggregateCalculates$jscomp$0, tooltipSummary:tooltipSummary$jscomp$0, tooltipTitleWithFieldName} = {postAggregateCalculates, errorBarSpecificAggregate:spec, tooltipSummary, tooltipTitleWithFieldName:tooltipTitleWithFieldName$jscomp$0}, {[continuousAxis]:oldContinuousAxisChannelDef, [continuousAxis === "x" ? "x2" : "y2"]:oldContinuousAxisChannelDef2, [continuousAxis === "x" ? "xError" : "yError"]:oldContinuousAxisChannelDefError, 
      [continuousAxis === "x" ? "xError2" : "yError2"]:oldContinuousAxisChannelDefError2, ...oldEncodingWithoutContinuousAxis} = encoding, {bins, timeUnits, aggregate:oldAggregate, groupby:oldGroupBy, encoding:encodingWithoutContinuousAxis} = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
      config = [...oldAggregate, ...errorBarSpecificAggregate];
      spec = inputType !== "raw" ? [] : oldGroupBy;
      postAggregateCalculates = getCompositeMarkTooltip(tooltipSummary$jscomp$0, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
      return {transform:[...(outerSpec.transform ?? []), ...bins, ...timeUnits, ...(config.length === 0 ? [] : [{aggregate:config, groupby:spec}]), ...postAggregateCalculates$jscomp$0], groupby:spec, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient:orient === "vertical" ? "horizontal" : "vertical", markDef, outerSpec, tooltipEncoding:postAggregateCalculates};
    }
    function normalizeErrorBand(spec, _ref) {
      ({config:_ref} = _ref);
      spec = {...spec, encoding:normalizeEncoding(spec.encoding, _ref)};
      const {transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding} = errorBarParams(spec, "errorband", _ref);
      _ref = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, _ref.errorband);
      spec = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
      let bandMark = {type:spec ? "area" : "rect"}, bordersMark = {type:spec ? "line" : "rule"};
      const interpolate = {...(markDef.interpolate ? {interpolate:markDef.interpolate} : {}), ...(markDef.tension && markDef.interpolate ? {tension:markDef.tension} : {})};
      spec ? (bandMark = {...bandMark, ...interpolate, ariaRoleDescription:"errorband"}, bordersMark = {...bordersMark, ...interpolate, aria:!1}) : markDef.interpolate ? warn(errorBand1DNotSupport("interpolate")) : markDef.tension && warn(errorBand1DNotSupport("tension"));
      return {...outerSpec, transform, layer:[..._ref({partName:"band", mark:bandMark, positionPrefix:"lower", endPositionPrefix:"upper", extraEncoding:tooltipEncoding}), ..._ref({partName:"borders", mark:bordersMark, positionPrefix:"lower", extraEncoding:tooltipEncoding}), ..._ref({partName:"borders", mark:bordersMark, positionPrefix:"upper", extraEncoding:tooltipEncoding})]};
    }
    function add(mark, run, parts) {
      run = new CompositeMarkNormalizer(mark, run);
      compositeMarkRegistry[mark] = {normalizer:run, parts};
    }
    function isLegendBinding(bind) {
      return bind === "legend" || !!bind?.legend;
    }
    function isLegendStreamBinding(bind) {
      return isLegendBinding(bind) && vega.isObject(bind);
    }
    function assembleParameterSignals(params) {
      const signals = [];
      for (const param of params || []) {
        if (param?.select) {
          continue;
        }
        const {expr, bind, ...rest} = param;
        bind && expr ? signals.push({...rest, bind, init:expr}) : signals.push({...rest, ...(expr ? {update:expr} : {}), ...(bind ? {bind} : {})});
      }
      return signals;
    }
    function getStepFor(_ref) {
      let {step, offsetIsDiscrete} = _ref;
      return offsetIsDiscrete ? step.for ?? "offset" : "position";
    }
    function isStep(size) {
      return hasProperty(size, "step");
    }
    function isFrameMixins(o) {
      return hasProperty(o, "view") || hasProperty(o, "width") || hasProperty(o, "height");
    }
    function getViewConfigContinuousSize(viewConfig, channel) {
      return viewConfig[channel] ?? viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
    }
    function getViewConfigDiscreteStep(viewConfig, channel) {
      viewConfig = getViewConfigDiscreteSize(viewConfig, channel);
      return isStep(viewConfig) ? viewConfig.step : 20;
    }
    function getViewConfigDiscreteSize(viewConfig, channel) {
      return getFirstDefined(viewConfig[channel] ?? viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"], {step:viewConfig.step});
    }
    function colorSignalConfig() {
      let color = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return {signals:[{name:"color", value:vega.isObject(color) ? {...DEFAULT_COLOR, ...color} : DEFAULT_COLOR}], mark:{color:{signal:"color.blue"}}, rule:{color:{signal:"color.gray0"}}, text:{color:{signal:"color.gray0"}}, style:{"guide-label":{fill:{signal:"color.gray0"}}, "guide-title":{fill:{signal:"color.gray0"}}, "group-title":{fill:{signal:"color.gray0"}}, "group-subtitle":{fill:{signal:"color.gray0"}}, cell:{stroke:{signal:"color.gray8"}}}, axis:{domainColor:{signal:"color.gray13"}, gridColor:{signal:"color.gray8"}, 
      tickColor:{signal:"color.gray13"}}, range:{category:[{signal:"color.blue"}, {signal:"color.orange"}, {signal:"color.red"}, {signal:"color.teal"}, {signal:"color.green"}, {signal:"color.yellow"}, {signal:"color.purple"}, {signal:"color.pink"}, {signal:"color.brown"}, {signal:"color.grey8"}]}};
    }
    function getAxisConfigInternal(axisConfig) {
      var props = keys(axisConfig || {});
      const axisConfigInternal = {};
      for (const prop of props) {
        props = axisConfig[prop], axisConfigInternal[prop] = props?.condition ? signalOrValueRefWithCondition(props) : signalRefOrValue(props);
      }
      return axisConfigInternal;
    }
    function initConfig() {
      const {color, font, fontSize, selection, ...restConfig} = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mergedConfig = vega.mergeConfig({}, duplicate(defaultConfig), font ? {text:{font}, style:{"guide-label":{font}, "guide-title":{font}, "group-title":{font}, "group-subtitle":{font}}} : {}, color ? colorSignalConfig(color) : {}, fontSize ? {signals:[{name:"fontSize", value:vega.isObject(fontSize) ? {...DEFAULT_FONT_SIZE, ...fontSize} : DEFAULT_FONT_SIZE}], text:{fontSize:{signal:"fontSize.text"}}, 
      style:{"guide-label":{fontSize:{signal:"fontSize.guideLabel"}}, "guide-title":{fontSize:{signal:"fontSize.guideTitle"}}, "group-title":{fontSize:{signal:"fontSize.groupTitle"}}, "group-subtitle":{fontSize:{signal:"fontSize.groupSubtitle"}}}} : {}, restConfig || {});
      selection && vega.writeConfig(mergedConfig, "selection", selection, !0);
      const outputConfig = omit(mergedConfig, configPropsWithExpr);
      for (var prop$jscomp$0 of ["background", "lineBreak", "padding"]) {
        mergedConfig[prop$jscomp$0] && (outputConfig[prop$jscomp$0] = signalRefOrValue(mergedConfig[prop$jscomp$0]));
      }
      for (var markConfigType of MARK_CONFIGS) {
        mergedConfig[markConfigType] && (outputConfig[markConfigType] = replaceExprRef(mergedConfig[markConfigType]));
      }
      for (var axisConfigType of AXIS_CONFIGS) {
        mergedConfig[axisConfigType] && (outputConfig[axisConfigType] = getAxisConfigInternal(mergedConfig[axisConfigType]));
      }
      for (const headerConfigType of HEADER_CONFIGS) {
        mergedConfig[headerConfigType] && (outputConfig[headerConfigType] = replaceExprRef(mergedConfig[headerConfigType]));
      }
      mergedConfig.legend && (outputConfig.legend = replaceExprRef(mergedConfig.legend));
      if (mergedConfig.scale) {
        const {invalid, ...otherScaleConfig} = mergedConfig.scale;
        prop$jscomp$0 = replaceExprRef(invalid, {level:1});
        outputConfig.scale = {...replaceExprRef(otherScaleConfig), ...(keys(prop$jscomp$0).length > 0 ? {invalid:prop$jscomp$0} : {})};
      }
      if (mergedConfig.style) {
        prop$jscomp$0 = mergedConfig.style;
        markConfigType = keys(prop$jscomp$0);
        axisConfigType = {};
        for (const prop of markConfigType) {
          axisConfigType[prop] = getAxisConfigInternal(prop$jscomp$0[prop]);
        }
        outputConfig.style = axisConfigType;
      }
      mergedConfig.title && (outputConfig.title = replaceExprRef(mergedConfig.title));
      mergedConfig.view && (outputConfig.view = replaceExprRef(mergedConfig.view));
      return outputConfig;
    }
    function stripAndRedirectConfig(config) {
      config = duplicate(config);
      for (var prop$jscomp$0 of VL_ONLY_CONFIG_PROPERTIES) {
        delete config[prop$jscomp$0];
      }
      if (config.axis) {
        for (var prop in config.axis) {
          config.axis[prop]?.condition && delete config.axis[prop];
        }
      }
      if (config.legend) {
        for (var prop$jscomp$1 of VL_ONLY_LEGEND_CONFIG) {
          delete config.legend[prop$jscomp$1];
        }
      }
      if (config.mark) {
        for (var prop$jscomp$2 of VL_ONLY_MARK_CONFIG_PROPERTIES) {
          delete config.mark[prop$jscomp$2];
        }
        config.mark.tooltip && vega.isObject(config.mark.tooltip) && delete config.mark.tooltip;
      }
      config.params && (config.signals = (config.signals || []).concat(assembleParameterSignals(config.params)), delete config.params);
      for (var markType of MARK_STYLES) {
        for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
          delete config[markType][prop];
        }
        if (prop$jscomp$0 = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType]) {
          for (const prop of prop$jscomp$0) {
            delete config[markType][prop];
          }
        }
        prop$jscomp$0 = config;
        prop = markType;
        prop$jscomp$1 = void 0;
        prop$jscomp$2 = prop$jscomp$0[prop];
        prop === "view" && (prop$jscomp$1 = "cell");
        prop$jscomp$2 = {...prop$jscomp$2, ...prop$jscomp$0.style[prop$jscomp$1 ?? prop]};
        isEmpty(prop$jscomp$2) || (prop$jscomp$0.style[prop$jscomp$1 ?? prop] = prop$jscomp$2);
        delete prop$jscomp$0[prop];
      }
      for (const m of keys(compositeMarkRegistry)) {
        delete config[m];
      }
      markType = config;
      const {titleMarkConfig, subtitleMarkConfig, subtitle} = extractTitleConfig(markType.title);
      isEmpty(titleMarkConfig) || (markType.style["group-title"] = {...markType.style["group-title"], ...titleMarkConfig});
      isEmpty(subtitleMarkConfig) || (markType.style["group-subtitle"] = {...markType.style["group-subtitle"], ...subtitleMarkConfig});
      isEmpty(subtitle) ? delete markType.title : markType.title = subtitle;
      for (const prop in config) {
        vega.isObject(config[prop]) && isEmpty(config[prop]) && delete config[prop];
      }
      return isEmpty(config) ? void 0 : config;
    }
    function isUnbinnedQuantitative(channelDef) {
      return isFieldDef(channelDef) && channelDef?.type === "quantitative" && !channelDef.bin;
    }
    function potentialStackedChannel(encoding, x, _ref) {
      let {orient, type:mark} = _ref;
      _ref = x === "x" ? "y" : "radius";
      const isCartesianBarOrArea = x === "x" && ["bar", "area"].includes(mark);
      var xDef = encoding[x];
      encoding = encoding[_ref];
      if (isFieldDef(xDef) && isFieldDef(encoding)) {
        if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(encoding)) {
          if (xDef.stack) {
            return x;
          }
          if (encoding.stack) {
            return _ref;
          }
          xDef = isFieldDef(xDef) && !!xDef.aggregate;
          encoding = isFieldDef(encoding) && !!encoding.aggregate;
          if (xDef !== encoding) {
            return xDef ? x : _ref;
          }
          if (isCartesianBarOrArea) {
            if (orient === "vertical") {
              return _ref;
            }
            if (orient === "horizontal") {
              return x;
            }
          }
        } else {
          if (isUnbinnedQuantitative(xDef)) {
            return x;
          }
          if (isUnbinnedQuantitative(encoding)) {
            return _ref;
          }
        }
      } else {
        if (isUnbinnedQuantitative(xDef)) {
          return isCartesianBarOrArea && orient === "vertical" ? void 0 : x;
        }
        if (isUnbinnedQuantitative(encoding)) {
          return isCartesianBarOrArea && orient === "horizontal" ? void 0 : _ref;
        }
      }
    }
    function getDimensionChannel(channel) {
      switch(channel) {
        case "x":
          return "y";
        case "y":
          return "x";
        case "theta":
          return "radius";
        case "radius":
          return "theta";
      }
    }
    function stack(m, encoding) {
      var markDef = isMarkDef(m) ? m : {type:m};
      m = markDef.type;
      if (!STACKABLE_MARKS.has(m)) {
        return null;
      }
      markDef = potentialStackedChannel(encoding, "x", markDef) || potentialStackedChannel(encoding, "theta", markDef);
      if (!markDef) {
        return null;
      }
      const stackedFieldDef = encoding[markDef];
      var stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0, dimensionChannel = getDimensionChannel(markDef);
      const groupbyChannels = [], groupbyFields = new Set();
      if (encoding[dimensionChannel]) {
        var dimensionDef = encoding[dimensionChannel];
        (dimensionDef = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0) && dimensionDef !== stackedField && (groupbyChannels.push(dimensionChannel), groupbyFields.add(dimensionDef));
      }
      dimensionChannel = dimensionChannel === "x" ? "xOffset" : "yOffset";
      dimensionDef = encoding[dimensionChannel];
      (dimensionDef = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0) && dimensionDef !== stackedField && (groupbyChannels.push(dimensionChannel), groupbyFields.add(dimensionDef));
      stackedField = NONPOSITION_CHANNELS.reduce((sc, channel) => {
        if (channel !== "tooltip" && channelHasField(encoding, channel)) {
          var channelDef = encoding[channel];
          for (const cDef of vega.array(channelDef)) {
            channelDef = getFieldDef(cDef);
            if (channelDef.aggregate) {
              continue;
            }
            const f = vgField(channelDef, {});
            f && groupbyFields.has(f) || sc.push({channel, fieldDef:channelDef});
          }
        }
        return sc;
      }, []);
      let offset;
      stackedFieldDef.stack !== void 0 ? offset = vega.isBoolean(stackedFieldDef.stack) ? stackedFieldDef.stack ? "zero" : null : stackedFieldDef.stack : STACK_BY_DEFAULT_MARKS.has(m) && (offset = "zero");
      if (!offset || !vega.hasOwnProperty(STACK_OFFSET_INDEX, offset) || isAggregate$1(encoding) && stackedField.length === 0) {
        return null;
      }
      stackedFieldDef?.scale?.type && stackedFieldDef?.scale?.type !== ScaleType.LINEAR && stackedFieldDef?.stack && warn(`Stack is applied to a non-linear scale (${stackedFieldDef.scale.type}).`);
      if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(markDef)])) {
        return stackedFieldDef.stack !== void 0 && warn(`Cannot stack "${markDef}" if there is already "${markDef}2".`), null;
      }
      isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate) && warn(`Stacking is applied even though the aggregate function is non-summative ("${stackedFieldDef.aggregate}").`);
      return {groupbyChannels, groupbyFields, fieldChannel:markDef, impute:stackedFieldDef.impute === null ? !1 : isPathMark(m), stackBy:stackedField, offset};
    }
    function initMarkdef(originalMarkDef, encoding, config) {
      originalMarkDef = replaceExprRef(originalMarkDef);
      var specifiedOrient = getMarkPropOrConfig("orient", originalMarkDef, config);
      originalMarkDef.orient = orient(originalMarkDef.type, encoding, specifiedOrient);
      specifiedOrient !== void 0 && specifiedOrient !== originalMarkDef.orient && warn(`Specified orient "${originalMarkDef.orient}" overridden with "${specifiedOrient}".`);
      if (originalMarkDef.type === "bar" && originalMarkDef.orient && (specifiedOrient = getMarkPropOrConfig("cornerRadiusEnd", originalMarkDef, config), specifiedOrient !== void 0)) {
        const newProps = originalMarkDef.orient === "horizontal" && encoding.x2 || originalMarkDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[originalMarkDef.orient];
        for (var newProp of newProps) {
          originalMarkDef[newProp] = specifiedOrient;
        }
        originalMarkDef.cornerRadiusEnd !== void 0 && delete originalMarkDef.cornerRadiusEnd;
      }
      newProp = getMarkPropOrConfig("opacity", originalMarkDef, config);
      specifiedOrient = getMarkPropOrConfig("fillOpacity", originalMarkDef, config);
      newProp === void 0 && specifiedOrient === void 0 && (newProp = contains([POINT, TICK, CIRCLE, SQUARE], originalMarkDef.type) && !isAggregate$1(encoding) ? 0.7 : void 0, originalMarkDef.opacity = newProp);
      getMarkPropOrConfig("cursor", originalMarkDef, config) === void 0 && (encoding = encoding.href || originalMarkDef.href || getMarkPropOrConfig("href", originalMarkDef, config) ? "pointer" : originalMarkDef.cursor, originalMarkDef.cursor = encoding);
      return originalMarkDef;
    }
    function defaultFilled(markDef, config, _ref) {
      ({graticule:_ref} = _ref);
      if (_ref) {
        return !1;
      }
      config = getMarkConfig("filled", markDef, config);
      markDef = markDef.type;
      return getFirstDefined(config, markDef !== POINT && markDef !== LINE && markDef !== RULE);
    }
    function orient(mark, encoding, specifiedOrient) {
      switch(mark) {
        case POINT:
        case CIRCLE:
        case SQUARE:
        case TEXT:
        case RECT:
        case IMAGE:
          return;
      }
      const {x, y, x2, y2} = encoding;
      switch(mark) {
        case BAR:
          if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {
            break;
          }
          if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {
            return "horizontal";
          }
          if (y2 || x2) {
            if (specifiedOrient) {
              return specifiedOrient;
            }
            if (!x2) {
              if ((isFieldDef(x) && x.type === "quantitative" && !isBinning(x.bin) || isNumericDataDef(x)) && isFieldDef(y) && isBinned(y.bin)) {
                return "horizontal";
              }
              break;
            }
            if (!y2) {
              if ((isFieldDef(y) && y.type === "quantitative" && !isBinning(y.bin) || isNumericDataDef(y)) && isFieldDef(x) && isBinned(x.bin)) {
                break;
              }
              return "horizontal";
            }
          }
        case RULE:
          if (!(!x2 || isFieldDef(x) && isBinned(x.bin) || !y2 || isFieldDef(y) && isBinned(y.bin))) {
            return;
          }
        case AREA:
          if (y2) {
            if (isFieldDef(y) && isBinned(y.bin)) {
              return "horizontal";
            }
            break;
          } else if (x2) {
            if (isFieldDef(x) && isBinned(x.bin)) {
              break;
            } else {
              return "horizontal";
            }
          } else if (mark === RULE) {
            if (x && !y) {
              break;
            } else if (y && !x) {
              return "horizontal";
            }
          }
        case LINE:
        case TICK:
          encoding = isUnbinnedQuantitativeFieldOrDatumDef(x);
          const yIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(y);
          if (specifiedOrient) {
            return specifiedOrient;
          }
          if (encoding && !yIsMeasure) {
            return mark !== "tick" ? "horizontal" : "vertical";
          }
          if (!encoding && yIsMeasure) {
            return mark !== "tick" ? "vertical" : "horizontal";
          }
          if (!encoding || !yIsMeasure) {
            if (mark = isTypedFieldDef(x) && x.type === "temporal", specifiedOrient = isTypedFieldDef(y) && y.type === "temporal", !mark || specifiedOrient) {
              if (!mark && specifiedOrient) {
                return "horizontal";
              }
              return;
            }
          }
      }
      return "vertical";
    }
    function getPointOverlay(markDef) {
      let markConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, encoding = arguments.length > 2 ? arguments[2] : void 0;
      if (markDef.point === "transparent") {
        return {opacity:0};
      }
      if (markDef.point) {
        return vega.isObject(markDef.point) ? markDef.point : {};
      }
      if (markDef.point !== void 0) {
        return null;
      }
      if (markConfig.point || encoding.shape) {
        return vega.isObject(markConfig.point) ? markConfig.point : {};
      }
    }
    function getLineOverlay(markDef) {
      let markConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (markDef.line) {
        return markDef.line === !0 ? {} : markDef.line;
      }
      if (markDef.line !== void 0) {
        return null;
      }
      if (markConfig.line) {
        return markConfig.line === !0 ? {} : markConfig.line;
      }
    }
    function replaceRepeaterInEncoding(encoding, repeater) {
      return repeater ? replaceRepeaterInMapping(encoding, repeater) : encoding;
    }
    function replaceRepeatInProp(prop, o, repeater) {
      const val = o[prop];
      if (!vega.isString(val) && hasProperty(val, "repeat")) {
        if (val.repeat in repeater) {
          return {...o, [prop]:repeater[val.repeat]};
        }
        warn(`Unknown repeated value "${val.repeat}".`);
      } else {
        return o;
      }
    }
    function replaceRepeaterInFieldDef(fieldDef, repeater) {
      fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
      if (fieldDef !== void 0) {
        if (fieldDef === null) {
          return null;
        }
        hasProperty(fieldDef, "sort") && isSortField(fieldDef.sort) && (repeater = replaceRepeatInProp("field", fieldDef.sort, repeater), fieldDef = {...fieldDef, ...(repeater ? {sort:repeater} : {})});
        return fieldDef;
      }
    }
    function replaceRepeaterInFieldOrDatumDef(def, repeater) {
      if (isFieldDef(def)) {
        return replaceRepeaterInFieldDef(def, repeater);
      }
      repeater = replaceRepeatInProp("datum", def, repeater);
      repeater === def || repeater.type || (repeater.type = "nominal");
      return repeater;
    }
    function replaceRepeaterInChannelDef(channelDef, repeater) {
      if (isFieldOrDatumDef(channelDef)) {
        if (repeater = replaceRepeaterInFieldOrDatumDef(channelDef, repeater)) {
          return repeater;
        }
        if (isConditionalDef(channelDef)) {
          return {condition:channelDef.condition};
        }
      } else {
        if (hasConditionalFieldOrDatumDef(channelDef)) {
          if (repeater = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater)) {
            return {...channelDef, condition:repeater};
          }
          const {condition, ...channelDefWithoutCondition} = channelDef;
          return channelDefWithoutCondition;
        }
        return channelDef;
      }
    }
    function replaceRepeaterInMapping(mapping, repeater) {
      const out = {};
      for (const channel in mapping) {
        if (hasProperty(mapping, channel)) {
          var channelDef = mapping[channel];
          vega.isArray(channelDef) ? out[channel] = channelDef.map(cd => replaceRepeaterInChannelDef(cd, repeater)).filter(cd => cd) : (channelDef = replaceRepeaterInChannelDef(channelDef, repeater), channelDef !== void 0 && (out[channel] = channelDef));
        }
      }
      return out;
    }
    function mergeEncoding(_ref2) {
      let {parentEncoding, encoding = {}, layer} = _ref2;
      _ref2 = {};
      if (parentEncoding) {
        var channels = new Set([...keys(parentEncoding), ...keys(encoding)]);
        for (const channel of channels) {
          channels = encoding[channel];
          const parentChannelDef = parentEncoding[channel];
          if (isFieldOrDatumDef(channels)) {
            _ref2[channel] = {...parentChannelDef, ...channels};
          } else if (hasConditionalFieldOrDatumDef(channels)) {
            _ref2[channel] = {...channels, condition:{...parentChannelDef, ...channels.condition}};
          } else if (channels || channels === null) {
            _ref2[channel] = channels;
          } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || vega.isArray(parentChannelDef)) {
            _ref2[channel] = parentChannelDef;
          }
        }
      } else {
        _ref2 = encoding;
      }
      return !_ref2 || isEmpty(_ref2) ? void 0 : _ref2;
    }
    function mergeProjection(opt) {
      const {parentProjection:parentProjection$jscomp$0, projection:projection$jscomp$0} = opt;
      if (parentProjection$jscomp$0 && projection$jscomp$0) {
        const {parentProjection, projection} = {parentProjection:parentProjection$jscomp$0, projection:projection$jscomp$0};
        opt = `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;
        warn(opt);
      }
      return projection$jscomp$0 ?? parentProjection$jscomp$0;
    }
    function normalizeTransform(transform) {
      return transform.map(t => hasProperty(t, "filter") ? {filter:normalizeLogicalComposition(t.filter, normalizePredicate$1)} : t);
    }
    function normalizeTransforms(spec, normParams) {
      const {transform:tx, ...rest} = spec;
      return tx ? (spec = tx.map(t => {
        if (hasProperty(t, "filter")) {
          return {filter:normalizePredicate(t, normParams)};
        }
        if (hasProperty(t, "bin") && vega.isObject(t.bin)) {
          return {...t, bin:normalizeBinExtent(t.bin)};
        }
        if (hasProperty(t, "lookup")) {
          const {selection:param, ...from} = t.from;
          return param ? {...t, from:{param, ...from}} : t;
        }
        return t;
      }), {...rest, transform:spec}) : spec;
    }
    function normalizeChannelDef(obj, normParams) {
      obj = duplicate(obj);
      isFieldDef(obj) && vega.isObject(obj.bin) && (obj.bin = normalizeBinExtent(obj.bin));
      if (isScaleFieldDef(obj) && obj.scale?.domain?.selection) {
        const {selection:param, ...domain} = obj.scale.domain;
        obj.scale.domain = {...domain, ...(param ? {param} : {})};
      }
      if (isConditionalDef(obj)) {
        if (vega.isArray(obj.condition)) {
          obj.condition = obj.condition.map(c => {
            const {selection, param, test, ...cond} = c;
            return param ? c : {...cond, test:normalizePredicate(c, normParams)};
          });
        } else {
          const {selection, param, test, ...cond} = normalizeChannelDef(obj.condition, normParams);
          obj.condition = param ? obj.condition : {...cond, test:normalizePredicate(obj.condition, normParams)};
        }
      }
      return obj;
    }
    function normalizeBinExtent(bin) {
      const ext = bin.extent;
      if (ext?.selection) {
        const {selection:param, ...rest} = ext;
        return {...bin, extent:{...rest, param}};
      }
      return bin;
    }
    function normalizePredicate(op, normParams) {
      const normalizeSelectionComposition = o => normalizeLogicalComposition(o, param => {
        const pred = {param, empty:normParams.emptySelections[param] ?? !0};
        let $jscomp$logical$assign$tmp730812712$0;
        ($jscomp$logical$assign$tmp730812712$0 = normParams.selectionPredicates)[param] ?? ($jscomp$logical$assign$tmp730812712$0[param] = []);
        normParams.selectionPredicates[param].push(pred);
        return pred;
      });
      return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);
    }
    function normalize(spec, config) {
      config === void 0 && (config = initConfig(spec.config));
      const normalizedSpec = normalizeGenericSpec(spec, config), {width:width$jscomp$0, height:height$jscomp$0} = spec;
      {
        let {width, height} = {width:width$jscomp$0, height:height$jscomp$0, autosize:spec.autosize};
        spec = isUnitSpec(normalizedSpec) || hasProperty(normalizedSpec, "layer");
        const autosizeDefault = {};
        spec ? width == "container" && height == "container" ? (autosizeDefault.type = "fit", autosizeDefault.contains = "padding") : width == "container" ? (autosizeDefault.type = "fit-x", autosizeDefault.contains = "padding") : height == "container" && (autosizeDefault.type = "fit-y", autosizeDefault.contains = "padding") : (width == "container" && (warn(containerSizeNonSingle("width")), width = void 0), height == "container" && (warn(containerSizeNonSingle("height")), height = void 0));
        config = {type:"pad", ...autosizeDefault, ...(config ? _normalizeAutoSize(config.autosize) : {}), ..._normalizeAutoSize(normalizedSpec.autosize)};
        config.type !== "fit" || spec || (warn('Autosize "fit" only works for single views and layered views.'), config.type = "pad");
        width == "container" && config.type != "fit" && config.type != "fit-x" && warn(containerSizeNotCompatibleWithAutosize("width"));
        height == "container" && config.type != "fit" && config.type != "fit-y" && warn(containerSizeNotCompatibleWithAutosize("height"));
        config = deepEqual(config, {type:"pad"}) ? void 0 : config;
      }
      return {...normalizedSpec, ...(config ? {autosize:config} : {})};
    }
    function normalizeGenericSpec(spec) {
      const normParams = {config:arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}};
      return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);
    }
    function _normalizeAutoSize(autosize) {
      return vega.isString(autosize) ? {type:autosize} : autosize ?? {};
    }
    function extractTopLevelProperties(t, includeParams) {
      const o = {};
      for (const p of TOP_LEVEL_PROPERTIES) {
        t && t[p] !== void 0 && (o[p] = signalRefOrValue(t[p]));
      }
      includeParams && (o.params = t.params);
      return o;
    }
    function makeExplicit(value) {
      return {explicit:!0, value};
    }
    function makeImplicit(value) {
      return {explicit:!1, value};
    }
    function tieBreakByComparing(compare) {
      return (v1, v2, property, propertyOf) => {
        const diff = compare(v1.value, v2.value);
        return diff > 0 ? v1 : diff < 0 ? v2 : defaultTieBreaker(v1, v2, property, propertyOf);
      };
    }
    function defaultTieBreaker(v1$jscomp$0, v2, property, propertyOf) {
      if (v1$jscomp$0.explicit && v2.explicit) {
        var v1 = v1$jscomp$0.value;
        v2 = v2.value;
        property = `Conflicting ${propertyOf.toString()} property "${property.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;
        warn(property);
      }
      return v1$jscomp$0;
    }
    function mergeValuesWithExplicit(v1, v2, property, propertyOf) {
      let tieBreaker = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : defaultTieBreaker;
      return v1 === void 0 || v1.value === void 0 ? v2 : v1.explicit && !v2.explicit ? v1 : v2.explicit && !v1.explicit ? v2 : deepEqual(v1.value, v2.value) ? v1 : tieBreaker(v1, v2, property, propertyOf);
    }
    function isInlineData(data) {
      return hasProperty(data, "values");
    }
    function isNamedData(data) {
      return hasProperty(data, "name") && !hasProperty(data, "url") && !isInlineData(data) && !isGenerator(data);
    }
    function isGenerator(data) {
      return data && (hasProperty(data, "sequence") || hasProperty(data, "sphere") || hasProperty(data, "graticule"));
    }
    function getDataSourcesForHandlingInvalidValues(_ref) {
      let {invalid, isPath} = _ref;
      switch(normalizeInvalidDataMode(invalid, {isPath})) {
        case "filter":
          return {marks:"exclude-invalid-values", scales:"exclude-invalid-values"};
        case "break-paths-show-domains":
          return {marks:isPath ? "include-invalid-values" : "exclude-invalid-values", scales:"include-invalid-values"};
        case "break-paths-filter-domains":
          return {marks:isPath ? "include-invalid-values" : "exclude-invalid-values", scales:"exclude-invalid-values"};
        case "show":
          return {marks:"include-invalid-values", scales:"include-invalid-values"};
      }
    }
    function getScaleDataSourceForHandlingInvalidValues(props) {
      const {marks, scales} = getDataSourcesForHandlingInvalidValues(props);
      return marks === scales ? DataSourceType.Main : scales === "include-invalid-values" ? DataSourceType.PreFilterInvalid : DataSourceType.PostFilterInvalid;
    }
    function offsetExpr(_ref) {
      let {timeUnit, field, reverse} = _ref;
      const {unit, utc} = timeUnit;
      _ref = getSmallestTimeUnitPart(unit);
      const {part, step} = getDateTimePartAndStep(_ref, timeUnit.step);
      return `${utc ? "utcOffset" : "timeOffset"}('${part}', ${accessWithDatumToUnescapedPath(field)}, ${reverse ? -step : step})`;
    }
    function offsetedRectFormulas(_ref2, rectBandPosition, timeUnit) {
      let [startField, endField] = _ref2;
      if (rectBandPosition !== void 0 && rectBandPosition !== 0.5) {
        _ref2 = accessWithDatumToUnescapedPath(startField);
        const endExpr = accessWithDatumToUnescapedPath(endField);
        return [{type:"formula", expr:interpolateExpr([offsetExpr({timeUnit, field:startField, reverse:!0}), _ref2], rectBandPosition + 0.5), as:`${startField}_${"offsetted_rect_start"}`}, {type:"formula", expr:interpolateExpr([_ref2, endExpr], rectBandPosition + 0.5), as:`${startField}_${"offsetted_rect_end"}`}];
      }
      return [];
    }
    function interpolateExpr(_ref3, fraction) {
      let [start, end] = _ref3;
      return `${1 - fraction} * ${start} + ${fraction} * ${end}`;
    }
    function assembleProjection(proj) {
      const {signals, hasLegend, index, ...rest} = proj;
      rest.field = replacePathInField(rest.field);
      return rest;
    }
    function assembleInit(init) {
      let isExpr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, wrap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : vega.identity;
      if (vega.isArray(init)) {
        const assembled = init.map(v => assembleInit(v, isExpr, wrap));
        return isExpr ? `[${assembled.join(", ")}]` : assembled;
      }
      return isDateTime(init) ? isExpr ? wrap(dateTimeToExpr(init)) : wrap(dateTimeToTimestamp(init)) : isExpr ? wrap(stringify(init)) : init;
    }
    function assembleFacetSignals(model, signals) {
      model.component.selection && keys(model.component.selection).length && (model = vega.stringValue(model.getName("cell")), signals.unshift({name:"facet", value:{}, on:[{events:vega.parseSelector("pointermove", "scope"), update:`isTuple(facet) ? facet : group(${model}).datum`}]}));
      return cleanupEmptyOnArray(signals);
    }
    function assembleTopLevelSignals(model, signals) {
      var hasSelections = !1;
      for (const selCmpt of vals(model.component.selection ?? {})) {
        const name = selCmpt.name;
        hasSelections = vega.stringValue(name + "_store");
        if (signals.filter(s => s.name === name).length === 0) {
          const isPoint = selCmpt.type === "point" ? ", true, true)" : ")";
          signals.push({name:selCmpt.name, update:`${"vlSelectionResolve"}(${hasSelections}, ${vega.stringValue(selCmpt.resolve === "global" ? "union" : selCmpt.resolve)}${isPoint}`});
        }
        hasSelections = !0;
        for (const c of selectionCompilers) {
          c.defined(selCmpt) && c.topLevelSignals && (signals = c.topLevelSignals(model, selCmpt, signals));
        }
      }
      hasSelections && signals.filter(s => s.name === "unit").length === 0 && signals.unshift({name:"unit", value:{}, on:[{events:"pointermove", update:"isTuple(group()) ? group() : unit"}]});
      return cleanupEmptyOnArray(signals);
    }
    function assembleUnitSelectionData(model, data) {
      const selectionData = [], animationData = [], unit = unitName(model, {escape:!1});
      for (const selCmpt of vals(model.component.selection ?? {})) {
        var store = {name:selCmpt.name + "_store"};
        selCmpt.project.hasSelectionId && (store.transform = [{type:"collect", sort:{field:"_vgsid_"}}]);
        if (selCmpt.init) {
          const fields = selCmpt.project.items.map(assembleProjection);
          store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map(i => ({unit, _vgsid_:assembleInit(i, !1)[0]})) : selCmpt.init.map(i => ({unit, fields, values:assembleInit(i, !1)}));
        }
        [...selectionData, ...data].filter(d => d.name === selCmpt.name + "_store").length || selectionData.push(store);
        if (isTimerSelection(selCmpt) && data.length) {
          const sourceName = model.lookupDataSource(model.getDataName(DataSourceType.Main));
          store = data.find(d => d.name === sourceName);
          const sourceDataFilter = store.transform.find(t => t.type === "filter" && t.expr.includes("vlSelectionTest"));
          sourceDataFilter && (store.transform = store.transform.filter(t => t !== sourceDataFilter), animationData.push({name:store.name + "_curr", source:store.name, transform:[sourceDataFilter]}));
        }
      }
      return selectionData.concat(data, animationData);
    }
    function assembleUnitSelectionMarks(model, marks) {
      for (const selCmpt of vals(model.component.selection ?? {})) {
        for (const c of selectionCompilers) {
          c.defined(selCmpt) && c.marks && (marks = c.marks(model, selCmpt, marks));
        }
      }
      return marks;
    }
    function assembleLayerSelectionMarks(model, marks) {
      for (const child of model.children) {
        isUnitModel(child) && (marks = assembleUnitSelectionMarks(child, marks));
      }
      return marks;
    }
    function cleanupEmptyOnArray(signals) {
      return signals.map(s => {
        s.on && !s.on.length && delete s.on;
        return s;
      });
    }
    function domain(model, channel) {
      return `domain(${vega.stringValue(model.scaleName(channel))})`;
    }
    function isTopLevelLayer(model) {
      return model.parent && isLayerModel(model.parent) && (!model.parent.parent || isTopLevelLayer(model.parent.parent));
    }
    function channelSignals(model, selCmpt, proj, init) {
      var scaledInterval = !model.hasProjection, channel = proj.channel;
      const vname = proj.signals.visual, scaleName = vega.stringValue(scaledInterval ? model.scaleName(channel) : model.projectionName());
      var scaled = str => `scale(${scaleName}, ${str})`;
      const size = model.getSizeSignalRef(channel === "x" ? "width" : "height").signal, coord = `${channel}(unit)`, von = selCmpt.events.reduce((def, evt) => [...def, {events:evt.between[0], update:`[${coord}, ${coord}]`}, {events:evt, update:`[${vname}[0], clamp(${coord}, 0, ${size})]`}], []);
      if (scaledInterval) {
        return proj = proj.signals.data, scaledInterval = scaleBindings.defined(selCmpt), model = (model = model.getScaleComponent(channel)) ? model.get("type") : void 0, channel = init ? {init:assembleInit(init, !0, scaled)} : {value:[]}, von.push({events:{signal:selCmpt.name + "_scale_trigger"}, update:hasContinuousDomain(model) ? `[${scaled(`${proj}[0]`)}, ${scaled(`${proj}[1]`)}]` : "[0, 0]"}), scaledInterval ? [{name:proj, on:[]}] : [{name:vname, ...channel, on:von}, {name:proj, ...(init ? {init:assembleInit(init)} : 
        {}), on:[{events:{signal:vname}, update:`${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`}]}];
      }
      scaled = channel === "x" ? 0 : 1;
      selCmpt = selCmpt.name + "_init";
      return [{name:vname, ...(init ? {init:`[${selCmpt}[0][${scaled}], ${selCmpt}[1][${scaled}]]`} : {value:[]}), on:von}];
    }
    function wrapCondition(_ref) {
      let {model, channelDef, vgChannel, invalidValueRef, mainRefFn} = _ref;
      var condition = isConditionalDef(channelDef) && channelDef.condition;
      _ref = [];
      condition && (_ref = vega.array(condition).map(c => {
        const conditionValueRef = mainRefFn(c);
        if (hasProperty(c, "param")) {
          const {param, empty} = c;
          return {test:parseSelectionPredicate(model, {param, empty}), ...conditionValueRef};
        }
        return {test:expression(model, c.test), ...conditionValueRef};
      }));
      invalidValueRef !== void 0 && _ref.push(invalidValueRef);
      condition = mainRefFn(channelDef);
      condition !== void 0 && _ref.push(condition);
      return _ref.length > 1 || _ref.length === 1 && _ref[0].test ? {[vgChannel]:_ref} : _ref.length === 1 ? {[vgChannel]:_ref[0]} : {};
    }
    function text$1(model) {
      let channel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "text";
      return wrapCondition({model, channelDef:model.encoding[channel], vgChannel:channel, mainRefFn:cDef => textRef(cDef, model.config), invalidValueRef:void 0});
    }
    function textRef(channelDef, config) {
      let expr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "datum";
      if (channelDef) {
        if (isValueDef(channelDef)) {
          return signalOrValueRef(channelDef.value);
        }
        if (isFieldOrDatumDef(channelDef)) {
          const {format, formatType} = getFormatMixins(channelDef);
          return formatSignalRef({fieldOrDatumDef:channelDef, format, formatType, expr, config});
        }
      }
    }
    function tooltip(model) {
      let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {encoding, markDef, config, stack} = model, channelDef = encoding.tooltip;
      if (vega.isArray(channelDef)) {
        return {tooltip:tooltipRefForEncoding({tooltip:channelDef}, stack, config, opt)};
      }
      const datum = opt.reactiveGeom ? "datum.datum" : "datum";
      return wrapCondition({model, channelDef, vgChannel:"tooltip", mainRefFn:cDef => {
        const tooltipRefFromChannelDef = textRef(cDef, config, datum);
        if (tooltipRefFromChannelDef) {
          return tooltipRefFromChannelDef;
        }
        if (cDef !== null) {
          cDef = getMarkPropOrConfig("tooltip", markDef, config);
          cDef === !0 && (cDef = {content:"encoding"});
          if (vega.isString(cDef)) {
            return {value:cDef};
          }
          if (vega.isObject(cDef)) {
            return isSignalRef(cDef) ? cDef : cDef.content === "encoding" ? tooltipRefForEncoding(encoding, stack, config, opt) : {signal:datum};
          }
        }
      }, invalidValueRef:void 0});
    }
    function tooltipData(encoding, stack, config) {
      function add(fDef, channel) {
        var mainChannel = getMainRangeChannel(channel);
        fDef = isTypedFieldDef(fDef) ? fDef : {...fDef, type:encoding[mainChannel].type};
        mainChannel = fDef.title || titleFormatter(fDef, formatConfig);
        mainChannel = vega.array(mainChannel).join(", ").replaceAll(/"/g, '\\"');
        if (isXorY(channel)) {
          const channel2 = channel === "x" ? "x2" : "y2";
          var fieldDef2 = getFieldDef(encoding[channel2]);
          if (isBinned(fDef.bin) && fieldDef2) {
            var value = vgField(fDef, {expr});
            fieldDef2 = vgField(fieldDef2, {expr});
            const {format, formatType} = getFormatMixins(fDef);
            value = binFormatExpression(value, fieldDef2, format, formatType, formatConfig);
            toSkip.add(channel2);
          }
        }
        if ((isXorY(channel) || channel === "theta" || channel === "radius") && stack && stack.fieldChannel === channel && stack.offset === "normalize") {
          const {format, formatType} = getFormatMixins(fDef);
          value = formatSignalRef({fieldOrDatumDef:fDef, format, formatType, expr, config:formatConfig, normalizeStack:!0}).signal;
        }
        value ??= textRef(fDef, formatConfig, expr).signal;
        tuples.push({channel, key:mainChannel, value});
      }
      var {reactiveGeom} = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const formatConfig = {...config, ...config.tooltipFormat}, toSkip = new Set(), expr = reactiveGeom ? "datum.datum" : "datum", tuples = [];
      forEach(encoding, (channelDef, channel) => {
        isFieldDef(channelDef) ? add(channelDef, channel) : hasConditionalFieldDef(channelDef) && add(channelDef.condition, channel);
      });
      reactiveGeom = {};
      for (const {channel, key, value} of tuples) {
        toSkip.has(channel) || reactiveGeom[key] || (reactiveGeom[key] = value);
      }
      return reactiveGeom;
    }
    function tooltipRefForEncoding(encoding, stack, config) {
      var {reactiveGeom} = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      reactiveGeom = tooltipData(encoding, stack, config, {reactiveGeom});
      reactiveGeom = entries$1(reactiveGeom).map(_ref => {
        let [key, value] = _ref;
        return `"${key}": ${value}`;
      });
      return reactiveGeom.length > 0 ? {signal:`{${reactiveGeom.join(", ")}}`} : void 0;
    }
    function description(model) {
      const {encoding, markDef, config, stack} = model;
      var channelDef = encoding.description;
      if (channelDef) {
        return wrapCondition({model, channelDef, vgChannel:"description", mainRefFn:cDef => textRef(cDef, model.config), invalidValueRef:void 0});
      }
      channelDef = getMarkPropOrConfig("description", markDef, config);
      if (channelDef != null) {
        return {description:signalOrValueRef(channelDef)};
      }
      if (config.aria === !1) {
        return {};
      }
      channelDef = tooltipData(encoding, stack, config);
      if (!isEmpty(channelDef)) {
        return {description:{signal:entries$1(channelDef).map((_ref, index) => {
          let [key, value] = _ref;
          return `"${index > 0 ? "; " : ""}${key}: " + (${value})`;
        }).join(" + ")}};
      }
    }
    function nonPosition(channel, model) {
      var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const {markDef, encoding, config} = model, {vgChannel} = opt;
      let {defaultRef, defaultValue} = opt;
      opt = encoding[channel];
      defaultRef === void 0 && (defaultValue ??= getMarkPropOrConfig(channel, markDef, config, {vgChannel, ignoreVgConfig:!isConditionalDef(opt)}), defaultValue !== void 0 && (defaultRef = signalOrValueRef(defaultValue)));
      const commonProps = {markDef, config, scaleName:model.scaleName(channel), scale:model.getScaleComponent(channel)}, invalidValueRef = getConditionalValueRefForIncludingInvalidValue({...commonProps, scaleChannel:channel, channelDef:opt});
      return wrapCondition({model, channelDef:opt, vgChannel:vgChannel ?? channel, invalidValueRef, mainRefFn:cDef => midPoint({...commonProps, channel, channelDef:cDef, stack:null, defaultRef})});
    }
    function color(model) {
      var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {filled:void 0};
      const {markDef, encoding, config} = model;
      var {type:markType} = markDef;
      opt = opt.filled ?? getMarkPropOrConfig("filled", markDef, config);
      markType = contains(["bar", "point", "circle", "square", "geoshape"], markType) ? "transparent" : void 0;
      markType = getMarkPropOrConfig(opt === !0 ? "color" : void 0, markDef, config, {vgChannel:"fill"}) ?? config.mark[opt === !0 && "color"] ?? markType;
      const defaultStroke = getMarkPropOrConfig(opt === !1 ? "color" : void 0, markDef, config, {vgChannel:"stroke"}) ?? config.mark[opt === !1 && "color"], colorVgChannel = opt ? "fill" : "stroke", fillStrokeMarkDefAndConfig = {...(markType ? {fill:signalOrValueRef(markType)} : {}), ...(defaultStroke ? {stroke:signalOrValueRef(defaultStroke)} : {})};
      markDef.color && (opt ? markDef.fill : markDef.stroke) && warn(droppingColor("property", {fill:"fill" in markDef, stroke:"stroke" in markDef}));
      return {...fillStrokeMarkDefAndConfig, ...nonPosition("color", model, {vgChannel:colorVgChannel, defaultValue:opt ? markType : defaultStroke}), ...nonPosition("fill", model, {defaultValue:encoding.fill ? markType : void 0}), ...nonPosition("stroke", model, {defaultValue:encoding.stroke ? defaultStroke : void 0})};
    }
    function zindex(model) {
      const {encoding, mark} = model, order = encoding.order;
      return !isPathMark(mark) && isValueDef(order) ? wrapCondition({model, channelDef:order, vgChannel:"zindex", mainRefFn:cd => signalOrValueRef(cd.value), invalidValueRef:void 0}) : {};
    }
    function positionOffset(_ref) {
      let {channel:baseChannel, markDef, encoding = {}, model, bandPosition} = _ref;
      _ref = `${baseChannel}Offset`;
      const defaultValue = markDef[_ref], channelDef = encoding[_ref];
      return _ref !== "xOffset" && _ref !== "yOffset" || !channelDef ? (_ref = markDef[_ref]) ? {offsetType:"visual", offset:_ref} : {} : {offsetType:"encoding", offset:midPoint({channel:_ref, channelDef, markDef, config:model?.config, scaleName:model.scaleName(_ref), scale:model.getScaleComponent(_ref), stack:null, defaultRef:signalOrValueRef(defaultValue), bandPosition})};
    }
    function pointPosition(channel$jscomp$0, model, _ref) {
      let {defaultPos, vgChannel} = _ref;
      const {encoding, markDef:markDef$jscomp$0, config, stack:stack$jscomp$0} = model;
      _ref = encoding[channel$jscomp$0];
      const channel2Def = encoding[getSecondaryRangeChannel(channel$jscomp$0)], scaleName$jscomp$0 = model.scaleName(channel$jscomp$0), scale = model.getScaleComponent(channel$jscomp$0), {offset:offset$jscomp$0, offsetType} = positionOffset({channel:channel$jscomp$0, markDef:markDef$jscomp$0, encoding, model, bandPosition:0.5}), defaultRef = pointPositionDefaultRef({model, defaultPos, channel:channel$jscomp$0, scaleName:scaleName$jscomp$0, scale});
      if (!_ref && isXorY(channel$jscomp$0) && (encoding.latitude || encoding.longitude)) {
        model = {field:model.getName(channel$jscomp$0)};
      } else {
        a: {
          model = {channel:channel$jscomp$0, channelDef:_ref, channel2Def, markDef:markDef$jscomp$0, config, scaleName:scaleName$jscomp$0, scale, stack:stack$jscomp$0, offset:offset$jscomp$0, defaultRef, bandPosition:offsetType === "encoding" ? 0 : void 0};
          const {channel, channelDef, scaleName, stack, offset, markDef} = model;
          if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {
            if (isFieldDef(channelDef) && (model = channelDef.bandPosition, model !== void 0 || markDef.type !== "text" || channel !== "radius" && channel !== "theta" || (model = 0.5), model !== void 0)) {
              model = interpolatedSignalRef({scaleName, fieldOrDatumDef:channelDef, startSuffix:"start", bandPosition:model, offset});
              break a;
            }
            model = valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix:"end"}, {offset});
          } else {
            model = midPointRefWithPositionInvalidTest(model);
          }
        }
      }
      return model ? {[vgChannel || channel$jscomp$0]:model} : void 0;
    }
    function pointPositionDefaultRef(_ref2) {
      let {model, defaultPos, channel, scaleName, scale} = _ref2;
      const {markDef, config} = model;
      return () => {
        const mainChannel = getMainRangeChannel(channel);
        var vgChannel = getVgPositionChannel(channel);
        vgChannel = getMarkPropOrConfig(channel, markDef, config, {vgChannel});
        if (vgChannel !== void 0) {
          return widthHeightValueOrSignalRef(channel, vgChannel);
        }
        switch(defaultPos) {
          case "zeroOrMin":
            return zeroOrMinOrMaxPosition({scaleName, scale, mode:"zeroOrMin", mainChannel, config});
          case "zeroOrMax":
            return zeroOrMinOrMaxPosition({scaleName, scale, mode:{zeroOrMax:{widthSignal:model.width.signal, heightSignal:model.height.signal}}, mainChannel, config});
          case "mid":
            return {...model[getSizeChannel(channel)], mult:0.5};
        }
      };
    }
    function zeroOrMinOrMaxPosition(_ref3) {
      let {mainChannel, config, ...otherProps} = _ref3;
      _ref3 = scaledZeroOrMinOrMax(otherProps);
      const {mode} = otherProps;
      if (_ref3) {
        return _ref3;
      }
      switch(mainChannel) {
        case "radius":
          if (mode === "zeroOrMin") {
            return {value:0};
          }
          const {widthSignal, heightSignal} = mode.zeroOrMax;
          return {signal:`min(${widthSignal},${heightSignal})/2`};
        case "theta":
          return mode === "zeroOrMin" ? {value:0} : {signal:"2*PI"};
        case "x":
          return mode === "zeroOrMin" ? {value:0} : {field:{group:"width"}};
        case "y":
          return mode === "zeroOrMin" ? {field:{group:"height"}} : {value:0};
      }
    }
    function vgAlignedPositionChannel(channel, markDef, config) {
      let defaultAlign = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "middle";
      if (channel === "radius" || channel === "theta") {
        return getVgPositionChannel(channel);
      }
      var alignChannel = channel === "x" ? "align" : "baseline";
      const align = getMarkPropOrConfig(alignChannel, markDef, config);
      isSignalRef(align) ? (warn(`The ${alignChannel} for range marks cannot be an expression`), alignChannel = void 0) : alignChannel = align;
      return channel === "x" ? ALIGNED_X_CHANNEL[alignChannel || (defaultAlign === "top" ? "left" : "center")] : BASELINED_Y_CHANNEL[alignChannel || defaultAlign];
    }
    function pointOrRangePosition(channel, model, _ref) {
      let {defaultPos, defaultPos2, range} = _ref;
      return range ? rangePosition(channel, model, {defaultPos, defaultPos2}) : pointPosition(channel, model, {defaultPos});
    }
    function rangePosition(channel, model, _ref2) {
      let {defaultPos, defaultPos2} = _ref2;
      const {markDef, config} = model;
      var channel2 = getSecondaryRangeChannel(channel);
      _ref2 = getSizeChannel(channel);
      {
        const {encoding, mark, markDef:markDef$jscomp$0, stack:stack$jscomp$0, config:config$jscomp$0} = model;
        var baseChannel = getMainRangeChannel(channel2), sizeChannel = getSizeChannel(channel2);
        const vgChannel = getVgPositionChannel(channel2);
        var channelDef$jscomp$0 = encoding[baseChannel], scaleName$jscomp$0 = model.scaleName(baseChannel);
        const scale$jscomp$0 = model.getScaleComponent(baseChannel);
        ({offset:baseChannel} = channel2 in encoding || channel2 in markDef$jscomp$0 ? positionOffset({channel:channel2, markDef:markDef$jscomp$0, encoding, model}) : positionOffset({channel:baseChannel, markDef:markDef$jscomp$0, encoding, model}));
        if (channelDef$jscomp$0 || channel2 !== "x2" && channel2 !== "y2" || !encoding.latitude && !encoding.longitude) {
          let {channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef} = {channel:channel2, channelDef:channelDef$jscomp$0, channel2Def:encoding[channel2], markDef:markDef$jscomp$0, config:config$jscomp$0, scaleName:scaleName$jscomp$0, scale:scale$jscomp$0, stack:stack$jscomp$0, offset:baseChannel, defaultRef:void 0};
          channelDef$jscomp$0 = isFieldOrDatumDef(channelDef) && stack && channel.charAt(0) === stack.fieldChannel.charAt(0) ? valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix:"start"}, {offset}) : midPointRefWithPositionInvalidTest({channel, channelDef:channel2Def, scaleName, scale, stack, markDef, config, offset, defaultRef});
          channel2 = channelDef$jscomp$0 !== void 0 ? {[vgChannel]:channelDef$jscomp$0} : position2orSize(channel2, markDef$jscomp$0) || position2orSize(channel2, {[channel2]:getMarkStyleConfig(channel2, markDef$jscomp$0, config$jscomp$0.style), [sizeChannel]:getMarkStyleConfig(sizeChannel, markDef$jscomp$0, config$jscomp$0.style)}) || position2orSize(channel2, config$jscomp$0[mark]) || position2orSize(channel2, config$jscomp$0.mark) || {[vgChannel]:pointPositionDefaultRef({model, defaultPos:defaultPos2, 
          channel:channel2, scaleName:scaleName$jscomp$0, scale:scale$jscomp$0})()};
        } else {
          sizeChannel = getSizeChannel(channel2), scaleName$jscomp$0 = model.markDef[sizeChannel], channel2 = scaleName$jscomp$0 != null ? {[sizeChannel]:{value:scaleName$jscomp$0}} : {[vgChannel]:{field:model.getName(channel2)}};
        }
      }
      _ref2 = channel2[_ref2] ? vgAlignedPositionChannel(channel, markDef, config) : getVgPositionChannel(channel);
      return {...pointPosition(channel, model, {defaultPos, vgChannel:_ref2}), ...channel2};
    }
    function position2orSize(channel, markDef) {
      const sizeChannel = getSizeChannel(channel), vgChannel = getVgPositionChannel(channel);
      if (markDef[vgChannel] !== void 0) {
        return {[vgChannel]:widthHeightValueOrSignalRef(channel, markDef[vgChannel])};
      }
      if (markDef[channel] !== void 0) {
        return {[vgChannel]:widthHeightValueOrSignalRef(channel, markDef[channel])};
      }
      if (markDef[sizeChannel]) {
        if (markDef = markDef[sizeChannel], isRelativeBandSize(markDef)) {
          warn(`Position range does not support relative band size for ${sizeChannel}.`);
        } else {
          return {[sizeChannel]:widthHeightValueOrSignalRef(channel, markDef)};
        }
      }
    }
    function rectPosition(model$jscomp$0, channel$jscomp$0) {
      const {config, encoding, markDef} = model$jscomp$0;
      var mark = markDef.type, channel2 = getSecondaryRangeChannel(channel$jscomp$0), sizeChannel = getSizeChannel(channel$jscomp$0), channelDef = encoding[channel$jscomp$0];
      channel2 = encoding[channel2];
      var scale = model$jscomp$0.getScaleComponent(channel$jscomp$0);
      scale = scale ? scale.get("type") : void 0;
      var orient = markDef.orient;
      sizeChannel = encoding[sizeChannel] ?? encoding.size ?? getMarkPropOrConfig("size", markDef, config, {vgChannel:sizeChannel});
      var offsetScaleChannel = getOffsetChannel(channel$jscomp$0);
      mark = mark === "bar" && (channel$jscomp$0 === "x" ? orient === "vertical" : orient === "horizontal") || mark === "tick" && (channel$jscomp$0 === "y" ? orient === "vertical" : orient === "horizontal");
      if (!isFieldDef(channelDef) || !(isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channel2) || sizeChannel && !isRelativeBandSize(sizeChannel) || encoding[offsetScaleChannel] || hasDiscreteDomain(scale)) {
        if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scale) || mark) && !channel2) {
          var JSCompiler_inline_result;
          {
            const {markDef, encoding, config, stack} = model$jscomp$0;
            orient = markDef.orient;
            scale = model$jscomp$0.scaleName(channel$jscomp$0);
            sizeChannel = model$jscomp$0.getScaleComponent(channel$jscomp$0);
            mark = getSizeChannel(channel$jscomp$0);
            channel2 = getSecondaryRangeChannel(channel$jscomp$0);
            offsetScaleChannel = getOffsetChannel(channel$jscomp$0);
            offsetScaleChannel = model$jscomp$0.scaleName(offsetScaleChannel);
            var offsetScale = model$jscomp$0.getScaleComponent(getOffsetScaleChannel(channel$jscomp$0));
            orient = markDef.type === "tick" || orient === "horizontal" && channel$jscomp$0 === "y" || orient === "vertical" && channel$jscomp$0 === "x";
            if (encoding.size || markDef.size) {
              orient ? JSCompiler_inline_result = nonPosition("size", model$jscomp$0, {vgChannel:mark, defaultRef:signalOrValueRef(markDef.size)}) : warn(`Cannot apply size to non-oriented mark "${markDef.type}".`);
            }
            var hasSizeFromMarkOrEncoding = !!JSCompiler_inline_result;
            orient = getBandSize({channel:channel$jscomp$0, fieldDef:channelDef, markDef, config, scaleType:(sizeChannel || offsetScale)?.get("type"), useVlSizeChannel:orient});
            JSCompiler_inline_result = JSCompiler_inline_result || {[mark]:defaultSizeRef(mark, offsetScaleChannel || scale, offsetScale || sizeChannel, config, orient, !!channelDef, markDef.type)};
            offsetScaleChannel = (sizeChannel || offsetScale)?.get("type") === "band" && isRelativeBandSize(orient) && !hasSizeFromMarkOrEncoding ? "top" : "middle";
            offsetScaleChannel = vgAlignedPositionChannel(channel$jscomp$0, markDef, config, offsetScaleChannel);
            offsetScale = offsetScaleChannel === "xc" || offsetScaleChannel === "yc";
            const {offset, offsetType} = positionOffset({channel:channel$jscomp$0, markDef, encoding, model:model$jscomp$0, bandPosition:offsetScale ? 0.5 : 0});
            model$jscomp$0 = midPointRefWithPositionInvalidTest({channel:channel$jscomp$0, channelDef, markDef, config, scaleName:scale, scale:sizeChannel, stack, offset, defaultRef:pointPositionDefaultRef({model:model$jscomp$0, defaultPos:"mid", channel:channel$jscomp$0, scaleName:scale, scale:sizeChannel}), bandPosition:offsetScale ? offsetType === "encoding" ? 0 : 0.5 : isSignalRef(orient) ? {signal:`(1-${orient})/2`} : isRelativeBandSize(orient) ? (1 - orient.band) / 2 : 0});
            mark ? JSCompiler_inline_result = {[offsetScaleChannel]:model$jscomp$0, ...JSCompiler_inline_result} : (channel$jscomp$0 = getVgPositionChannel(channel2), JSCompiler_inline_result = JSCompiler_inline_result[mark], JSCompiler_inline_result = offset ? {...JSCompiler_inline_result, offset} : JSCompiler_inline_result, JSCompiler_inline_result = {[offsetScaleChannel]:model$jscomp$0, [channel$jscomp$0]:vega.isArray(model$jscomp$0) ? [model$jscomp$0[0], {...model$jscomp$0[1], offset:JSCompiler_inline_result}] : 
            {...model$jscomp$0, offset:JSCompiler_inline_result}});
          }
          return JSCompiler_inline_result;
        }
        return rangePosition(channel$jscomp$0, model$jscomp$0, {defaultPos:"zeroOrMax", defaultPos2:"zeroOrMin"});
      }
      a: {
        let {fieldDef, fieldDef2, channel, model} = {fieldDef:channelDef, fieldDef2:channel2, channel:channel$jscomp$0, model:model$jscomp$0};
        const {config, markDef, encoding} = model;
        channel$jscomp$0 = model.getScaleComponent(channel);
        JSCompiler_inline_result = model.scaleName(channel);
        model$jscomp$0 = channel$jscomp$0 ? channel$jscomp$0.get("type") : void 0;
        channel2 = channel$jscomp$0.get("reverse");
        scale = getBandSize({channel, fieldDef, markDef, config, scaleType:model$jscomp$0});
        sizeChannel = model.component.axes[channel]?.[0]?.get("translate") ?? 0.5;
        orient = isXorY(channel) ? getMarkPropOrConfig("binSpacing", markDef, config) ?? 0 : 0;
        channelDef = getSecondaryRangeChannel(channel);
        model$jscomp$0 = getVgPositionChannel(channel);
        channel$jscomp$0 = getVgPositionChannel(channelDef);
        offsetScaleChannel = getMarkConfig("minBandSize", markDef, config);
        ({offset:offsetScale} = positionOffset({channel, markDef, encoding, model, bandPosition:0}));
        ({offset:hasSizeFromMarkOrEncoding} = positionOffset({channel:channelDef, markDef, encoding, model, bandPosition:0}));
        let {scaleName, fieldDef:fieldDef$jscomp$0} = {fieldDef, scaleName:JSCompiler_inline_result};
        mark = vgField(fieldDef$jscomp$0, {expr:"datum"});
        var JSCompiler_inline_result$jscomp$0 = vgField(fieldDef$jscomp$0, {expr:"datum", suffix:"end"});
        JSCompiler_inline_result$jscomp$0 = `abs(scale("${scaleName}", ${JSCompiler_inline_result$jscomp$0}) - scale("${scaleName}", ${mark}))`;
        mark = getBinSpacing(channel, orient, channel2, sizeChannel, offsetScale, offsetScaleChannel, JSCompiler_inline_result$jscomp$0);
        channel2 = getBinSpacing(channelDef, orient, channel2, sizeChannel, hasSizeFromMarkOrEncoding ?? offsetScale, offsetScaleChannel, JSCompiler_inline_result$jscomp$0);
        scale = isSignalRef(scale) ? {signal:`(1-${scale.signal})/2`} : isRelativeBandSize(scale) ? (1 - scale.band) / 2 : 0.5;
        sizeChannel = getBandPosition({fieldDef, fieldDef2, markDef, config});
        if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
          channelDef = fieldDef.timeUnit && sizeChannel !== 0.5, JSCompiler_inline_result = {[channel$jscomp$0]:rectBinRef({fieldDef, scaleName:JSCompiler_inline_result, bandPosition:scale, offset:channel2, useRectOffsetField:channelDef}), [model$jscomp$0]:rectBinRef({fieldDef, scaleName:JSCompiler_inline_result, bandPosition:isSignalRef(scale) ? {signal:`1-${scale.signal}`} : 1 - scale, offset:mark, useRectOffsetField:channelDef})};
        } else {
          if (isBinned(fieldDef.bin)) {
            channel2 = valueRefForFieldOrDatumDef(fieldDef, JSCompiler_inline_result, {}, {offset:channel2});
            if (isFieldDef(fieldDef2)) {
              JSCompiler_inline_result = {[channel$jscomp$0]:channel2, [model$jscomp$0]:valueRefForFieldOrDatumDef(fieldDef2, JSCompiler_inline_result, {}, {offset:mark})};
              break a;
            }
            if (vega.isObject(fieldDef.bin) && fieldDef.bin.step) {
              JSCompiler_inline_result = {[channel$jscomp$0]:channel2, [model$jscomp$0]:{signal:`scale("${JSCompiler_inline_result}", ${vgField(fieldDef, {expr:"datum"})} + ${fieldDef.bin.step})`, offset:mark}};
              break a;
            }
          }
          warn(channelRequiredForBinned(channelDef));
          JSCompiler_inline_result = void 0;
        }
      }
      return JSCompiler_inline_result;
    }
    function defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize, hasFieldDef, mark) {
      if (isRelativeBandSize(bandSize)) {
        if (scale) {
          const scaleType = scale.get("type");
          if (scaleType === "band") {
            return sizeChannel = `bandwidth('${scaleName}')`, bandSize.band !== 1 && (sizeChannel = `${bandSize.band} * ${sizeChannel}`), config = getMarkConfig("minBandSize", {type:mark}, config), {signal:config ? `max(${signalOrStringValue(config)}, ${sizeChannel})` : sizeChannel};
          }
          bandSize.band !== 1 && warn(`Cannot use the relative band size with ${scaleType} scale.`);
        } else {
          return {mult:bandSize.band, field:{group:sizeChannel}};
        }
      } else {
        if (isSignalRef(bandSize)) {
          return bandSize;
        }
        if (bandSize) {
          return {value:bandSize};
        }
      }
      if (scale && (bandSize = scale.get("range"), isVgRangeStep(bandSize) && vega.isNumber(bandSize.step))) {
        return {value:bandSize.step - 2};
      }
      if (!hasFieldDef) {
        const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, tickBandPaddingInner} = config.scale;
        mark = getFirstDefined(bandPaddingInner, mark === "tick" ? tickBandPaddingInner : mark === "bar" ? barBandPaddingInner : rectBandPaddingInner);
        if (isSignalRef(mark)) {
          return {signal:`(1 - (${mark.signal})) * ${sizeChannel}`};
        }
        if (vega.isNumber(mark)) {
          return {signal:`${1 - mark} * ${sizeChannel}`};
        }
      }
      return {value:getViewConfigDiscreteStep(config.view, sizeChannel) - 2};
    }
    function getBinSpacing(channel, spacing, reverse, axisTranslate, offset, minBandSize, bandSizeExpr) {
      if (vega.hasOwnProperty(POLAR_POSITION_CHANNEL_INDEX, channel)) {
        return 0;
      }
      spacing = (channel = channel === "x" || channel === "y2") ? -spacing / 2 : spacing / 2;
      if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(axisTranslate) || minBandSize) {
        reverse = signalOrStringValue(reverse);
        offset = signalOrStringValue(offset);
        axisTranslate = signalOrStringValue(axisTranslate);
        const minBandSizeExpr = signalOrStringValue(minBandSize);
        minBandSize = minBandSize ? `(${bandSizeExpr} < ${minBandSizeExpr} ? ${channel ? "" : "-"}0.5 * (${minBandSizeExpr} - (${bandSizeExpr})) : ${spacing})` : spacing;
        return {signal:(axisTranslate ? `${axisTranslate} + ` : "") + (reverse ? `(${reverse} ? -1 : 1) * ` : "") + (offset ? `(${offset} + ${minBandSize})` : minBandSize)};
      }
      offset = offset || 0;
      return axisTranslate + (reverse ? -offset - spacing : +offset + spacing);
    }
    function rectBinRef(_ref2) {
      let {fieldDef, scaleName, bandPosition, offset, useRectOffsetField} = _ref2;
      return interpolatedSignalRef({scaleName, fieldOrDatumDef:fieldDef, bandPosition, offset, ...(useRectOffsetField ? {startSuffix:"offsetted_rect_start", endSuffix:"offsetted_rect_end"} : {})});
    }
    function baseEncodeEntry(model, ignore) {
      const {fill, stroke} = ignore.color === "include" ? color(model) : {};
      ignore = {...markDefProperties(model.markDef, ignore)};
      var JSCompiler_temp_const = {...(fill ? {fill} : {})}, JSCompiler_temp_const$jscomp$0 = {...(stroke ? {stroke} : {})}, JSCompiler_temp_const$jscomp$1 = {...nonPosition("opacity", model)}, JSCompiler_temp_const$jscomp$2 = {...nonPosition("fillOpacity", model)}, JSCompiler_temp_const$jscomp$3 = {...nonPosition("strokeOpacity", model)}, JSCompiler_temp_const$jscomp$4 = {...nonPosition("strokeWidth", model)}, JSCompiler_temp_const$jscomp$5 = {...nonPosition("strokeDash", model)}, JSCompiler_temp_const$jscomp$6 = 
      {...zindex(model)}, JSCompiler_temp_const$jscomp$7 = {...tooltip(model)}, JSCompiler_temp_const$jscomp$8 = {...text$1(model, "href")};
      {
        const {markDef, config} = model, enableAria = getMarkPropOrConfig("aria", markDef, config);
        if (enableAria === !1) {
          model = {};
        } else {
          {
            const {mark, markDef, config} = model;
            if (config.aria === !1) {
              var JSCompiler_inline_result = {};
            } else {
              JSCompiler_inline_result = getMarkPropOrConfig("ariaRoleDescription", markDef, config), JSCompiler_inline_result = JSCompiler_inline_result != null ? {ariaRoleDescription:{value:JSCompiler_inline_result}} : vega.hasOwnProperty(VG_MARK_INDEX, mark) ? {} : {ariaRoleDescription:{value:mark}};
            }
          }
          model = {...(enableAria ? {aria:enableAria} : {}), ...JSCompiler_inline_result, ...description(model)};
        }
      }
      return {...ignore, ...JSCompiler_temp_const, ...JSCompiler_temp_const$jscomp$0, ...JSCompiler_temp_const$jscomp$1, ...JSCompiler_temp_const$jscomp$2, ...JSCompiler_temp_const$jscomp$3, ...JSCompiler_temp_const$jscomp$4, ...JSCompiler_temp_const$jscomp$5, ...JSCompiler_temp_const$jscomp$6, ...JSCompiler_temp_const$jscomp$7, ...JSCompiler_temp_const$jscomp$8, ...model};
    }
    function markDefProperties(mark, ignore) {
      return VG_MARK_CONFIGS.reduce((m, prop) => {
        !ALWAYS_IGNORE.has(prop) && hasProperty(mark, prop) && ignore[prop] !== "ignore" && (m[prop] = signalOrValueRef(mark[prop]));
        return m;
      }, {});
    }
    function defined(model) {
      const {config, markDef} = model, fieldsToBreakPath = new Set();
      model.forEachFieldDef((fieldDef, channel) => {
        var scaleType;
        isScaleChannel(channel) && (scaleType = model.getScaleType(channel)) && (fieldDef = isCountingAggregateOp(fieldDef.aggregate), scaleType = getScaleInvalidDataMode({scaleChannel:channel, markDef, config, scaleType, isCountAggregate:fieldDef}), (scaleType === "break-paths-filter-domains" || scaleType === "break-paths-show-domains") && (channel = model.vgField(channel, {expr:"datum", binSuffix:model.stack?.impute ? "mid" : void 0})) && fieldsToBreakPath.add(channel));
      });
      if (fieldsToBreakPath.size > 0) {
        return {defined:{signal:[...fieldsToBreakPath].map(field => fieldValidPredicate(field, !0)).join(" \x26\x26 ")}};
      }
    }
    function valueIfDefined(prop, value) {
      if (value !== void 0) {
        return {[prop]:signalOrValueRef(value)};
      }
    }
    function onDelta$1(model, selCmpt, proj, size, signals) {
      var name = selCmpt.name, anchor = name + "_translate_anchor";
      name += "_translate_delta";
      var channel = proj.channel;
      const boundScales = scaleBindings.defined(selCmpt);
      selCmpt = signals.find(s => s.name === proj.signals[boundScales ? "data" : "visual"]);
      size = model.getSizeSignalRef(size).signal;
      signals = (model = model.getScaleComponent(channel)) && model.get("type");
      var reversed = model && model.get("reverse");
      anchor = `${anchor}.extent_${channel}`;
      channel = `${boundScales ? channel === "x" ? reversed ? "" : "-" : reversed ? "-" : "" : ""}${name}.${channel} / ${boundScales ? `${size}` : `span(${anchor})`}`;
      reversed = boundScales && model ? signals === "log" ? "panLog" : signals === "symlog" ? "panSymlog" : signals === "pow" ? "panPow" : "panLinear" : "panLinear";
      model = boundScales ? signals === "pow" ? `, ${model.get("exponent") ?? 1}` : signals === "symlog" ? `, ${model.get("constant") ?? 1}` : "" : "";
      anchor = `${reversed}(${anchor}, ${channel}${model})`;
      selCmpt.on.push({events:{signal:name}, update:boundScales ? anchor : `clampRange(${anchor}, 0, ${size})`});
    }
    function onDelta(model, selCmpt, proj, size, signals) {
      var name = selCmpt.name, channel = proj.channel;
      const boundScales = scaleBindings.defined(selCmpt);
      selCmpt = signals.find(s => s.name === proj.signals[boundScales ? "data" : "visual"]);
      size = model.getSizeSignalRef(size).signal;
      const scaleType = (signals = model.getScaleComponent(channel)) && signals.get("type"), base = boundScales ? domain(model, channel) : selCmpt.name;
      model = name + "_zoom_delta";
      name = `${name}${"_zoom_anchor"}.${channel}`;
      channel = boundScales && signals ? scaleType === "log" ? "zoomLog" : scaleType === "symlog" ? "zoomSymlog" : scaleType === "pow" ? "zoomPow" : "zoomLinear" : "zoomLinear";
      signals = boundScales ? scaleType === "pow" ? `, ${signals.get("exponent") ?? 1}` : scaleType === "symlog" ? `, ${signals.get("constant") ?? 1}` : "" : "";
      name = `${channel}(${base}, ${name}, ${model}${signals})`;
      selCmpt.on.push({events:{signal:model}, update:boundScales ? name : `clampRange(${name}, 0, ${size})`});
    }
    function unitName(model) {
      var {escape} = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {escape:!0};
      escape = escape ? vega.stringValue(model.name) : model.name;
      var JSCompiler_inline_result;
      for (JSCompiler_inline_result = model.parent; JSCompiler_inline_result && !isFacetModel(JSCompiler_inline_result);) {
        JSCompiler_inline_result = JSCompiler_inline_result.parent;
      }
      if (JSCompiler_inline_result) {
        const {facet} = JSCompiler_inline_result;
        for (const channel of FACET_CHANNELS) {
          facet[channel] && (escape += ` + '__facet_${channel}_' + (facet[${vega.stringValue(JSCompiler_inline_result.vgField(channel))}])`);
        }
      }
      return escape;
    }
    function requiresSelectionId(model) {
      return vals(model.component.selection ?? {}).reduce((identifier, selCmpt) => identifier || selCmpt.project.hasSelectionId, !1);
    }
    function disableDirectManipulation(selCmpt, selDef) {
      !vega.isString(selDef.select) && selDef.select.on || delete selCmpt.events;
      !vega.isString(selDef.select) && selDef.select.clear || delete selCmpt.clear;
      !vega.isString(selDef.select) && selDef.select.toggle || delete selCmpt.toggle;
    }
    function isTimerSelection(selCmpt) {
      return selCmpt.events?.find(e => "type" in e && e.type === "timer");
    }
    function getName(node) {
      const name = [];
      if (node.type === "Identifier") {
        return [node.name];
      }
      if (node.type === "Literal") {
        return [node.value];
      }
      node.type === "MemberExpression" && (name.push(...getName(node.object)), name.push(...getName(node.property)));
      return name;
    }
    function startsWithDatum(node) {
      return node.object.type === "MemberExpression" ? startsWithDatum(node.object) : node.object.name === "datum";
    }
    function getDependentFields(expression) {
      expression = vega.parseExpression(expression);
      const dependents = new Set();
      expression.visit(node => {
        node.type === "MemberExpression" && startsWithDatum(node) && dependents.add(getName(node).slice(1).join("."));
      });
      return dependents;
    }
    function parseSelectionPredicate(model, pred, dfnode) {
      var datum = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "datum", name = vega.isString(pred) ? pred : pred.param, vname = varName(name), store = vega.stringValue(vname + "_store");
      try {
        var selCmpt = model.getSelectionComponent(vname, name);
      } catch (e) {
        return `!!${vname}`;
      }
      selCmpt.project.timeUnit && (name = dfnode ?? model.component.data.raw, vname = selCmpt.project.timeUnit.clone(), name.parent ? vname.insertAsParentOf(name) : name.parent = vname);
      name = selCmpt.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(";
      selCmpt = selCmpt.resolve === "global" ? ")" : `, ${vega.stringValue(selCmpt.resolve)})`;
      datum = `${name}${store}, ${datum}${selCmpt}`;
      store = `length(data(${store}))`;
      return pred.empty === !1 ? `${store} && ${datum}` : `!${store} || ${datum}`;
    }
    function parseSelectionExtent(model, name, extent) {
      const vname = varName(name), encoding = extent.encoding;
      let field = extent.field, selCmpt;
      try {
        selCmpt = model.getSelectionComponent(vname, name);
      } catch (e) {
        return vname;
      }
      encoding || field ? encoding && !field && (model = selCmpt.project.items.filter(p => p.channel === encoding), !model.length || model.length > 1 ? (field = selCmpt.project.items[0].field, warn(selectionAsScaleDomainWrongEncodings(model, encoding, extent, field))) : field = model[0].field) : (field = selCmpt.project.items[0].field, selCmpt.project.items.length > 1 && warn('A "field" or "encoding" must be specified when using a selection as a scale domain. ' + `Using "field": ${vega.stringValue(field)}.`));
      return `${selCmpt.name}[${vega.stringValue(replacePathInField(field))}]`;
    }
    function expression(model, filterOp, node) {
      return logicalExpr(filterOp, predicate => vega.isString(predicate) ? predicate : hasProperty(predicate, "param") ? parseSelectionPredicate(model, predicate, node) : fieldFilterExpression(predicate));
    }
    function assembleTitle(title, config) {
      if (title) {
        return vega.isArray(title) && !isText(title) ? title.map(fieldDef => titleFormatter(fieldDef, config)).join(", ") : title;
      }
    }
    function setAxisEncode(axis, part, vgProp, vgRef) {
      axis.encode ?? (axis.encode = {});
      let $jscomp$logical$assign$tmp730812712$2;
      ($jscomp$logical$assign$tmp730812712$2 = axis.encode)[part] ?? ($jscomp$logical$assign$tmp730812712$2[part] = {});
      let $jscomp$logical$assign$tmp730812712$3;
      ($jscomp$logical$assign$tmp730812712$3 = axis.encode[part]).update ?? ($jscomp$logical$assign$tmp730812712$3.update = {});
      axis.encode[part].update[vgProp] = vgRef;
    }
    function assembleAxis(axisCmpt, kind, config) {
      var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {header:!1};
      const {disable, orient, scale, labelExpr, title, zindex, ...axis} = axisCmpt.combine();
      if (!disable) {
        for (const p in axis) {
          const prop = p;
          var propType = AXIS_PROPERTY_TYPE[prop], propValue = axis[prop];
          if (propType && propType !== kind && propType !== "both") {
            delete axis[prop];
          } else if (propValue?.condition) {
            const {condition, ...valueOrSignalRef} = propValue;
            propValue = vega.array(condition);
            if (propType = CONDITIONAL_AXIS_PROP_INDEX[prop]) {
              const {vgProp, part} = propType;
              propValue = [...propValue.map(c => {
                const {test, ...valueOrSignalCRef} = c;
                return {test:expression(null, test), ...valueOrSignalCRef};
              }), valueOrSignalRef];
              setAxisEncode(axis, part, vgProp, propValue);
              delete axis[prop];
            } else {
              propType === null && (propValue = {signal:propValue.map(c => {
                const {test, ...valueOrSignalCRef} = c;
                return `${expression(null, test)} ? ${isSignalRef(valueOrSignalCRef) ? valueOrSignalCRef.signal : vega.stringValue(valueOrSignalCRef.value)} : `;
              }).join("") + (isSignalRef(valueOrSignalRef) ? valueOrSignalRef.signal : vega.stringValue(valueOrSignalRef.value))}, axis[prop] = propValue);
            }
          } else if (isSignalRef(propValue) && (propType = CONDITIONAL_AXIS_PROP_INDEX[prop])) {
            const {vgProp, part} = propType;
            setAxisEncode(axis, part, vgProp, propValue);
            delete axis[prop];
          }
          contains(["labelAlign", "labelBaseline"], prop) && axis[prop] === null && delete axis[prop];
        }
        if (kind === "grid") {
          if (axis.grid) {
            if (axis.encode) {
              var {grid} = axis.encode;
              axis.encode = {...(grid ? {grid} : {})};
              isEmpty(axis.encode) && delete axis.encode;
            }
            return {scale, orient, ...axis, domain:!1, labels:!1, aria:!1, maxExtent:0, minExtent:0, ticks:!1, zindex:getFirstDefined(zindex, 0)};
          }
        } else {
          if (opt.header || !axisCmpt.mainExtracted) {
            labelExpr !== void 0 && (opt = labelExpr, axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text) && (opt = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal)), setAxisEncode(axis, "labels", "text", {signal:opt}));
            axis.labelAlign === null && delete axis.labelAlign;
            if (axis.encode) {
              for (grid of AXIS_PARTS) {
                axisCmpt.hasAxisPart(grid) || delete axis.encode[grid];
              }
              isEmpty(axis.encode) && delete axis.encode;
            }
            grid = assembleTitle(title, config);
            return {scale, orient, grid:!1, ...(grid ? {title:grid} : {}), ...axis, ...(config.aria === !1 ? {aria:!1} : {}), zindex:getFirstDefined(zindex, 0)};
          }
        }
      }
    }
    function assembleAxisSignals(model) {
      const {axes} = model.component, signals = [];
      for (const channel of POSITION_SCALE_CHANNELS) {
        if (axes[channel]) {
          for (const axis of axes[channel]) {
            if (!axis.get("disable") && !axis.get("gridScale")) {
              const sizeType = channel === "x" ? "height" : "width", update = model.getSizeSignalRef(sizeType).signal;
              sizeType !== update && signals.push({name:sizeType, update});
            }
          }
        }
      }
      return signals;
    }
    function assembleAxes(axisComponents, config) {
      const {x = [], y = []} = axisComponents;
      return [...x.map(a => assembleAxis(a, "grid", config)), ...y.map(a => assembleAxis(a, "grid", config)), ...x.map(a => assembleAxis(a, "main", config)), ...y.map(a => assembleAxis(a, "main", config))].filter(a => a);
    }
    function getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {
      return Object.assign.apply(null, [{}, ...configTypes.map(configType => {
        if (configType === "axisOrient") {
          configType = channel === "x" ? "bottom" : "left";
          const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {}, orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {}, props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]), conditionalOrientAxisConfig = {};
          for (const prop of props.values()) {
            conditionalOrientAxisConfig[prop] = {signal:`${orient.signal} === "${configType}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`};
          }
          return conditionalOrientAxisConfig;
        }
        return config[configType];
      })]);
    }
    function getAxisConfigs(channel, scaleType, orient, config) {
      var typeBasedConfigTypes = scaleType === "band" ? ["axisDiscrete", "axisBand"] : scaleType === "point" ? ["axisDiscrete", "axisPoint"] : QUANTITATIVE_SCALES.has(scaleType) ? ["axisQuantitative"] : scaleType === "time" || scaleType === "utc" ? ["axisTemporal"] : [];
      const axisChannel = channel === "x" ? "axisX" : "axisY";
      scaleType = isSignalRef(orient) ? "axisOrient" : `axis${titleCase(orient)}`;
      typeBasedConfigTypes = [...typeBasedConfigTypes, ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))];
      scaleType = ["axis", scaleType, axisChannel];
      return {vlOnlyAxisConfig:getAxisConfigFromConfigTypes(typeBasedConfigTypes, config, channel, orient), vgAxisConfig:getAxisConfigFromConfigTypes(scaleType, config, channel, orient), axisConfigStyle:getAxisConfigStyle([...scaleType, ...typeBasedConfigTypes], config)};
    }
    function getAxisConfigStyle(axisConfigTypes, config) {
      const toMerge = [{}];
      for (const configType of axisConfigTypes) {
        if (axisConfigTypes = config[configType]?.style) {
          axisConfigTypes = vega.array(axisConfigTypes);
          for (const s of axisConfigTypes) {
            toMerge.push(config.style[s]);
          }
        }
      }
      return Object.assign.apply(null, toMerge);
    }
    function getAxisConfig(property, styleConfigIndex, style) {
      let axisConfigs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const styleConfig = getStyleConfig(property, style, styleConfigIndex);
      if (styleConfig !== void 0) {
        return {configFrom:"style", configValue:styleConfig};
      }
      for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
        if (axisConfigs[configFrom]?.[property] !== void 0) {
          return {configFrom, configValue:axisConfigs[configFrom][property]};
        }
      }
      return {};
    }
    function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {
      const labelAngle = axis?.labelAngle;
      if (labelAngle !== void 0) {
        return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
      }
      ({configValue:axis} = getAxisConfig("labelAngle", styleConfig, axis?.style, axisConfigs));
      if (axis !== void 0) {
        return normalizeAngle(axis);
      }
      if (channel === "x" && contains(["nominal", "ordinal"], fieldOrDatumDef.type) && (!isFieldDef(fieldOrDatumDef) || !fieldOrDatumDef.timeUnit)) {
        return 270;
      }
    }
    function normalizeAngleExpr(angle) {
      return `(((${angle.signal} % 360) + 360) % 360)`;
    }
    function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {
      if (angle !== void 0) {
        return channel === "x" ? isSignalRef(angle) ? (alwaysIncludeMiddle = normalizeAngleExpr(angle), orient = isSignalRef(orient) ? `(${orient.signal} === "top")` : orient === "top", {signal:`(45 < ${alwaysIncludeMiddle} && ${alwaysIncludeMiddle} < 135) || (225 < ${alwaysIncludeMiddle} && ${alwaysIncludeMiddle} < 315) ? "middle" :` + `(${alwaysIncludeMiddle} <= 45 || 315 <= ${alwaysIncludeMiddle}) === ${orient} ? "bottom" : "top"`}) : 45 < angle && angle < 135 || 225 < angle && angle < 315 ? "middle" : 
        isSignalRef(orient) ? {signal:`${orient.signal} ${angle <= 45 || 315 <= angle ? "\x3d\x3d\x3d" : "!\x3d\x3d"} "top" ? "bottom" : "top"`} : (angle <= 45 || 315 <= angle) === (orient === "top") ? "bottom" : "top" : isSignalRef(angle) ? (angle = normalizeAngleExpr(angle), orient = isSignalRef(orient) ? `(${orient.signal} === "left")` : orient === "left", {signal:`${angle} <= 45 || 315 <= ${angle} || (135 <= ${angle} && ${angle} <= 225) ? ${alwaysIncludeMiddle ? '"middle"' : "null"} : (45 <= ${angle} && ${angle} <= 135) === ${orient} ? "top" : "bottom"`}) : 
        angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225 ? alwaysIncludeMiddle ? "middle" : null : isSignalRef(orient) ? {signal:`${orient.signal} ${45 <= angle && angle <= 135 ? "\x3d\x3d\x3d" : "!\x3d\x3d"} "left" ? "top" : "bottom"`} : (45 <= angle && angle <= 135) === (orient === "left") ? "top" : "bottom";
      }
    }
    function defaultLabelAlign(angle, orient, channel) {
      if (angle !== void 0) {
        var startAngle = (channel = channel === "x") ? 0 : 90, mainOrient = channel ? "bottom" : "left";
        return isSignalRef(angle) ? (angle = normalizeAngleExpr(angle), orient = isSignalRef(orient) ? `(${orient.signal} === "${mainOrient}")` : orient === mainOrient, {signal:`(${startAngle ? `(${angle} + 90)` : angle} % 180 === 0) ? ${channel ? null : '"center"'} :` + `(${startAngle} < ${angle} && ${angle} < ${180 + startAngle}) === ${orient} ? "left" : "right"`}) : (angle + startAngle) % 180 === 0 ? channel ? null : "center" : isSignalRef(orient) ? {signal:`${`${orient.signal} ${startAngle < 
        angle && angle < 180 + startAngle ? "\x3d\x3d\x3d" : "!\x3d\x3d"} "${mainOrient}"`} ? "left" : "right"`} : (startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient) ? "left" : "right";
      }
    }
    function getFieldDefTitle(model, channel) {
      var channel2 = channel === "x" ? "x2" : "y2";
      channel = model.fieldDef(channel);
      model = model.fieldDef(channel2);
      channel2 = channel ? channel.title : void 0;
      model = model ? model.title : void 0;
      if (channel2 && model) {
        return mergeTitle(channel2, model);
      }
      if (channel2) {
        return channel2;
      }
      if (model) {
        return model;
      }
      if (channel2 !== void 0) {
        return channel2;
      }
      if (model !== void 0) {
        return model;
      }
    }
    function sortArrayIndexField(fieldDef, channel, opt) {
      return vgField(fieldDef, {prefix:channel, suffix:"sort_index", ...opt});
    }
    function getHeaderChannel(channel, orient) {
      return contains(["top", "bottom"], orient) ? "column" : contains(["left", "right"], orient) ? "row" : channel === "row" ? "row" : "column";
    }
    function getHeaderProperty(prop, header, config, channel) {
      return getFirstDefined((header || {})[prop], (channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet)[prop], config.header[prop]);
    }
    function getHeaderProperties(properties, header, config, channel) {
      const props = {};
      for (const prop of properties) {
        properties = getHeaderProperty(prop, header || {}, config, channel), properties !== void 0 && (props[prop] = properties);
      }
      return props;
    }
    function defaultHeaderGuideAlign(headerChannel, angle) {
      switch(arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "middle") {
        case "start":
          return {align:"left"};
        case "end":
          return {align:"right"};
      }
      const align = defaultLabelAlign(angle, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
      return align ? {align} : {};
    }
    function defaultHeaderGuideBaseline(angle, channel) {
      return (angle = defaultLabelBaseline(angle, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", !0)) ? {baseline:angle} : {};
    }
    function assembleLabelTitle(facetFieldDef, channel, config) {
      const {format, formatType, labelAngle, labelAnchor, labelOrient, labelExpr} = getHeaderProperties("format formatType labelAngle labelAnchor labelOrient labelExpr".split(" "), facetFieldDef.header, config, channel), titleTextExpr = formatSignalRef({fieldOrDatumDef:facetFieldDef, format, formatType, expr:"parent", config}).signal, headerChannel = getHeaderChannel(channel, labelOrient);
      return {text:{signal:labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, {expr:"parent"})) : titleTextExpr}, ...(channel === "row" ? {orient:"left"} : {}), style:"guide-label", frame:"group", ...defaultHeaderGuideBaseline(labelAngle, headerChannel), ...defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor), ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)};
    }
    function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
      const props = {};
      for (const prop of properties) {
        propertiesMap[prop] && (properties = getHeaderProperty(prop, facetFieldDef?.header, config, channel), properties !== void 0 && (props[propertiesMap[prop]] = properties));
      }
      return props;
    }
    function assembleLayoutSignals(model) {
      return [...sizeSignals(model, "width"), ...sizeSignals(model, "height"), ...sizeSignals(model, "childWidth"), ...sizeSignals(model, "childHeight")];
    }
    function sizeSignals(model, sizeType) {
      var channel = sizeType === "width" ? "x" : "y", size = model.component.layoutSize.get(sizeType);
      if (!size || size === "merged") {
        return [];
      }
      sizeType = model.getSizeSignalRef(sizeType).signal;
      if (size === "step") {
        if (size = model.getScaleComponent(channel)) {
          var type = size.get("type");
          const range = size.get("range");
          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {
            return type = model.scaleName(channel), isFacetModel(model.parent) && model.parent.component.resolve.scale[channel] === "independent" ? [stepSignal(type, range)] : [stepSignal(type, range), {name:sizeType, update:sizeExpr(type, size, `domain('${type}').length`)}];
          }
        }
        throw Error("layout size is step although width/height is not step.");
      }
      return size == "container" ? (channel = (size = sizeType.endsWith("width")) ? "containerSize()[0]" : "containerSize()[1]", model = getViewConfigContinuousSize(model.config.view, size ? "width" : "height"), model = `isFinite(${channel}) ? ${channel} : ${model}`, [{name:sizeType, init:model, on:[{update:model, events:"window:resize"}]}]) : [{name:sizeType, value:size}];
    }
    function stepSignal(scaleName, range) {
      scaleName = `${scaleName}_step`;
      return isSignalRef(range.step) ? {name:scaleName, update:range.step.signal} : {name:scaleName, value:range.step};
    }
    function sizeExpr(scaleName, scaleComponent, cardinality) {
      const type = scaleComponent.get("type"), padding = scaleComponent.get("padding"), paddingOuter = getFirstDefined(scaleComponent.get("paddingOuter"), padding);
      scaleComponent = scaleComponent.get("paddingInner");
      return `bandspace(${cardinality}, ${signalOrStringValue(type === "band" ? scaleComponent !== void 0 ? scaleComponent : padding : 1)}, ${signalOrStringValue(paddingOuter)}) * ${scaleName}_step`;
    }
    function getSizeTypeFromLayoutSizeType(layoutSizeType) {
      return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
    }
    function guideEncodeEntry(encoding, model) {
      return keys(encoding).reduce((encode, channel) => ({...encode, ...wrapCondition({model, channelDef:encoding[channel], vgChannel:channel, mainRefFn:def => signalOrValueRef(def.value), invalidValueRef:void 0})}), {});
    }
    function defaultScaleResolve(channel, model) {
      if (isFacetModel(model)) {
        return channel === "theta" ? "independent" : "shared";
      }
      if (isLayerModel(model)) {
        return "shared";
      }
      if (model?.type === "concat") {
        return isXorY(channel) || channel === "theta" || channel === "radius" ? "independent" : "shared";
      }
      throw Error("invalid model type for resolve");
    }
    function parseGuideResolve(resolve, channel) {
      const channelScaleResolve = resolve.scale[channel], guide = isXorY(channel) ? "axis" : "legend";
      return channelScaleResolve === "independent" ? (resolve[guide][channel] === "shared" && warn(`Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`), "independent") : resolve[guide][channel] || "shared";
    }
    function getMaxValue(channelDef) {
      return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
    }
    function getFirstConditionValue(channelDef) {
      return getConditionValue(channelDef, (v, conditionalDef) => getFirstDefined(v, conditionalDef.value));
    }
    function getConditionValue(channelDef, reducer) {
      const condition = channelDef?.condition;
      if (condition && (vega.isArray(condition) || isValueDef(condition))) {
        return vega.array(channelDef.condition).reduce(reducer, channelDef.value);
      }
      if (isValueDef(channelDef)) {
        return channelDef.value;
      }
    }
    function selectedCondition(model, legendCmpt, fieldDef) {
      model = legendCmpt.get("selections");
      if (model?.length) {
        var field = vega.stringValue(fieldDef.field);
        return model.map(name => `(!length(data(${vega.stringValue(varName(name) + "_store")})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`).join(" || ");
      }
    }
    function parseLegend(model) {
      if (isUnitModel(model)) {
        var {encoding} = model, legendComponent = {};
        for (JSCompiler_temp of ["color", ...LEGEND_SCALE_CHANNELS]) {
          var def = getFieldOrDatumDef(encoding[JSCompiler_temp]);
          if (def && model.getScaleComponent(JSCompiler_temp) && (JSCompiler_temp !== "shape" || !isFieldDef(def) || def.type !== "geojson")) {
            a: {
              var JSCompiler_inline_result;
              def = model;
              var legend$jscomp$0 = def.legend(JSCompiler_temp);
              const {markDef, encoding, config} = def;
              var legendConfig$jscomp$0 = config.legend;
              b: {
                var JSCompiler_inline_result$jscomp$0 = def;
                var scale = JSCompiler_inline_result$jscomp$0.scaleName(JSCompiler_temp);
                if (JSCompiler_inline_result$jscomp$0.mark === "trail") {
                  if (JSCompiler_temp === "color") {
                    JSCompiler_inline_result$jscomp$0 = {stroke:scale};
                    break b;
                  }
                  if (JSCompiler_temp === "size") {
                    JSCompiler_inline_result$jscomp$0 = {strokeWidth:scale};
                    break b;
                  }
                }
                JSCompiler_inline_result$jscomp$0 = JSCompiler_temp === "color" ? JSCompiler_inline_result$jscomp$0.markDef.filled ? {fill:scale} : {stroke:scale} : {[JSCompiler_temp]:scale};
              }
              JSCompiler_inline_result$jscomp$0 = new LegendComponent({}, JSCompiler_inline_result$jscomp$0);
              scale = def.fieldDef(JSCompiler_temp)?.field;
              for (const selCmpt of vals(def.component.selection ?? {})) {
                if ((JSCompiler_inline_result = selCmpt.project.hasField[scale] ?? selCmpt.project.hasChannel[JSCompiler_temp]) && legendBindings.defined(selCmpt)) {
                  var legendSelections = JSCompiler_inline_result$jscomp$0.get("selections") ?? [];
                  legendSelections.push(selCmpt.name);
                  JSCompiler_inline_result$jscomp$0.set("selections", legendSelections, !1);
                  JSCompiler_inline_result.hasLegend = !0;
                }
              }
              scale = legend$jscomp$0 !== void 0 ? !legend$jscomp$0 : legendConfig$jscomp$0.disable;
              JSCompiler_inline_result$jscomp$0.set("disable", scale, legend$jscomp$0 !== void 0);
              if (scale) {
                def = JSCompiler_inline_result$jscomp$0;
                break a;
              }
              legend$jscomp$0 = legend$jscomp$0 || {};
              legendSelections = def.getScaleComponent(JSCompiler_temp).get("type");
              scale = getFieldOrDatumDef(encoding[JSCompiler_temp]);
              JSCompiler_inline_result = isFieldDef(scale) ? normalizeTimeUnit(scale.timeUnit)?.unit : void 0;
              var orient$jscomp$0 = legend$jscomp$0.orient || config.legend.orient || "right";
              JSCompiler_inline_result = {legend:legend$jscomp$0, channel:JSCompiler_temp, timeUnit:JSCompiler_inline_result, scaleType:legendSelections};
              var {legend:legend$jscomp$1} = JSCompiler_inline_result;
              legend$jscomp$1 = legend$jscomp$1.type;
              b: {
                let {channel, timeUnit, scaleType} = JSCompiler_inline_result;
                if (isColorChannel(channel)) {
                  if (contains(["quarter", "month", "day"], timeUnit)) {
                    JSCompiler_inline_result = "symbol";
                    break b;
                  }
                  if (CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)) {
                    JSCompiler_inline_result = "gradient";
                    break b;
                  }
                }
                JSCompiler_inline_result = "symbol";
              }
              JSCompiler_inline_result = getFirstDefined(legend$jscomp$1, JSCompiler_inline_result);
              let {legendConfig, legendType, orient, legend} = {legend:legend$jscomp$0, legendType:JSCompiler_inline_result, orient:orient$jscomp$0, legendConfig:legendConfig$jscomp$0};
              if ((legend$jscomp$1 = legend.direction ?? legendConfig[legendType ? "gradientDirection" : "symbolDirection"]) == null) {
                b: {
                  switch(orient) {
                    case "top":
                    case "bottom":
                      legend$jscomp$1 = "horizontal";
                      break b;
                    case "left":
                    case "right":
                    case "none":
                    case void 0:
                      break;
                    default:
                      legend$jscomp$1 = legendType === "gradient" ? "horizontal" : void 0;
                      break b;
                  }
                  legend$jscomp$1 = void 0;
                }
              }
              legendConfig$jscomp$0 = {legend:legend$jscomp$0, channel:JSCompiler_temp, model:def, markDef, encoding, fieldOrDatumDef:scale, legendConfig:legendConfig$jscomp$0, config, scaleType:legendSelections, orient:orient$jscomp$0, legendType:JSCompiler_inline_result, direction:legend$jscomp$1};
              for (const property of LEGEND_COMPONENT_PROPERTIES) {
                if (!(JSCompiler_inline_result === "gradient" && property.startsWith("symbol") || JSCompiler_inline_result === "symbol" && property.startsWith("gradient")) && (legendSelections = property in legendRules ? legendRules[property](legendConfig$jscomp$0) : legend$jscomp$0[property], legendSelections !== void 0)) {
                  b: {
                    orient$jscomp$0 = legendSelections;
                    legend$jscomp$1 = property;
                    var legend$jscomp$2 = legend$jscomp$0, fieldDef = def.fieldDef(JSCompiler_temp);
                    switch(legend$jscomp$1) {
                      case "disable":
                        orient$jscomp$0 = legend$jscomp$2 !== void 0;
                        break b;
                      case "values":
                        orient$jscomp$0 = !!legend$jscomp$2?.values;
                        break b;
                      case "title":
                        if (legend$jscomp$1 === "title" && orient$jscomp$0 === fieldDef?.title) {
                          orient$jscomp$0 = !0;
                          break b;
                        }
                    }
                    orient$jscomp$0 = orient$jscomp$0 === (legend$jscomp$2 || {})[legend$jscomp$1];
                  }
                  (orient$jscomp$0 || config.legend[property] === void 0) && JSCompiler_inline_result$jscomp$0.set(property, legendSelections, orient$jscomp$0);
                }
              }
              legendConfig$jscomp$0 = legend$jscomp$0?.encoding ?? {};
              legendSelections = JSCompiler_inline_result$jscomp$0.get("selections");
              orient$jscomp$0 = {};
              JSCompiler_inline_result = {fieldOrDatumDef:scale, model:def, channel:JSCompiler_temp, legendCmpt:JSCompiler_inline_result$jscomp$0, legendType:JSCompiler_inline_result};
              for (const part of "labels legend title symbols gradient entries".split(" ")) {
                legend$jscomp$1 = guideEncodeEntry(legendConfig$jscomp$0[part] ?? {}, def), legend$jscomp$1 = part in legendEncodeRules ? legendEncodeRules[part](legend$jscomp$1, JSCompiler_inline_result) : legend$jscomp$1, legend$jscomp$1 === void 0 || isEmpty(legend$jscomp$1) || (orient$jscomp$0[part] = {...(legendSelections?.length && isFieldDef(scale) ? {name:`${varName(scale.field)}_legend_${part}`} : {}), ...(legendSelections?.length ? {interactive:!!legendSelections} : {}), update:legend$jscomp$1});
              }
              isEmpty(orient$jscomp$0) || JSCompiler_inline_result$jscomp$0.set("encode", orient$jscomp$0, !!legend$jscomp$0?.encoding);
              def = JSCompiler_inline_result$jscomp$0;
            }
            legendComponent[JSCompiler_temp] = def;
          }
        }
        var JSCompiler_temp = legendComponent;
      } else {
        const {legends, resolve} = model.component;
        for (encoding of model.children) {
          parseLegend(encoding);
          for (legendComponent of keys(encoding.component.legends)) {
            resolve.legend[legendComponent] = parseGuideResolve(model.component.resolve, legendComponent), resolve.legend[legendComponent] === "shared" && (legends[legendComponent] = mergeLegendComponent(legends[legendComponent], encoding.component.legends[legendComponent]), legends[legendComponent] || (resolve.legend[legendComponent] = "independent", delete legends[legendComponent]));
          }
        }
        for (def of keys(legends)) {
          for (legend$jscomp$0 of model.children) {
            legend$jscomp$0.component.legends[def] && resolve.legend[def] === "shared" && delete legend$jscomp$0.component.legends[def];
          }
        }
        JSCompiler_temp = legends;
      }
      return model.component.legends = JSCompiler_temp;
    }
    function mergeLegendComponent(mergedLegend, childLegend) {
      if (!mergedLegend) {
        return childLegend.clone();
      }
      var mergedOrient = mergedLegend.getWithExplicit("orient");
      const childOrient = childLegend.getWithExplicit("orient");
      if (!mergedOrient.explicit || !childOrient.explicit || mergedOrient.value === childOrient.value) {
        var typeMerged = !1;
        for (const prop of LEGEND_COMPONENT_PROPERTIES) {
          mergedOrient = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, "legend", (v1, v2) => {
            switch(prop) {
              case "symbolType":
                return v1 = v2.value === "circle" ? v2 : v1, v1;
              case "title":
                return mergeTitleComponent(v1, v2);
              case "type":
                return typeMerged = !0, makeImplicit("symbol");
            }
            return defaultTieBreaker(v1, v2, prop, "legend");
          }), mergedLegend.setWithExplicit(prop, mergedOrient);
        }
        typeMerged && (mergedLegend.implicit?.encode?.gradient && deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]), mergedLegend.explicit?.encode?.gradient && deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]));
        return mergedLegend;
      }
    }
    function assembleLegends(model) {
      const legendComponentIndex = model.component.legends, legendByDomain = {};
      for (const channel of keys(legendComponentIndex)) {
        var scaleComponent = model.getScaleComponent(channel);
        scaleComponent = stringify(scaleComponent.get("domains"));
        if (legendByDomain[scaleComponent]) {
          for (const mergedLegendComponent of legendByDomain[scaleComponent]) {
            mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]) || legendByDomain[scaleComponent].push(legendComponentIndex[channel]);
          }
        } else {
          legendByDomain[scaleComponent] = [legendComponentIndex[channel].clone()];
        }
      }
      return vals(legendByDomain).flat().map(l => {
        {
          var config = model.config;
          const {disable, labelExpr, selections, ...legend} = l.combine();
          if (disable) {
            var JSCompiler_inline_result = void 0;
          } else {
            config.aria === !1 && legend.aria == void 0 && (legend.aria = !1);
            if (legend.encode?.symbols) {
              l = legend.encode.symbols.update;
              !l.fill || l.fill.value === "transparent" || l.stroke || legend.stroke || (l.stroke = {value:"transparent"});
              for (var property of LEGEND_SCALE_CHANNELS) {
                legend[property] && delete l[property];
              }
            }
            legend.title || delete legend.title;
            if (labelExpr !== void 0) {
              l = labelExpr;
              legend.encode?.labels?.update && isSignalRef(legend.encode.labels.update.text) && (l = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal));
              property = legend;
              l = {signal:l};
              property.encode ?? (property.encode = {});
              (JSCompiler_inline_result = property.encode).labels ?? (JSCompiler_inline_result.labels = {});
              let $jscomp$inline_2696;
              ($jscomp$inline_2696 = property.encode.labels).update ?? ($jscomp$inline_2696.update = {});
              property.encode.labels.update.text = l;
            }
            JSCompiler_inline_result = legend;
          }
        }
        return JSCompiler_inline_result;
      }).filter(l => l !== void 0);
    }
    function assembleProjectionsForModelAndChildren(model) {
      return model.children.reduce((projections, child) => projections.concat(child.assembleProjections()), assembleProjectionForModel(model));
    }
    function assembleProjectionForModel(model) {
      var component = model.component.projection;
      if (!component || component.merged) {
        return [];
      }
      const projection = component.combine(), {name} = projection;
      if (component.data) {
        const size = {signal:`[${component.size.map(ref => ref.signal).join(", ")}]`};
        component = component.data.reduce((sources, data) => {
          data = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;
          sources.includes(data) || sources.push(data);
          return sources;
        }, []);
        if (component.length <= 0) {
          throw Error("Projection's fit didn't find any data sources");
        }
        return [{name, size, fit:{signal:component.length > 1 ? `[${component.join(", ")}]` : component[0]}, ...projection}];
      }
      return [{name, translate:{signal:"[width / 2, height / 2]"}, ...projection}];
    }
    function parseUnitProjection(model) {
      if (model.hasProjection) {
        const proj = replaceExprRef(model.specifiedProjection);
        var fit = !(proj && (proj.scale != null || proj.translate != null));
        const size = fit ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
        if (fit) {
          fit = [];
          const {encoding} = model;
          for (JSCompiler_temp of [["longitude", "latitude"], ["longitude2", "latitude2"]]) {
            (getFieldOrDatumDef(encoding[JSCompiler_temp[0]]) || getFieldOrDatumDef(encoding[JSCompiler_temp[1]])) && fit.push({signal:model.getName(`geojson_${fit.length}`)});
          }
          model.channelHasField("shape") && model.typedFieldDef("shape").type === "geojson" && fit.push({signal:model.getName(`geojson_${fit.length}`)});
          fit.length === 0 && fit.push(model.requestDataName(DataSourceType.Main));
          var JSCompiler_temp = fit;
        } else {
          JSCompiler_temp = void 0;
        }
        model = new ProjectionComponent(model.projectionName(!0), {...replaceExprRef(model.config.projection), ...proj}, size, JSCompiler_temp);
        model.get("type") || model.set("type", "equalEarth", !1);
        return model;
      }
    }
    function mergeIfNoConflict(first, second) {
      const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => !vega.hasOwnProperty(first.explicit, prop) && !vega.hasOwnProperty(second.explicit, prop) || vega.hasOwnProperty(first.explicit, prop) && vega.hasOwnProperty(second.explicit, prop) && deepEqual(first.get(prop), second.get(prop)) ? !0 : !1);
      if (deepEqual(first.size, second.size)) {
        if (allPropertiesShared) {
          return first;
        }
        if (deepEqual(first.explicit, {})) {
          return second;
        }
        if (deepEqual(second.explicit, {})) {
          return first;
        }
      }
      return null;
    }
    function parseNonUnitProjections(model) {
      if (model.children.length !== 0) {
        var nonUnitProjection;
        for (var child$jscomp$0 of model.children) {
          child$jscomp$0.component.projection = isUnitModel(child$jscomp$0) ? parseUnitProjection(child$jscomp$0) : parseNonUnitProjections(child$jscomp$0);
        }
        child$jscomp$0 = every(model.children, child => {
          if (child = child.component.projection) {
            if (nonUnitProjection) {
              return (child = mergeIfNoConflict(nonUnitProjection, child)) && (nonUnitProjection = child), !!child;
            }
            nonUnitProjection = child;
          }
          return !0;
        });
        if (nonUnitProjection && child$jscomp$0) {
          child$jscomp$0 = model.projectionName(!0);
          const modelProjection = new ProjectionComponent(child$jscomp$0, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
          for (const child of model.children) {
            if (model = child.component.projection) {
              model.isFit && modelProjection.data.push(...child.component.projection.data), child.renameProjection(model.get("name"), child$jscomp$0), model.merged = !0;
            }
          }
          return modelProjection;
        }
      }
    }
    function getBinSignalName(model, field, bin) {
      bin = normalizeBin(bin, void 0) ?? {};
      field = `${binToString(bin)}_${field}`;
      return model.getName(`${field}_bins`);
    }
    function createBinComponent(t, bin, model) {
      let as;
      as = "as" in t ? vega.isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]] : [vgField(t, {forAs:!0}), vgField(t, {binSuffix:"end", forAs:!0})];
      bin = {...normalizeBin(bin, void 0)};
      var JSCompiler_inline_result = t.field;
      JSCompiler_inline_result = `${binToString(bin)}_${JSCompiler_inline_result}`;
      var JSCompiler_inline_result$jscomp$0 = {signal:model.getName(`${JSCompiler_inline_result}_bins`), extentSignal:model.getName(`${JSCompiler_inline_result}_extent`)};
      const {signal, extentSignal} = JSCompiler_inline_result$jscomp$0;
      if (hasProperty(bin.extent, "param")) {
        var span = bin.extent;
        span = parseSelectionExtent(model, span.param, span);
        delete bin.extent;
      }
      return {key:JSCompiler_inline_result, binComponent:{bin, field:t.field, as:[as], ...(signal ? {signal} : {}), ...(extentSignal ? {extentSignal} : {}), ...(span ? {span} : {})}};
    }
    function unquote(pattern) {
      return pattern.startsWith("'") && pattern.endsWith("'") || pattern.startsWith('"') && pattern.endsWith('"') ? pattern.slice(1, -1) : pattern;
    }
    function parseExpression(field, parse) {
      field = accessPathWithDatum(field);
      if (parse === "number") {
        return `toNumber(${field})`;
      }
      if (parse === "boolean") {
        return `toBoolean(${field})`;
      }
      if (parse === "string") {
        return `toString(${field})`;
      }
      if (parse === "date") {
        return `toDate(${field})`;
      }
      if (parse === "flatten") {
        return field;
      }
      if (parse.startsWith("date:")) {
        return parse = unquote(parse.slice(5, parse.length)), `timeParse(${field},'${parse}')`;
      }
      if (parse.startsWith("utc:")) {
        return parse = unquote(parse.slice(4, parse.length)), `utcParse(${field},'${parse}')`;
      }
      warn(`Unrecognized parse "${parse}".`);
      return null;
    }
    function getImplicitFromFilterTransform(transform) {
      const implicit = {};
      forEachLeaf(transform.filter, filter => {
        if (isFieldPredicate(filter)) {
          let val = null;
          filter?.field && filter.equal !== void 0 ? val = signalRefOrValue(filter.equal) : filter?.field && filter.lte !== void 0 ? val = signalRefOrValue(filter.lte) : filter?.field && filter.lt !== void 0 ? val = signalRefOrValue(filter.lt) : filter?.field && filter.gt !== void 0 ? val = signalRefOrValue(filter.gt) : filter?.field && filter.gte !== void 0 ? val = signalRefOrValue(filter.gte) : isFieldRangePredicate(filter) ? val = filter.range[0] : isFieldOneOfPredicate(filter) && (val = (filter.oneOf ?? 
          filter.in)[0]);
          val && (isDateTime(val) ? implicit[filter.field] = "date" : vega.isNumber(val) ? implicit[filter.field] = "number" : vega.isString(val) && (implicit[filter.field] = "string"));
          filter.timeUnit && (implicit[filter.field] = "date");
        }
      });
      return implicit;
    }
    function getImplicitFromEncoding(model) {
      function add(fieldDef) {
        if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
          implicit[fieldDef.field] = "date";
        } else {
          var JSCompiler_temp;
          if (JSCompiler_temp = fieldDef.type === "quantitative") {
            JSCompiler_temp = fieldDef.aggregate, JSCompiler_temp = vega.isString(JSCompiler_temp) && contains(["min", "max"], JSCompiler_temp);
          }
          JSCompiler_temp ? implicit[fieldDef.field] = "number" : accessPathDepth(fieldDef.field) > 1 ? fieldDef.field in implicit || (implicit[fieldDef.field] = "flatten") : isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1 && (fieldDef.sort.field in implicit || (implicit[fieldDef.sort.field] = "flatten"));
        }
      }
      const implicit = {};
      (isUnitModel(model) || isFacetModel(model)) && model.forEachFieldDef((fieldDef, channel) => {
        isTypedFieldDef(fieldDef) ? add(fieldDef) : (channel = getMainRangeChannel(channel), channel = model.fieldDef(channel), add({...fieldDef, type:channel.type}));
      });
      if (isUnitModel(model)) {
        const {mark, markDef, encoding} = model;
        if (isPathMark(mark) && !model.encoding.order) {
          const dimensionChannelDef = encoding[markDef.orient === "horizontal" ? "y" : "x"];
          !isFieldDef(dimensionChannelDef) || dimensionChannelDef.type !== "quantitative" || dimensionChannelDef.field in implicit || (implicit[dimensionChannelDef.field] = "number");
        }
      }
      return implicit;
    }
    function isDataSourceNode(node) {
      return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
    }
    function isValidFiniteNumberExpr(ref) {
      return `isValid(${ref}) && isFinite(+${ref})`;
    }
    function getStackByFields(model) {
      return model.stack.stackBy.reduce((fields, by) => {
        (by = vgField(by.fieldDef)) && fields.push(by);
        return fields;
      }, []);
    }
    function isValidAsArray(as) {
      return vega.isArray(as) && as.every(s => vega.isString(s)) && as.length > 1;
    }
    function cloneSubtree(facet) {
      function clone(node) {
        if (!(node instanceof FacetNode)) {
          const copy = node.clone();
          if (copy instanceof OutputNode) {
            const newName = "scale_" + copy.getSource();
            copy.setSource(newName);
            facet.model.component.data.outputNodes[newName] = copy;
          } else {
            (copy instanceof AggregateNode || copy instanceof StackNode || copy instanceof WindowTransformNode || copy instanceof JoinAggregateTransformNode) && copy.addDimensions(facet.fields);
          }
          for (const n of node.children.flatMap(clone)) {
            n.parent = copy;
          }
          return [copy];
        }
        return node.children.flatMap(clone);
      }
      return clone;
    }
    function moveFacetDown(node) {
      if (node instanceof FacetNode) {
        if (node.numChildren() !== 1 || node.children[0] instanceof OutputNode) {
          var facetMain = node.model.component.data.main;
          moveMainDownToFacet(facetMain);
          const cloner = cloneSubtree(node);
          node = node.children.map(cloner).flat();
          for (const c of node) {
            c.parent = facetMain;
          }
        } else {
          facetMain = node.children[0], (facetMain instanceof AggregateNode || facetMain instanceof StackNode || facetMain instanceof WindowTransformNode || facetMain instanceof JoinAggregateTransformNode) && facetMain.addDimensions(node.fields), facetMain.swapWithParent(), moveFacetDown(node);
        }
      } else {
        node.children.map(moveFacetDown);
      }
    }
    function moveMainDownToFacet(node) {
      if (node instanceof OutputNode && node.type === DataSourceType.Main && node.numChildren() === 1) {
        const child = node.children[0];
        child instanceof FacetNode || (child.swapWithParent(), moveMainDownToFacet(node));
      }
    }
    function checkLinks(nodes) {
      for (const node of nodes) {
        for (const child of node.children) {
          if (child.parent !== node) {
            return !1;
          }
        }
        if (!checkLinks(node.children)) {
          return !1;
        }
      }
      return !0;
    }
    function runOptimizer(optimizer, nodes) {
      let modified = !1;
      for (const node of nodes) {
        modified = optimizer.optimize(node) || modified;
      }
      return modified;
    }
    function optimizationDataflowHelper(dataComponent, model, firstPass) {
      let roots = dataComponent.sources, modified = !1;
      modified = runOptimizer(new RemoveUnnecessaryOutputNodes(), roots) || modified;
      modified = runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots) || modified;
      roots = roots.filter(r => r.numChildren() > 0);
      modified = runOptimizer(new RemoveUnusedSubtrees(), roots) || modified;
      roots = roots.filter(r => r.numChildren() > 0);
      firstPass || (modified = runOptimizer(new MoveParseUp(), roots) || modified, modified = runOptimizer(new MergeBins(model), roots) || modified, modified = runOptimizer(new RemoveDuplicateTimeUnits(), roots) || modified, modified = runOptimizer(new MergeParse(), roots) || modified, modified = runOptimizer(new MergeAggregates(), roots) || modified, modified = runOptimizer(new MergeTimeUnits(), roots) || modified, modified = runOptimizer(new MergeIdenticalNodes(), roots) || modified, modified = 
      runOptimizer(new MergeOutputs(), roots) || modified);
      dataComponent.sources = roots;
      return modified;
    }
    function parseUnitScaleDomain(model$jscomp$0) {
      const localScaleComponents = model$jscomp$0.component.scales;
      for (const channel of keys(localScaleComponents)) {
        var model = model$jscomp$0, scaleType = model.getScaleComponent(channel).get("type"), {encoding} = model;
        var JSCompiler_inline_result = model.scaleDomain(channel);
        var fieldDef = model.typedFieldDef(channel), scaleConfig = model.config.scale;
        if (JSCompiler_inline_result === "unaggregated") {
          const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);
          valid || (warn(reason), JSCompiler_inline_result = void 0);
        } else {
          JSCompiler_inline_result === void 0 && scaleConfig.useUnaggregatedDomain && ({valid:fieldDef} = canUseUnaggregatedDomain(fieldDef, scaleType), fieldDef && (JSCompiler_inline_result = "unaggregated"));
        }
        JSCompiler_inline_result !== model.scaleDomain(channel) && (model.specifiedScales[channel] = {...model.specifiedScales[channel], domain:JSCompiler_inline_result});
        model = channel === "x" && getFieldOrDatumDef(encoding.x2) ? getFieldOrDatumDef(encoding.x) ? mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, JSCompiler_inline_result, model, "x"), parseSingleChannelDomain(scaleType, JSCompiler_inline_result, model, "x2"), "domain", "scale", domainsTieBreaker) : parseSingleChannelDomain(scaleType, JSCompiler_inline_result, model, "x2") : channel === "y" && getFieldOrDatumDef(encoding.y2) ? getFieldOrDatumDef(encoding.y) ? mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, 
        JSCompiler_inline_result, model, "y"), parseSingleChannelDomain(scaleType, JSCompiler_inline_result, model, "y2"), "domain", "scale", domainsTieBreaker) : parseSingleChannelDomain(scaleType, JSCompiler_inline_result, model, "y2") : parseSingleChannelDomain(scaleType, JSCompiler_inline_result, model, channel);
        localScaleComponents[channel].setWithExplicit("domains", model);
        scaleType = model$jscomp$0.component.scales[channel];
        JSCompiler_inline_result = model$jscomp$0.specifiedScales[channel].domain;
        encoding = model$jscomp$0.fieldDef(channel)?.bin;
        JSCompiler_inline_result = hasProperty(JSCompiler_inline_result, "param") ? JSCompiler_inline_result : void 0;
        encoding = vega.isObject(encoding) && hasProperty(encoding.extent, "param") ? encoding.extent : void 0;
        (JSCompiler_inline_result || encoding) && scaleType.set("selectionExtent", JSCompiler_inline_result ?? encoding, !0);
        if (model$jscomp$0.component.data.isFaceted) {
          for (scaleType = model$jscomp$0; !isFacetModel(scaleType) && scaleType.parent;) {
            scaleType = scaleType.parent;
          }
          if (scaleType.component.resolve.scale[channel] === "shared") {
            for (const domain of model.value) {
              isDataRefDomain(domain) && (domain.data = "scale_" + domain.data.replace("scale_", ""));
            }
          }
        }
      }
    }
    function parseNonUnitScaleDomain(model) {
      for (var child of model.children) {
        isUnitModel(child) ? parseUnitScaleDomain(child) : parseNonUnitScaleDomain(child);
      }
      child = model.component.scales;
      for (const channel of keys(child)) {
        let domains, selectionExtent = null;
        for (const child of model.children) {
          var childComponent = child.component.scales[channel];
          childComponent && (domains = domains === void 0 ? childComponent.getWithExplicit("domains") : mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker), childComponent = childComponent.get("selectionExtent"), selectionExtent && childComponent && selectionExtent.param !== childComponent.param && warn("The same selection must be used to override scale domains in a layered view."), selectionExtent = childComponent);
        }
        child[channel].setWithExplicit("domains", domains);
        selectionExtent && child[channel].set("selectionExtent", selectionExtent, !0);
      }
    }
    function mapDomainToDataSignal(domain, type, timeUnit) {
      return domain.map(v => ({signal:`{data: ${valueExpr(v, {timeUnit, type})}}`}));
    }
    function convertDomainIfItIsDateTime(domain, type, timeUnit) {
      timeUnit = normalizeTimeUnit(timeUnit)?.unit;
      return type === "temporal" || timeUnit ? mapDomainToDataSignal(domain, type, timeUnit) : [domain];
    }
    function parseSingleChannelDomain(scaleType, domain, model, channel) {
      const {encoding, markDef, mark, config, stack} = model;
      var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      const {type} = fieldOrDatumDef, timeUnit = fieldOrDatumDef.timeUnit;
      var dataSourceTypeForScaleDomain = getScaleDataSourceForHandlingInvalidValues({invalid:getMarkConfig("invalid", markDef, config), isPath:isPathMark(mark)});
      if (hasProperty(domain, "unionWith")) {
        return channel = parseSingleChannelDomain(scaleType, void 0, model, channel), fieldOrDatumDef = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit), makeExplicit([...fieldOrDatumDef, ...channel.value]);
      }
      if (isSignalRef(domain)) {
        return makeExplicit([domain]);
      }
      if (domain && domain !== "unaggregated" && !hasProperty(domain, "param")) {
        return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));
      }
      if (stack && channel === stack.fieldChannel) {
        if (stack.offset === "normalize") {
          return makeImplicit([[0, 1]]);
        }
        fieldOrDatumDef = model.requestDataName(dataSourceTypeForScaleDomain);
        return makeImplicit([{data:fieldOrDatumDef, field:model.vgField(channel, {suffix:"start"})}, {data:fieldOrDatumDef, field:model.vgField(channel, {suffix:"end"})}]);
      }
      const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : void 0;
      if (isDatumDef(fieldOrDatumDef)) {
        return channel = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit), makeImplicit(channel);
      }
      if (domain === "unaggregated") {
        return {field:channel} = fieldOrDatumDef, makeImplicit([{data:model.requestDataName(dataSourceTypeForScaleDomain), field:vgField({field:channel, aggregate:"min"})}, {data:model.requestDataName(dataSourceTypeForScaleDomain), field:vgField({field:channel, aggregate:"max"})}]);
      }
      if (isBinning(fieldOrDatumDef.bin)) {
        if (hasDiscreteDomain(scaleType)) {
          return scaleType === "bin-ordinal" ? makeImplicit([]) : makeImplicit([{data:isBoolean(sort) ? model.requestDataName(dataSourceTypeForScaleDomain) : model.requestDataName(DataSourceType.Raw), field:model.vgField(channel, binRequiresRange(fieldOrDatumDef, channel) ? {binSuffix:"range"} : {}), sort:sort !== !0 && vega.isObject(sort) ? sort : {field:model.vgField(channel, {}), op:"min"}}]);
        }
        ({bin:domain} = fieldOrDatumDef);
        if (isBinning(domain)) {
          const binSignal = getBinSignalName(model, fieldOrDatumDef.field, domain);
          return makeImplicit([new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })]);
        }
        return makeImplicit([{data:model.requestDataName(dataSourceTypeForScaleDomain), field:model.vgField(channel, {})}]);
      }
      return fieldOrDatumDef.timeUnit && contains(["time", "utc"], scaleType) && (domain = encoding[getSecondaryRangeChannel(channel)], hasBandEnd(fieldOrDatumDef, domain, markDef, config)) ? (dataSourceTypeForScaleDomain = model.requestDataName(dataSourceTypeForScaleDomain), fieldOrDatumDef = getBandPosition({fieldDef:fieldOrDatumDef, fieldDef2:domain, markDef, config}), fieldOrDatumDef = isRectBasedMark(mark) && fieldOrDatumDef !== 0.5 && isXorY(channel), makeImplicit([{data:dataSourceTypeForScaleDomain, 
      field:model.vgField(channel, fieldOrDatumDef ? {suffix:"offsetted_rect_start"} : {})}, {data:dataSourceTypeForScaleDomain, field:model.vgField(channel, {suffix:fieldOrDatumDef ? "offsetted_rect_end" : "end"})}])) : sort ? makeImplicit([{data:isBoolean(sort) ? model.requestDataName(dataSourceTypeForScaleDomain) : model.requestDataName(DataSourceType.Raw), field:model.vgField(channel), sort}]) : makeImplicit([{data:model.requestDataName(dataSourceTypeForScaleDomain), field:model.vgField(channel)}]);
    }
    function normalizeSortField(sort, isStackedMeasure) {
      const {op, field, order} = sort;
      return {op:op ?? (isStackedMeasure ? "sum" : "min"), ...(field ? {field:replacePathInField(field)} : {}), ...(order ? {order} : {})};
    }
    function domainSort(model, channel, scaleType) {
      if (hasDiscreteDomain(scaleType)) {
        var fieldDef = model.fieldDef(channel);
        scaleType = fieldDef.sort;
        if (isSortArray(scaleType)) {
          return {op:"min", field:sortArrayIndexField(fieldDef, channel), order:"ascending"};
        }
        ({stack:fieldDef} = model);
        var stackDimensions = fieldDef ? new Set([...fieldDef.groupbyFields, ...fieldDef.stackBy.map(s => s.fieldDef.field)]) : void 0;
        if (isSortField(scaleType)) {
          return model = fieldDef && !stackDimensions.has(scaleType.field), normalizeSortField(scaleType, model);
        }
        if (hasProperty(scaleType, "encoding")) {
          const {encoding, order} = scaleType;
          model = model.fieldDef(encoding);
          const {aggregate, field} = model;
          channel = fieldDef && !stackDimensions.has(field);
          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
            return normalizeSortField({field:vgField(model), order}, channel);
          }
          if (isAggregateOp(aggregate) || !aggregate) {
            return normalizeSortField({op:aggregate, field, order}, channel);
          }
        } else {
          if (scaleType === "descending") {
            return {op:"min", field:model.vgField(channel), order:"descending"};
          }
          if (contains(["ascending", void 0], scaleType)) {
            return !0;
          }
        }
      }
    }
    function canUseUnaggregatedDomain(fieldDef, scaleType) {
      const {aggregate, type} = fieldDef;
      return aggregate ? vega.isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate) ? {valid:!1, reason:`Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`} : type === "quantitative" && scaleType === "log" ? {valid:!1, reason:`Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`} : {valid:!0} : {valid:!1, reason:`Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`};
    }
    function domainsTieBreaker(v1, v2$jscomp$0, property, propertyOf) {
      if (v1.explicit && v2$jscomp$0.explicit) {
        var v2 = v2$jscomp$0.value;
        property = `Conflicting ${propertyOf.toString()} property "${property.toString()}" (${stringify(v1.value)} and ${stringify(v2)}). Using the union of the two domains.`;
        warn(property);
      }
      return {explicit:v1.explicit, value:[...v1.value, ...v2$jscomp$0.value]};
    }
    function mergeDomains(domains) {
      var uniqueDomains = unique(domains.map(domain => {
        if (isDataRefDomain(domain)) {
          const {sort:_s, ...domainWithoutSort} = domain;
          return domainWithoutSort;
        }
        return domain;
      }), hash), sorts = unique(domains.map(d => {
        if (isDataRefDomain(d)) {
          return d = d.sort, d === void 0 || isBoolean(d) || ("op" in d && d.op === "count" && delete d.field, d.order === "ascending" && delete d.order), d;
        }
      }).filter(s => s !== void 0), hash);
      if (uniqueDomains.length !== 0) {
        if (uniqueDomains.length === 1) {
          uniqueDomains = domains[0];
          if (isDataRefDomain(uniqueDomains) && sorts.length > 0) {
            var sort = sorts[0];
            sorts.length > 1 ? (warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."), sort = sorts.filter(s => vega.isObject(s) && "op" in s && s.op !== "min"), sort = sorts.every(s => vega.isObject(s) && "op" in s) && sort.length === 1 ? sort[0] : !0) : vega.isObject(sort) && "field" in sort && uniqueDomains.field === sort.field && (sort = sort.order ? {order:sort.order} : !0);
            return {...uniqueDomains, sort};
          }
          return uniqueDomains;
        }
        sorts = unique(sorts.map(s => {
          if (isBoolean(s) || !("op" in s) || vega.isString(s.op) && vega.hasOwnProperty(MULTIDOMAIN_SORT_OP_INDEX, s.op)) {
            return s;
          }
          warn(`Dropping sort property ${stringify(s)} as unioned domains only support boolean or op "count", "min", and "max".`);
          return !0;
        }), hash);
        sorts.length === 1 ? sort = sorts[0] : sorts.length > 1 && (warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."), sort = !0);
        sorts = unique(domains.map(d => isDataRefDomain(d) ? d.data : null), x => x);
        return sorts.length === 1 && sorts[0] !== null ? {data:sorts[0], fields:uniqueDomains.map(d => d.field), ...(sort ? {sort} : {})} : {fields:uniqueDomains, ...(sort ? {sort} : {})};
      }
    }
    function getFieldFromDomain(domain) {
      if (isDataRefDomain(domain) && vega.isString(domain.field)) {
        return domain.field;
      }
      var JSCompiler_inline_result = vega.isArray(domain) ? !1 : hasProperty(domain, "fields") && !hasProperty(domain, "data");
      if (JSCompiler_inline_result) {
        let field;
        for (const nonUnionDomain of domain.fields) {
          if (isDataRefDomain(nonUnionDomain) && vega.isString(nonUnionDomain.field)) {
            if (!field) {
              field = nonUnionDomain.field;
            } else if (field !== nonUnionDomain.field) {
              return warn("Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect."), field;
            }
          }
        }
        warn("Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.");
        return field;
      }
      JSCompiler_inline_result = vega.isArray(domain) ? !1 : hasProperty(domain, "fields") && hasProperty(domain, "data");
      if (JSCompiler_inline_result) {
        return warn("Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect."), domain = domain.fields[0], vega.isString(domain) ? domain : void 0;
      }
    }
    function assembleDomain(model, channel) {
      channel = model.component.scales[channel].get("domains").map(domain => {
        isDataRefDomain(domain) && (domain.data = model.lookupDataSource(domain.data));
        return domain;
      });
      return mergeDomains(channel);
    }
    function assembleScales(model) {
      return isLayerModel(model) || model?.type === "concat" ? model.children.reduce((scales, child) => scales.concat(assembleScales(child)), assembleScalesForModel(model)) : assembleScalesForModel(model);
    }
    function assembleScalesForModel(model) {
      return keys(model.component.scales).reduce((scales, channel) => {
        var scaleComponent = model.component.scales[channel];
        if (scaleComponent.merged) {
          return scales;
        }
        var scale = scaleComponent.combine();
        const {name, type, selectionExtent, domains:_d, range:_r, reverse, ...otherScaleProps} = scale;
        scale = scale.range;
        isXorY(channel) ? isVgRangeStep(scale) && (scale = {step:{signal:`${name}_step`}}) : vega.isObject(scale) && isDataRefDomain(scale) && (scale = {...scale, data:model.lookupDataSource(scale.data)});
        channel = assembleDomain(model, channel);
        if (selectionExtent) {
          const parsedExtent = parseSelectionExtent(model, selectionExtent.param, selectionExtent);
          scaleComponent = {signal:hasContinuousDomain(scaleComponent.get("type")) && vega.isArray(channel) && channel[0] > channel[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent};
        } else {
          scaleComponent = null;
        }
        scales.push({name, type, ...(channel ? {domain:channel} : {}), ...(scaleComponent ? {domainRaw:scaleComponent} : {}), range:scale, ...(reverse !== void 0 ? {reverse} : {}), ...otherScaleProps});
        return scales;
      }, []);
    }
    function getBinStepSignal(model, channel) {
      var fieldDef = model.fieldDef(channel);
      if (fieldDef?.bin) {
        const {bin, field} = fieldDef;
        fieldDef = getSizeChannel(channel);
        const sizeSignal = model.getName(fieldDef);
        if (vega.isObject(bin) && bin.binned && bin.step !== void 0) {
          return new SignalRefWrapper(() => {
            var scaleName = model.scaleName(channel);
            scaleName = `(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin.step}`;
            return `${model.getSignalName(sizeSignal)} / (${scaleName})`;
          });
        }
        if (isBinning(bin)) {
          const binSignal = getBinSignalName(model, field, bin);
          return new SignalRefWrapper(() => {
            var updatedName = model.getSignalName(binSignal);
            updatedName = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
            return `${model.getSignalName(sizeSignal)} / (${updatedName})`;
          });
        }
      }
    }
    function parseRangeForChannel(channel, model) {
      const specifiedScale = model.specifiedScales[channel];
      var {size} = model, scaleType = model.getScaleComponent(channel).get("type");
      for (var property of RANGE_PROPERTIES) {
        if (specifiedScale[property] !== void 0) {
          const supportedByScaleType = scaleTypeSupportProperty(scaleType, property), channelIncompatability = channelScalePropertyIncompatability(channel, property);
          if (supportedByScaleType) {
            if (channelIncompatability) {
              warn(channelIncompatability);
            } else {
              switch(property) {
                case "range":
                  scaleType = specifiedScale.range;
                  if (vega.isArray(scaleType)) {
                    if (isXorY(channel)) {
                      return makeExplicit(scaleType.map(v => {
                        if (v === "width" || v === "height") {
                          v = model.getName(v);
                          const getSignalName = model.getSignalName.bind(model);
                          return SignalRefWrapper.fromName(getSignalName, v);
                        }
                        return v;
                      }));
                    }
                  } else if (vega.isObject(scaleType)) {
                    return makeExplicit({data:model.requestDataName(DataSourceType.Main), field:scaleType.field, sort:{op:"min", field:model.vgField(channel)}});
                  }
                  return makeExplicit(scaleType);
                case "scheme":
                  return makeExplicit(parseScheme(specifiedScale[property]));
              }
            }
          } else {
            warn(scalePropertyNotWorkWithScaleType(scaleType, property, channel));
          }
        }
      }
      property = channel === "x" || channel === "xOffset" ? "width" : "height";
      size = size[property];
      if (isStep(size)) {
        if (isXorY(channel)) {
          if (hasDiscreteDomain(scaleType)) {
            if (size = getPositionStep(size, model, channel)) {
              return makeExplicit({step:size});
            }
          } else {
            warn(stepDropped(property));
          }
        } else if (vega.hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel) && model.getScaleComponent(channel === "xOffset" ? "x" : "y").get("type") === "band" && (size = getOffsetStep(size, scaleType))) {
          return makeExplicit(size);
        }
      }
      const {rangeMin, rangeMax} = specifiedScale;
      channel = defaultRange(channel, model);
      return (rangeMin !== void 0 || rangeMax !== void 0) && scaleTypeSupportProperty(scaleType, "rangeMin") && vega.isArray(channel) && channel.length === 2 ? makeExplicit([rangeMin ?? channel[0], rangeMax ?? channel[1]]) : makeImplicit(channel);
    }
    function parseScheme(scheme) {
      return !vega.isString(scheme) && hasProperty(scheme, "name") ? {scheme:scheme.name, ...omit(scheme, ["name"])} : {scheme};
    }
    function fullWidthOrHeightRange(channel, model, scaleType) {
      let {center} = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var sizeType = getSizeChannel(channel);
      sizeType = model.getName(sizeType);
      const getSignalName = model.getSignalName.bind(model);
      return channel === "y" && hasContinuousDomain(scaleType) ? center ? [SignalRefWrapper.fromName(name => `${getSignalName(name)}/2`, sizeType), SignalRefWrapper.fromName(name => `-${getSignalName(name)}/2`, sizeType)] : [SignalRefWrapper.fromName(getSignalName, sizeType), 0] : center ? [SignalRefWrapper.fromName(name => `-${getSignalName(name)}/2`, sizeType), SignalRefWrapper.fromName(name => `${getSignalName(name)}/2`, sizeType)] : [0, SignalRefWrapper.fromName(getSignalName, sizeType)];
    }
    function defaultRange(channel, model) {
      const {size, config, mark, encoding} = model;
      var {type} = getFieldOrDatumDef(encoding[channel]);
      const scaleType = model.getScaleComponent(channel).get("type"), {domain, domainMid} = model.specifiedScales[channel];
      switch(channel) {
        case "x":
        case "y":
          return contains(["point", "band"], scaleType) && (type = getDiscretePositionSize(channel, size, config.view), isStep(type)) ? {step:getPositionStep(type, model, channel)} : fullWidthOrHeightRange(channel, model, scaleType);
        case "xOffset":
        case "yOffset":
          return getOffsetRange(channel, model, scaleType);
        case "size":
          type = sizeRangeMin(mark, config);
          const rangeMax = sizeRangeMax(mark, size, model, config);
          return CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType) ? interpolateRange(type, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel)) : [type, rangeMax];
        case "theta":
          return [0, Math.PI * 2];
        case "angle":
          return [0, 360];
        case "radius":
          return [0, new SignalRefWrapper(() => {
            const w = model.getSignalName(isFacetModel(model.parent) ? "child_width" : "width"), h = model.getSignalName(isFacetModel(model.parent) ? "child_height" : "height");
            return `min(${w},${h})/2`;
          })];
        case "time":
          return {step:1000 / config.scale.framesPerSecond};
        case "strokeWidth":
          return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
        case "strokeDash":
          return [[1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];
        case "shape":
          return "symbol";
        case "color":
        case "fill":
        case "stroke":
          return scaleType === "ordinal" ? type === "nominal" ? "category" : "ordinal" : domainMid !== void 0 ? "diverging" : mark === "rect" || mark === "geoshape" ? "heatmap" : "ramp";
        case "opacity":
        case "fillOpacity":
        case "strokeOpacity":
          return [config.scale.minOpacity, config.scale.maxOpacity];
      }
    }
    function getPositionStep(step, model, channel) {
      var {encoding} = model, mergedScaleCmpt = model.getScaleComponent(channel);
      channel = getOffsetScaleChannel(channel);
      const offsetDef = encoding[channel];
      return getStepFor({step, offsetIsDiscrete:isFieldOrDatumDef(offsetDef) && isDiscrete$1(offsetDef.type)}) === "offset" && channelHasFieldOrDatum(encoding, channel) ? (encoding = model.getScaleComponent(channel), model = `domain('${model.scaleName(channel)}').length`, encoding.get("type") === "band" && (channel = encoding.get("paddingInner") ?? encoding.get("padding") ?? 0, encoding = encoding.get("paddingOuter") ?? encoding.get("padding") ?? 0, model = `bandspace(${model}, ${channel}, ${encoding})`), 
      mergedScaleCmpt = mergedScaleCmpt.get("paddingInner") ?? mergedScaleCmpt.get("padding"), step = step.step, mergedScaleCmpt = isSignalRef(mergedScaleCmpt) ? mergedScaleCmpt.signal : vega.stringValue(mergedScaleCmpt), {signal:`${step} * ${model} / (1-${mergedScaleCmpt})`}) : step.step;
    }
    function getOffsetStep(step, offsetScaleType) {
      if (getStepFor({step, offsetIsDiscrete:hasDiscreteDomain(offsetScaleType)}) === "offset") {
        return {step:step.step};
      }
    }
    function getOffsetRange(channel, model, offsetScaleType) {
      var positionChannel = channel === "xOffset" ? "x" : "y", positionScaleCmpt = model.getScaleComponent(positionChannel);
      if (!positionScaleCmpt) {
        return fullWidthOrHeightRange(positionChannel, model, offsetScaleType, {center:!0});
      }
      positionScaleCmpt = positionScaleCmpt.get("type");
      const positionScaleName = model.scaleName(positionChannel), {markDef, config} = model;
      if (positionScaleCmpt === "band") {
        return model = getDiscretePositionSize(positionChannel, model.size, model.config.view), isStep(model) && (model = getOffsetStep(model, offsetScaleType)) ? model : [0, {signal:`bandwidth('${positionScaleName}')`}];
      }
      offsetScaleType = model.encoding[positionChannel];
      return isFieldDef(offsetScaleType) && offsetScaleType.timeUnit ? (channel = durationExpr(offsetScaleType.timeUnit, expr => `scale('${positionScaleName}', ${expr})`), model = model.config.scale.bandWithNestedOffsetPaddingInner, positionChannel = getBandPosition({fieldDef:offsetScaleType, markDef, config}) - 0.5, positionScaleCmpt = positionChannel !== 0 ? ` + ${positionChannel}` : "", model ? (offsetScaleType = isSignalRef(model) ? `${model.signal}/2` + positionScaleCmpt : `${model / 2 + positionChannel}`, 
      model = isSignalRef(model) ? `(1 - ${model.signal}/2)` + positionScaleCmpt : `${1 - model / 2 + positionChannel}`, [{signal:`${offsetScaleType} * (${channel})`}, {signal:`${model} * (${channel})`}]) : [0, {signal:channel}]) : never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);
    }
    function getDiscretePositionSize(channel, size, viewConfig) {
      channel = channel === "x" ? "width" : "height";
      return (size = size[channel]) ? size : getViewConfigDiscreteSize(viewConfig, channel);
    }
    function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {
      switch(scaleType) {
        case "quantile":
          return config.scale.quantileCount;
        case "quantize":
          return config.scale.quantizeCount;
        case "threshold":
          if (domain !== void 0 && vega.isArray(domain)) {
            return domain.length + 1;
          }
          warn(`Domain for ${channel} is required for threshold scale.`);
          return 3;
      }
    }
    function interpolateRange(rangeMin, rangeMax, cardinality) {
      const f = () => {
        const rMax = signalOrStringValue(rangeMax), rMin = signalOrStringValue(rangeMin), step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
        return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
      };
      return isSignalRef(rangeMax) ? new SignalRefWrapper(f) : {signal:f()};
    }
    function sizeRangeMin(mark, config) {
      switch(mark) {
        case "bar":
        case "tick":
          return config.scale.minBandSize;
        case "line":
        case "trail":
        case "rule":
          return config.scale.minStrokeWidth;
        case "text":
          return config.scale.minFontSize;
        case "point":
        case "square":
        case "circle":
          return config.scale.minSize;
      }
      throw Error(incompatibleChannel("size", mark));
    }
    function sizeRangeMax(mark, size, model, config) {
      model = {x:getBinStepSignal(model, "x"), y:getBinStepSignal(model, "y")};
      switch(mark) {
        case "bar":
        case "tick":
          if (config.scale.maxBandSize !== void 0) {
            return config.scale.maxBandSize;
          }
          const min = minXYStep(size, model, config.view);
          return vega.isNumber(min) ? min - 1 : new SignalRefWrapper(() => `${min.signal} - 1`);
        case "line":
        case "trail":
        case "rule":
          return config.scale.maxStrokeWidth;
        case "text":
          return config.scale.maxFontSize;
        case "point":
        case "square":
        case "circle":
          if (config.scale.maxSize) {
            return config.scale.maxSize;
          }
          const pointStep = minXYStep(size, model, config.view);
          return vega.isNumber(pointStep) ? Math.pow(0.95 * pointStep, 2) : new SignalRefWrapper(() => `pow(${0.95} * ${pointStep.signal}, 2)`);
      }
      throw Error(incompatibleChannel("size", mark));
    }
    function minXYStep(size, xyStepSignals, viewConfig) {
      const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width"), heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
      return xyStepSignals.x || xyStepSignals.y ? new SignalRefWrapper(() => `min(${[xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep].join(", ")})`) : Math.min(widthStep, heightStep);
    }
    function parseScaleProperty(model, property) {
      if (isUnitModel(model)) {
        const localScaleComponents = model.component.scales, {config, encoding, markDef, specifiedScales} = model;
        for (const channel of keys(localScaleComponents)) {
          var specifiedScale = specifiedScales[channel];
          const localScaleCmpt = localScaleComponents[channel];
          var mergedScaleCmpt = model.getScaleComponent(channel), fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]), specifiedValue = specifiedScale[property];
          const scaleType = mergedScaleCmpt.get("type"), scalePadding = mergedScaleCmpt.get("padding");
          mergedScaleCmpt = mergedScaleCmpt.get("paddingInner");
          const supportedByScaleType = scaleTypeSupportProperty(scaleType, property), channelIncompatability = channelScalePropertyIncompatability(channel, property);
          specifiedValue !== void 0 && (supportedByScaleType ? channelIncompatability && warn(channelIncompatability) : warn(scalePropertyNotWorkWithScaleType(scaleType, property, channel)));
          if (supportedByScaleType && channelIncompatability === void 0) {
            if (specifiedValue !== void 0) {
              switch(specifiedValue = fieldOrDatumDef.timeUnit, fieldOrDatumDef = fieldOrDatumDef.type, property) {
                case "domainMax":
                case "domainMin":
                  isDateTime(specifiedScale[property]) || fieldOrDatumDef === "temporal" || specifiedValue ? localScaleCmpt.set(property, {signal:valueExpr(specifiedScale[property], {type:fieldOrDatumDef, timeUnit:specifiedValue})}, !0) : localScaleCmpt.set(property, specifiedScale[property], !0);
                  break;
                default:
                  localScaleCmpt.copyKeyFromObject(property, specifiedScale);
              }
            } else {
              specifiedScale = hasProperty(scaleRules, property) ? scaleRules[property]({model, channel, fieldOrDatumDef, scaleType, scalePadding, scalePaddingInner:mergedScaleCmpt, domain:specifiedScale.domain, domainMin:specifiedScale.domainMin, domainMax:specifiedScale.domainMax, markDef, config, hasNestedOffsetScale:channelHasNestedOffsetScale(encoding, channel), hasSecondaryRangeChannel:!!encoding[getSecondaryRangeChannel(channel)]}) : config.scale[property], specifiedScale !== void 0 && localScaleCmpt.set(property, 
              specifiedScale, !1);
            }
          }
        }
      } else {
        parseNonUnitScaleProperty(model, property);
      }
    }
    function parseScaleRange(model) {
      if (isUnitModel(model)) {
        const localScaleComponents = model.component.scales;
        for (const channel of SCALE_CHANNELS) {
          const localScaleCmpt = localScaleComponents[channel];
          if (!localScaleCmpt) {
            continue;
          }
          const rangeWithExplicit = parseRangeForChannel(channel, model);
          localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
        }
      } else {
        parseNonUnitScaleProperty(model, "range");
      }
    }
    function parseNonUnitScaleProperty(model, property) {
      const localScaleComponents = model.component.scales;
      for (var child$jscomp$0 of model.children) {
        property === "range" ? parseScaleRange(child$jscomp$0) : parseScaleProperty(child$jscomp$0, property);
      }
      for (const channel of keys(localScaleComponents)) {
        let valueWithExplicit;
        for (const child of model.children) {
          if (child$jscomp$0 = child.component.scales[channel]) {
            child$jscomp$0 = child$jscomp$0.getWithExplicit(property), valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, child$jscomp$0, property, "scale", tieBreakByComparing((v1, v2) => {
              switch(property) {
                case "range":
                  if (v1.step && v2.step) {
                    return v1.step - v2.step;
                  }
              }
              return 0;
            }));
          }
        }
        localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);
      }
    }
    function bins(model, fieldDef) {
      const bin = fieldDef.bin;
      if (isBinning(bin)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin);
        return new SignalRefWrapper(() => model.getSignalName(binSignal));
      }
      if (isBinned(bin) && vega.isObject(bin) && bin.step !== void 0) {
        return {step:bin.step};
      }
    }
    function paddingInner(paddingValue, channel, mark, scaleType, scaleConfig) {
      let hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
      if (paddingValue === void 0) {
        if (isXorY(channel)) {
          const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, tickBandPaddingInner, bandWithNestedOffsetPaddingInner} = scaleConfig;
          return hasNestedOffsetScale ? bandWithNestedOffsetPaddingInner : getFirstDefined(bandPaddingInner, mark === "bar" ? barBandPaddingInner : mark === "tick" ? tickBandPaddingInner : rectBandPaddingInner);
        }
        if (vega.hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel) && scaleType === ScaleType.BAND) {
          return scaleConfig.offsetBandPaddingInner;
        }
      }
    }
    function paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig) {
      let hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
      if (paddingValue === void 0) {
        if (isXorY(channel)) {
          const {bandPaddingOuter, bandWithNestedOffsetPaddingOuter} = scaleConfig;
          if (hasNestedOffsetScale) {
            return bandWithNestedOffsetPaddingOuter;
          }
          if (scaleType === ScaleType.BAND) {
            return getFirstDefined(bandPaddingOuter, isSignalRef(paddingInnerValue) ? {signal:`${paddingInnerValue.signal}/2`} : paddingInnerValue / 2);
          }
        } else if (vega.hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel)) {
          if (scaleType === ScaleType.POINT) {
            return 0.5;
          }
          if (scaleType === ScaleType.BAND) {
            return scaleConfig.offsetBandPaddingOuter;
          }
        }
      }
    }
    function scaleType(specifiedScale, channel, fieldDef, mark) {
      const defaultScaleType = defaultType(channel, fieldDef, mark, arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1), {type} = specifiedScale;
      if (!isScaleChannel(channel)) {
        return null;
      }
      if (type !== void 0) {
        if (!channelSupportScaleType(channel, type)) {
          return warn(`Channel "${channel}" does not work with "${type}" scale. We are using "${defaultScaleType}" scale instead.`), defaultScaleType;
        }
        var JSCompiler_temp;
        if (JSCompiler_temp = isFieldDef(fieldDef)) {
          JSCompiler_temp = fieldDef.type, JSCompiler_temp = !(contains(["ordinal", "nominal"], JSCompiler_temp) ? type === void 0 || hasDiscreteDomain(type) : JSCompiler_temp === "temporal" ? contains([ScaleType.TIME, ScaleType.UTC, void 0], type) : JSCompiler_temp === "quantitative" ? QUANTITATIVE_SCALES.has(type) || CONTINUOUS_TO_DISCRETE_SCALES.has(type) || type === void 0 : 1);
        }
        return JSCompiler_temp ? (warn(`FieldDef does not work with "${type}" scale. We are using "${defaultScaleType}" scale instead.`), defaultScaleType) : type;
      }
      return defaultScaleType;
    }
    function defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {
      switch(fieldDef.type) {
        case "nominal":
        case "ordinal":
          if (isColorChannel(channel) || rangeType(channel) === "discrete") {
            return channel === "shape" && fieldDef.type === "ordinal" && warn(discreteChannelCannotEncode(channel, "ordinal")), "ordinal";
          }
          if (channel in TIME_SCALE_CHANNEL_INDEX) {
            return "band";
          }
          if (isXorY(channel) || vega.hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel)) {
            if (contains(["rect", "bar", "image", "rule", "tick"], mark.type) || hasNestedOffsetScale) {
              return "band";
            }
          } else if (mark.type === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
            return "band";
          }
          channel = mark[getSizeChannel(channel)];
          return isRelativeBandSize(channel) || isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis?.tickBand ? "band" : "point";
        case "temporal":
          if (!isColorChannel(channel)) {
            if (rangeType(channel) === "discrete") {
              return warn(discreteChannelCannotEncode(channel, "temporal")), "ordinal";
            }
            if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
              return "utc";
            }
            if (channel in TIME_SCALE_CHANNEL_INDEX) {
              return "band";
            }
          }
          return "time";
        case "quantitative":
          if (isColorChannel(channel)) {
            if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
              return "bin-ordinal";
            }
          } else {
            if (rangeType(channel) === "discrete") {
              return warn(discreteChannelCannotEncode(channel, "quantitative")), "ordinal";
            }
            if (channel in TIME_SCALE_CHANNEL_INDEX) {
              return "band";
            }
          }
          return "linear";
        case "geojson":
          return;
      }
      throw Error(`Invalid field type "${fieldDef.type}".`);
    }
    function parseScales(model) {
      let {ignoreRange} = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      parseScaleCore(model);
      isUnitModel(model) ? parseUnitScaleDomain(model) : parseNonUnitScaleDomain(model);
      for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
        parseScaleProperty(model, prop);
      }
      ignoreRange || parseScaleRange(model);
    }
    function parseScaleCore(model) {
      if (isUnitModel(model)) {
        var JSCompiler_temp_const = model.component;
        const {encoding, mark, markDef} = model;
        var scaleComponents = {};
        for (var channel of SCALE_CHANNELS) {
          var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
          if (!fieldOrDatumDef || mark !== GEOSHAPE || channel !== "shape" || fieldOrDatumDef.type !== "geojson") {
            var specifiedScale = fieldOrDatumDef && fieldOrDatumDef.scale;
            if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== !1) {
              specifiedScale ??= {};
              var hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);
              fieldOrDatumDef = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);
              scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, !0), {value:fieldOrDatumDef, explicit:specifiedScale.type === fieldOrDatumDef});
            }
          }
        }
        JSCompiler_temp_const.scales = scaleComponents;
      } else {
        channel = model.component;
        specifiedScale = model.component.scales = {};
        fieldOrDatumDef = {};
        const resolve = model.component.resolve;
        for (hasNestedOffsetScale of model.children) {
          parseScaleCore(hasNestedOffsetScale);
          for (var channel$jscomp$0 of keys(hasNestedOffsetScale.component.scales)) {
            let $jscomp$inline_1808, $jscomp$inline_1809;
            ($jscomp$inline_1808 = resolve.scale)[$jscomp$inline_1809 = channel$jscomp$0] ?? ($jscomp$inline_1808[$jscomp$inline_1809] = defaultScaleResolve(channel$jscomp$0, model));
            if (resolve.scale[channel$jscomp$0] === "shared") {
              const explicitScaleType = fieldOrDatumDef[channel$jscomp$0], childScaleType = hasNestedOffsetScale.component.scales[channel$jscomp$0].getWithExplicit("type");
              if (explicitScaleType) {
                const scaleCategory1 = SCALE_CATEGORY_INDEX[explicitScaleType.value], scaleCategory2 = SCALE_CATEGORY_INDEX[childScaleType.value];
                scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time" ? fieldOrDatumDef[channel$jscomp$0] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker) : (resolve.scale[channel$jscomp$0] = "independent", delete fieldOrDatumDef[channel$jscomp$0]);
              } else {
                fieldOrDatumDef[channel$jscomp$0] = childScaleType;
              }
            }
          }
        }
        for (JSCompiler_temp_const of keys(fieldOrDatumDef)) {
          hasNestedOffsetScale = model.scaleName(JSCompiler_temp_const, !0);
          specifiedScale[JSCompiler_temp_const] = new ScaleComponent(hasNestedOffsetScale, fieldOrDatumDef[JSCompiler_temp_const]);
          for (scaleComponents of model.children) {
            if (channel$jscomp$0 = scaleComponents.component.scales[JSCompiler_temp_const]) {
              scaleComponents.renameScale(channel$jscomp$0.get("name"), hasNestedOffsetScale), channel$jscomp$0.merged = !0;
            }
          }
        }
        channel.scales = specifiedScale;
      }
    }
    function isUnitModel(model) {
      return model?.type === "unit";
    }
    function isFacetModel(model) {
      return model?.type === "facet";
    }
    function isLayerModel(model) {
      return model?.type === "layer";
    }
    function makeWalkTree(data) {
      function walkTree(node, dataSource) {
        node instanceof SourceNode && !node.isGenerator && !hasProperty(node.data, "url") && (data.push(dataSource), dataSource = {name:null, source:dataSource.name, transform:[]});
        node instanceof ParseNode && (node.parent instanceof SourceNode && !dataSource.source ? (dataSource.format = {...dataSource.format, parse:node.assembleFormatParse()}, dataSource.transform.push(...node.assembleTransforms(!0))) : dataSource.transform.push(...node.assembleTransforms()));
        if (node instanceof FacetNode) {
          dataSource.name || (dataSource.name = `data_${datasetIndex++}`), !dataSource.source || dataSource.transform.length > 0 ? (data.push(dataSource), node.data = dataSource.name) : node.data = dataSource.source, data.push(...node.assemble());
        } else {
          switch((node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || 
          node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode || node instanceof ExtentTransformNode) && dataSource.transform.push(node.assemble()), (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) && dataSource.transform.push(...node.assemble()), node instanceof 
          OutputNode && (dataSource.source && dataSource.transform.length === 0 ? node.setSource(dataSource.source) : node.parent instanceof OutputNode ? node.setSource(dataSource.name) : (dataSource.name || (dataSource.name = `data_${datasetIndex++}`), node.setSource(dataSource.name), node.numChildren() === 1 && (data.push(dataSource), dataSource = {name:null, source:dataSource.name, transform:[]}))), node.numChildren()) {
            case 0:
              node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0) && data.push(dataSource);
              break;
            case 1:
              walkTree(node.children[0], dataSource);
              break;
            default:
              dataSource.name || (dataSource.name = `data_${datasetIndex++}`);
              let source = dataSource.name;
              !dataSource.source || dataSource.transform.length > 0 ? data.push(dataSource) : source = dataSource.source;
              for (const child of node.children) {
                walkTree(child, {name:null, source, transform:[]});
              }
          }
        }
      }
      let datasetIndex = 0;
      return walkTree;
    }
    function assembleFacetData(root) {
      const data = [], walkTree = makeWalkTree(data);
      for (const child of root.children) {
        walkTree(child, {source:root.name, name:null, transform:[]});
      }
      return data;
    }
    function assembleRootData(dataComponent, datasets) {
      const data = [];
      var walkTree = makeWalkTree(data);
      let sourceIndex = 0;
      for (const root of dataComponent.sources) {
        root.hasName() || (root.dataName = `source_${sourceIndex++}`);
        const newData = root.assemble();
        walkTree(root, newData);
      }
      for (const d of data) {
        d.transform.length === 0 && delete d.transform;
      }
      walkTree = 0;
      for (const [i, d] of data.entries()) {
        (d.transform ?? []).length !== 0 || d.source || data.splice(walkTree++, 0, data.splice(i, 1)[0]);
      }
      for (const d of data) {
        for (const t of d.transform ?? []) {
          t.type === "lookup" && (t.from = dataComponent.outputNodes[t.from].getSource());
        }
      }
      for (const d of data) {
        d.name in datasets && (d.values = datasets[d.name]);
      }
      return data;
    }
    function makeHeaderComponent(model, channel, labels) {
      channel = channel === "row" ? "height" : "width";
      return {labels, sizeSignal:model.child.component.layoutSize.get(channel) ? model.child.getSizeSignalRef(channel) : void 0, axes:[]};
    }
    function mergeChildAxis(model, channel) {
      var {child} = model;
      if (child.component.axes[channel]) {
        const {layoutHeaders, resolve} = model.component;
        resolve.axis[channel] = parseGuideResolve(resolve, channel);
        if (resolve.axis[channel] === "shared") {
          const headerChannel = channel === "x" ? "column" : "row", layoutHeader = layoutHeaders[headerChannel];
          for (const axisComponent of child.component.axes[channel]) {
            channel = axisComponent.get("orient");
            channel = channel === "top" || channel === "left" || isSignalRef(channel) ? "header" : "footer";
            let $jscomp$logical$assign$tmp730812712$8, $jscomp$logical$assign$tmpindex730812712$8;
            ($jscomp$logical$assign$tmp730812712$8 = layoutHeader)[$jscomp$logical$assign$tmpindex730812712$8 = channel] ?? ($jscomp$logical$assign$tmp730812712$8[$jscomp$logical$assign$tmpindex730812712$8] = [makeHeaderComponent(model, headerChannel, !1)]);
            (child = assembleAxis(axisComponent, "main", model.config, {header:!0})) && layoutHeader[channel][0].axes.push(child);
            axisComponent.mainExtracted = !0;
          }
        }
      }
    }
    function parseChildrenLayoutSize(model) {
      for (const child of model.children) {
        child.parseLayoutSize();
      }
    }
    function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType), channel = getPositionScaleChannel(sizeType), resolve = model.component.resolve, layoutSizeCmpt = model.component.layoutSize;
      let mergedSize;
      for (const child of model.children) {
        const childSize = child.component.layoutSize.getWithExplicit(sizeType), scaleResolve = resolve.scale[channel] ?? defaultScaleResolve(channel, model);
        if (scaleResolve === "independent" && childSize.value === "step") {
          mergedSize = void 0;
          break;
        }
        if (mergedSize) {
          if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
            mergedSize = void 0;
            break;
          }
          mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
        } else {
          mergedSize = childSize;
        }
      }
      if (mergedSize) {
        for (const child of model.children) {
          model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType)), child.component.layoutSize.set(sizeType, "merged", !1);
        }
        layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
      } else {
        layoutSizeCmpt.setWithExplicit(layoutSizeType, {explicit:!1, value:void 0});
      }
    }
    function defaultUnitSize(model, sizeType) {
      const config = model.config;
      var scaleComponent = model.getScaleComponent(sizeType === "width" ? "x" : "y");
      if (scaleComponent) {
        return model = scaleComponent.get("type"), scaleComponent = scaleComponent.get("range"), hasDiscreteDomain(model) ? (sizeType = getViewConfigDiscreteSize(config.view, sizeType), isVgRangeStep(scaleComponent) || isStep(sizeType) ? "step" : sizeType) : getViewConfigContinuousSize(config.view, sizeType);
      }
      if (model.hasProjection || model.mark === "arc") {
        return getViewConfigContinuousSize(config.view, sizeType);
      }
      sizeType = getViewConfigDiscreteSize(config.view, sizeType);
      return isStep(sizeType) ? sizeType.step : sizeType;
    }
    function facetSortFieldName(fieldDef, sort, opt) {
      return vgField(sort, {suffix:`by_${vgField(fieldDef)}`, ...opt});
    }
    function findSource(data, sources) {
      for (const other of sources) {
        sources = other.data;
        if (data.name && other.hasName() && data.name !== other.dataName) {
          continue;
        }
        const formatMesh = data.format?.mesh;
        var otherFeature = sources.format?.feature;
        if (formatMesh && otherFeature) {
          continue;
        }
        const formatFeature = data.format?.feature;
        if (!formatFeature && !otherFeature || formatFeature === otherFeature) {
          if (otherFeature = sources.format?.mesh, !formatMesh && !otherFeature || formatMesh === otherFeature) {
            if (isInlineData(data) && isInlineData(sources)) {
              if (deepEqual(data.values, sources.values)) {
                return other;
              }
            } else if (hasProperty(data, "url") && hasProperty(sources, "url")) {
              if (data.url === sources.url) {
                return other;
              }
            } else if (isNamedData(data) && data.name === other.dataName) {
              return other;
            }
          }
        }
      }
      return null;
    }
    function parseRoot(model, sources) {
      if (model.data || !model.parent) {
        if (model.data === null) {
          return model = new SourceNode({values:[]}), sources.push(model), model;
        }
        const existingSource = findSource(model.data, sources);
        if (existingSource) {
          return isGenerator(model.data) || (existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format)), !existingSource.hasName() && model.data.name && (existingSource.dataName = model.data.name), existingSource;
        }
        model = new SourceNode(model.data);
        sources.push(model);
        return model;
      }
      return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
    }
    function parseData(model) {
      var head = parseRoot(model, model.component.data.sources);
      const {outputNodes, outputNodeRefCounts} = model.component.data;
      var data = model.data;
      const ancestorParse = data && (isGenerator(data) || hasProperty(data, "url") || isInlineData(data)) || !model.parent ? new AncestorParse() : model.parent.component.data.ancestorParse.clone();
      isGenerator(data) ? (hasProperty(data, "sequence") ? head = new SequenceNode(head, data.sequence) : hasProperty(data, "graticule") && (head = new GraticuleNode(head, data.graticule)), ancestorParse.parseNothing = !0) : data?.format?.parse === null && (ancestorParse.parseNothing = !0);
      head = ParseNode.makeExplicit(head, model, ancestorParse) ?? head;
      head = new IdentifierNode(head);
      data = model.parent && isLayerModel(model.parent);
      (isUnitModel(model) || isFacetModel(model)) && data && (head = BinNode.makeFromEncoding(head, model) ?? head);
      if (model.transforms.length > 0) {
        let lookupCounter = 0;
        for (var t of model.transforms) {
          let derivedType = void 0;
          var transformNode = void 0;
          if (hasProperty(t, "calculate")) {
            transformNode = head = new CalculateNode(head, t), derivedType = "derived";
          } else if (hasProperty(t, "filter")) {
            transformNode = getImplicitFromFilterTransform(t), transformNode = head = ParseNode.makeWithAncestors(head, {}, transformNode, ancestorParse) ?? head, head = new FilterNode(head, model, t.filter);
          } else if (hasProperty(t, "bin")) {
            transformNode = head = BinNode.makeFromTransform(head, t, model), derivedType = "number";
          } else if (hasProperty(t, "timeUnit")) {
            derivedType = "date", ancestorParse.getWithExplicit(t.field).value === void 0 && (head = new ParseNode(head, {[t.field]:derivedType}), ancestorParse.set(t.field, derivedType, !1)), transformNode = head = TimeUnitNode.makeFromTransform(head, t);
          } else if (hasProperty(t, "aggregate")) {
            transformNode = head = AggregateNode.makeFromTransform(head, t), derivedType = "number", requiresSelectionId(model) && (head = new IdentifierNode(head));
          } else if (hasProperty(t, "lookup")) {
            transformNode = head = LookupNode.make(head, model, t, lookupCounter++), derivedType = "derived";
          } else if (hasProperty(t, "window")) {
            transformNode = head = new WindowTransformNode(head, t), derivedType = "number";
          } else if (hasProperty(t, "joinaggregate")) {
            transformNode = head = new JoinAggregateTransformNode(head, t), derivedType = "number";
          } else if (hasProperty(t, "stack")) {
            transformNode = head = StackNode.makeFromTransform(head, t), derivedType = "derived";
          } else if (hasProperty(t, "fold")) {
            transformNode = head = new FoldTransformNode(head, t), derivedType = "derived";
          } else if (!hasProperty(t, "extent") || hasProperty(t, "density") || hasProperty(t, "regression")) {
            if (hasProperty(t, "flatten")) {
              transformNode = head = new FlattenTransformNode(head, t), derivedType = "derived";
            } else if (hasProperty(t, "pivot")) {
              transformNode = head = new PivotTransformNode(head, t), derivedType = "derived";
            } else if (hasProperty(t, "sample")) {
              head = new SampleTransformNode(head, t);
            } else if (hasProperty(t, "impute")) {
              transformNode = head = ImputeNode.makeFromTransform(head, t), derivedType = "derived";
            } else if (hasProperty(t, "density")) {
              transformNode = head = new DensityTransformNode(head, t), derivedType = "derived";
            } else if (hasProperty(t, "quantile")) {
              transformNode = head = new QuantileTransformNode(head, t), derivedType = "derived";
            } else if (hasProperty(t, "regression")) {
              transformNode = head = new RegressionTransformNode(head, t), derivedType = "derived";
            } else if (hasProperty(t, "loess")) {
              transformNode = head = new LoessTransformNode(head, t), derivedType = "derived";
            } else {
              warn(`Ignoring an invalid transform: ${stringify(t)}.`);
              continue;
            }
          } else {
            transformNode = head = new ExtentTransformNode(head, t), derivedType = "derived";
          }
          if (transformNode && derivedType !== void 0) {
            for (var field of transformNode.producedFields() ?? []) {
              ancestorParse.set(field, derivedType, !1);
            }
          }
        }
      }
      t = {};
      if (isUnitModel(model) && model.component.selection) {
        for (var name of keys(model.component.selection)) {
          field = model.component.selection[name];
          for (var proj of field.project.items) {
            !proj.channel && accessPathDepth(proj.field) > 1 && (t[proj.field] = "flatten");
          }
        }
      }
      name = getImplicitFromEncoding(model);
      head = ParseNode.makeWithAncestors(head, {}, {...t, ...name}, ancestorParse) ?? head;
      isUnitModel(model) && (head = GeoJSONNode.parseAll(head, model), head = GeoPointNode.parseAll(head, model));
      if (isUnitModel(model) || isFacetModel(model)) {
        data || (head = BinNode.makeFromEncoding(head, model) ?? head), head = TimeUnitNode.makeFromEncoding(head, model) ?? head, head = CalculateNode.parseAllForSortIndex(head, model);
      }
      data = head = makeOutputNode(DataSourceType.Raw, model, head);
      if (isUnitModel(model)) {
        if (name = AggregateNode.makeFromEncoding(head, model)) {
          head = name, requiresSelectionId(model) && (head = new IdentifierNode(head));
        }
        head = ImputeNode.makeFromEncoding(head, model) ?? head;
        head = StackNode.makeFromEncoding(head, model) ?? head;
      }
      let preFilterInvalid;
      if (isUnitModel(model)) {
        const {markDef, mark, config} = model;
        var dataSourcesForHandlingInvalidValues = getMarkPropOrConfig("invalid", markDef, config);
        const {marks, scales} = dataSourcesForHandlingInvalidValues = getDataSourcesForHandlingInvalidValues({invalid:dataSourcesForHandlingInvalidValues, isPath:isPathMark(mark)});
        marks !== scales && scales === "include-invalid-values" && (preFilterInvalid = head = makeOutputNode(DataSourceType.PreFilterInvalid, model, head));
        marks === "exclude-invalid-values" && (head = FilterInvalidNode.make(head, model, dataSourcesForHandlingInvalidValues) ?? head);
      }
      name = head = makeOutputNode(DataSourceType.Main, model, head);
      let postFilterInvalid;
      if (isUnitModel(model) && dataSourcesForHandlingInvalidValues) {
        const {marks, scales} = dataSourcesForHandlingInvalidValues;
        marks === "include-invalid-values" && scales === "exclude-invalid-values" && (head = FilterInvalidNode.make(head, model, dataSourcesForHandlingInvalidValues) ?? head, postFilterInvalid = head = makeOutputNode(DataSourceType.PostFilterInvalid, model, head));
      }
      if (isUnitModel(model)) {
        for (const [selection, selCmpt] of entries$1(model.component.selection ?? {})) {
          dataSourcesForHandlingInvalidValues = model.getName(`lookup_${selection}`), model.component.data.outputNodes[dataSourcesForHandlingInvalidValues] = selCmpt.materialized = new OutputNode(new FilterNode(name, model, {param:selection}), dataSourcesForHandlingInvalidValues, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
        }
      }
      proj = null;
      if (isFacetModel(model)) {
        dataSourcesForHandlingInvalidValues = model.getName("facet");
        {
          proj = head;
          const {row, column} = model.facet;
          if (row && column) {
            t = null;
            for (JSCompiler_inline_result of [row, column]) {
              if (isSortField(JSCompiler_inline_result.sort)) {
                const {field, op = "min"} = JSCompiler_inline_result.sort;
                proj = t = new JoinAggregateTransformNode(proj, {joinaggregate:[{op, field, as:facetSortFieldName(JSCompiler_inline_result, JSCompiler_inline_result.sort, {forAs:!0})}], groupby:[vgField(JSCompiler_inline_result)]});
              }
            }
            var JSCompiler_inline_result = t;
          } else {
            JSCompiler_inline_result = null;
          }
        }
        proj = new FacetNode(JSCompiler_inline_result ?? head, model, dataSourcesForHandlingInvalidValues, name.getSource());
        outputNodes[dataSourcesForHandlingInvalidValues] = proj;
      }
      return {...model.component.data, outputNodes, outputNodeRefCounts, raw:data, main:name, facetRoot:proj, ancestorParse, preFilterInvalid, postFilterInvalid};
    }
    function makeOutputNode(dataSourceType, model, head) {
      const {outputNodes, outputNodeRefCounts} = model.component.data;
      model = model.getDataName(dataSourceType);
      dataSourceType = new OutputNode(head, model, dataSourceType, outputNodeRefCounts);
      return outputNodes[model] = dataSourceType;
    }
    function labels(model, channel, specifiedLabelsSpec) {
      const {encoding, config} = model, fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) ?? getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
      model = model.axis(channel) || {};
      const {format, formatType} = model;
      if (isCustomFormatType(formatType)) {
        return {text:formatCustomType({fieldOrDatumDef, field:"datum.value", format, formatType, config}), ...specifiedLabelsSpec};
      }
      if (format === void 0 && formatType === void 0 && config.customFormatTypes) {
        if (fieldOrDatumDef?.type === "quantitative") {
          if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormatType) {
            return {text:formatCustomType({fieldOrDatumDef, field:"datum.value", format:config.normalizedNumberFormat, formatType:config.normalizedNumberFormatType, config}), ...specifiedLabelsSpec};
          }
          if (config.numberFormatType) {
            return {text:formatCustomType({fieldOrDatumDef, field:"datum.value", format:config.numberFormat, formatType:config.numberFormatType, config}), ...specifiedLabelsSpec};
          }
        }
        if (fieldOrDatumDef?.type === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && !fieldOrDatumDef.timeUnit) {
          return {text:formatCustomType({fieldOrDatumDef, field:"datum.value", format:config.timeFormat, formatType:config.timeFormatType, config}), ...specifiedLabelsSpec};
        }
      }
      return specifiedLabelsSpec;
    }
    function parseUnitAxes(model) {
      return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
        model.component.scales[channel] && (axis[channel] = [parseAxis(channel, model)]);
        return axis;
      }, {});
    }
    function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
      if (mergedAxisCmpts) {
        if (mergedAxisCmpts.length !== childAxisCmpts.length) {
          return;
        }
        const length = mergedAxisCmpts.length;
        for (let i = 0; i < length; i++) {
          const merged = mergedAxisCmpts[i], child = childAxisCmpts[i];
          if (!!merged !== !!child) {
            return;
          }
          if (merged && child) {
            const mergedOrient = merged.getWithExplicit("orient"), childOrient = child.getWithExplicit("orient");
            if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
              return;
            }
            mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
          }
        }
      } else {
        return childAxisCmpts.map(axisComponent => axisComponent.clone());
      }
      return mergedAxisCmpts;
    }
    function mergeAxisComponent(merged, child) {
      for (const prop of AXIS_COMPONENT_PROPERTIES) {
        const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, "axis", (v1, v2) => {
          switch(prop) {
            case "title":
              return mergeTitleComponent(v1, v2);
            case "gridScale":
              return {explicit:v1.explicit, value:getFirstDefined(v1.value, v2.value)};
          }
          return defaultTieBreaker(v1, v2, prop, "axis");
        });
        merged.setWithExplicit(prop, mergedValueWithExplicit);
      }
      return merged;
    }
    function isExplicit(value, property, axis, model, channel) {
      if (property === "disable") {
        return axis !== void 0;
      }
      axis = axis || {};
      switch(property) {
        case "titleAngle":
        case "labelAngle":
          return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
        case "values":
          return !!axis.values;
        case "encode":
          return !!axis.encoding || !!axis.labelAngle;
        case "title":
          if (value === getFieldDefTitle(model, channel)) {
            return !0;
          }
      }
      return value === axis[property];
    }
    function parseAxis(channel, model) {
      let axis = model.axis(channel);
      const axisComponent = new AxisComponent();
      var fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
      const {mark, config} = model;
      var orient = axis?.orient || config[channel === "x" ? "axisX" : "axisY"]?.orient || config.axis?.orient || (channel === "x" ? "bottom" : "left"), scaleType = model.getScaleComponent(channel).get("type"), axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config), disable = axis !== void 0 ? !axis : getAxisConfig("disable", config.style, axis?.style, axisConfigs).configValue;
      axisComponent.set("disable", disable, axis !== void 0);
      if (disable) {
        return axisComponent;
      }
      axis = axis || {};
      disable = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);
      var formatType = guideFormatType(axis.formatType, fieldOrDatumDef, scaleType);
      const format = guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, axis.format, axis.formatType, config, !0);
      fieldOrDatumDef = {fieldOrDatumDef, axis, channel, model, scaleType, orient, labelAngle:disable, format, formatType, mark, config};
      for (const property of AXIS_COMPONENT_PROPERTIES) {
        if (orient = property in axisRules ? axisRules[property](fieldOrDatumDef) : vega.hasOwnProperty(AXIS_PROPERTIES_INDEX, property) ? axis[property] : void 0, scaleType = orient !== void 0, disable = isExplicit(orient, property, axis, model, channel), scaleType && disable) {
          axisComponent.set(property, orient, disable);
        } else {
          const {configValue, configFrom} = vega.hasOwnProperty(AXIS_PROPERTIES_INDEX, property) && property !== "values" ? getAxisConfig(property, config.style, axis.style, axisConfigs) : {};
          formatType = configValue !== void 0;
          scaleType && !formatType ? axisComponent.set(property, orient, disable) : (configFrom !== "vgAxisConfig" || propsToAlwaysIncludeConfig.has(property) && formatType || configValue?.condition || isSignalRef(configValue)) && axisComponent.set(property, configValue, !1);
        }
      }
      const axisEncoding = axis.encoding ?? {};
      axisConfigs = AXIS_PARTS.reduce((e, part) => {
        if (!axisComponent.hasAxisPart(part)) {
          return e;
        }
        var axisEncodingPart = guideEncodeEntry(axisEncoding[part] ?? {}, model);
        axisEncodingPart = part === "labels" ? labels(model, channel, axisEncodingPart) : axisEncodingPart;
        axisEncodingPart === void 0 || isEmpty(axisEncodingPart) || (e[part] = {update:axisEncodingPart});
        return e;
      }, {});
      isEmpty(axisConfigs) || axisComponent.set("encode", axisConfigs, !!axis.encoding || axis.labelAngle !== void 0);
      return axisComponent;
    }
    function initLayoutSize(_ref) {
      let {encoding, size} = _ref;
      for (const channel of POSITION_SCALE_CHANNELS) {
        _ref = getSizeChannel(channel), isStep(size[_ref]) && isContinuousFieldOrDatumDef(encoding[channel]) && (delete size[_ref], warn(stepDropped(_ref)));
      }
      return size;
    }
    function encodeEntry(model, fixedShape) {
      var JSCompiler_temp_const = {...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", size:"include", orient:"ignore", theta:"ignore"})}, JSCompiler_temp_const$jscomp$0 = {...pointPosition("x", model, {defaultPos:"mid"})}, JSCompiler_temp_const$jscomp$1 = {...pointPosition("y", model, {defaultPos:"mid"})}, JSCompiler_temp_const$jscomp$2 = {...nonPosition("size", model)}, JSCompiler_temp_const$jscomp$3 = {...nonPosition("angle", model)};
      model = fixedShape ? {shape:{value:fixedShape}} : nonPosition("shape", model);
      return {...JSCompiler_temp_const, ...JSCompiler_temp_const$jscomp$0, ...JSCompiler_temp_const$jscomp$1, ...JSCompiler_temp_const$jscomp$2, ...JSCompiler_temp_const$jscomp$3, ...model};
    }
    function parseMarkGroups(model) {
      if (contains([LINE, AREA, TRAIL], model.mark)) {
        var details = pathGroupingFields(model.mark, model.encoding);
        if (details.length > 0) {
          return getPathGroups(model, details);
        }
      } else if (model.mark === BAR && (details = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config)), model.stack && !model.fieldDef("size") && details)) {
        return getGroupsForStackedBarWithCornerRadius(model);
      }
      return getMarkGroup(model);
    }
    function getPathGroups(model, details) {
      return [{name:model.getName("pathgroup"), type:"group", from:{facet:{name:"faceted_path_" + model.requestDataName(DataSourceType.Main), data:model.requestDataName(DataSourceType.Main), groupby:details}}, encode:{update:{width:{field:{group:"width"}}, height:{field:{group:"height"}}}}, marks:getMarkGroup(model, {fromPrefix:"faceted_path_"})}];
    }
    function getGroupsForStackedBarWithCornerRadius(model) {
      const [mark] = getMarkGroup(model, {fromPrefix:"stack_group_"}), fieldScale = model.scaleName(model.stack.fieldChannel), stackField = function() {
        return model.vgField(model.stack.fieldChannel, arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {});
      };
      var stackFieldGroup = (func, expr) => {
        expr = [stackField({prefix:"min", suffix:"start", expr}), stackField({prefix:"max", suffix:"start", expr}), stackField({prefix:"min", suffix:"end", expr}), stackField({prefix:"max", suffix:"end", expr})];
        return `${func}(${expr.map(field => `scale('${fieldScale}',${field})`).join(",")})`;
      };
      let innerGroupUpdate;
      model.stack.fieldChannel === "x" ? (stackFieldGroup = {...pick(mark.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS]), x:{signal:stackFieldGroup("min", "datum")}, x2:{signal:stackFieldGroup("max", "datum")}, clip:{value:!0}}, innerGroupUpdate = {x:{field:{group:"x"}, mult:-1}, height:{field:{group:"height"}}}, mark.encode.update = {...omit(mark.encode.update, ["y", "yc", "y2"]), height:{field:{group:"height"}}}) : (stackFieldGroup = {...pick(mark.encode.update, ["x", 
      "xc", "x2", "width"]), y:{signal:stackFieldGroup("min", "datum")}, y2:{signal:stackFieldGroup("max", "datum")}, clip:{value:!0}}, innerGroupUpdate = {y:{field:{group:"y"}, mult:-1}, width:{field:{group:"width"}}}, mark.encode.update = {...omit(mark.encode.update, ["x", "xc", "x2"]), width:{field:{group:"width"}}});
      for (var key of VG_CORNERRADIUS_CHANNELS) {
        var configValue = getMarkConfig(key, model.markDef, model.config);
        mark.encode.update[key] ? (stackFieldGroup[key] = mark.encode.update[key], delete mark.encode.update[key]) : configValue && (stackFieldGroup[key] = signalOrValueRef(configValue));
        configValue && (mark.encode.update[key] = {value:0});
      }
      key = [];
      if (model.stack.groupbyChannels?.length > 0) {
        for (const groupbyChannel of model.stack.groupbyChannels) {
          configValue = model.fieldDef(groupbyChannel);
          const field = vgField(configValue);
          field && key.push(field);
          (configValue?.bin || configValue?.timeUnit) && key.push(vgField(configValue, {binSuffix:"end"}));
        }
      }
      stackFieldGroup = "stroke strokeWidth strokeJoin strokeCap strokeDash strokeDashOffset strokeMiterLimit strokeOpacity".split(" ").reduce((encode, prop) => {
        if (mark.encode.update[prop]) {
          return {...encode, [prop]:mark.encode.update[prop]};
        }
        const configValue = getMarkConfig(prop, model.markDef, model.config);
        return configValue !== void 0 ? {...encode, [prop]:signalOrValueRef(configValue)} : encode;
      }, stackFieldGroup);
      stackFieldGroup.stroke && (stackFieldGroup.strokeForeground = {value:!0}, stackFieldGroup.strokeOffset = {value:0});
      return [{type:"group", from:{facet:{data:model.requestDataName(DataSourceType.Main), name:"stack_group_" + model.requestDataName(DataSourceType.Main), groupby:key, aggregate:{fields:[stackField({suffix:"start"}), stackField({suffix:"start"}), stackField({suffix:"end"}), stackField({suffix:"end"})], ops:["min", "max", "min", "max"]}}}, encode:{update:stackFieldGroup}, marks:[{type:"group", encode:{update:innerGroupUpdate}, marks:[mark]}]}];
    }
    function getMarkGroup(model) {
      let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {fromPrefix:""};
      const {mark, markDef, encoding, config} = model;
      var JSCompiler_temp_const = markDef.clip;
      var JSCompiler_inline_result = model.getScaleComponent("x");
      var yScale = model.getScaleComponent("y");
      JSCompiler_inline_result = JSCompiler_inline_result?.get("selectionExtent") || yScale?.get("selectionExtent") ? !0 : void 0;
      yScale = model.component.projection;
      JSCompiler_temp_const = getFirstDefined(JSCompiler_temp_const, JSCompiler_inline_result, yScale && !yScale.isFit ? !0 : void 0);
      JSCompiler_inline_result = [].concat(markDef.type, markDef.style ?? []);
      yScale = encoding.key;
      a: {
        const {encoding, stack, mark, markDef, config} = model;
        var JSCompiler_inline_result$jscomp$0 = encoding.order;
        if (!(!vega.isArray(JSCompiler_inline_result$jscomp$0) && isValueDef(JSCompiler_inline_result$jscomp$0) && isNullOrFalse(JSCompiler_inline_result$jscomp$0.value) || !JSCompiler_inline_result$jscomp$0 && isNullOrFalse(getMarkPropOrConfig("order", markDef, config)))) {
          if ((vega.isArray(JSCompiler_inline_result$jscomp$0) || isFieldDef(JSCompiler_inline_result$jscomp$0)) && !stack) {
            JSCompiler_inline_result$jscomp$0 = sortParams(JSCompiler_inline_result$jscomp$0, {expr:"datum"});
            break a;
          }
          if (isPathMark(mark) && (JSCompiler_inline_result$jscomp$0 = markDef.orient === "horizontal" ? "y" : "x", isFieldDef(encoding[JSCompiler_inline_result$jscomp$0]))) {
            JSCompiler_inline_result$jscomp$0 = {field:JSCompiler_inline_result$jscomp$0};
            break a;
          }
        }
        JSCompiler_inline_result$jscomp$0 = void 0;
      }
      var JSCompiler_inline_result$jscomp$1;
      if (model.component.selection) {
        for (var parentCount = JSCompiler_inline_result$jscomp$1 = keys(model.component.selection).length, parent = model.parent; parent && parentCount === 0;) {
          parentCount = keys(parent.component.selection).length, parent = parent.parent;
        }
        JSCompiler_inline_result$jscomp$1 = parentCount ? {interactive:JSCompiler_inline_result$jscomp$1 > 0 || model.mark === "geoshape" || !!model.encoding.tooltip || !!model.markDef.tooltip} : null;
      } else {
        JSCompiler_inline_result$jscomp$1 = null;
      }
      parentCount = getMarkPropOrConfig("aria", markDef, config);
      parent = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;
      return [{name:model.getName("marks"), type:markCompiler[mark].vgMark, ...(JSCompiler_temp_const ? {clip:JSCompiler_temp_const} : {}), ...(JSCompiler_inline_result ? {style:JSCompiler_inline_result} : {}), ...(yScale ? {key:yScale.field} : {}), ...(JSCompiler_inline_result$jscomp$0 ? {sort:JSCompiler_inline_result$jscomp$0} : {}), ...(JSCompiler_inline_result$jscomp$1 ? JSCompiler_inline_result$jscomp$1 : {}), ...(parentCount === !1 ? {aria:parentCount} : {}), from:{data:opt.fromPrefix + model.requestDataName(DataSourceType.Main)}, 
      encode:{update:markCompiler[mark].encodeEntry(model)}, ...(parent ? {transform:parent} : {})}];
    }
    function buildModel(spec, parent, parentGivenName, unitSize, config) {
      if (hasProperty(spec, "facet")) {
        return new FacetModel(spec, parent, parentGivenName, config);
      }
      if (hasProperty(spec, "layer")) {
        return new LayerModel(spec, parent, parentGivenName, unitSize, config);
      }
      if (isUnitSpec(spec)) {
        return new UnitModel(spec, parent, parentGivenName, unitSize, config);
      }
      if (hasProperty(spec, "vconcat") || hasProperty(spec, "hconcat") || hasProperty(spec, "concat")) {
        return new ConcatModel(spec, parent, parentGivenName, config);
      }
      throw Error(invalidSpec(spec));
    }
    function assembleTopLevelModel(model, topLevelProperties) {
      var datasets = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let usermeta = arguments.length > 3 ? arguments[3] : void 0;
      const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
      datasets = assembleRootData(model.component.data, datasets);
      datasets = model.assembleSelectionData(datasets);
      const projections = model.assembleProjections(), title = model.assembleTitle(), style = model.assembleGroupStyle(), encodeEntry = model.assembleGroupEncodeEntry(!0);
      let layoutSignals = model.assembleLayoutSignals();
      layoutSignals = layoutSignals.filter(signal => signal.name !== "width" && signal.name !== "height" || signal.value === void 0 ? !0 : (topLevelProperties[signal.name] = +signal.value, !1));
      const {params, ...otherTopLevelProps} = topLevelProperties;
      return {$schema:"https://vega.github.io/schema/vega/v5.json", ...(model.description ? {description:model.description} : {}), ...otherTopLevelProps, ...(title ? {title} : {}), ...(style ? {style} : {}), ...(encodeEntry ? {encode:{update:encodeEntry}} : {}), data:datasets, ...(projections.length > 0 ? {projections} : {}), ...model.assembleGroup([...layoutSignals, ...model.assembleSelectionTopLevelSignals([]), ...assembleParameterSignals(params)]), ...(vgConfig ? {config:vgConfig} : {}), ...(usermeta ? 
      {usermeta} : {})};
    }
    const duplicate = structuredClone;
    Set.prototype.toJSON = function() {
      return `Set(${[...this].map(x => stringify(x)).join(",")})`;
    };
    const keys = Object.keys, vals = Object.values, entries$1 = Object.entries;
    let idCounter = 42;
    const clonedProto = Object.getPrototypeOf(structuredClone({})), POLAR_POSITION_CHANNEL_INDEX = {theta:1, theta2:1, radius:1, radius2:1}, GEO_POSIITON_CHANNEL_INDEX = {longitude:1, longitude2:1, latitude:1, latitude2:1}, GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX), UNIT_CHANNEL_INDEX = {x:1, y:1, x2:1, y2:1, ...POLAR_POSITION_CHANNEL_INDEX, ...GEO_POSIITON_CHANNEL_INDEX, xOffset:1, yOffset:1, color:1, fill:1, stroke:1, time:1, opacity:1, fillOpacity:1, strokeOpacity:1, strokeWidth:1, 
    strokeDash:1, size:1, angle:1, shape:1, order:1, text:1, detail:1, key:1, tooltip:1, href:1, url:1, description:1}, FACET_CHANNEL_INDEX = {row:1, column:1, facet:1}, FACET_CHANNELS = keys(FACET_CHANNEL_INDEX), CHANNEL_INDEX = {...UNIT_CHANNEL_INDEX, ...FACET_CHANNEL_INDEX}, CHANNELS = keys(CHANNEL_INDEX), {order:_o, detail:_d, tooltip:_tt1, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX, {row:_r, column:_c, facet:_f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX} = SINGLE_DEF_CHANNEL_INDEX, SECONDARY_RANGE_CHANNEL = 
    "x2 y2 latitude2 longitude2 theta2 radius2".split(" "), UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX), {x:_x, y:_y, x2:_x2, y2:_y2, xOffset:_xo, yOffset:_yo, latitude:_latitude, longitude:_longitude, latitude2:_latitude2, longitude2:_longitude2, theta:_theta, theta2:_theta2, radius:_radius, radius2:_radius2, ...NONPOSITION_CHANNEL_INDEX} = UNIT_CHANNEL_INDEX, NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX), POSITION_SCALE_CHANNEL_INDEX = {x:1, y:1}, POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX), 
    POLAR_POSITION_SCALE_CHANNEL_INDEX = {theta:1, radius:1}, POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX), OFFSET_SCALE_CHANNEL_INDEX = {xOffset:1, yOffset:1}, TIME_SCALE_CHANNEL_INDEX = {time:1}, {text:_t, tooltip:_tt, href:_hr, url:_u, description:_al, detail:_dd, key:_k, order:_oo, ...NONPOSITION_SCALE_CHANNEL_INDEX} = NONPOSITION_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX), SCALE_CHANNEL_INDEX = {...POSITION_SCALE_CHANNEL_INDEX, 
    ...POLAR_POSITION_SCALE_CHANNEL_INDEX, ...OFFSET_SCALE_CHANNEL_INDEX, ...NONPOSITION_SCALE_CHANNEL_INDEX}, SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX), ALL_MARKS = {arc:"always", area:"always", bar:"always", circle:"always", geoshape:"always", image:"always", line:"always", rule:"always", point:"always", rect:"always", square:"always", trail:"always", text:"always", tick:"always"}, {geoshape:_g, ...ALL_MARKS_EXCEPT_GEOSHAPE} = ALL_MARKS, AGGREGATE_OP_INDEX = {argmax:1, argmin:1, average:1, count:1, 
    distinct:1, exponential:1, exponentialb:1, product:1, max:1, mean:1, median:1, min:1, missing:1, q1:1, q3:1, ci0:1, ci1:1, stderr:1, stdev:1, stdevp:1, sum:1, valid:1, values:1, variance:1, variancep:1}, MULTIDOMAIN_SORT_OP_INDEX = {count:1, min:1, max:1}, COUNTING_OPS = new Set(["count", "valid", "missing", "distinct"]), SUM_OPS = new Set(["count", "sum", "distinct", "valid", "missing"]), SHARED_DOMAIN_OPS = new Set("mean average median q1 q3 min max".split(" ")), VG_MARK_CONFIGS = keys({aria:1, 
    description:1, ariaRole:1, ariaRoleDescription:1, blend:1, opacity:1, fill:1, fillOpacity:1, stroke:1, strokeCap:1, strokeWidth:1, strokeOpacity:1, strokeDash:1, strokeDashOffset:1, strokeJoin:1, strokeOffset:1, strokeMiterLimit:1, startAngle:1, endAngle:1, padAngle:1, innerRadius:1, outerRadius:1, size:1, shape:1, interpolate:1, tension:1, orient:1, align:1, baseline:1, text:1, dir:1, dx:1, dy:1, ellipsis:1, limit:1, radius:1, theta:1, angle:1, font:1, fontSize:1, fontWeight:1, fontStyle:1, 
    lineBreak:1, lineHeight:1, cursor:1, href:1, tooltip:1, cornerRadius:1, cornerRadiusTopLeft:1, cornerRadiusTopRight:1, cornerRadiusBottomLeft:1, cornerRadiusBottomRight:1, aspect:1, width:1, height:1, url:1, smooth:1}), VG_MARK_INDEX = {arc:1, area:1, group:1, image:1, line:1, path:1, rect:1, rule:1, shape:1, symbol:1, text:1, trail:1}, VG_CORNERRADIUS_CHANNELS = ["cornerRadius", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight"], main = vega.logger(vega.Warn);
    let current = main;
    const MONTHS = "january february march april may june july august september october november december".split(" "), SHORT_MONTHS = MONTHS.map(m => m.substr(0, 3)), DAYS = "sunday monday tuesday wednesday thursday friday saturday".split(" "), SHORT_DAYS = DAYS.map(d => d.substr(0, 3)), LOCAL_SINGLE_TIMEUNIT_INDEX = {year:1, quarter:1, month:1, week:1, day:1, dayofyear:1, date:1, hours:1, minutes:1, seconds:1, milliseconds:1}, TIMEUNIT_PARTS = keys(LOCAL_SINGLE_TIMEUNIT_INDEX), VEGALITE_TIMEFORMAT = 
    {"year-month":"%b %Y ", "year-month-date":"%b %d, %Y "}, DATE_PARTS = {year:1, month:1, date:1, hours:1, minutes:1, seconds:1, milliseconds:1}, ScaleType = {LINEAR:"linear", LOG:"log", POW:"pow", SQRT:"sqrt", SYMLOG:"symlog", IDENTITY:"identity", SEQUENTIAL:"sequential", TIME:"time", UTC:"utc", QUANTILE:"quantile", QUANTIZE:"quantize", THRESHOLD:"threshold", BIN_ORDINAL:"bin-ordinal", ORDINAL:"ordinal", POINT:"point", BAND:"band"}, SCALE_CATEGORY_INDEX = {linear:"numeric", log:"numeric", pow:"numeric", 
    sqrt:"numeric", symlog:"numeric", identity:"numeric", sequential:"numeric", time:"time", utc:"time", ordinal:"ordinal", "bin-ordinal":"bin-ordinal", point:"ordinal-position", band:"ordinal-position", quantile:"discretizing", quantize:"discretizing", threshold:"discretizing"}, SCALE_PRECEDENCE_INDEX = {linear:0, log:1, pow:1, sqrt:1, symlog:1, identity:1, sequential:1, time:0, utc:0, point:10, band:11, ordinal:0, "bin-ordinal":0, quantile:0, quantize:0, threshold:0}, QUANTITATIVE_SCALES = new Set(["linear", 
    "log", "pow", "sqrt", "symlog"]), CONTINUOUS_TO_CONTINUOUS_SCALES = new Set([...QUANTITATIVE_SCALES, "time", "utc"]), CONTINUOUS_TO_DISCRETE_SCALES = new Set(["quantile", "quantize", "threshold"]), CONTINUOUS_DOMAIN_SCALES = new Set([...CONTINUOUS_TO_CONTINUOUS_SCALES, ...CONTINUOUS_TO_DISCRETE_SCALES, "sequential", "identity"]), DISCRETE_DOMAIN_SCALES = new Set(["ordinal", "bin-ordinal", "point", "band"]), {type, domain:domain$1, range, rangeMax, rangeMin, scheme, ...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX} = 
    {type:1, domain:1, domainMax:1, domainMin:1, domainMid:1, domainRaw:1, align:1, range:1, rangeMax:1, rangeMin:1, scheme:1, bins:1, reverse:1, round:1, clamp:1, nice:1, base:1, exponent:1, constant:1, interpolate:1, zero:1, padding:1, paddingInner:1, paddingOuter:1}, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX), Mark = {arc:"arc", area:"area", bar:"bar", image:"image", line:"line", point:"point", rect:"rect", rule:"rule", text:"text", tick:"tick", 
    trail:"trail", circle:"circle", square:"square", geoshape:"geoshape"}, ARC = Mark.arc, AREA = Mark.area, BAR = Mark.bar, IMAGE = Mark.image, LINE = Mark.line, POINT = Mark.point, RECT = Mark.rect, RULE = Mark.rule, TEXT = Mark.text, TICK = Mark.tick, TRAIL = Mark.trail, CIRCLE = Mark.circle, SQUARE = Mark.square, GEOSHAPE = Mark.geoshape, PRIMITIVE_MARKS = new Set(keys(Mark)), FILL_STROKE_CONFIG = "stroke strokeWidth strokeDash strokeDashOffset strokeOpacity strokeJoin strokeMiterLimit fill fillOpacity".split(" "), 
    VL_ONLY_MARK_CONFIG_PROPERTIES = keys({color:1, filled:1, invalid:1, order:1, radius2:1, theta2:1, timeUnitBandSize:1, timeUnitBandPosition:1}), VL_ONLY_RECT_CONFIG = ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"], VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {area:["line", "point"], bar:VL_ONLY_RECT_CONFIG, rect:VL_ONLY_RECT_CONFIG, line:["point"], tick:["bandSize", "thickness", ...VL_ONLY_RECT_CONFIG]}, MARK_CONFIGS = keys({mark:1, arc:1, area:1, bar:1, circle:1, image:1, 
    line:1, point:1, rect:1, rule:1, square:1, text:1, tick:1, trail:1, geoshape:1}), BAR_CORNER_RADIUS_INDEX = {horizontal:["cornerRadiusTopRight", "cornerRadiusBottomRight"], vertical:["cornerRadiusTopLeft", "cornerRadiusTopRight"]}, defaultRectConfig = {binSpacing:0, continuousBandSize:5, minBandSize:0.25, timeUnitBandPosition:0.5}, defaultBarConfig = {...defaultRectConfig, binSpacing:1}, defaultTickConfig = {...defaultRectConfig, thickness:1}, SORT_BY_CHANNEL_INDEX = {x:1, y:1, color:1, fill:1, 
    stroke:1, strokeWidth:1, size:1, shape:1, fillOpacity:1, strokeOpacity:1, opacity:1, text:1}, defaultTitleFormatter = (fieldDef, config) => {
      switch(config.fieldTitle) {
        case "plain":
          return fieldDef.field;
        case "functional":
          {
            const {aggregate, bin, timeUnit, field} = fieldDef;
            isArgmaxDef(aggregate) ? fieldDef = `${field} for argmax(${aggregate.argmax})` : isArgminDef(aggregate) ? fieldDef = `${field} for argmin(${aggregate.argmin})` : (fieldDef = timeUnit && !isBinnedTimeUnit(timeUnit) ? normalizeTimeUnit(timeUnit) : void 0, fieldDef = (fieldDef = aggregate || fieldDef?.unit || fieldDef?.maxbins && "timeunit" || isBinning(bin) && "bin") ? `${fieldDef.toUpperCase()}(${field})` : field);
          }
          return fieldDef;
        default:
          return verbalTitleFormatter(fieldDef, config);
      }
    };
    let titleFormatter = defaultTitleFormatter;
    const COMPATIBLE = {compatible:!0}, CONDITIONAL_AXIS_PROP_INDEX = {labelAlign:{part:"labels", vgProp:"align"}, labelBaseline:{part:"labels", vgProp:"baseline"}, labelColor:{part:"labels", vgProp:"fill"}, labelFont:{part:"labels", vgProp:"font"}, labelFontSize:{part:"labels", vgProp:"fontSize"}, labelFontStyle:{part:"labels", vgProp:"fontStyle"}, labelFontWeight:{part:"labels", vgProp:"fontWeight"}, labelOpacity:{part:"labels", vgProp:"opacity"}, labelOffset:null, labelPadding:null, gridColor:{part:"grid", 
    vgProp:"stroke"}, gridDash:{part:"grid", vgProp:"strokeDash"}, gridDashOffset:{part:"grid", vgProp:"strokeDashOffset"}, gridOpacity:{part:"grid", vgProp:"opacity"}, gridWidth:{part:"grid", vgProp:"strokeWidth"}, tickColor:{part:"ticks", vgProp:"stroke"}, tickDash:{part:"ticks", vgProp:"strokeDash"}, tickDashOffset:{part:"ticks", vgProp:"strokeDashOffset"}, tickOpacity:{part:"ticks", vgProp:"opacity"}, tickSize:null, tickWidth:{part:"ticks", vgProp:"strokeWidth"}}, AXIS_PARTS = ["domain", "grid", 
    "labels", "ticks", "title"], AXIS_PROPERTY_TYPE = {grid:"grid", gridCap:"grid", gridColor:"grid", gridDash:"grid", gridDashOffset:"grid", gridOpacity:"grid", gridScale:"grid", gridWidth:"grid", orient:"main", bandPosition:"both", aria:"main", description:"main", domain:"main", domainCap:"main", domainColor:"main", domainDash:"main", domainDashOffset:"main", domainOpacity:"main", domainWidth:"main", format:"main", formatType:"main", labelAlign:"main", labelAngle:"main", labelBaseline:"main", labelBound:"main", 
    labelColor:"main", labelFlush:"main", labelFlushOffset:"main", labelFont:"main", labelFontSize:"main", labelFontStyle:"main", labelFontWeight:"main", labelLimit:"main", labelLineHeight:"main", labelOffset:"main", labelOpacity:"main", labelOverlap:"main", labelPadding:"main", labels:"main", labelSeparation:"main", maxExtent:"main", minExtent:"main", offset:"both", position:"main", tickCap:"main", tickColor:"main", tickDash:"main", tickDashOffset:"main", tickMinStep:"both", tickOffset:"both", tickOpacity:"main", 
    tickRound:"both", ticks:"main", tickSize:"main", tickWidth:"both", title:"main", titleAlign:"main", titleAnchor:"main", titleAngle:"main", titleBaseline:"main", titleColor:"main", titleFont:"main", titleFontSize:"main", titleFontStyle:"main", titleFontWeight:"main", titleLimit:"main", titleLineHeight:"main", titleOpacity:"main", titlePadding:"main", titleX:"main", titleY:"main", encode:"both", scale:"both", tickBand:"both", tickCount:"both", tickExtra:"both", translate:"both", values:"both", 
    zindex:"both"}, COMMON_AXIS_PROPERTIES_INDEX = {orient:1, aria:1, bandPosition:1, description:1, domain:1, domainCap:1, domainColor:1, domainDash:1, domainDashOffset:1, domainOpacity:1, domainWidth:1, format:1, formatType:1, grid:1, gridCap:1, gridColor:1, gridDash:1, gridDashOffset:1, gridOpacity:1, gridWidth:1, labelAlign:1, labelAngle:1, labelBaseline:1, labelBound:1, labelColor:1, labelFlush:1, labelFlushOffset:1, labelFont:1, labelFontSize:1, labelFontStyle:1, labelFontWeight:1, labelLimit:1, 
    labelLineHeight:1, labelOffset:1, labelOpacity:1, labelOverlap:1, labelPadding:1, labels:1, labelSeparation:1, maxExtent:1, minExtent:1, offset:1, position:1, tickBand:1, tickCap:1, tickColor:1, tickCount:1, tickDash:1, tickDashOffset:1, tickExtra:1, tickMinStep:1, tickOffset:1, tickOpacity:1, tickRound:1, ticks:1, tickSize:1, tickWidth:1, title:1, titleAlign:1, titleAnchor:1, titleAngle:1, titleBaseline:1, titleColor:1, titleFont:1, titleFontSize:1, titleFontStyle:1, titleFontWeight:1, titleLimit:1, 
    titleLineHeight:1, titleOpacity:1, titlePadding:1, titleX:1, titleY:1, translate:1, values:1, zindex:1}, AXIS_PROPERTIES_INDEX = {...COMMON_AXIS_PROPERTIES_INDEX, style:1, labelExpr:1, encoding:1}, AXIS_CONFIGS = keys({axis:1, axisBand:1, axisBottom:1, axisDiscrete:1, axisLeft:1, axisPoint:1, axisQuantitative:1, axisRight:1, axisTemporal:1, axisTop:1, axisX:1, axisXBand:1, axisXDiscrete:1, axisXPoint:1, axisXQuantitative:1, axisXTemporal:1, axisY:1, axisYBand:1, axisYDiscrete:1, axisYPoint:1, 
    axisYQuantitative:1, axisYTemporal:1});
    class CompositeMarkNormalizer {
      constructor(name, run) {
        this.name = name;
        this.run = run;
      }
      hasMatchingType(spec) {
        return isUnitSpec(spec) ? (spec = spec.mark, (isMarkDef(spec) ? spec.type : spec) === this.name) : !1;
      }
    }
    const boxPlotNormalizer = new CompositeMarkNormalizer("boxplot", normalizeBoxPlot), errorBarNormalizer = new CompositeMarkNormalizer("errorbar", normalizeErrorBar), errorBandNormalizer = new CompositeMarkNormalizer("errorband", normalizeErrorBand), compositeMarkRegistry = {};
    add("boxplot", normalizeBoxPlot, ["box", "median", "outliers", "rule", "ticks"]);
    add("errorbar", normalizeErrorBar, ["ticks", "rule"]);
    add("errorband", normalizeErrorBand, ["band", "borders"]);
    const VL_ONLY_LEGEND_CONFIG = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"], HEADER_TITLE_PROPERTIES_MAP = {titleAlign:"align", titleAnchor:"anchor", titleAngle:"angle", titleBaseline:"baseline", titleColor:"color", titleFont:"font", titleFontSize:"fontSize", titleFontStyle:"fontStyle", titleFontWeight:"fontWeight", titleLimit:"limit", titleLineHeight:"lineHeight", titleOrient:"orient", titlePadding:"offset"}, 
    HEADER_LABEL_PROPERTIES_MAP = {labelAlign:"align", labelAnchor:"anchor", labelAngle:"angle", labelBaseline:"baseline", labelColor:"color", labelFont:"font", labelFontSize:"fontSize", labelFontStyle:"fontStyle", labelFontWeight:"fontWeight", labelLimit:"limit", labelLineHeight:"lineHeight", labelOrient:"orient", labelPadding:"offset"}, HEADER_TITLE_PROPERTIES = keys(HEADER_TITLE_PROPERTIES_MAP), HEADER_LABEL_PROPERTIES = keys(HEADER_LABEL_PROPERTIES_MAP), HEADER_CONFIGS = keys({header:1, headerRow:1, 
    headerColumn:1, headerFacet:1}), LEGEND_SCALE_CHANNELS = "size shape fill stroke strokeDash strokeWidth opacity".split(" "), COMPOSITION_LAYOUT_PROPERTIES = keys({align:1, bounds:1, center:1, columns:1, spacing:1}), defaultConfig = {background:"white", padding:5, timeFormat:"%b %d, %Y", countTitle:"Count of Records", view:{continuousWidth:200, continuousHeight:200, step:20}, mark:{color:"#4c78a8", invalid:"break-paths-show-path-domains", timeUnitBandSize:1}, arc:{}, area:{}, bar:defaultBarConfig, 
    circle:{}, geoshape:{}, image:{}, line:{}, point:{}, rect:defaultRectConfig, rule:{color:"black"}, square:{}, text:{color:"black"}, tick:defaultTickConfig, trail:{}, boxplot:{size:14, extent:1.5, box:{}, median:{color:"white"}, outliers:{}, rule:{}, ticks:null}, errorbar:{center:"mean", rule:!0, ticks:!1}, errorband:{band:{opacity:0.3}, borders:!1}, scale:{pointPadding:0.5, barBandPaddingInner:0.1, rectBandPaddingInner:0, tickBandPaddingInner:0.25, bandWithNestedOffsetPaddingInner:0.2, bandWithNestedOffsetPaddingOuter:0.2, 
    minBandSize:2, minFontSize:8, maxFontSize:40, minOpacity:0.3, maxOpacity:0.8, minSize:4, minStrokeWidth:1, maxStrokeWidth:4, quantileCount:4, quantizeCount:4, zero:!0, framesPerSecond:2, animationDuration:5}, projection:{}, legend:{gradientHorizontalMaxLength:200, gradientHorizontalMinLength:100, gradientVerticalMaxLength:200, gradientVerticalMinLength:64, unselectedOpacity:0.35}, header:{titlePadding:10, labelPadding:10}, headerColumn:{}, headerRow:{}, headerFacet:{}, selection:{point:{on:"click", 
    fields:["_vgsid_"], toggle:"event.shiftKey", resolve:"global", clear:"dblclick"}, interval:{on:"[pointerdown, window:pointerup] \x3e window:pointermove!", encodings:["x", "y"], translate:"[pointerdown, window:pointerup] \x3e window:pointermove!", zoom:"wheel!", mark:{fill:"#333", fillOpacity:0.125, stroke:"white"}, resolve:"global", clear:"dblclick"}}, style:{}, title:{}, facet:{spacing:20}, concat:{spacing:20}, normalizedNumberFormat:".0%"}, tab10 = "#4c78a8 #f58518 #e45756 #72b7b2 #54a24b #eeca3b #b279a2 #ff9da6 #9d755d #bab0ac".split(" "), 
    DEFAULT_FONT_SIZE = {text:11, guideLabel:10, guideTitle:11, groupTitle:13, groupSubtitle:12}, DEFAULT_COLOR = {blue:tab10[0], orange:tab10[1], red:tab10[2], teal:tab10[3], green:tab10[4], yellow:tab10[5], purple:tab10[6], pink:tab10[7], brown:tab10[8], gray0:"#000", gray1:"#111", gray2:"#222", gray3:"#333", gray4:"#444", gray5:"#555", gray6:"#666", gray7:"#777", gray8:"#888", gray9:"#999", gray10:"#aaa", gray11:"#bbb", gray12:"#ccc", gray13:"#ddd", gray14:"#eee", gray15:"#fff"}, configPropsWithExpr = 
    [...MARK_CONFIGS, ...AXIS_CONFIGS, ...HEADER_CONFIGS, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"], MARK_STYLES = new Set(["view", ...PRIMITIVE_MARKS]), VL_ONLY_CONFIG_PROPERTIES = "color fontSize background padding facet concat numberFormat numberFormatType normalizedNumberFormat normalizedNumberFormatType timeFormat countTitle header axisQuantitative axisTemporal axisDiscrete axisPoint axisXBand axisXPoint axisXDiscrete axisXQuantitative axisXTemporal axisYBand axisYPoint axisYDiscrete axisYQuantitative axisYTemporal scale selection overlay".split(" "), 
    VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {view:["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"], ...VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX};
    class SpecMapper {
      map(spec, params) {
        return hasProperty(spec, "facet") ? this.mapFacet(spec, params) : hasProperty(spec, "repeat") ? this.mapRepeat(spec, params) : hasProperty(spec, "hconcat") ? this.mapHConcat(spec, params) : hasProperty(spec, "vconcat") ? this.mapVConcat(spec, params) : hasProperty(spec, "concat") ? this.mapConcat(spec, params) : this.mapLayerOrUnit(spec, params);
      }
      mapLayerOrUnit(spec, params) {
        if (hasProperty(spec, "layer")) {
          return this.mapLayer(spec, params);
        }
        if (isUnitSpec(spec)) {
          return this.mapUnit(spec, params);
        }
        throw Error(invalidSpec(spec));
      }
      mapLayer(spec, params) {
        return {...spec, layer:spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params))};
      }
      mapHConcat(spec, params) {
        return {...spec, hconcat:spec.hconcat.map(subspec => this.map(subspec, params))};
      }
      mapVConcat(spec, params) {
        return {...spec, vconcat:spec.vconcat.map(subspec => this.map(subspec, params))};
      }
      mapConcat(spec, params) {
        const {concat, ...rest} = spec;
        return {...rest, concat:concat.map(subspec => this.map(subspec, params))};
      }
      mapFacet(spec, params) {
        return {...spec, spec:this.map(spec.spec, params)};
      }
      mapRepeat(spec, params) {
        return {...spec, spec:this.map(spec.spec, params)};
      }
    }
    const STACK_OFFSET_INDEX = {zero:1, center:1, normalize:1}, STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]), STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);
    class PathOverlayNormalizer {
      name="path-overlay";
      hasMatchingType(spec, config) {
        if (isUnitSpec(spec)) {
          const {mark, encoding} = spec;
          spec = isMarkDef(mark) ? mark : {type:mark};
          switch(spec.type) {
            case "line":
            case "rule":
            case "trail":
              return !!getPointOverlay(spec, config[spec.type], encoding);
            case "area":
              return !!getPointOverlay(spec, config[spec.type], encoding) || !!getLineOverlay(spec, config[spec.type]);
          }
        }
        return !1;
      }
      run(spec, normParams, normalize) {
        var {config} = normParams;
        const {params, projection, mark, name, encoding:e, ...outerSpec} = spec;
        spec = normalizeEncoding(e, config);
        const markDef = isMarkDef(mark) ? mark : {type:mark}, pointOverlay = getPointOverlay(markDef, config[markDef.type], spec), lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
        const {point:_point, line:_line, ...mark$jscomp$0} = {...(markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? {opacity:0.7} : {}), ...markDef};
        var JSCompiler_inline_result = keys(mark$jscomp$0).length > 1 ? mark$jscomp$0 : mark$jscomp$0.type;
        JSCompiler_inline_result = [{name, ...(params ? {params} : {}), mark:JSCompiler_inline_result, encoding:omit(spec, ["shape"])}];
        const stackProps = stack(initMarkdef(markDef, spec, config), spec);
        let overlayEncoding = spec;
        if (stackProps) {
          const {fieldChannel:stackFieldChannel, offset} = stackProps;
          overlayEncoding = {...spec, [stackFieldChannel]:{...spec[stackFieldChannel], ...(offset ? {stack:offset} : {})}};
        }
        overlayEncoding = omit(overlayEncoding, ["y2", "x2"]);
        lineOverlay && JSCompiler_inline_result.push({...(projection ? {projection} : {}), mark:{type:"line", ...pick(markDef, ["clip", "interpolate", "tension", "tooltip"]), ...lineOverlay}, encoding:overlayEncoding});
        pointOverlay && JSCompiler_inline_result.push({...(projection ? {projection} : {}), mark:{type:"point", opacity:1, filled:!0, ...pick(markDef, ["clip", "tooltip"]), ...pointOverlay}, encoding:overlayEncoding});
        for (const mark of ["line", "area", "rule", "trail"]) {
          config[mark] && (config = {...config, [mark]:omit(config[mark], ["point", "line"])});
        }
        return normalize({...outerSpec, layer:JSCompiler_inline_result}, {...normParams, config});
      }
    }
    class RuleForRangedLineNormalizer {
      name="RuleForRangedLine";
      hasMatchingType(spec) {
        if (isUnitSpec(spec)) {
          const {encoding, mark} = spec;
          if (mark === "line" || isMarkDef(mark) && mark.type === "line") {
            for (const channel of SECONDARY_RANGE_CHANNEL) {
              if (spec = getMainRangeChannel(channel), spec = encoding[spec], encoding[channel] && (isFieldDef(spec) && !isBinned(spec.bin) || isDatumDef(spec))) {
                return !0;
              }
            }
          }
        }
        return !1;
      }
      run(spec, params, normalize) {
        const {encoding, mark} = spec;
        var hasX2 = !!encoding.x2;
        warn(`Line mark is for continuous lines and thus cannot be used with ${hasX2 && encoding.y2 ? "x2 and y2" : hasX2 ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`);
        return normalize({...spec, mark:vega.isObject(mark) ? {...mark, type:"rule"} : "rule"}, params);
      }
    }
    class CoreNormalizer extends SpecMapper {
      nonFacetUnitNormalizers=[boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer()];
      map(spec, params) {
        if (isUnitSpec(spec)) {
          const hasRow = channelHasField(spec.encoding, "row"), hasColumn = channelHasField(spec.encoding, "column"), hasFacet = channelHasField(spec.encoding, "facet");
          if (hasRow || hasColumn || hasFacet) {
            return this.mapFacetedUnit(spec, params);
          }
        }
        return super.map(spec, params);
      }
      mapUnit(spec, params) {
        const {parentEncoding, parentProjection} = params;
        var encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);
        spec = {...spec, ...(spec.name ? {name:[params.repeaterPrefix, spec.name].filter(n => n).join("_")} : {}), ...(encoding ? {encoding} : {})};
        if (parentEncoding || parentProjection) {
          return this.mapUnitWithParentEncodingOrProjection(spec, params);
        }
        encoding = this.mapLayerOrUnit.bind(this);
        for (const unitNormalizer of this.nonFacetUnitNormalizers) {
          if (unitNormalizer.hasMatchingType(spec, params.config)) {
            return unitNormalizer.run(spec, params, encoding);
          }
        }
        return spec;
      }
      mapRepeat(spec, params) {
        return !vega.isArray(spec.repeat) && hasProperty(spec.repeat, "layer") ? this.mapLayerRepeat(spec, params) : this.mapNonLayerRepeat(spec, params);
      }
      mapLayerRepeat(spec, params) {
        const {repeat, spec:childSpec, ...rest} = spec, {row, column, layer} = repeat, {repeater = {}, repeaterPrefix = ""} = params;
        return row || column ? this.mapRepeat({...spec, repeat:{...(row ? {row} : {}), ...(column ? {column} : {})}, spec:{repeat:{layer}, spec:childSpec}}, params) : {...rest, layer:layer.map(layerValue => {
          var childRepeater = {...repeater, layer:layerValue};
          layerValue = `${(childSpec.name ? `${childSpec.name}_` : "") + repeaterPrefix}child__layer_${varName(layerValue)}`;
          childRepeater = this.mapLayerOrUnit(childSpec, {...params, repeater:childRepeater, repeaterPrefix:layerValue});
          childRepeater.name = layerValue;
          return childRepeater;
        })};
      }
      mapNonLayerRepeat(spec, params) {
        const {repeat, spec:childSpec, data, ...remainingProperties} = spec;
        !vega.isArray(repeat) && spec.columns && (spec = omit(spec, ["columns"]), warn(columnsNotSupportByRowCol("repeat")));
        const concat = [], {repeater = {}, repeaterPrefix = ""} = params, row = !vega.isArray(repeat) && repeat.row || [repeater ? repeater.row : null], column = !vega.isArray(repeat) && repeat.column || [repeater ? repeater.column : null];
        var repeatValues = vega.isArray(repeat) && repeat || [repeater ? repeater.repeat : null];
        for (const repeatValue of repeatValues) {
          for (const rowValue of row) {
            for (const columnValue of column) {
              var childRepeater = {repeat:repeatValue, row:rowValue, column:columnValue, layer:repeater.layer};
              repeatValues = (childSpec.name ? `${childSpec.name}_` : "") + repeaterPrefix + "child__" + (vega.isArray(repeat) ? `${varName(repeatValue)}` : (repeat.row ? `row_${varName(rowValue)}` : "") + (repeat.column ? `column_${varName(columnValue)}` : ""));
              childRepeater = this.map(childSpec, {...params, repeater:childRepeater, repeaterPrefix:repeatValues});
              childRepeater.name = repeatValues;
              concat.push(omit(childRepeater, ["data"]));
            }
          }
        }
        spec = vega.isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;
        return {data:childSpec.data ?? data, align:"all", ...remainingProperties, columns:spec, concat};
      }
      mapFacet(spec, params) {
        const {facet} = spec;
        isFacetMapping(facet) && spec.columns && (spec = omit(spec, ["columns"]), warn(columnsNotSupportByRowCol("facet")));
        return super.mapFacet(spec, params);
      }
      mapUnitWithParentEncodingOrProjection(spec, params) {
        const {encoding, projection} = spec, {parentEncoding, parentProjection, config} = params, mergedProjection = mergeProjection({parentProjection, projection});
        params = mergeEncoding({parentEncoding, encoding:replaceRepeaterInEncoding(encoding, params.repeater)});
        return this.mapUnit({...spec, ...(mergedProjection ? {projection:mergedProjection} : {}), ...(params ? {encoding:params} : {})}, {config});
      }
      mapFacetedUnit(spec, normParams) {
        const {row, column, facet, ...encoding} = spec.encoding, {mark, width, projection, height, view, params, encoding:_, ...outerSpec} = spec, {facetMapping, layout} = this.getFacetMappingAndLayout({row, column, facet}, normParams);
        spec = replaceRepeaterInEncoding(encoding, normParams.repeater);
        return this.mapFacet({...outerSpec, ...layout, facet:facetMapping, spec:{...(width ? {width} : {}), ...(height ? {height} : {}), ...(view ? {view} : {}), ...(projection ? {projection} : {}), mark, encoding:spec, ...(params ? {params} : {})}}, normParams);
      }
      getFacetMappingAndLayout(facets, params) {
        const {row, column, facet} = facets;
        if (row || column) {
          facet && (params = [...(row ? ["row"] : []), ...(column ? ["column"] : [])], params = `Facet encoding dropped as ${params.join(" and ")} ${params.length > 1 ? "are" : "is"} also specified.`, warn(params));
          params = {};
          const layout = {};
          for (const channel of ["row", "column"]) {
            const def = facets[channel];
            if (def) {
              const {align, center, spacing, columns, ...defWithoutLayout} = def;
              params[channel] = defWithoutLayout;
              for (const prop of ["align", "center", "spacing"]) {
                if (def[prop] !== void 0) {
                  let $jscomp$logical$assign$tmp730812712$9, $jscomp$logical$assign$tmpindex730812712$9;
                  ($jscomp$logical$assign$tmp730812712$9 = layout)[$jscomp$logical$assign$tmpindex730812712$9 = prop] ?? ($jscomp$logical$assign$tmp730812712$9[$jscomp$logical$assign$tmpindex730812712$9] = {});
                  layout[prop][channel] = def[prop];
                }
              }
            }
          }
          return {facetMapping:params, layout};
        }
        const {align, center, spacing, columns, ...facetMapping} = facet;
        facets = (facets = params.repeater) ? isFacetMapping(facetMapping) ? replaceRepeaterInMapping(facetMapping, facets) : replaceRepeaterInFieldDef(facetMapping, facets) : facetMapping;
        return {facetMapping:facets, layout:{...(align ? {align} : {}), ...(center ? {center} : {}), ...(spacing ? {spacing} : {}), ...(columns ? {columns} : {})}};
      }
      mapLayer(spec, _ref) {
        let {parentEncoding, parentProjection, ...otherParams} = _ref;
        const {encoding, projection, ...rest} = spec;
        _ref = {...otherParams, parentEncoding:mergeEncoding({parentEncoding, encoding, layer:!0}), parentProjection:mergeProjection({parentProjection, projection})};
        return super.mapLayer({...rest, ...(spec.name ? {name:[_ref.repeaterPrefix, spec.name].filter(n => n).join("_")} : {})}, _ref);
      }
    }
    class SelectionCompatibilityNormalizer extends SpecMapper {
      map(spec, normParams) {
        normParams.emptySelections ?? (normParams.emptySelections = {});
        normParams.selectionPredicates ?? (normParams.selectionPredicates = {});
        spec = normalizeTransforms(spec, normParams);
        return super.map(spec, normParams);
      }
      mapLayerOrUnit(spec, normParams) {
        spec = normalizeTransforms(spec, normParams);
        if (spec.encoding) {
          const encoding = {};
          for (const [channel, enc] of entries$1(spec.encoding)) {
            encoding[channel] = normalizeChannelDef(enc, normParams);
          }
          spec = {...spec, encoding};
        }
        return super.mapLayerOrUnit(spec, normParams);
      }
      mapUnit(spec, normParams) {
        const {selection, ...rest} = spec;
        return selection ? {...rest, params:entries$1(selection).map(_ref => {
          let [name, selDef] = _ref;
          const {init:value, bind, empty, ...select} = selDef;
          select.type === "single" ? (select.type = "point", select.toggle = !1) : select.type === "multi" && (select.type = "point");
          normParams.emptySelections[name] = empty !== "none";
          for (const pred of vals(normParams.selectionPredicates[name] ?? {})) {
            pred.empty = empty !== "none";
          }
          return {name, value, select, bind};
        })} : spec;
      }
    }
    class TopLevelSelectionsNormalizer extends SpecMapper {
      map(spec, normParams) {
        const selections = normParams.selections ?? [];
        if (spec.params && !isUnitSpec(spec)) {
          const params = [];
          for (const param of spec.params) {
            param?.select ? selections.push(param) : params.push(param);
          }
          spec.params = params;
        }
        normParams.selections = selections;
        return super.map(spec, normParams);
      }
      mapUnit(spec, normParams) {
        const selections = normParams.selections;
        if (!selections || !selections.length) {
          return spec;
        }
        const path = (normParams.path ?? []).concat(spec.name);
        normParams = [];
        for (const selection of selections) {
          if (selection.views && selection.views.length) {
            for (const view of selection.views) {
              (vega.isString(view) && (view === spec.name || path.includes(view)) || vega.isArray(view) && view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) && normParams.push(selection);
            }
          } else {
            normParams.push(selection);
          }
        }
        normParams.length && (spec.params = normParams);
        return spec;
      }
    }
    for (const method of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
      const proto = TopLevelSelectionsNormalizer.prototype[method];
      TopLevelSelectionsNormalizer.prototype[method] = function(spec, params) {
        var JSCompiler_temp_const = proto, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.call;
        params = spec.name ? {...params, path:(params.path ?? []).concat(spec.name)} : params;
        return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, this, spec, params);
      };
    }
    const coreNormalizer = new CoreNormalizer(), selectionCompatNormalizer = new SelectionCompatibilityNormalizer(), topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer(), TOP_LEVEL_PROPERTIES = ["background", "padding"];
    class Split {
      constructor() {
        let implicit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.explicit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.implicit = implicit;
      }
      clone() {
        return new Split(duplicate(this.explicit), duplicate(this.implicit));
      }
      combine() {
        return {...this.explicit, ...this.implicit};
      }
      get(key) {
        return getFirstDefined(this.explicit[key], this.implicit[key]);
      }
      getWithExplicit(key) {
        return this.explicit[key] !== void 0 ? {explicit:!0, value:this.explicit[key]} : this.implicit[key] !== void 0 ? {explicit:!1, value:this.implicit[key]} : {explicit:!1, value:void 0};
      }
      setWithExplicit(key, _ref) {
        let {value, explicit} = _ref;
        value !== void 0 && this.set(key, value, explicit);
      }
      set(key, value, explicit) {
        delete this[explicit ? "implicit" : "explicit"][key];
        this[explicit ? "explicit" : "implicit"][key] = value;
        return this;
      }
      copyKeyFromSplit(key, _ref2) {
        let {explicit, implicit} = _ref2;
        explicit[key] !== void 0 ? this.set(key, explicit[key], !0) : implicit[key] !== void 0 && this.set(key, implicit[key], !1);
      }
      copyKeyFromObject(key, s) {
        s[key] !== void 0 && this.set(key, s[key], !0);
      }
      copyAll(other) {
        for (const key of keys(other.combine())) {
          const val = other.getWithExplicit(key);
          this.setWithExplicit(key, val);
        }
      }
    }
    class AncestorParse extends Split {
      constructor() {
        let explicit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, implicit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, parseNothing = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        super(explicit, implicit);
        this.explicit = explicit;
        this.implicit = implicit;
        this.parseNothing = parseNothing;
      }
      clone() {
        const clone = super.clone();
        clone.parseNothing = this.parseNothing;
        return clone;
      }
    }
    let DataSourceType = function(DataSourceType) {
      DataSourceType[DataSourceType.Raw = 0] = "Raw";
      DataSourceType[DataSourceType.Main = 1] = "Main";
      DataSourceType[DataSourceType.Row = 2] = "Row";
      DataSourceType[DataSourceType.Column = 3] = "Column";
      DataSourceType[DataSourceType.Lookup = 4] = "Lookup";
      DataSourceType[DataSourceType.PreFilterInvalid = 5] = "PreFilterInvalid";
      DataSourceType[DataSourceType.PostFilterInvalid = 6] = "PostFilterInvalid";
      return DataSourceType;
    }({});
    class DataFlowNode {
      _children=[];
      _parent=null;
      constructor(parent, debugName) {
        this.debugName = debugName;
        parent && (this.parent = parent);
      }
      clone() {
        throw Error("Cannot clone node");
      }
      get parent() {
        return this._parent;
      }
      set parent(parent) {
        (this._parent = parent) && parent.addChild(this);
      }
      get children() {
        return this._children;
      }
      numChildren() {
        return this._children.length;
      }
      addChild(child, loc) {
        this._children.includes(child) ? warn("Attempt to add the same child twice.") : loc !== void 0 ? this._children.splice(loc, 0, child) : this._children.push(child);
      }
      removeChild(oldChild) {
        oldChild = this._children.indexOf(oldChild);
        this._children.splice(oldChild, 1);
        return oldChild;
      }
      remove() {
        let loc = this._parent.removeChild(this);
        for (const child of this._children) {
          child._parent = this._parent, this._parent.addChild(child, loc++);
        }
      }
      insertAsParentOf(other) {
        const parent = other.parent;
        parent.removeChild(this);
        this.parent = parent;
        other.parent = this;
      }
      swapWithParent() {
        const parent = this._parent, newParent = parent.parent;
        for (var child of this._children) {
          child.parent = parent;
        }
        this._children = [];
        parent.removeChild(this);
        child = parent.parent.removeChild(parent);
        this._parent = newParent;
        newParent.addChild(this, child);
        parent.parent = this;
      }
    }
    class OutputNode extends DataFlowNode {
      clone() {
        const cloneObj = new this.constructor();
        cloneObj.debugName = `clone_${this.debugName}`;
        cloneObj._source = this._source;
        cloneObj._name = `clone_${this._name}`;
        cloneObj.type = this.type;
        cloneObj.refCounts = this.refCounts;
        cloneObj.refCounts[cloneObj._name] = 0;
        return cloneObj;
      }
      constructor(parent, source, type, refCounts) {
        super(parent, source);
        this.type = type;
        this.refCounts = refCounts;
        this._source = this._name = source;
        !this.refCounts || this._name in this.refCounts || (this.refCounts[this._name] = 0);
      }
      dependentFields() {
        return new Set();
      }
      producedFields() {
        return new Set();
      }
      hash() {
        this._hash === void 0 && (this._hash = `Output ${uniqueId()}`);
        return this._hash;
      }
      getSource() {
        this.refCounts[this._name]++;
        return this._source;
      }
      isRequired() {
        return !!this.refCounts[this._name];
      }
      setSource(source) {
        this._source = source;
      }
    }
    class TimeUnitNode extends DataFlowNode {
      clone() {
        return new TimeUnitNode(null, duplicate(this.timeUnits));
      }
      constructor(parent, timeUnits) {
        super(parent);
        this.timeUnits = timeUnits;
      }
      static makeFromEncoding(parent, model) {
        const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {
          const {field, timeUnit} = fieldDef;
          if (timeUnit) {
            let component;
            if (isBinnedTimeUnit(timeUnit)) {
              if (isUnitModel(model)) {
                const {mark, markDef, config} = model, bandPosition = getBandPosition({fieldDef, markDef, config});
                if (isRectBasedMark(mark) || bandPosition) {
                  component = {timeUnit:normalizeTimeUnit(timeUnit), field};
                }
              }
            } else {
              component = {as:vgField(fieldDef, {forAs:!0}), field, timeUnit};
            }
            if (isUnitModel(model)) {
              const {mark, markDef, config} = model;
              fieldDef = getBandPosition({fieldDef, markDef, config});
              isRectBasedMark(mark) && isXorY(channel) && fieldDef !== 0.5 && (component.rectBandPosition = fieldDef);
            }
            component && (timeUnitComponent[hash(component)] = component);
          }
          return timeUnitComponent;
        }, {});
        return isEmpty(formula) ? null : new TimeUnitNode(parent, formula);
      }
      static makeFromTransform(parent, t) {
        const {timeUnit, ...other} = {...t};
        t = normalizeTimeUnit(timeUnit);
        t = {...other, timeUnit:t};
        return new TimeUnitNode(parent, {[hash(t)]:t});
      }
      merge(other) {
        this.timeUnits = {...this.timeUnits};
        for (const key in other.timeUnits) {
          this.timeUnits[key] || (this.timeUnits[key] = other.timeUnits[key]);
        }
        for (const child of other.children) {
          other.removeChild(child), child.parent = this;
        }
        other.remove();
      }
      removeFormulas(fields) {
        const newFormula = {};
        for (const [key, timeUnitComponent] of entries$1(this.timeUnits)) {
          fields.has(timeUnitComponent.as !== void 0 ? timeUnitComponent.as : `${timeUnitComponent.field}_end`) || (newFormula[key] = timeUnitComponent);
        }
        this.timeUnits = newFormula;
      }
      producedFields() {
        return new Set(vals(this.timeUnits).map(f => f.as !== void 0 ? f.as : `${f.field}_end`));
      }
      dependentFields() {
        return new Set(vals(this.timeUnits).map(f => f.field));
      }
      hash() {
        return `TimeUnit ${hash(this.timeUnits)}`;
      }
      assemble() {
        const transforms = [];
        for (const f of vals(this.timeUnits)) {
          const {rectBandPosition} = f, normalizedTimeUnit = normalizeTimeUnit(f.timeUnit);
          if (f.as !== void 0) {
            const {field, as} = f, {unit, utc, ...params} = normalizedTimeUnit;
            var startEnd = [as, `${as}_end`];
            transforms.push({field:replacePathInField(field), type:"timeunit", ...(unit ? {units:getTimeUnitParts(unit)} : {}), ...(utc ? {timezone:"utc"} : {}), ...params, as:startEnd});
            transforms.push(...offsetedRectFormulas(startEnd, rectBandPosition, normalizedTimeUnit));
          } else if (f) {
            ({field:startEnd} = f);
            startEnd = startEnd.replaceAll("\\.", ".");
            const expr = offsetExpr({timeUnit:normalizedTimeUnit, field:startEnd}), endAs = `${startEnd}_end`;
            transforms.push({type:"formula", expr, as:endAs});
            transforms.push(...offsetedRectFormulas([startEnd, endAs], rectBandPosition, normalizedTimeUnit));
          }
        }
        return transforms;
      }
    }
    class SelectionProjectionComponent {
      constructor() {
        for (var _len = arguments.length, items = Array(_len), _key = 0; _key < _len; _key++) {
          items[_key] = arguments[_key];
        }
        this.items = items;
        this.hasChannel = {};
        this.hasField = {};
        this.hasSelectionId = !1;
      }
    }
    const THROTTLE = 1 / 60 * 1000, animationSignals = (selectionName, scaleName) => [{name:"eased_anim_clock", update:"anim_clock"}, {name:`${selectionName}_domain`, init:`domain('${scaleName}')`}, {name:"min_extent", init:`extent(${selectionName}_domain)[0]`}, {name:"max_range_extent", init:`extent(range('${scaleName}'))[1]`}, {name:"anim_value", update:`invert('${scaleName}', ${"eased_anim_clock"})`}], scaleBindings = {defined:selCmpt => selCmpt.type === "interval" && selCmpt.resolve === "global" && 
    selCmpt.bind && selCmpt.bind === "scales", parse:(model, selCmpt) => {
      const bound = selCmpt.scales = [];
      for (const proj of selCmpt.project.items) {
        var channel = proj.channel;
        if (!isScaleChannel(channel)) {
          continue;
        }
        const scaleType = (channel = model.getScaleComponent(channel)) ? channel.get("type") : void 0;
        scaleType == "sequential" && warn("Sequntial scales are deprecated. The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc");
        channel && hasContinuousDomain(scaleType) ? (channel.set("selectionExtent", {param:selCmpt.name, field:proj.field}, !0), bound.push(proj)) : warn("Scale bindings are currently only supported for scales with unbinned, continuous domains.");
      }
    }, topLevelSignals:(model, selCmpt, signals) => {
      const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);
      if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {
        return signals;
      }
      model = signals.find(s => s.name === selCmpt.name);
      let update = model.update;
      if (update.includes("vlSelectionResolve")) {
        model.update = `{${bound.map(proj => `${vega.stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;
      } else {
        for (const proj of bound) {
          const mapping = `${vega.stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;
          update.includes(mapping) || (update = `${update.substring(0, update.length - 1)}, ${mapping}}`);
        }
        model.update = update;
      }
      return signals.concat(bound.map(proj => ({name:proj.signals.data})));
    }, signals:(model, selCmpt, signals) => {
      if (model.parent && !isTopLevelLayer(model)) {
        for (const proj of selCmpt.scales) {
          model = signals.find(s => s.name === proj.signals.data), model.push = "outer", delete model.value, delete model.update;
        }
      }
      return signals;
    }}, ALIGNED_X_CHANNEL = {left:"x", center:"xc", right:"x2"}, BASELINED_Y_CHANNEL = {top:"y", middle:"yc", bottom:"y2"}, ALWAYS_IGNORE = new Set(["aria", "width", "height"]), nearest = {defined:selCmpt => selCmpt.type === "point" && selCmpt.nearest, parse:(model, selCmpt) => {
      if (selCmpt.events) {
        for (const s of selCmpt.events) {
          s.markname = model.getName("voronoi");
        }
      }
    }, marks:(model, selCmpt, marks) => {
      const {x, y} = selCmpt.project.hasChannel;
      selCmpt = model.mark;
      if (isPathMark(selCmpt)) {
        return warn(`The "nearest" transform is not supported for ${selCmpt} marks.`), marks;
      }
      selCmpt = {name:model.getName("voronoi"), type:"path", interactive:!0, from:{data:model.getName("marks")}, encode:{update:{fill:{value:"transparent"}, strokeWidth:{value:0.35}, stroke:{value:"transparent"}, isVoronoi:{value:!0}, ...tooltip(model, {reactiveGeom:!0})}}, transform:[{type:"voronoi", x:{expr:x || !y ? "datum.datum.x || 0" : "0"}, y:{expr:y || !x ? "datum.datum.y || 0" : "0"}, size:[model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]}]};
      let index = 0, exists = !1;
      marks.forEach((mark, i) => {
        mark = mark.name ?? "";
        mark === model.component.mark[0].name ? index = i : mark.includes("voronoi") && (exists = !0);
      });
      exists || marks.splice(index + 1, 0, selCmpt);
      return marks;
    }}, inputBindings = {defined:selCmpt => selCmpt.type === "point" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind), parse:(model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef), topLevelSignals:(model, selCmpt, signals) => {
      const name = selCmpt.name;
      model = selCmpt.project;
      const bind = selCmpt.bind, init = selCmpt.init && selCmpt.init[0], datum = nearest.defined(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
      model.items.forEach((p, i) => {
        const sgname = varName(`${name}_${p.field}`);
        signals.filter(s => s.name === sgname).length || signals.unshift({name:sgname, ...(init ? {init:assembleInit(init[i])} : {value:null}), on:selCmpt.events ? [{events:selCmpt.events, update:`datum && item().mark.marktype !== 'group' ? ${datum}[${vega.stringValue(p.field)}] : null`}] : [], bind:bind[p.field] ?? bind[p.channel] ?? bind});
      });
      return signals;
    }, signals:(model, selCmpt, signals) => {
      const name = selCmpt.name;
      var proj = selCmpt.project;
      model = signals.find(s => s.name === name + "_tuple");
      selCmpt = name + "_tuple_fields";
      proj = proj.items.map(p => varName(`${name}_${p.field}`));
      const valid = proj.map(v => `${v} !== null`).join(" \x26\x26 ");
      proj.length && (model.update = `${valid} ? {fields: ${selCmpt}, values: [${proj.join(", ")}]} : null`);
      delete model.value;
      delete model.on;
      return signals;
    }}, toggle = {defined:selCmpt => selCmpt.type === "point" && !isTimerSelection(selCmpt) && !!selCmpt.toggle, signals:(model, selCmpt, signals) => signals.concat({name:selCmpt.name + "_toggle", value:!1, on:[{events:selCmpt.events, update:selCmpt.toggle}]}), modifyExpr:(model, selCmpt) => {
      const tpl = selCmpt.name + "_tuple", signal = selCmpt.name + "_toggle";
      return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
    }}, legendBindings = {defined:selCmpt => {
      const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
      selCmpt = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== "_vgsid_";
      spec && !selCmpt && warn("Legend bindings are only supported for selections over an individual field or encoding channel.");
      return spec && selCmpt;
    }, parse:(model, selCmpt, selDef) => {
      model = duplicate(selDef);
      model.select = vega.isString(model.select) ? {type:model.select, toggle:selCmpt.toggle} : {...model.select, toggle:selCmpt.toggle};
      disableDirectManipulation(selCmpt, model);
      if (vega.isObject(selDef.select) && (selDef.select.on || selDef.select.clear)) {
        for (const evt of selCmpt.events) {
          evt.filter = vega.array(evt.filter ?? []), evt.filter.includes('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0') || evt.filter.push('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0');
        }
      }
      selDef = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
      selDef = vega.isString(selDef) ? vega.parseSelector(selDef, "view") : vega.array(selDef);
      selCmpt.bind = {legend:{merge:selDef}};
    }, topLevelSignals:(model, selCmpt, signals) => {
      model = selCmpt.name;
      const stream = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend, markName = name => s => {
        s = duplicate(s);
        s.markname = name;
        return s;
      };
      for (const proj of selCmpt.project.items) {
        if (!proj.hasLegend) {
          continue;
        }
        var prefix = `${varName(proj.field)}_legend`;
        const sgName = `${model}_${prefix}`;
        signals.filter(s => s.name === sgName).length === 0 && (prefix = stream.merge.map(markName(`${prefix}_symbols`)).concat(stream.merge.map(markName(`${prefix}_labels`))).concat(stream.merge.map(markName(`${prefix}_entries`))), signals.unshift({name:sgName, ...(selCmpt.init ? {} : {value:null}), on:[{events:prefix, update:"isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value", force:!0}, {events:stream.merge, update:`!event.item || !datum ? null : ${sgName}`, force:!0}]}));
      }
      return signals;
    }, signals:(model, selCmpt, signals) => {
      const name = selCmpt.name;
      var proj = selCmpt.project;
      model = signals.find(s => s.name === name + "_tuple");
      var fields = name + "_tuple_fields";
      proj = proj.items.filter(p => p.hasLegend).map(p => varName(`${name}_${varName(p.field)}_legend`));
      fields = `${proj.map(v => `${v} !== null`).join(" \x26\x26 ")} ? {fields: ${fields}, values: [${proj.join(", ")}]} : null`;
      selCmpt.events && proj.length > 0 ? model.on.push({events:proj.map(signal => ({signal})), update:fields}) : proj.length > 0 && (model.update = fields, delete model.value, delete model.on);
      model = signals.find(s => s.name === name + "_toggle");
      fields = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
      model && (selCmpt.events ? model.on.push({...model.on[0], events:fields}) : model.on[0].events = fields);
      return signals;
    }}, selectionCompilers = [{defined:selCmpt => selCmpt.type === "point", topLevelSignals:(model, selCmpt, signals) => {
      isTimerSelection(selCmpt) && (signals = signals.concat([{name:"anim_clock", init:"0", on:[{events:{type:"timer", throttle:THROTTLE}, update:"is_playing ? (anim_clock + (now() - last_tick_at) \x3e max_range_extent ? 0 : anim_clock + (now() - last_tick_at)) : anim_clock"}]}, {name:"last_tick_at", init:"now()", on:[{events:[{signal:"anim_clock"}, {signal:"is_playing"}], update:"now()"}]}, {name:"is_playing", init:"true"}]));
      return signals;
    }, signals:(model, selCmpt, signals) => {
      const name = selCmpt.name, fieldsSg = name + "_tuple_fields";
      var project = selCmpt.project, brushes = vals(model.component.selection ?? {}).reduce((acc, cmpt) => cmpt.type === "interval" ? acc.concat(cmpt.name + "_brush") : acc, []).map(b => `indexof(item().mark.name, '${b}') < 0`).join(" \x26\x26 ");
      brushes = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ""}`;
      let update = `unit: ${unitName(model)}, `;
      selCmpt.project.hasSelectionId ? update += `${"_vgsid_"}: ${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue("_vgsid_")}]` : isTimerSelection(selCmpt) ? update += `fields: ${fieldsSg}, values: [${"anim_value"} ? ${"anim_value"} : ${"min_extent"}]` : (project = project.items.map(p => model.fieldDef(p.channel)?.bin ? `[${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue(model.vgField(p.channel, {}))}], ` + `${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue(model.vgField(p.channel, 
      {binSuffix:"end"}))}]]` : `${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue(p.field)}]`).join(", "), update += `fields: ${fieldsSg}, values: [${project}]`);
      if (isTimerSelection(selCmpt)) {
        return signals.concat(animationSignals(selCmpt.name, model.scaleName("time")), [{name:name + "_tuple", on:[{events:[{signal:"eased_anim_clock"}, {signal:"anim_value"}], update:`{${update}}`, force:!0}]}]);
      }
      selCmpt = selCmpt.events;
      return signals.concat([{name:name + "_tuple", on:selCmpt ? [{events:selCmpt, update:`${brushes} ? {${update}} : null`, force:!0}] : []}]);
    }}, {defined:selCmpt => selCmpt.type === "interval", parse:(model, selCmpt, selDef) => {
      model.hasProjection && (model = {...(vega.isObject(selDef.select) ? selDef.select : {}), fields:["_vgsid_"]}, model.encodings || (model.encodings = selDef.value ? keys(selDef.value) : ["longitude", "latitude"]), selDef.select = {type:"interval", ...model});
      if (selCmpt.translate && !scaleBindings.defined(selCmpt)) {
        selDef = `!event.item || event.item.mark.name !== ${vega.stringValue(selCmpt.name + "_brush")}`;
        for (const evt of selCmpt.events) {
          if (!evt.between) {
            warn(`${evt} is not an ordered event stream for interval selections.`);
            continue;
          }
          let $jscomp$logical$assign$tmp730812712$13;
          selCmpt = vega.array(($jscomp$logical$assign$tmp730812712$13 = evt.between[0]).filter ?? ($jscomp$logical$assign$tmp730812712$13.filter = []));
          selCmpt.includes(selDef) || selCmpt.push(selDef);
        }
      }
    }, signals:(model, selCmpt, signals) => {
      var name = selCmpt.name;
      const tupleSg = name + "_tuple";
      var channels = vals(selCmpt.project.hasChannel).filter(p => p.channel === "x" || p.channel === "y");
      const init = selCmpt.init ? selCmpt.init[0] : null;
      signals.push(...channels.reduce((arr, proj) => arr.concat(channelSignals(model, selCmpt, proj, init && init[proj.index])), []));
      if (model.hasProjection) {
        var projection = vega.stringValue(model.projectionName());
        const centerSg = model.projectionName() + "_center", {x, y} = selCmpt.project.hasChannel;
        var xvname = x && x.signals.visual;
        const yvname = y && y.signals.visual;
        var xinit = x ? init && init[x.index] : `${centerSg}[0]`;
        const yinit = y ? init && init[y.index] : `${centerSg}[1]`;
        xvname = "[" + `[${xvname ? xvname + "[0]" : "0"}, ${yvname ? yvname + "[0]" : "0"}],` + `[${xvname ? xvname + "[1]" : model.getSizeSignalRef("width").signal}, ` + `${yvname ? yvname + "[1]" : model.getSizeSignalRef("height").signal}]` + "]";
        init && (signals.unshift({name:name + "_init", init:`[scale(${projection}, [${x ? xinit[0] : xinit}, ${y ? yinit[0] : yinit}]), ` + `scale(${projection}, [${x ? xinit[1] : xinit}, ${y ? yinit[1] : yinit}])]`}), x && y || signals.find(s => s.name === centerSg) || signals.unshift({name:centerSg, update:`invert(${projection}, [${model.getSizeSignalRef("width").signal}/2, ${model.getSizeSignalRef("height").signal}/2])`}));
        name = `intersect(${xvname}, {markname: ${vega.stringValue(model.getName("marks"))}}, unit.mark)`;
        projection = `{unit: ${unitName(model)}}`;
        name = `vlSelectionTuples(${name}, ${projection})`;
        channels = channels.map(proj => proj.signals.visual);
        return signals.concat({name:tupleSg, on:[{events:[...(channels.length ? [{signal:channels.join(" || ")}] : []), ...(init ? [{signal:"geo_interval_init_tick"}] : [])], update:name}]});
      }
      scaleBindings.defined(selCmpt) || (projection = name + "_scale_trigger", xinit = channels.map(proj => {
        var channel = proj.channel;
        const {data:dname, visual:vname} = proj.signals;
        proj = vega.stringValue(model.scaleName(channel));
        channel = model.getScaleComponent(channel).get("type");
        channel = hasContinuousDomain(channel) ? "+" : "";
        return `(!isArray(${dname}) || ` + `(${channel}invert(${proj}, ${vname})[0] === ${channel}${dname}[0] && ` + `${channel}invert(${proj}, ${vname})[1] === ${channel}${dname}[1]))`;
      }), xinit.length && signals.push({name:projection, value:{}, on:[{events:channels.map(proj => ({scale:model.scaleName(proj.channel)})), update:xinit.join(" \x26\x26 ") + ` ? ${projection} : {}`}]}));
      channels = channels.map(proj => proj.signals.data);
      name = `unit: ${unitName(model)}, fields: ${name + "_tuple_fields"}, values`;
      return signals.concat({name:tupleSg, ...(init ? {init:`{${name}: ${assembleInit(init)}}`} : {}), ...(channels.length ? {on:[{events:[{signal:channels.join(" || ")}], update:`${channels.join(" \x26\x26 ")} ? {${name}: [${channels}]} : null`}]} : {})});
    }, topLevelSignals:(model, selCmpt, signals) => {
      isUnitModel(model) && model.hasProjection && selCmpt.init && (signals.filter(s => s.name === "geo_interval_init_tick").length || signals.unshift({name:"geo_interval_init_tick", value:null, on:[{events:"timer{1}", update:"geo_interval_init_tick \x3d\x3d\x3d null ? {} : geo_interval_init_tick"}]}));
      return signals;
    }, marks:(model, selCmpt, marks) => {
      const name = selCmpt.name, {x, y} = selCmpt.project.hasChannel, xvname = x?.signals.visual, yvname = y?.signals.visual, store = `data(${vega.stringValue(selCmpt.name + "_store")})`;
      if (scaleBindings.defined(selCmpt) || !x && !y) {
        return marks;
      }
      const update = {x:x !== void 0 ? {signal:`${xvname}[0]`} : {value:0}, y:y !== void 0 ? {signal:`${yvname}[0]`} : {value:0}, x2:x !== void 0 ? {signal:`${xvname}[1]`} : {field:{group:"width"}}, y2:y !== void 0 ? {signal:`${yvname}[1]`} : {field:{group:"height"}}};
      if (selCmpt.resolve === "global") {
        for (const key of keys(update)) {
          update[key] = [{test:`${store}.length && ${store}[0].unit === ${unitName(model)}`, ...update[key]}, {value:0}];
        }
      }
      const {fill, fillOpacity, cursor, ...stroke} = selCmpt.mark;
      model = keys(stroke).reduce((def, k) => {
        def[k] = [{test:[x !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter(t => t).join(" \x26\x26 "), value:stroke[k]}, {value:null}];
        return def;
      }, {});
      selCmpt = cursor ?? (selCmpt.translate ? "move" : null);
      return [{name:`${name + "_brush"}_bg`, type:"rect", clip:!0, encode:{enter:{fill:{value:fill}, fillOpacity:{value:fillOpacity}}, update}}, ...marks, {name:name + "_brush", type:"rect", clip:!0, encode:{enter:{...(selCmpt ? {cursor:{value:selCmpt}} : {}), fill:{value:"transparent"}}, update:{...update, ...model}}}];
    }}, {defined:() => !0, parse:(model, selCmpt, selDef) => {
      const name = selCmpt.name, proj = selCmpt.project ?? (selCmpt.project = new SelectionProjectionComponent()), parsed = {}, timeUnits = {}, signals = new Set(), signalName = (p, range) => {
        p = range === "visual" ? p.channel : p.field;
        let sg = varName(`${name}_${p}`);
        for (let counter = 1; signals.has(sg); counter++) {
          sg = varName(`${name}_${p}_${counter}`);
        }
        signals.add(sg);
        return {[range]:sg};
      }, type = selCmpt.type;
      var cfg = model.config.selection[type];
      const init = selDef.value !== void 0 ? vega.array(selDef.value) : null;
      let {fields, encodings} = vega.isObject(selDef.select) ? selDef.select : {};
      if (!fields && !encodings && init) {
        for (var initVal of init) {
          if (vega.isObject(initVal)) {
            for (const key of keys(initVal)) {
              vega.hasOwnProperty(SINGLE_DEF_UNIT_CHANNEL_INDEX, key) ? (encodings ||= []).push(key) : type === "interval" ? (warn('Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.'), encodings = cfg.encodings) : (fields ??= []).push(key);
            }
          }
        }
      }
      fields || encodings || (encodings = cfg.encodings, "fields" in cfg && (fields = cfg.fields));
      for (const channel of encodings ?? []) {
        (cfg = model.fieldDef(channel)) ? (selDef = cfg.field, cfg.aggregate ? warn(`Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${cfg.aggregate}").`) : selDef ? (cfg.timeUnit && !isBinnedTimeUnit(cfg.timeUnit) && (selDef = model.vgField(channel), initVal = {timeUnit:cfg.timeUnit, as:selDef, field:cfg.field}, timeUnits[hash(initVal)] = initVal), parsed[selDef] || (cfg = type === "interval" && isScaleChannel(channel) && hasContinuousDomain(model.getScaleComponent(channel).get("type")) ? 
        "R" : cfg.bin ? "R-RE" : "E", cfg = {field:selDef, channel, type:cfg, index:proj.items.length}, cfg.signals = {...signalName(cfg, "data"), ...signalName(cfg, "visual")}, proj.items.push(parsed[selDef] = cfg), proj.hasField[selDef] = parsed[selDef], proj.hasSelectionId = proj.hasSelectionId || selDef === "_vgsid_", vega.hasOwnProperty(GEO_POSIITON_CHANNEL_INDEX, channel) ? (cfg.geoChannel = channel, cfg.channel = getPositionChannelFromLatLong(channel), proj.hasChannel[cfg.channel] = parsed[selDef]) : 
        proj.hasChannel[channel] = parsed[selDef])) : warn(cannotProjectOnChannelWithoutField(channel))) : warn(cannotProjectOnChannelWithoutField(channel));
      }
      for (const field of fields ?? []) {
        proj.hasField[field] || (model = {type:"E", field, index:proj.items.length}, model.signals = {...signalName(model, "data")}, proj.items.push(model), proj.hasField[field] = model, proj.hasSelectionId = proj.hasSelectionId || field === "_vgsid_");
      }
      init && (selCmpt.init = init.map(v => proj.items.map(p => vega.isObject(v) ? v[p.geoChannel || p.channel] !== void 0 ? v[p.geoChannel || p.channel] : v[p.field] : v)));
      isEmpty(timeUnits) || (proj.timeUnit = new TimeUnitNode(null, timeUnits));
    }, signals:(model, selCmpt, allSignals) => {
      const name = selCmpt.name + "_tuple_fields";
      return allSignals.filter(s => s.name === name).length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({name, value:selCmpt.project.items.map(assembleProjection)});
    }}, toggle, inputBindings, scaleBindings, legendBindings, {defined:selCmpt => selCmpt.clear !== void 0 && selCmpt.clear !== !1 && !isTimerSelection(selCmpt), parse:(model, selCmpt) => {
      selCmpt.clear && (selCmpt.clear = vega.isString(selCmpt.clear) ? vega.parseSelector(selCmpt.clear, "view") : selCmpt.clear);
    }, topLevelSignals:(model, selCmpt, signals) => {
      if (inputBindings.defined(selCmpt)) {
        for (const proj of selCmpt.project.items) {
          model = signals.findIndex(n => n.name === varName(`${selCmpt.name}_${proj.field}`)), model !== -1 && signals[model].on.push({events:selCmpt.clear, update:"null"});
        }
      }
      return signals;
    }, signals:(model, selCmpt, signals) => {
      function addClear(idx, update) {
        idx !== -1 && signals[idx].on && signals[idx].on.push({events:selCmpt.clear, update});
      }
      if (selCmpt.type === "interval") {
        for (const proj of selCmpt.project.items) {
          model = signals.findIndex(n => n.name === proj.signals.visual), addClear(model, "[0, 0]"), model === -1 && (model = signals.findIndex(n => n.name === proj.signals.data), addClear(model, "null"));
        }
      } else {
        model = signals.findIndex(n => n.name === selCmpt.name + "_tuple"), addClear(model, "null"), toggle.defined(selCmpt) && (model = signals.findIndex(n => n.name === selCmpt.name + "_toggle"), addClear(model, "false"));
      }
      return signals;
    }}, {defined:selCmpt => selCmpt.type === "interval" && selCmpt.translate, signals:(model, selCmpt, signals) => {
      const name = selCmpt.name, boundScales = scaleBindings.defined(selCmpt), anchor = name + "_translate_anchor", {x, y} = selCmpt.project.hasChannel;
      let events = vega.parseSelector(selCmpt.translate, "scope");
      boundScales || (events = events.map(e => (e.between[0].markname = name + "_brush", e)));
      signals.push({name:anchor, value:{}, on:[{events:events.map(e => e.between[0]), update:"{x: x(unit), y: y(unit)" + (x !== void 0 ? `, extent_x: ${boundScales ? domain(model, "x") : `slice(${x.signals.visual})`}` : "") + (y !== void 0 ? `, extent_y: ${boundScales ? domain(model, "y") : `slice(${y.signals.visual})`}` : "") + "}"}]}, {name:name + "_translate_delta", value:{}, on:[{events, update:`{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`}]});
      x !== void 0 && onDelta$1(model, selCmpt, x, "width", signals);
      y !== void 0 && onDelta$1(model, selCmpt, y, "height", signals);
      return signals;
    }}, {defined:selCmpt => selCmpt.type === "interval" && selCmpt.zoom, signals:(model, selCmpt, signals) => {
      const name = selCmpt.name, boundScales = scaleBindings.defined(selCmpt), delta = name + "_zoom_delta", {x, y} = selCmpt.project.hasChannel, sx = vega.stringValue(model.scaleName("x")), sy = vega.stringValue(model.scaleName("y"));
      let events = vega.parseSelector(selCmpt.zoom, "scope");
      boundScales || (events = events.map(e => (e.markname = name + "_brush", e)));
      signals.push({name:name + "_zoom_anchor", on:[{events, update:boundScales ? "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter(expr => expr).join(", ") + "}" : "{x: x(unit), y: y(unit)}"}]}, {name:delta, on:[{events, force:!0, update:"pow(1.001, event.deltaY * pow(16, event.deltaMode))"}]});
      x !== void 0 && onDelta(model, selCmpt, x, "width", signals);
      y !== void 0 && onDelta(model, selCmpt, y, "height", signals);
      return signals;
    }}, nearest];
    class FilterNode extends DataFlowNode {
      clone() {
        return new FilterNode(null, this.model, duplicate(this.filter));
      }
      constructor(parent, model, filter) {
        super(parent);
        this.model = model;
        this.filter = filter;
        this.expr = expression(this.model, this.filter, this);
        this._dependentFields = getDependentFields(this.expr);
      }
      dependentFields() {
        return this._dependentFields;
      }
      producedFields() {
        return new Set();
      }
      assemble() {
        return {type:"filter", expr:this.expr};
      }
      hash() {
        return `Filter ${this.expr}`;
      }
    }
    const axisRules = {scale:_ref => {
      let {model, channel} = _ref;
      return model.scaleName(channel);
    }, format:_ref2 => {
      ({format:_ref2} = _ref2);
      return _ref2;
    }, formatType:_ref3 => {
      ({formatType:_ref3} = _ref3);
      return _ref3;
    }, grid:_ref4 => {
      let {fieldOrDatumDef, axis, scaleType} = _ref4;
      var JSCompiler_temp;
      return (JSCompiler_temp = axis.grid) != null ? JSCompiler_temp : !hasDiscreteDomain(scaleType) && isFieldDef(fieldOrDatumDef) && !isBinning(fieldOrDatumDef?.bin) && !isBinned(fieldOrDatumDef?.bin);
    }, gridScale:_ref5 => {
      let {model, channel} = _ref5;
      _ref5 = channel === "x" ? "y" : "x";
      _ref5 = model.getScaleComponent(_ref5) ? model.scaleName(_ref5) : void 0;
      return _ref5;
    }, labelAlign:_ref6 => {
      let {axis, labelAngle, orient, channel} = _ref6;
      return axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel);
    }, labelAngle:_ref7 => {
      ({labelAngle:_ref7} = _ref7);
      return _ref7;
    }, labelBaseline:_ref8 => {
      let {axis, labelAngle, orient, channel} = _ref8;
      return axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel);
    }, labelFlush:_ref9 => {
      let {axis, fieldOrDatumDef, channel} = _ref9;
      (_ref9 = axis.labelFlush) == null && (_ref9 = channel === "x" && contains(["quantitative", "temporal"], fieldOrDatumDef.type) ? !0 : void 0);
      return _ref9;
    }, labelOverlap:_ref10 => {
      let {axis, fieldOrDatumDef, scaleType} = _ref10;
      if ((_ref10 = axis.labelOverlap) == null) {
        _ref10 = fieldOrDatumDef.type;
        var hasTimeUnit = isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
        _ref10 = hasTimeUnit && !vega.isObject(sort) || _ref10 !== "nominal" && _ref10 !== "ordinal" ? scaleType === "log" || scaleType === "symlog" ? "greedy" : !0 : void 0;
      }
      return _ref10;
    }, orient:_ref11 => {
      ({orient:_ref11} = _ref11);
      return _ref11;
    }, tickCount:_ref12 => {
      let {channel, model, axis, fieldOrDatumDef:fieldOrDatumDef$jscomp$0, scaleType:scaleType$jscomp$0} = _ref12;
      _ref12 = (_ref12 = channel === "x" ? "width" : channel === "y" ? "height" : void 0) ? model.getSizeSignalRef(_ref12) : void 0;
      var JSCompiler_temp;
      if ((JSCompiler_temp = axis.tickCount) != null) {
        _ref12 = JSCompiler_temp;
      } else {
        a: {
          let {fieldOrDatumDef, scaleType, size, values:vals} = {fieldOrDatumDef:fieldOrDatumDef$jscomp$0, scaleType:scaleType$jscomp$0, size:_ref12, values:axis.values};
          if (vals || hasDiscreteDomain(scaleType) || scaleType === "log") {
            _ref12 = void 0;
          } else {
            if (isFieldDef(fieldOrDatumDef)) {
              if (isBinning(fieldOrDatumDef.bin)) {
                _ref12 = {signal:`ceil(${size.signal}/10)`};
                break a;
              }
              if (fieldOrDatumDef.timeUnit && contains(["month", "hours", "day", "quarter"], normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit)) {
                _ref12 = void 0;
                break a;
              }
            }
            _ref12 = {signal:`ceil(${size.signal}/40)`};
          }
        }
      }
      return _ref12;
    }, tickMinStep:function(_ref17) {
      let {format, fieldOrDatumDef} = _ref17;
      if (format === "d") {
        return 1;
      }
      if (isFieldDef(fieldOrDatumDef) && ({timeUnit:_ref17} = fieldOrDatumDef, _ref17 && (_ref17 = durationExpr(_ref17)))) {
        return {signal:_ref17};
      }
    }, title:_ref13 => {
      let {axis, model, channel} = _ref13;
      if (axis.title !== void 0) {
        return axis.title;
      }
      _ref13 = getFieldDefTitle(model, channel);
      if (_ref13 !== void 0) {
        return _ref13;
      }
      _ref13 = model.typedFieldDef(channel);
      const fieldDef2 = model.fieldDef(channel === "x" ? "x2" : "y2");
      return mergeTitleFieldDefs(_ref13 ? [toFieldDefBase(_ref13)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
    }, values:_ref14 => {
      let {axis, fieldOrDatumDef} = _ref14;
      _ref14 = axis.values;
      _ref14 = vega.isArray(_ref14) ? valueArray(fieldOrDatumDef, _ref14) : isSignalRef(_ref14) ? _ref14 : void 0;
      return _ref14;
    }, zindex:_ref15 => {
      let {axis, fieldOrDatumDef, mark} = _ref15;
      (_ref15 = axis.zindex) == null && (_ref15 = mark === "rect" && isDiscrete(fieldOrDatumDef) ? 1 : 0);
      return _ref15;
    }};
    class CalculateNode extends DataFlowNode {
      clone() {
        return new CalculateNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this._dependentFields = getDependentFields(this.transform.calculate);
      }
      static parseAllForSortIndex(parent, model) {
        model.forEachFieldDef((fieldDef, channel) => {
          if (isScaleFieldDef(fieldDef) && isSortArray(fieldDef.sort)) {
            const {field, timeUnit} = fieldDef;
            var sort = fieldDef.sort;
            sort = sort.map((sortValue, i) => `${fieldFilterExpression({field, timeUnit, equal:sortValue})} ? ${i} : `).join("") + sort.length;
            parent = new CalculateNode(parent, {calculate:sort, as:sortArrayIndexField(fieldDef, channel, {forAs:!0})});
          }
        });
        return parent;
      }
      producedFields() {
        return new Set([this.transform.as]);
      }
      dependentFields() {
        return this._dependentFields;
      }
      assemble() {
        return {type:"formula", expr:this.transform.calculate, as:this.transform.as};
      }
      hash() {
        return `Calculate ${hash(this.transform)}`;
      }
    }
    const HEADER_CHANNELS = ["row", "column"], HEADER_TYPES = ["header", "footer"], LAYOUT_TITLE_BAND = {column:{start:0, end:1}, row:{start:1, end:0}}, LEGEND_COMPONENT_PROPERTIES = keys({aria:1, clipHeight:1, columnPadding:1, columns:1, cornerRadius:1, description:1, direction:1, fillColor:1, format:1, formatType:1, gradientLength:1, gradientOpacity:1, gradientStrokeColor:1, gradientStrokeWidth:1, gradientThickness:1, gridAlign:1, labelAlign:1, labelBaseline:1, labelColor:1, labelFont:1, labelFontSize:1, 
    labelFontStyle:1, labelFontWeight:1, labelLimit:1, labelOffset:1, labelOpacity:1, labelOverlap:1, labelPadding:1, labelSeparation:1, legendX:1, legendY:1, offset:1, orient:1, padding:1, rowPadding:1, strokeColor:1, symbolDash:1, symbolDashOffset:1, symbolFillColor:1, symbolLimit:1, symbolOffset:1, symbolOpacity:1, symbolSize:1, symbolStrokeColor:1, symbolStrokeWidth:1, symbolType:1, tickCount:1, tickMinStep:1, title:1, titleAlign:1, titleAnchor:1, titleBaseline:1, titleColor:1, titleFont:1, titleFontSize:1, 
    titleFontStyle:1, titleFontWeight:1, titleLimit:1, titleLineHeight:1, titleOpacity:1, titleOrient:1, titlePadding:1, type:1, values:1, zindex:1, disable:1, labelExpr:1, selections:1, opacity:1, shape:1, stroke:1, fill:1, size:1, strokeWidth:1, strokeDash:1, encode:1});
    class LegendComponent extends Split {
    }
    const legendEncodeRules = {symbols:function(symbolsSpec, _ref) {
      let {fieldOrDatumDef, model, channel, legendCmpt, legendType} = _ref;
      if (legendType === "symbol") {
        var {markDef, encoding, config, mark} = model;
        _ref = markDef.filled && mark !== "trail";
        var e = {};
        for (var property of FILL_STROKE_CONFIG) {
          var value = getMarkConfig(property, model.markDef, model.config);
          value !== void 0 && (e[property] = signalOrValueRef(value));
        }
        property = {...e, ...color(model, {filled:_ref})};
        e = legendCmpt.get("symbolOpacity") ?? config.legend.symbolOpacity;
        var symbolFillColor = legendCmpt.get("symbolFillColor") ?? config.legend.symbolFillColor;
        value = legendCmpt.get("symbolStrokeColor") ?? config.legend.symbolStrokeColor;
        e = e === void 0 ? getMaxValue(encoding.opacity) ?? markDef.opacity : void 0;
        property.fill && (channel === "fill" || _ref && channel === "color" ? delete property.fill : hasProperty(property.fill, "field") ? symbolFillColor ? delete property.fill : (property.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? "black"), property.fillOpacity = signalOrValueRef(e ?? 1)) : vega.isArray(property.fill) && (symbolFillColor = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (_ref && markDef.color)) && (property.fill = signalOrValueRef(symbolFillColor)));
        property.stroke && (channel === "stroke" || !_ref && channel === "color" ? delete property.stroke : hasProperty(property.stroke, "field") || value ? delete property.stroke : vega.isArray(property.stroke) && (_ref = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, _ref ? markDef.color : void 0)) && (property.stroke = {value:_ref}));
        channel !== "opacity" && ((_ref = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef)) ? property.opacity = [{test:_ref, ...signalOrValueRef(e ?? 1)}, signalOrValueRef(config.legend.unselectedOpacity)] : e && (property.opacity = signalOrValueRef(e)));
        property = {...property, ...symbolsSpec};
        return isEmpty(property) ? void 0 : property;
      }
    }, gradient:function(gradientSpec, _ref2) {
      let {model, legendType, legendCmpt} = _ref2;
      if (legendType === "gradient") {
        var {config, markDef, encoding} = model;
        _ref2 = {};
        var opacity = (legendCmpt.get("gradientOpacity") ?? config.legend.gradientOpacity) === void 0 ? getMaxValue(encoding.opacity) || markDef.opacity : void 0;
        opacity && (_ref2.opacity = signalOrValueRef(opacity));
        _ref2 = {..._ref2, ...gradientSpec};
        return isEmpty(_ref2) ? void 0 : _ref2;
      }
    }, labels:function(specifiedlabelsSpec, _ref3) {
      let {fieldOrDatumDef, model, channel, legendCmpt} = _ref3;
      var legend = model.legend(channel) || {};
      _ref3 = model.config;
      var condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
      condition = condition ? [{test:condition, value:1}, {value:_ref3.legend.unselectedOpacity}] : void 0;
      const {format, formatType} = legend;
      legend = void 0;
      isCustomFormatType(formatType) ? legend = formatCustomType({fieldOrDatumDef, field:"datum.value", format, formatType, config:_ref3}) : format === void 0 && formatType === void 0 && _ref3.customFormatTypes && (fieldOrDatumDef.type === "quantitative" && _ref3.numberFormatType ? legend = formatCustomType({fieldOrDatumDef, field:"datum.value", format:_ref3.numberFormat, formatType:_ref3.numberFormatType, config:_ref3}) : fieldOrDatumDef.type === "temporal" && _ref3.timeFormatType && isFieldDef(fieldOrDatumDef) && 
      fieldOrDatumDef.timeUnit === void 0 && (legend = formatCustomType({fieldOrDatumDef, field:"datum.value", format:_ref3.timeFormat, formatType:_ref3.timeFormatType, config:_ref3})));
      specifiedlabelsSpec = {...(condition ? {opacity:condition} : {}), ...(legend ? {text:legend} : {}), ...specifiedlabelsSpec};
      return isEmpty(specifiedlabelsSpec) ? void 0 : specifiedlabelsSpec;
    }, entries:function(entriesSpec, _ref4) {
      ({legendCmpt:_ref4} = _ref4);
      return _ref4.get("selections")?.length ? {...entriesSpec, fill:{value:"transparent"}} : entriesSpec;
    }}, legendRules = {direction:_ref => {
      ({direction:_ref} = _ref);
      return _ref;
    }, format:_ref2 => {
      let {fieldOrDatumDef, legend, config} = _ref2;
      const {format, formatType} = legend;
      return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, !1);
    }, formatType:_ref3 => {
      let {legend, fieldOrDatumDef, scaleType} = _ref3;
      ({formatType:_ref3} = legend);
      return guideFormatType(_ref3, fieldOrDatumDef, scaleType);
    }, gradientLength:params => {
      const {legend, legendConfig} = params;
      var JSCompiler_temp;
      if ((JSCompiler_temp = legend.gradientLength ?? legendConfig.gradientLength) != null) {
        params = JSCompiler_temp;
      } else {
        {
          let {legendConfig, model, direction, orient, scaleType} = params;
          const {gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength} = legendConfig;
          params = CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType) ? direction === "horizontal" ? orient === "top" || orient === "bottom" ? {signal:`clamp(${model.getSizeSignalRef("width").signal}, ${gradientHorizontalMinLength}, ${gradientHorizontalMaxLength})`} : gradientHorizontalMinLength : {signal:`clamp(${model.getSizeSignalRef("height").signal}, ${gradientVerticalMinLength}, ${gradientVerticalMaxLength})`} : void 0;
        }
      }
      return params;
    }, labelOverlap:_ref4 => {
      let {legend, legendConfig, scaleType} = _ref4;
      (_ref4 = legend.labelOverlap ?? legendConfig.labelOverlap) == null && (_ref4 = contains(["quantile", "threshold", "log", "symlog"], scaleType) ? "greedy" : void 0);
      return _ref4;
    }, symbolType:_ref5 => {
      let {legend, markDef, channel, encoding} = _ref5;
      if ((_ref5 = legend.symbolType) == null) {
        a: {
          _ref5 = markDef.type;
          var shapeChannelDef = encoding.shape, markShape = markDef.shape;
          if (channel !== "shape" && (shapeChannelDef = getFirstConditionValue(shapeChannelDef) ?? markShape)) {
            _ref5 = shapeChannelDef;
            break a;
          }
          switch(_ref5) {
            case "bar":
            case "rect":
            case "image":
            case "square":
              _ref5 = "square";
              break a;
            case "line":
            case "trail":
            case "rule":
              _ref5 = "stroke";
              break a;
            case "arc":
            case "point":
            case "circle":
            case "tick":
            case "geoshape":
            case "area":
            case "text":
              _ref5 = "circle";
              break a;
          }
          _ref5 = void 0;
        }
      }
      return _ref5;
    }, title:_ref6 => {
      let {fieldOrDatumDef, config} = _ref6;
      return title(fieldOrDatumDef, config, {allowDisabling:!0});
    }, type:_ref7 => {
      let {legendType, scaleType, channel} = _ref7;
      if (isColorChannel(channel) && CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)) {
        if (legendType === "gradient") {
          return;
        }
      } else if (legendType === "symbol") {
        return;
      }
      return legendType;
    }, values:_ref8 => {
      let {fieldOrDatumDef, legend} = _ref8;
      _ref8 = legend.values;
      _ref8 = vega.isArray(_ref8) ? valueArray(fieldOrDatumDef, _ref8) : isSignalRef(_ref8) ? _ref8 : void 0;
      return _ref8;
    }}, PROJECTION_PROPERTIES = "type clipAngle clipExtent center rotate precision reflectX reflectY coefficient distance fraction lobes parallel radius ratio spacing tilt".split(" ");
    class ProjectionComponent extends Split {
      merged=!1;
      constructor(name, specifiedProjection, size, data) {
        super({...specifiedProjection}, {name});
        this.specifiedProjection = specifiedProjection;
        this.size = size;
        this.data = data;
      }
      get isFit() {
        return !!this.data;
      }
    }
    class BinNode extends DataFlowNode {
      clone() {
        return new BinNode(null, duplicate(this.bins));
      }
      constructor(parent, bins) {
        super(parent);
        this.bins = bins;
      }
      static makeFromEncoding(parent, model) {
        const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
          if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
            const {key, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);
            var JSCompiler_temp_const = {...binComponentIndex[key]};
            var config = model.config;
            if (binRequiresRange(fieldDef, channel)) {
              channel = isUnitModel(model) ? model.axis(channel) ?? model.legend(channel) ?? {} : {};
              const startField = vgField(fieldDef, {expr:"datum"}), endField = vgField(fieldDef, {expr:"datum", binSuffix:"end"});
              fieldDef = {formulaAs:vgField(fieldDef, {binSuffix:"range", forAs:!0}), formula:binFormatExpression(startField, endField, channel.format, channel.formatType, config)};
            } else {
              fieldDef = {};
            }
            binComponentIndex[key] = {...binComponent, ...JSCompiler_temp_const, ...fieldDef};
          }
          return binComponentIndex;
        }, {});
        return isEmpty(bins) ? null : new BinNode(parent, bins);
      }
      static makeFromTransform(parent, t, model) {
        const {key, binComponent} = createBinComponent(t, t.bin, model);
        return new BinNode(parent, {[key]:binComponent});
      }
      merge(other, renameSignal) {
        for (const key of keys(other.bins)) {
          key in this.bins ? (renameSignal(other.bins[key].signal, this.bins[key].signal), this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash)) : this.bins[key] = other.bins[key];
        }
        for (const child of other.children) {
          other.removeChild(child), child.parent = this;
        }
        other.remove();
      }
      producedFields() {
        return new Set(vals(this.bins).map(c => c.as).flat(2));
      }
      dependentFields() {
        return new Set(vals(this.bins).map(c => c.field));
      }
      hash() {
        return `Bin ${hash(this.bins)}`;
      }
      assemble() {
        return vals(this.bins).flatMap(bin => {
          const transform = [], [binAs, ...remainingAs] = bin.as, {extent, ...params} = bin.bin;
          var binTrans = {type:"bin", field:replacePathInField(bin.field), as:binAs, signal:bin.signal, ...(hasProperty(extent, "param") ? {extent:null} : {extent}), ...(bin.span ? {span:{signal:`span(${bin.span})`}} : {}), ...params};
          !extent && bin.extentSignal && (transform.push({type:"extent", field:replacePathInField(bin.field), signal:bin.extentSignal}), binTrans.extent = {signal:bin.extentSignal});
          transform.push(binTrans);
          for (const as of remainingAs) {
            for (binTrans = 0; binTrans < 2; binTrans++) {
              transform.push({type:"formula", expr:vgField({field:binAs[binTrans]}, {expr:"datum"}), as:as[binTrans]});
            }
          }
          bin.formula && transform.push({type:"formula", expr:bin.formula, as:bin.formulaAs});
          return transform;
        });
      }
    }
    class AggregateNode extends DataFlowNode {
      clone() {
        return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
      }
      constructor(parent, dimensions, measures) {
        super(parent);
        this.dimensions = dimensions;
        this.measures = measures;
      }
      get groupBy() {
        return this.dimensions;
      }
      static makeFromEncoding(parent, model) {
        let isAggregate = !1;
        model.forEachFieldDef(fd => {
          fd.aggregate && (isAggregate = !0);
        });
        const meas = {}, dims = new Set();
        if (!isAggregate) {
          return null;
        }
        model.forEachFieldDef((fieldDef, channel) => {
          const {aggregate, field} = fieldDef;
          if (aggregate) {
            if (aggregate === "count") {
              meas["*"] ?? (meas["*"] = {}), meas["*"].count = new Set([vgField(fieldDef, {forAs:!0})]);
            } else {
              if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
                fieldDef = isArgminDef(aggregate) ? "argmin" : "argmax";
                var argField = aggregate[fieldDef];
                meas[argField] ?? (meas[argField] = {});
                meas[argField][fieldDef] = new Set([vgField({op:fieldDef, field:argField}, {forAs:!0})]);
              } else {
                meas[field] ?? (meas[field] = {}), meas[field][aggregate] = new Set([vgField(fieldDef, {forAs:!0})]);
              }
              isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated" && (meas[field] ?? (meas[field] = {}), meas[field].min = new Set([vgField({field, aggregate:"min"}, {forAs:!0})]), meas[field].max = new Set([vgField({field, aggregate:"max"}, {forAs:!0})]));
            }
          } else {
            argField = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
            if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, argField, model.markDef, model.config)) {
              dims.add(vgField(fieldDef, {}));
              dims.add(vgField(fieldDef, {suffix:"end"}));
              const {mark, markDef, config} = model;
              argField = getBandPosition({fieldDef, markDef, config});
              isRectBasedMark(mark) && argField !== 0.5 && isXorY(channel) && (dims.add(vgField(fieldDef, {suffix:"offsetted_rect_start"})), dims.add(vgField(fieldDef, {suffix:"offsetted_rect_end"})));
              fieldDef.bin && binRequiresRange(fieldDef, channel) && dims.add(vgField(fieldDef, {binSuffix:"range"}));
            } else {
              vega.hasOwnProperty(GEO_POSIITON_CHANNEL_INDEX, channel) ? (channel = getPositionChannelFromLatLong(channel), dims.add(model.getName(channel))) : dims.add(vgField(fieldDef));
            }
            if (channel = isScaleFieldDef(fieldDef)) {
              channel = fieldDef.scale?.range, channel = vega.isObject(channel) && "field" in channel;
            }
            channel && dims.add(fieldDef.scale.range.field);
          }
        });
        return dims.size + keys(meas).length === 0 ? null : new AggregateNode(parent, dims, meas);
      }
      static makeFromTransform(parent, t) {
        const dims = new Set(), meas = {};
        for (const s of t.aggregate) {
          const {op, field, as} = s;
          if (op) {
            if (op === "count") {
              let $jscomp$logical$assign$tmp730812712$18;
              ($jscomp$logical$assign$tmp730812712$18 = meas)["*"] ?? ($jscomp$logical$assign$tmp730812712$18["*"] = {});
              meas["*"].count = new Set([as ? as : vgField(s, {forAs:!0})]);
            } else {
              let $jscomp$logical$assign$tmp730812712$19, $jscomp$logical$assign$tmpindex730812712$19;
              ($jscomp$logical$assign$tmp730812712$19 = meas)[$jscomp$logical$assign$tmpindex730812712$19 = field] ?? ($jscomp$logical$assign$tmp730812712$19[$jscomp$logical$assign$tmpindex730812712$19] = {});
              let $jscomp$logical$assign$tmp730812712$20, $jscomp$logical$assign$tmpindex730812712$20;
              ($jscomp$logical$assign$tmp730812712$20 = meas[field])[$jscomp$logical$assign$tmpindex730812712$20 = op] ?? ($jscomp$logical$assign$tmp730812712$20[$jscomp$logical$assign$tmpindex730812712$20] = new Set());
              meas[field][op].add(as ? as : vgField(s, {forAs:!0}));
            }
          }
        }
        for (const s of t.groupby ?? []) {
          dims.add(s);
        }
        return dims.size + keys(meas).length === 0 ? null : new AggregateNode(parent, dims, meas);
      }
      merge(other) {
        if (setEqual(this.dimensions, other.dimensions)) {
          var parentMeasures = this.measures;
          other = other.measures;
          for (const field of keys(other)) {
            const ops = other[field];
            for (const op of keys(ops)) {
              field in parentMeasures ? parentMeasures[field][op] = new Set([...(parentMeasures[field][op] ?? []), ...ops[op]]) : parentMeasures[field] = {[op]:ops[op]};
            }
          }
          return !0;
        }
        debug("different dimensions, cannot merge");
        return !1;
      }
      addDimensions(fields) {
        fields.forEach(this.dimensions.add, this.dimensions);
      }
      dependentFields() {
        return new Set([...this.dimensions, ...keys(this.measures)]);
      }
      producedFields() {
        const out = new Set();
        for (const field of keys(this.measures)) {
          for (const op of keys(this.measures[field])) {
            const m = this.measures[field][op];
            m.size === 0 ? out.add(`${op}_${field}`) : m.forEach(out.add, out);
          }
        }
        return out;
      }
      hash() {
        return `Aggregate ${hash({dimensions:this.dimensions, measures:this.measures})}`;
      }
      assemble() {
        const ops = [], fields = [], as = [];
        for (const field of keys(this.measures)) {
          for (const op of keys(this.measures[field])) {
            for (const alias of this.measures[field][op]) {
              as.push(alias), ops.push(op), fields.push(field === "*" ? null : replacePathInField(field));
            }
          }
        }
        return {type:"aggregate", groupby:[...this.dimensions].map(replacePathInField), ops, fields, as};
      }
    }
    class FacetNode extends DataFlowNode {
      constructor(parent, model, name, data) {
        super(parent);
        this.model = model;
        this.name = name;
        this.data = data;
        for (const channel of FACET_CHANNELS) {
          if (parent = model.facet[channel]) {
            const {bin, sort} = parent;
            this[channel] = {name:model.getName(`${channel}_domain`), fields:[vgField(parent), ...(isBinning(bin) ? [vgField(parent, {binSuffix:"end"})] : [])], ...(isSortField(sort) ? {sortField:sort} : vega.isArray(sort) ? {sortIndexField:sortArrayIndexField(parent, channel)} : {})};
          }
        }
        this.childModel = model.child;
      }
      hash() {
        let out = "Facet";
        for (const channel of FACET_CHANNELS) {
          this[channel] && (out += ` ${channel.charAt(0)}:${hash(this[channel])}`);
        }
        return out;
      }
      get fields() {
        const f = [];
        for (const channel of FACET_CHANNELS) {
          this[channel]?.fields && f.push(...this[channel].fields);
        }
        return f;
      }
      dependentFields() {
        const depFields = new Set(this.fields);
        for (const channel of FACET_CHANNELS) {
          this[channel] && (this[channel].sortField && depFields.add(this[channel].sortField.field), this[channel].sortIndexField && depFields.add(this[channel].sortIndexField));
        }
        return depFields;
      }
      producedFields() {
        return new Set();
      }
      getSource() {
        return this.name;
      }
      getChildIndependentFieldsWithStep() {
        const childIndependentFieldsWithStep = {};
        for (const channel of POSITION_SCALE_CHANNELS) {
          var childScaleComponent = this.childModel.component.scales[channel];
          if (childScaleComponent && !childScaleComponent.merged) {
            var type = childScaleComponent.get("type");
            childScaleComponent = childScaleComponent.get("range");
            hasDiscreteDomain(type) && isVgRangeStep(childScaleComponent) && (type = assembleDomain(this.childModel, channel), (type = getFieldFromDomain(type)) ? childIndependentFieldsWithStep[channel] = type : warn(unknownField(channel)));
          }
        }
        return childIndependentFieldsWithStep;
      }
      assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
        const childChannel = {row:"y", column:"x", facet:void 0}[channel], fields = [], ops = [], as = [];
        childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel] && (crossedDataName ? (fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`), ops.push("max")) : (fields.push(childIndependentFieldsWithStep[childChannel]), ops.push("distinct")), as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`));
        const {sortField, sortIndexField} = this[channel];
        if (sortField) {
          const {op = "min", field} = sortField;
          fields.push(field);
          ops.push(op);
          as.push(vgField(sortField, {forAs:!0}));
        } else {
          sortIndexField && (fields.push(sortIndexField), ops.push("max"), as.push(sortIndexField));
        }
        return {name:this[channel].name, source:crossedDataName ?? this.data, transform:[{type:"aggregate", groupby:this[channel].fields, ...(fields.length ? {fields, ops, as} : {})}]};
      }
      assembleFacetHeaderData(childIndependentFieldsWithStep) {
        const {columns} = this.model.layout, {layoutHeaders} = this.model.component, data = [], hasSharedAxis = {};
        for (const headerChannel of HEADER_CHANNELS) {
          for (const headerType of HEADER_TYPES) {
            var headers = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) ?? [];
            for (const header of headers) {
              if (header.axes?.length > 0) {
                hasSharedAxis[headerChannel] = !0;
                break;
              }
            }
          }
          hasSharedAxis[headerChannel] && (headers = `length(data("${this.facet.name}"))`, data.push({name:`${this.facet.name}_${headerChannel}`, transform:[{type:"sequence", start:0, stop:headerChannel === "row" ? columns ? {signal:`ceil(${headers} / ${columns})`} : 1 : columns ? {signal:`min(${headers}, ${columns})`} : {signal:headers}}]}));
        }
        const {row, column} = hasSharedAxis;
        (row || column) && data.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
        return data;
      }
      assemble() {
        const data = [];
        var crossedDataName = null;
        const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep(), {column, row, facet} = this;
        if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
          crossedDataName = `cross_${this.column.name}_${this.row.name}`;
          const fields = [].concat(childIndependentFieldsWithStep.x ?? [], childIndependentFieldsWithStep.y ?? []), ops = fields.map(() => "distinct");
          data.push({name:crossedDataName, source:this.data, transform:[{type:"aggregate", groupby:this.fields, fields, ops}]});
        }
        for (const channel of ["column", "row"]) {
          this[channel] && data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
        }
        facet && (crossedDataName = this.assembleFacetHeaderData(childIndependentFieldsWithStep)) && data.push(...crossedDataName);
        return data;
      }
    }
    class ParseNode extends DataFlowNode {
      clone() {
        return new ParseNode(null, duplicate(this._parse));
      }
      constructor(parent, parse) {
        super(parent);
        this._parse = parse;
      }
      hash() {
        return `Parse ${hash(this._parse)}`;
      }
      static makeExplicit(parent, model, ancestorParse) {
        let explicit = {};
        model = model.data;
        !isGenerator(model) && model?.format?.parse && (explicit = model.format.parse);
        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
      }
      static makeWithAncestors(parent, explicit, implicit, ancestorParse) {
        for (var field of keys(implicit)) {
          const parsedAs = ancestorParse.getWithExplicit(field);
          parsedAs.value !== void 0 && (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === "derived" || implicit[field] === "flatten" ? delete implicit[field] : warn(differentParse(field, implicit[field], parsedAs.value)));
        }
        for (var field$jscomp$0 of keys(explicit)) {
          field = ancestorParse.get(field$jscomp$0), field !== void 0 && (field === explicit[field$jscomp$0] ? delete explicit[field$jscomp$0] : warn(differentParse(field$jscomp$0, explicit[field$jscomp$0], field)));
        }
        explicit = new Split(explicit, implicit);
        ancestorParse.copyAll(explicit);
        implicit = {};
        for (const key of keys(explicit.combine())) {
          field$jscomp$0 = explicit.get(key), field$jscomp$0 !== null && (implicit[key] = field$jscomp$0);
        }
        return keys(implicit).length === 0 || ancestorParse.parseNothing ? null : new ParseNode(parent, implicit);
      }
      get parse() {
        return this._parse;
      }
      merge(other) {
        this._parse = {...this._parse, ...other.parse};
        other.remove();
      }
      assembleFormatParse() {
        const formatParse = {};
        for (const field of keys(this._parse)) {
          const p = this._parse[field];
          accessPathDepth(field) === 1 && (formatParse[field] = p);
        }
        return formatParse;
      }
      producedFields() {
        return new Set(keys(this._parse));
      }
      dependentFields() {
        return new Set(keys(this._parse));
      }
      assembleTransforms() {
        let onlyNested = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        return keys(this._parse).filter(field => onlyNested ? accessPathDepth(field) > 1 : !0).map(field => {
          const expr = parseExpression(field, this._parse[field]);
          return expr ? {type:"formula", expr, as:removePathFromField(field)} : null;
        }).filter(t => t !== null);
      }
    }
    class IdentifierNode extends DataFlowNode {
      clone() {
        return new IdentifierNode(null);
      }
      constructor(parent) {
        super(parent);
      }
      dependentFields() {
        return new Set();
      }
      producedFields() {
        return new Set(["_vgsid_"]);
      }
      hash() {
        return "Identifier";
      }
      assemble() {
        return {type:"identifier", as:"_vgsid_"};
      }
    }
    class GraticuleNode extends DataFlowNode {
      clone() {
        return new GraticuleNode(null, this.params);
      }
      constructor(parent, params) {
        super(parent);
        this.params = params;
      }
      dependentFields() {
        return new Set();
      }
      producedFields() {
      }
      hash() {
        return `Graticule ${hash(this.params)}`;
      }
      assemble() {
        return {type:"graticule", ...(this.params === !0 ? {} : this.params)};
      }
    }
    class SequenceNode extends DataFlowNode {
      clone() {
        return new SequenceNode(null, this.params);
      }
      constructor(parent, params) {
        super(parent);
        this.params = params;
      }
      dependentFields() {
        return new Set();
      }
      producedFields() {
        return new Set([this.params.as ?? "data"]);
      }
      hash() {
        return `Hash ${hash(this.params)}`;
      }
      assemble() {
        return {type:"sequence", ...this.params};
      }
    }
    class SourceNode extends DataFlowNode {
      constructor(data) {
        super(null);
        data ??= {name:"source"};
        let format;
        isGenerator(data) || (format = data.format ? {...omit(data.format, ["parse"])} : {});
        if (isInlineData(data)) {
          this._data = {values:data.values};
        } else if (hasProperty(data, "url")) {
          if (this._data = {url:data.url}, !format.type) {
            let defaultExtension = /(?:\.([^.]+))?$/.exec(data.url)[1];
            contains(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension) || (defaultExtension = "json");
            format.type = defaultExtension;
          }
        } else if (hasProperty(data, "sphere")) {
          this._data = {values:[{type:"Sphere"}]};
        } else if (isNamedData(data) || isGenerator(data)) {
          this._data = {};
        }
        this._generator = isGenerator(data);
        data.name && (this._name = data.name);
        format && !isEmpty(format) && (this._data.format = format);
      }
      dependentFields() {
        return new Set();
      }
      producedFields() {
      }
      get data() {
        return this._data;
      }
      hasName() {
        return !!this._name;
      }
      get isGenerator() {
        return this._generator;
      }
      get dataName() {
        return this._name;
      }
      set dataName(name) {
        this._name = name;
      }
      set parent(parent) {
        throw Error("Source nodes have to be roots.");
      }
      remove() {
        throw Error("Source nodes are roots and cannot be removed.");
      }
      hash() {
        throw Error("Cannot hash sources");
      }
      assemble() {
        return {name:this._name, ...this._data, transform:[]};
      }
    }
    class Optimizer {
      #modified;
      constructor() {
        this.#modified = !1;
      }
      setModified() {
        this.#modified = !0;
      }
      get modifiedFlag() {
        return this.#modified;
      }
    }
    class BottomUpOptimizer extends Optimizer {
      getNodeDepths(node, depth, depths) {
        depths.set(node, depth);
        for (const child of node.children) {
          this.getNodeDepths(child, depth + 1, depths);
        }
        return depths;
      }
      optimize(node) {
        node = [...this.getNodeDepths(node, 0, new Map()).entries()].sort((a, b) => b[1] - a[1]);
        for (const tuple of node) {
          this.run(tuple[0]);
        }
        return this.modifiedFlag;
      }
    }
    class TopDownOptimizer extends Optimizer {
      optimize(node) {
        this.run(node);
        for (const child of node.children) {
          this.optimize(child);
        }
        return this.modifiedFlag;
      }
    }
    class MergeIdenticalNodes extends TopDownOptimizer {
      mergeNodes(parent, nodes) {
        const mergedNode = nodes.shift();
        for (const node of nodes) {
          parent.removeChild(node), node.parent = mergedNode, node.remove();
        }
      }
      run(node) {
        const hashes = node.children.map(x => x.hash()), buckets = {};
        for (let i = 0; i < hashes.length; i++) {
          buckets[hashes[i]] === void 0 ? buckets[hashes[i]] = [node.children[i]] : buckets[hashes[i]].push(node.children[i]);
        }
        for (const k of keys(buckets)) {
          buckets[k].length > 1 && (this.setModified(), this.mergeNodes(node, buckets[k]));
        }
      }
    }
    class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {
      constructor(model) {
        super();
        this.requiresSelectionId = model && requiresSelectionId(model);
      }
      run(node) {
        !(node instanceof IdentifierNode) || this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode) || (this.setModified(), node.remove());
      }
    }
    class RemoveDuplicateTimeUnits extends Optimizer {
      optimize(node) {
        this.run(node, new Set());
        return this.modifiedFlag;
      }
      run(node, timeUnitFields) {
        let producedFields = new Set();
        node instanceof TimeUnitNode && (producedFields = node.producedFields(), hasIntersection(producedFields, timeUnitFields) && (this.setModified(), node.removeFormulas(timeUnitFields), node.producedFields.length === 0 && node.remove()));
        for (const child of node.children) {
          this.run(child, new Set([...timeUnitFields, ...producedFields]));
        }
      }
    }
    class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {
      constructor() {
        super();
      }
      run(node) {
        node instanceof OutputNode && !node.isRequired() && (this.setModified(), node.remove());
      }
    }
    class MoveParseUp extends BottomUpOptimizer {
      run(node) {
        if (!(isDataSourceNode(node) || node.numChildren() > 1)) {
          for (const child of node.children) {
            child instanceof ParseNode && (node instanceof ParseNode ? (this.setModified(), node.merge(child)) : fieldIntersection(node.producedFields(), child.dependentFields()) || (this.setModified(), child.swapWithParent()));
          }
        }
      }
    }
    class MergeParse extends BottomUpOptimizer {
      run(node) {
        const originalChildren = [...node.children];
        var parseChildren = node.children.filter(child => child instanceof ParseNode);
        if (node.numChildren() > 1 && parseChildren.length >= 1) {
          const commonParse = {};
          var conflictingParse = new Set();
          for (const parseNode of parseChildren) {
            parseChildren = parseNode.parse;
            for (const k of keys(parseChildren)) {
              k in commonParse ? commonParse[k] !== parseChildren[k] && conflictingParse.add(k) : commonParse[k] = parseChildren[k];
            }
          }
          for (const field of conflictingParse) {
            delete commonParse[field];
          }
          if (!isEmpty(commonParse)) {
            this.setModified();
            conflictingParse = new ParseNode(node, commonParse);
            for (const childNode of originalChildren) {
              if (childNode instanceof ParseNode) {
                for (const key of keys(commonParse)) {
                  delete childNode.parse[key];
                }
              }
              node.removeChild(childNode);
              childNode.parent = conflictingParse;
              childNode instanceof ParseNode && keys(childNode.parse).length === 0 && childNode.remove();
            }
          }
        }
      }
    }
    class RemoveUnusedSubtrees extends BottomUpOptimizer {
      run(node) {
        node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode || node instanceof SourceNode || (this.setModified(), node.remove());
      }
    }
    class MergeTimeUnits extends BottomUpOptimizer {
      run(node) {
        node = node.children.filter(x => x instanceof TimeUnitNode);
        const combination = node.pop();
        for (const timeUnit of node) {
          this.setModified(), combination.merge(timeUnit);
        }
      }
    }
    class MergeAggregates extends BottomUpOptimizer {
      run(node) {
        var aggChildren = node.children.filter(child => child instanceof AggregateNode);
        const groupedAggregates = {};
        for (var agg$jscomp$0 of aggChildren) {
          aggChildren = hash(agg$jscomp$0.groupBy), aggChildren in groupedAggregates || (groupedAggregates[aggChildren] = []), groupedAggregates[aggChildren].push(agg$jscomp$0);
        }
        for (const group of keys(groupedAggregates)) {
          if (agg$jscomp$0 = groupedAggregates[group], agg$jscomp$0.length > 1) {
            aggChildren = agg$jscomp$0.pop();
            for (const agg of agg$jscomp$0) {
              aggChildren.merge(agg) && (node.removeChild(agg), agg.parent = aggChildren, agg.remove(), this.setModified());
            }
          }
        }
      }
    }
    class MergeBins extends BottomUpOptimizer {
      constructor(model) {
        super();
        this.model = model;
      }
      run(node) {
        var moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);
        const promotableBins = [], remainingBins = [];
        for (const child of node.children) {
          child instanceof BinNode && (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields()) ? promotableBins.push(child) : remainingBins.push(child));
        }
        if (promotableBins.length > 0) {
          moveBinsUp = promotableBins.pop();
          for (const bin of promotableBins) {
            moveBinsUp.merge(bin, this.model.renameSignal.bind(this.model));
          }
          this.setModified();
          node instanceof BinNode ? node.merge(moveBinsUp, this.model.renameSignal.bind(this.model)) : moveBinsUp.swapWithParent();
        }
        if (remainingBins.length > 1) {
          node = remainingBins.pop();
          for (const bin of remainingBins) {
            node.merge(bin, this.model.renameSignal.bind(this.model));
          }
          this.setModified();
        }
      }
    }
    class MergeOutputs extends BottomUpOptimizer {
      run(node) {
        var children = [...node.children];
        if (some(children, child => child instanceof OutputNode) && !(node.numChildren() <= 1)) {
          var otherChildren = [];
          for (const child of children) {
            if (child instanceof OutputNode) {
              for (children = child; children.numChildren() === 1;) {
                const [theChild] = children.children;
                if (theChild instanceof OutputNode) {
                  children = theChild;
                } else {
                  break;
                }
              }
              otherChildren.push(...children.children);
              if (mainOutput) {
                node.removeChild(child), child.parent = mainOutput.parent, mainOutput.parent.removeChild(mainOutput), mainOutput.parent = children, this.setModified();
              } else {
                var mainOutput = children;
              }
            } else {
              otherChildren.push(child);
            }
          }
          if (otherChildren.length) {
            this.setModified();
            for (const child of otherChildren) {
              child.parent.removeChild(child), child.parent = mainOutput;
            }
          }
        }
      }
    }
    class JoinAggregateTransformNode extends DataFlowNode {
      clone() {
        return new JoinAggregateTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
      }
      addDimensions(fields) {
        this.transform.groupby = unique(this.transform.groupby.concat(fields), d => d);
      }
      dependentFields() {
        const out = new Set();
        this.transform.groupby && this.transform.groupby.forEach(out.add, out);
        this.transform.joinaggregate.map(w => w.field).filter(f => f !== void 0).forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this.transform.joinaggregate.map(this.getDefaultName));
      }
      getDefaultName(joinAggregateFieldDef) {
        return joinAggregateFieldDef.as ?? vgField(joinAggregateFieldDef);
      }
      hash() {
        return `JoinAggregateTransform ${hash(this.transform)}`;
      }
      assemble() {
        const fields = [], ops = [], as = [];
        for (var joinaggregate of this.transform.joinaggregate) {
          ops.push(joinaggregate.op), as.push(this.getDefaultName(joinaggregate)), fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
        }
        joinaggregate = this.transform.groupby;
        return {type:"joinaggregate", as, ops, fields, ...(joinaggregate !== void 0 ? {groupby:joinaggregate} : {})};
      }
    }
    class FilterInvalidNode extends DataFlowNode {
      clone() {
        return new FilterInvalidNode(null, {...this.filter});
      }
      constructor(parent, filter) {
        super(parent);
        this.filter = filter;
      }
      static make(parent, model, dataSourcesForHandlingInvalidValues) {
        const {config, markDef} = model, {marks, scales} = dataSourcesForHandlingInvalidValues;
        if (marks === "include-invalid-values" && scales === "include-invalid-values") {
          return null;
        }
        dataSourcesForHandlingInvalidValues = model.reduceFieldDef((aggregator, fieldDef, channel) => {
          var scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
          if (scaleComponent) {
            scaleComponent = scaleComponent.get("type");
            const {aggregate} = fieldDef;
            channel = getScaleInvalidDataMode({scaleChannel:channel, markDef, config, scaleType:scaleComponent, isCountAggregate:isCountingAggregateOp(aggregate)});
            channel !== "show" && channel !== "always-valid" && (aggregator[fieldDef.field] = fieldDef);
          }
          return aggregator;
        }, {});
        return keys(dataSourcesForHandlingInvalidValues).length ? new FilterInvalidNode(parent, dataSourcesForHandlingInvalidValues) : null;
      }
      dependentFields() {
        return new Set(keys(this.filter));
      }
      producedFields() {
        return new Set();
      }
      hash() {
        return `FilterInvalid ${hash(this.filter)}`;
      }
      assemble() {
        const filters = keys(this.filter).reduce((vegaFilters, field) => {
          field = this.filter[field];
          const ref = vgField(field, {expr:"datum"});
          field !== null && (field.type === "temporal" ? vegaFilters.push(`(isDate(${ref}) || (${isValidFiniteNumberExpr(ref)}))`) : field.type === "quantitative" && vegaFilters.push(isValidFiniteNumberExpr(ref)));
          return vegaFilters;
        }, []);
        return filters.length > 0 ? {type:"filter", expr:filters.join(" \x26\x26 ")} : null;
      }
    }
    class StackNode extends DataFlowNode {
      clone() {
        return new StackNode(null, duplicate(this._stack));
      }
      constructor(parent, stack) {
        super(parent);
        this._stack = stack;
      }
      static makeFromTransform(parent, stackTransform) {
        const {stack, groupby, as, offset = "zero"} = stackTransform;
        var sortFields = [];
        const sortOrder = [];
        if (stackTransform.sort !== void 0) {
          for (const sortField of stackTransform.sort) {
            sortFields.push(sortField.field), sortOrder.push(getFirstDefined(sortField.order, "ascending"));
          }
        }
        sortFields = {field:sortFields, order:sortOrder};
        stackTransform = isValidAsArray(as) ? as : vega.isString(as) ? [as, `${as}_end`] : [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];
        return new StackNode(parent, {dimensionFieldDefs:[], stackField:stack, groupby, offset, sort:sortFields, facetby:[], as:stackTransform});
      }
      static makeFromEncoding(parent, model) {
        var stackProperties = model.stack;
        const {encoding} = model;
        if (!stackProperties) {
          return null;
        }
        const {groupbyChannels, fieldChannel, offset, impute} = stackProperties;
        stackProperties = groupbyChannels.map(groupbyChannel => getFieldDef(encoding[groupbyChannel])).filter(def => !!def);
        const stackby = getStackByFields(model);
        var orderDef = model.encoding.order;
        if (vega.isArray(orderDef) || isFieldDef(orderDef)) {
          orderDef = sortParams(orderDef);
        } else {
          const sortOrder = hasProperty(orderDef, "sort") && !hasProperty(orderDef, "field") ? orderDef.sort : fieldChannel === "y" ? "descending" : "ascending";
          orderDef = stackby.reduce((s, field) => {
            s.field.includes(field) || (s.field.push(field), s.order.push(sortOrder));
            return s;
          }, {field:[], order:[]});
        }
        return new StackNode(parent, {dimensionFieldDefs:stackProperties, stackField:model.vgField(fieldChannel), facetby:[], stackby, sort:orderDef, offset, impute, as:[model.vgField(fieldChannel, {suffix:"start", forAs:!0}), model.vgField(fieldChannel, {suffix:"end", forAs:!0})]});
      }
      get stack() {
        return this._stack;
      }
      addDimensions(fields) {
        this._stack.facetby.push(...fields);
      }
      dependentFields() {
        const out = new Set();
        out.add(this._stack.stackField);
        this.getGroupbyFields().forEach(out.add, out);
        this._stack.facetby.forEach(out.add, out);
        this._stack.sort.field.forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this._stack.as);
      }
      hash() {
        return `Stack ${hash(this._stack)}`;
      }
      getGroupbyFields() {
        const {dimensionFieldDefs, impute, groupby} = this._stack;
        return dimensionFieldDefs.length > 0 ? dimensionFieldDefs.map(dimensionFieldDef => dimensionFieldDef.bin ? impute ? [vgField(dimensionFieldDef, {binSuffix:"mid"})] : [vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {binSuffix:"end"})] : [vgField(dimensionFieldDef)]).flat() : groupby ?? [];
      }
      assemble() {
        const transform = [], {facetby, dimensionFieldDefs, stackField:field, stackby, sort, offset, impute, as} = this._stack;
        if (impute) {
          for (const dimensionFieldDef of dimensionFieldDefs) {
            const {bandPosition = 0.5, bin} = dimensionFieldDef;
            if (bin) {
              const binStart = vgField(dimensionFieldDef, {expr:"datum"}), binEnd = vgField(dimensionFieldDef, {expr:"datum", binSuffix:"end"});
              transform.push({type:"formula", expr:`${isValidFiniteNumberExpr(binStart)} ? ${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd} : ${binStart}`, as:vgField(dimensionFieldDef, {binSuffix:"mid", forAs:!0})});
            }
            transform.push({type:"impute", field, groupby:[...stackby, ...facetby], key:vgField(dimensionFieldDef, {binSuffix:"mid"}), method:"value", value:0});
          }
        }
        transform.push({type:"stack", groupby:[...this.getGroupbyFields(), ...facetby], field, sort, as, offset});
        return transform;
      }
    }
    class WindowTransformNode extends DataFlowNode {
      clone() {
        return new WindowTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
      }
      addDimensions(fields) {
        this.transform.groupby = unique(this.transform.groupby.concat(fields), d => d);
      }
      dependentFields() {
        const out = new Set();
        (this.transform.groupby ?? []).forEach(out.add, out);
        (this.transform.sort ?? []).forEach(m => out.add(m.field));
        this.transform.window.map(w => w.field).filter(f => f !== void 0).forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this.transform.window.map(this.getDefaultName));
      }
      getDefaultName(windowFieldDef) {
        return windowFieldDef.as ?? vgField(windowFieldDef);
      }
      hash() {
        return `WindowTransform ${hash(this.transform)}`;
      }
      assemble() {
        const fields = [], ops = [], as = [], params = [];
        for (var window of this.transform.window) {
          ops.push(window.op), as.push(this.getDefaultName(window)), params.push(window.param === void 0 ? null : window.param), fields.push(window.field === void 0 ? null : window.field);
        }
        window = this.transform.frame;
        const groupby = this.transform.groupby;
        if (window && window[0] === null && window[1] === null && ops.every(o => isAggregateOp(o))) {
          return {type:"joinaggregate", as, ops, fields, ...(groupby !== void 0 ? {groupby} : {})};
        }
        const sortFields = [], sortOrder = [];
        if (this.transform.sort !== void 0) {
          for (var sortField of this.transform.sort) {
            sortFields.push(sortField.field), sortOrder.push(sortField.order ?? "ascending");
          }
        }
        sortField = this.transform.ignorePeers;
        return {type:"window", params, as, ops, fields, sort:{field:sortFields, order:sortOrder}, ...(sortField !== void 0 ? {ignorePeers:sortField} : {}), ...(groupby !== void 0 ? {groupby} : {}), ...(window !== void 0 ? {frame:window} : {})};
      }
    }
    class SignalRefWrapper {
      constructor(exprGenerator) {
        Object.defineProperty(this, "signal", {enumerable:!0, get:exprGenerator});
      }
      static fromName(rename, signalName) {
        return new SignalRefWrapper(() => rename(signalName));
      }
    }
    class ScaleComponent extends Split {
      merged=!1;
      constructor(name, typeWithExplicit) {
        super({}, {name});
        this.setWithExplicit("type", typeWithExplicit);
      }
      domainHasZero() {
        var scaleType = this.get("type");
        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {
          return "definitely-not";
        }
        var scaleZero = this.get("zero");
        if (scaleZero === !0 || scaleZero === void 0 && contains([ScaleType.LINEAR, ScaleType.SQRT, ScaleType.POW], scaleType)) {
          return "definitely";
        }
        var domains = this.get("domains");
        if (domains.length > 0) {
          let hasDomainBasedOnField = scaleZero = scaleType = !1;
          for (const d of domains) {
            if (vega.isArray(d)) {
              domains = d[0];
              const last = d[d.length - 1];
              if (vega.isNumber(domains) && vega.isNumber(last)) {
                domains <= 0 && last >= 0 ? scaleType = !0 : scaleZero = !0;
                continue;
              }
            }
            hasDomainBasedOnField = !0;
          }
          if (scaleType) {
            return "definitely";
          }
          if (scaleZero && !hasDomainBasedOnField) {
            return "definitely-not";
          }
        }
        return "maybe";
      }
    }
    const RANGE_PROPERTIES = ["range", "scheme"], scaleRules = {bins:_ref => {
      let {model, fieldOrDatumDef} = _ref;
      return isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0;
    }, interpolate:_ref2 => {
      let {channel, fieldOrDatumDef} = _ref2;
      _ref2 = fieldOrDatumDef.type;
      _ref2 = contains(["color", "fill", "stroke"], channel) && _ref2 !== "nominal" ? "hcl" : void 0;
      return _ref2;
    }, nice:_ref3 => {
      let {scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef} = _ref3;
      _ref3 = getFieldDef(fieldOrDatumDef)?.bin || vega.isArray(domain) || domainMax != null || domainMin != null || contains([ScaleType.TIME, ScaleType.UTC], scaleType) ? void 0 : isXorY(channel) ? !0 : void 0;
      return _ref3;
    }, padding:_ref4 => {
      let {channel, scaleType, fieldOrDatumDef, markDef, config} = _ref4;
      a: {
        _ref4 = config.scale;
        var barConfig = config.bar;
        if (isXorY(channel)) {
          if (CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)) {
            if (_ref4.continuousPadding !== void 0) {
              _ref4 = _ref4.continuousPadding;
              break a;
            }
            const {type, orient} = markDef;
            if (type === "bar" && (!isFieldDef(fieldOrDatumDef) || !fieldOrDatumDef.bin && !fieldOrDatumDef.timeUnit) && (orient === "vertical" && channel === "x" || orient === "horizontal" && channel === "y")) {
              _ref4 = barConfig.continuousBandSize;
              break a;
            }
          }
          if (scaleType === ScaleType.POINT) {
            _ref4 = _ref4.pointPadding;
            break a;
          }
        }
        _ref4 = void 0;
      }
      return _ref4;
    }, paddingInner:_ref5 => {
      let {scalePadding, channel, markDef, scaleType, config, hasNestedOffsetScale} = _ref5;
      return paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale);
    }, paddingOuter:_ref6 => {
      let {scalePadding, channel, scaleType, scalePaddingInner, config, hasNestedOffsetScale} = _ref6;
      return paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale);
    }, reverse:_ref7 => {
      let {fieldOrDatumDef, scaleType, channel, config} = _ref7;
      _ref7 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
      var scaleConfig = config.scale;
      _ref7 = channel === "x" && scaleConfig.xReverse !== void 0 ? hasContinuousDomain(scaleType) && _ref7 === "descending" ? isSignalRef(scaleConfig.xReverse) ? {signal:`!${scaleConfig.xReverse.signal}`} : !scaleConfig.xReverse : scaleConfig.xReverse : hasContinuousDomain(scaleType) && _ref7 === "descending" ? !0 : void 0;
      return _ref7;
    }, zero:_ref8 => {
      let {channel, fieldOrDatumDef, domain, markDef, scaleType, config, hasSecondaryRangeChannel} = _ref8;
      a: {
        if (_ref8 = config.scale, domain && domain !== "unaggregated" && hasContinuousDomain(scaleType)) {
          if (vega.isArray(domain)) {
            _ref8 = domain[0];
            const last = domain[domain.length - 1];
            if (vega.isNumber(_ref8) && _ref8 <= 0 && vega.isNumber(last) && last >= 0) {
              _ref8 = !0;
              break a;
            }
          }
          _ref8 = !1;
        } else {
          if (channel !== "size" || fieldOrDatumDef.type !== "quantitative" || CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)) {
            if (isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.bin || !contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
              _ref8 = !1;
            } else {
              const {orient, type} = markDef;
              _ref8 = contains(["bar", "area", "line", "trail"], type) && (orient === "horizontal" && channel === "y" || orient === "vertical" && channel === "x") ? !1 : contains(["bar", "area"], type) && !hasSecondaryRangeChannel ? !0 : _ref8?.zero;
            }
          } else {
            _ref8 = !0;
          }
        }
      }
      return _ref8;
    }}, scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => SCALE_PRECEDENCE_INDEX[st1] - SCALE_PRECEDENCE_INDEX[st2]);
    class NameMap {
      constructor() {
        this.nameMap = {};
      }
      rename(oldName, newName) {
        this.nameMap[oldName] = newName;
      }
      has(name) {
        return this.nameMap[name] !== void 0;
      }
      get(name) {
        for (; this.nameMap[name] && name !== this.nameMap[name];) {
          name = this.nameMap[name];
        }
        return name;
      }
    }
    class Model {
      constructor(spec, type, parent, parentGivenName, config, resolve, view) {
        this.type = type;
        this.parent = parent;
        this.config = config;
        this.parent = parent;
        this.config = config;
        this.view = replaceExprRef(view);
        this.name = spec.name ?? parentGivenName;
        this.title = isText(spec.title) ? {text:spec.title} : spec.title ? replaceExprRef(spec.title) : void 0;
        this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
        this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
        this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
        this.data = spec.data;
        this.description = spec.description;
        this.transforms = normalizeTransform(spec.transform ?? []);
        if (type === "layer" || type === "unit") {
          var JSCompiler_temp = {};
        } else {
          parentGivenName = {};
          const {spacing:spacingConfig, columns} = config[type];
          spacingConfig !== void 0 && (parentGivenName.spacing = spacingConfig);
          columns !== void 0 && (hasProperty(spec, "facet") && !isFacetMapping(spec.facet) || hasProperty(spec, "concat")) && (parentGivenName.columns = columns);
          hasProperty(spec, "vconcat") && (parentGivenName.columns = 1);
          for (JSCompiler_temp of COMPOSITION_LAYOUT_PROPERTIES) {
            spec[JSCompiler_temp] !== void 0 && (JSCompiler_temp === "spacing" ? (type = spec[JSCompiler_temp], parentGivenName[JSCompiler_temp] = vega.isNumber(type) ? type : {row:type.row ?? spacingConfig, column:type.column ?? spacingConfig}) : parentGivenName[JSCompiler_temp] = spec[JSCompiler_temp]);
          }
          JSCompiler_temp = parentGivenName;
        }
        this.layout = JSCompiler_temp;
        this.component = {data:{sources:parent ? parent.component.data.sources : [], outputNodes:parent ? parent.component.data.outputNodes : {}, outputNodeRefCounts:parent ? parent.component.data.outputNodeRefCounts : {}, isFaceted:hasProperty(spec, "facet") || parent?.component.data.isFaceted && spec.data === void 0}, layoutSize:new Split(), layoutHeaders:{row:{}, column:{}, facet:{}}, mark:null, resolve:{scale:{}, axis:{}, legend:{}, ...(resolve ? duplicate(resolve) : {})}, selection:null, scales:null, 
        projection:null, axes:{}, legends:{}};
      }
      get width() {
        return this.getSizeSignalRef("width");
      }
      get height() {
        return this.getSizeSignalRef("height");
      }
      parse() {
        this.parseScale();
        this.parseLayoutSize();
        this.renameTopLevelLayoutSizeSignal();
        this.parseSelections();
        this.parseProjection();
        this.parseData();
        this.parseAxesAndHeaders();
        this.parseLegends();
        this.parseMarkGroup();
      }
      parseScale() {
        parseScales(this);
      }
      parseProjection() {
        this.component.projection = isUnitModel(this) ? parseUnitProjection(this) : parseNonUnitProjections(this);
      }
      renameTopLevelLayoutSizeSignal() {
        this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width");
        this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
      }
      parseLegends() {
        parseLegend(this);
      }
      assembleEncodeFromView(view) {
        const {style:_, ...baseView} = view;
        view = {};
        for (const property of keys(baseView)) {
          const value = baseView[property];
          value !== void 0 && (view[property] = signalOrValueRef(value));
        }
        return view;
      }
      assembleGroupEncodeEntry(isTopLevel) {
        let encodeEntry = {};
        this.view && (encodeEntry = this.assembleEncodeFromView(this.view));
        return isTopLevel || (this.description && (encodeEntry.description = signalOrValueRef(this.description)), this.type !== "unit" && this.type !== "layer") ? isEmpty(encodeEntry) ? void 0 : encodeEntry : {width:this.getSizeSignalRef("width"), height:this.getSizeSignalRef("height"), ...encodeEntry};
      }
      assembleLayout() {
        if (this.layout) {
          var {spacing, ...layout} = this.layout, {component, config} = this;
          var JSCompiler_inline_result = component.layoutHeaders;
          var titleBand = {};
          for (const channel of FACET_CHANNELS) {
            var headerComponent = JSCompiler_inline_result[channel];
            if (headerComponent?.facetFieldDef) {
              const {titleAnchor, titleOrient} = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef.header, config, channel);
              headerComponent = getHeaderChannel(channel, titleOrient);
              const band = LAYOUT_TITLE_BAND[headerComponent][titleAnchor];
              band !== void 0 && (titleBand[headerComponent] = band);
            }
          }
          JSCompiler_inline_result = isEmpty(titleBand) ? void 0 : titleBand;
          return {padding:spacing, ...this.assembleDefaultLayout(), ...layout, ...(JSCompiler_inline_result ? {titleBand:JSCompiler_inline_result} : {})};
        }
      }
      assembleDefaultLayout() {
        return {};
      }
      assembleHeaderMarks() {
        var {layoutHeaders} = this.component, headerMarks = [];
        for (var channel$jscomp$0 of FACET_CHANNELS) {
          if (layoutHeaders[channel$jscomp$0].title) {
            var JSCompiler_temp_const = headerMarks, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.push;
            var JSCompiler_inline_result = this.component.layoutHeaders[channel$jscomp$0].title;
            var config = this.config ? this.config : void 0, facetFieldDef = this.component.layoutHeaders[channel$jscomp$0].facetFieldDef ? this.component.layoutHeaders[channel$jscomp$0].facetFieldDef : void 0;
            const {titleAnchor, titleAngle:ta, titleOrient} = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef.header, config, channel$jscomp$0);
            var headerChannel = getHeaderChannel(channel$jscomp$0, titleOrient), titleAngle = normalizeAngle(ta);
            JSCompiler_inline_result = {name:`${channel$jscomp$0}-title`, type:"group", role:`${headerChannel}-title`, title:{text:JSCompiler_inline_result, ...(channel$jscomp$0 === "row" ? {orient:"left"} : {}), style:"guide-title", ...defaultHeaderGuideBaseline(titleAngle, headerChannel), ...defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor), ...assembleHeaderProperties(config, facetFieldDef, channel$jscomp$0, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)}};
            JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, JSCompiler_inline_result);
          }
        }
        for (const channel of HEADER_CHANNELS) {
          layoutHeaders = headerMarks;
          headerMarks = layoutHeaders.concat;
          JSCompiler_temp_const = this.component.layoutHeaders[channel];
          JSCompiler_temp_const$jscomp$0 = [];
          for (const headerType of HEADER_TYPES) {
            if (JSCompiler_temp_const[headerType]) {
              for (const headerComponent of JSCompiler_temp_const[headerType]) {
                a: {
                  channel$jscomp$0 = channel;
                  JSCompiler_inline_result = headerType;
                  var JSCompiler_temp = JSCompiler_temp_const;
                  if (config = headerComponent) {
                    facetFieldDef = null;
                    ({facetFieldDef:JSCompiler_inline_result$jscomp$0} = JSCompiler_temp);
                    headerChannel = this.config ? this.config : void 0;
                    JSCompiler_inline_result$jscomp$0 && config.labels && ({labelOrient:titleAngle} = getHeaderProperties(["labelOrient"], JSCompiler_inline_result$jscomp$0.header, headerChannel, channel$jscomp$0), channel$jscomp$0 === "row" && !contains(["top", "bottom"], titleAngle) || channel$jscomp$0 === "column" && !contains(["left", "right"], titleAngle)) && (facetFieldDef = assembleLabelTitle(JSCompiler_inline_result$jscomp$0, channel$jscomp$0, headerChannel));
                    titleAngle = isFacetModel(this) && !isFacetMapping(this.facet);
                    const axes = config.axes, hasAxes = axes?.length > 0;
                    if (facetFieldDef || hasAxes) {
                      const sizeChannel = channel$jscomp$0 === "row" ? "height" : "width";
                      headerChannel = this.getName(`${channel$jscomp$0}_${JSCompiler_inline_result}`);
                      if (JSCompiler_temp.facetFieldDef) {
                        JSCompiler_temp = {data:this.getName(`${channel$jscomp$0}_domain`)};
                        {
                          const {sort} = JSCompiler_inline_result$jscomp$0;
                          var JSCompiler_inline_result$jscomp$0 = isSortField(sort) ? {field:vgField(sort, {expr:"datum"}), order:sort.order ?? "ascending"} : vega.isArray(sort) ? {field:sortArrayIndexField(JSCompiler_inline_result$jscomp$0, channel$jscomp$0, {expr:"datum"}), order:"ascending"} : {field:vgField(JSCompiler_inline_result$jscomp$0, {expr:"datum"}), order:sort ?? "ascending"};
                        }
                        JSCompiler_temp = {from:JSCompiler_temp, sort:JSCompiler_inline_result$jscomp$0};
                      } else {
                        JSCompiler_temp = {};
                      }
                      channel$jscomp$0 = {name:headerChannel, type:"group", role:`${channel$jscomp$0}-${JSCompiler_inline_result}`, ...JSCompiler_temp, ...(hasAxes && titleAngle ? {from:{data:this.getName(`facet_domain_${channel$jscomp$0}`)}} : {}), ...(facetFieldDef ? {title:facetFieldDef} : {}), ...(config.sizeSignal ? {encode:{update:{[sizeChannel]:config.sizeSignal}}} : {}), ...(hasAxes ? {axes} : {})};
                      break a;
                    }
                  }
                  channel$jscomp$0 = null;
                }
                channel$jscomp$0 != null && JSCompiler_temp_const$jscomp$0.push(channel$jscomp$0);
              }
            }
          }
          headerMarks = headerMarks.call(layoutHeaders, JSCompiler_temp_const$jscomp$0);
        }
        return headerMarks;
      }
      assembleAxes() {
        return assembleAxes(this.component.axes, this.config);
      }
      assembleLegends() {
        return assembleLegends(this);
      }
      assembleProjections() {
        var JSCompiler_inline_result = isLayerModel(this) || this?.type === "concat" ? assembleProjectionsForModelAndChildren(this) : assembleProjectionForModel(this);
        return JSCompiler_inline_result;
      }
      assembleTitle() {
        const {encoding, ...titleNoEncoding} = this.title ?? {}, title = {...extractTitleConfig(this.config.title).nonMarkTitleProperties, ...titleNoEncoding, ...(encoding ? {encode:{update:encoding}} : {})};
        if (title.text) {
          return contains(["unit", "layer"], this.type) ? contains(["middle", void 0], title.anchor) && (title.frame ?? (title.frame = "group")) : title.anchor ?? (title.anchor = "start"), isEmpty(title) ? void 0 : title;
        }
      }
      assembleGroup() {
        var signals = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        const group = {};
        signals = signals.concat(this.assembleSignals());
        signals.length > 0 && (group.signals = signals);
        if (signals = this.assembleLayout()) {
          group.layout = signals;
        }
        group.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
        signals = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
        signals.length > 0 && (group.scales = signals);
        signals = this.assembleAxes();
        signals.length > 0 && (group.axes = signals);
        signals = this.assembleLegends();
        signals.length > 0 && (group.legends = signals);
        return group;
      }
      getName(text) {
        return varName((this.name ? `${this.name}_` : "") + text);
      }
      getDataName(type) {
        return this.getName(DataSourceType[type].toLowerCase());
      }
      requestDataName(name) {
        name = this.getDataName(name);
        const refCounts = this.component.data.outputNodeRefCounts;
        refCounts[name] = (refCounts[name] || 0) + 1;
        return name;
      }
      getSizeSignalRef(layoutSizeType) {
        if (isFacetModel(this.parent)) {
          var sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType), channel = getPositionScaleChannel(sizeType);
          if ((sizeType = this.component.scales[channel]) && !sizeType.merged) {
            var type = sizeType.get("type");
            const range = sizeType.get("range");
            if (hasDiscreteDomain(type) && isVgRangeStep(range)) {
              layoutSizeType = sizeType.get("name");
              type = assembleDomain(this, channel);
              if (type = getFieldFromDomain(type)) {
                return channel = vgField({aggregate:"distinct", field:type}, {expr:"datum"}), {signal:sizeExpr(layoutSizeType, sizeType, channel)};
              }
              warn(unknownField(channel));
              return null;
            }
          }
        }
        return {signal:this.signalNameMap.get(this.getName(layoutSizeType))};
      }
      lookupDataSource(name) {
        const node = this.component.data.outputNodes[name];
        return node ? node.getSource() : name;
      }
      getSignalName(oldSignalName) {
        return this.signalNameMap.get(oldSignalName);
      }
      renameSignal(oldName, newName) {
        this.signalNameMap.rename(oldName, newName);
      }
      renameScale(oldName, newName) {
        this.scaleNameMap.rename(oldName, newName);
      }
      renameProjection(oldName, newName) {
        this.projectionNameMap.rename(oldName, newName);
      }
      scaleName(originalScaleName, parse) {
        if (parse) {
          return this.getName(originalScaleName);
        }
        if (vega.hasOwnProperty(CHANNEL_INDEX, originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || this.scaleNameMap.has(this.getName(originalScaleName))) {
          return this.scaleNameMap.get(this.getName(originalScaleName));
        }
      }
      projectionName(parse) {
        if (parse) {
          return this.getName("projection");
        }
        if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
          return this.projectionNameMap.get(this.getName("projection"));
        }
      }
      getScaleComponent(channel) {
        if (!this.component.scales) {
          throw Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
        }
        const localScaleComponent = this.component.scales[channel];
        return localScaleComponent && !localScaleComponent.merged ? localScaleComponent : this.parent ? this.parent.getScaleComponent(channel) : void 0;
      }
      getScaleType(channel) {
        return (channel = this.getScaleComponent(channel)) ? channel.get("type") : void 0;
      }
      getSelectionComponent(variableName, origName) {
        let sel = this.component.selection[variableName];
        !sel && this.parent && (sel = this.parent.getSelectionComponent(variableName, origName));
        if (!sel) {
          throw Error(`Cannot find a selection named "${origName}".`);
        }
        return sel;
      }
      hasAxisOrientSignalRef() {
        return this.component.axes.x?.some(a => a.hasOrientSignalRef()) || this.component.axes.y?.some(a => a.hasOrientSignalRef());
      }
    }
    class ModelWithField extends Model {
      vgField(channel) {
        let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const fieldDef = this.fieldDef(channel);
        if (fieldDef) {
          return vgField(fieldDef, opt);
        }
      }
      reduceFieldDef(f, init) {
        return reduce(this.getMapping(), (acc, cd, c) => (cd = getFieldDef(cd)) ? f(acc, cd, c) : acc, init);
      }
      forEachFieldDef(f, t) {
        forEach(this.getMapping(), (cd, c) => {
          (cd = getFieldDef(cd)) && f(cd, c);
        }, t);
      }
    }
    class DensityTransformNode extends DataFlowNode {
      clone() {
        return new DensityTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
        parent = this.transform.as ?? [void 0, void 0];
        this.transform.as = [parent[0] ?? "value", parent[1] ?? "density"];
        this.transform.resolve = this.transform.resolve ?? "shared";
      }
      dependentFields() {
        return new Set([this.transform.density, ...(this.transform.groupby ?? [])]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `DensityTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {density, ...rest} = this.transform, result = {type:"kde", field:density, ...rest};
        result.resolve = this.transform.resolve;
        return result;
      }
    }
    class ExtentTransformNode extends DataFlowNode {
      clone() {
        return new ExtentTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
      }
      dependentFields() {
        return new Set([this.transform.extent]);
      }
      producedFields() {
        return new Set([]);
      }
      hash() {
        return `ExtentTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {extent, param} = this.transform;
        return {type:"extent", field:extent, signal:param};
      }
    }
    class FlattenTransformNode extends DataFlowNode {
      clone() {
        return new FlattenTransformNode(this.parent, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
        const {flatten, as = []} = this.transform;
        this.transform.as = flatten.map((f, i) => as[i] ?? f);
      }
      dependentFields() {
        return new Set(this.transform.flatten);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `FlattenTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {flatten:fields, as} = this.transform;
        return {type:"flatten", fields, as};
      }
    }
    class FoldTransformNode extends DataFlowNode {
      clone() {
        return new FoldTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
        parent = this.transform.as ?? [void 0, void 0];
        this.transform.as = [parent[0] ?? "key", parent[1] ?? "value"];
      }
      dependentFields() {
        return new Set(this.transform.fold);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `FoldTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {fold, as} = this.transform;
        return {type:"fold", fields:fold, as};
      }
    }
    class GeoJSONNode extends DataFlowNode {
      clone() {
        return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
      }
      static parseAll(parent, model) {
        if (model.component.projection && !model.component.projection.isFit) {
          return parent;
        }
        let geoJsonCounter = 0;
        for (var coordinates of [["longitude", "latitude"], ["longitude2", "latitude2"]]) {
          const pair = coordinates.map(channel => {
            channel = getFieldOrDatumDef(model.encoding[channel]);
            return isFieldDef(channel) ? channel.field : isDatumDef(channel) ? {expr:`${channel.datum}`} : isValueDef(channel) ? {expr:`${channel.value}`} : void 0;
          });
          if (pair[0] || pair[1]) {
            parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
          }
        }
        model.channelHasField("shape") && (coordinates = model.typedFieldDef("shape"), coordinates.type === "geojson" && (parent = new GeoJSONNode(parent, null, coordinates.field, model.getName(`geojson_${geoJsonCounter++}`))));
        return parent;
      }
      constructor(parent, fields, geojson, signal) {
        super(parent);
        this.fields = fields;
        this.geojson = geojson;
        this.signal = signal;
      }
      dependentFields() {
        const fields = (this.fields ?? []).filter(vega.isString);
        return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);
      }
      producedFields() {
        return new Set();
      }
      hash() {
        return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
      }
      assemble() {
        return [...(this.geojson ? [{type:"filter", expr:`isValid(datum["${this.geojson}"])`}] : []), {type:"geojson", ...(this.fields ? {fields:this.fields} : {}), ...(this.geojson ? {geojson:this.geojson} : {}), signal:this.signal}];
      }
    }
    class GeoPointNode extends DataFlowNode {
      clone() {
        return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
      }
      constructor(parent, projection, fields, as) {
        super(parent);
        this.projection = projection;
        this.fields = fields;
        this.as = as;
      }
      static parseAll(parent, model) {
        if (!model.projectionName()) {
          return parent;
        }
        for (const coordinates of [["longitude", "latitude"], ["longitude2", "latitude2"]]) {
          const pair = coordinates.map(channel => {
            channel = getFieldOrDatumDef(model.encoding[channel]);
            return isFieldDef(channel) ? channel.field : isDatumDef(channel) ? {expr:`${channel.datum}`} : isValueDef(channel) ? {expr:`${channel.value}`} : void 0;
          }), suffix = coordinates[0] === "longitude2" ? "2" : "";
          if (pair[0] || pair[1]) {
            parent = new GeoPointNode(parent, model.projectionName(), pair, [model.getName(`x${suffix}`), model.getName(`y${suffix}`)]);
          }
        }
        return parent;
      }
      dependentFields() {
        return new Set(this.fields.filter(vega.isString));
      }
      producedFields() {
        return new Set(this.as);
      }
      hash() {
        return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
      }
      assemble() {
        return {type:"geopoint", projection:this.projection, fields:this.fields, as:this.as};
      }
    }
    class ImputeNode extends DataFlowNode {
      clone() {
        return new ImputeNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
      }
      dependentFields() {
        return new Set([this.transform.impute, this.transform.key, ...(this.transform.groupby ?? [])]);
      }
      producedFields() {
        return new Set([this.transform.impute]);
      }
      processSequence(keyvals) {
        const {start = 0, stop, step} = keyvals;
        return {signal:`sequence(${[start, stop, ...(step ? [step] : [])].join()})`};
      }
      static makeFromTransform(parent, imputeTransform) {
        return new ImputeNode(parent, imputeTransform);
      }
      static makeFromEncoding(parent, model) {
        const encoding = model.encoding;
        var xDef = encoding.x;
        const yDef = encoding.y;
        if (isFieldDef(xDef) && isFieldDef(yDef)) {
          const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
          if (imputedChannel === void 0) {
            return;
          }
          xDef = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
          const {method, value, frame, keyvals} = imputedChannel.impute;
          model = pathGroupingFields(model.mark, encoding);
          return new ImputeNode(parent, {impute:imputedChannel.field, key:xDef.field, ...(method ? {method} : {}), ...(value !== void 0 ? {value} : {}), ...(frame ? {frame} : {}), ...(keyvals !== void 0 ? {keyvals} : {}), ...(model.length ? {groupby:model} : {})});
        }
        return null;
      }
      hash() {
        return `Impute ${hash(this.transform)}`;
      }
      assemble() {
        const {impute, key, keyvals, method, groupby, value, frame = [null, null]} = this.transform, imputeTransform = {type:"impute", field:impute, key, ...(keyvals ? {keyvals:hasProperty(keyvals, "stop") ? this.processSequence(keyvals) : keyvals} : {}), method:"value", ...(groupby ? {groupby} : {}), value:method && method !== "value" ? null : value};
        return method && method !== "value" ? [imputeTransform, {type:"window", as:[`imputed_${impute}_value`], ops:[method], fields:[impute], frame, ignorePeers:!1, ...(groupby ? {groupby} : {})}, {type:"formula", expr:`datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`, as:impute}] : [imputeTransform];
      }
    }
    class LoessTransformNode extends DataFlowNode {
      clone() {
        return new LoessTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
        parent = this.transform.as ?? [void 0, void 0];
        this.transform.as = [parent[0] ?? transform.on, parent[1] ?? transform.loess];
      }
      dependentFields() {
        return new Set([this.transform.loess, this.transform.on, ...(this.transform.groupby ?? [])]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `LoessTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {loess, on, ...rest} = this.transform;
        return {type:"loess", x:on, y:loess, ...rest};
      }
    }
    class LookupNode extends DataFlowNode {
      clone() {
        return new LookupNode(null, duplicate(this.transform), this.secondary);
      }
      constructor(parent, transform, secondary) {
        super(parent);
        this.transform = transform;
        this.secondary = secondary;
      }
      static make(parent, model, transform, counter) {
        const sources = model.component.data.sources, {from} = transform;
        var fromOutputNode = null;
        if (hasProperty(from, "data")) {
          fromOutputNode = findSource(from.data, sources), fromOutputNode || (fromOutputNode = new SourceNode(from.data), sources.push(fromOutputNode)), counter = model.getName(`lookup_${counter}`), fromOutputNode = new OutputNode(fromOutputNode, counter, DataSourceType.Lookup, model.component.data.outputNodeRefCounts), model.component.data.outputNodes[counter] = fromOutputNode;
        } else if (hasProperty(from, "param")) {
          counter = from.param;
          transform = {as:counter, ...transform};
          let selCmpt;
          try {
            selCmpt = model.getSelectionComponent(varName(counter), counter);
          } catch (e) {
            throw Error(`Lookups can only be performed on selection parameters. "${counter}" is a variable parameter.`);
          }
          fromOutputNode = selCmpt.materialized;
          if (!fromOutputNode) {
            throw Error(`Cannot define and lookup the "${counter}" selection in the same view. ` + "Try moving the lookup into a second, layered view?");
          }
        }
        return new LookupNode(parent, transform, fromOutputNode.getSource());
      }
      dependentFields() {
        return new Set([this.transform.lookup]);
      }
      producedFields() {
        return new Set(this.transform.as ? vega.array(this.transform.as) : this.transform.from.fields);
      }
      hash() {
        return `Lookup ${hash({transform:this.transform, secondary:this.secondary})}`;
      }
      assemble() {
        if (this.transform.from.fields) {
          var foreign = {values:this.transform.from.fields, ...(this.transform.as ? {as:vega.array(this.transform.as)} : {})};
        } else {
          foreign = this.transform.as, vega.isString(foreign) || (warn('If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.'), foreign = "_lookup"), foreign = {as:[foreign]};
        }
        return {type:"lookup", from:this.secondary, key:this.transform.from.key, fields:[this.transform.lookup], ...foreign, ...(this.transform.default ? {default:this.transform.default} : {})};
      }
    }
    class QuantileTransformNode extends DataFlowNode {
      clone() {
        return new QuantileTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
        parent = this.transform.as ?? [void 0, void 0];
        this.transform.as = [parent[0] ?? "prob", parent[1] ?? "value"];
      }
      dependentFields() {
        return new Set([this.transform.quantile, ...(this.transform.groupby ?? [])]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `QuantileTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {quantile, ...rest} = this.transform;
        return {type:"quantile", field:quantile, ...rest};
      }
    }
    class RegressionTransformNode extends DataFlowNode {
      clone() {
        return new RegressionTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
        this.transform = duplicate(transform);
        parent = this.transform.as ?? [void 0, void 0];
        this.transform.as = [parent[0] ?? transform.on, parent[1] ?? transform.regression];
      }
      dependentFields() {
        return new Set([this.transform.regression, this.transform.on, ...(this.transform.groupby ?? [])]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `RegressionTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {regression, on, ...rest} = this.transform;
        return {type:"regression", x:on, y:regression, ...rest};
      }
    }
    class PivotTransformNode extends DataFlowNode {
      clone() {
        return new PivotTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
      }
      addDimensions(fields) {
        this.transform.groupby = unique((this.transform.groupby ?? []).concat(fields), d => d);
      }
      producedFields() {
      }
      dependentFields() {
        return new Set([this.transform.pivot, this.transform.value, ...(this.transform.groupby ?? [])]);
      }
      hash() {
        return `PivotTransform ${hash(this.transform)}`;
      }
      assemble() {
        const {pivot, value, groupby, limit, op} = this.transform;
        return {type:"pivot", field:pivot, value, ...(limit !== void 0 ? {limit} : {}), ...(op !== void 0 ? {op} : {}), ...(groupby !== void 0 ? {groupby} : {})};
      }
    }
    class SampleTransformNode extends DataFlowNode {
      clone() {
        return new SampleTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform) {
        super(parent);
        this.transform = transform;
      }
      dependentFields() {
        return new Set();
      }
      producedFields() {
        return new Set();
      }
      hash() {
        return `SampleTransform ${hash(this.transform)}`;
      }
      assemble() {
        return {type:"sample", size:this.transform.sample};
      }
    }
    class FacetModel extends ModelWithField {
      constructor(spec, parent, parentGivenName, config) {
        super(spec, "facet", parent, parentGivenName, config, spec.resolve);
        this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
        this.children = [this.child];
        this.facet = this.initFacet(spec.facet);
      }
      initFacet(facet) {
        if (!isFacetMapping(facet)) {
          return {facet:this.initFacetFieldDef(facet, "facet")};
        }
        var channels = keys(facet);
        const normalizedFacet = {};
        for (const channel of channels) {
          if (!["row", "column"].includes(channel)) {
            warn(incompatibleChannel(channel, "facet"));
            break;
          }
          channels = facet[channel];
          if (channels.field === void 0) {
            warn(emptyFieldDef(channels, channel));
            break;
          }
          normalizedFacet[channel] = this.initFacetFieldDef(channels, channel);
        }
        return normalizedFacet;
      }
      initFacetFieldDef(fieldDef, channel) {
        fieldDef = initFieldDef(fieldDef, channel);
        fieldDef.header ? fieldDef.header = replaceExprRef(fieldDef.header) : fieldDef.header === null && (fieldDef.header = null);
        return fieldDef;
      }
      channelHasField(channel) {
        return hasProperty(this.facet, channel);
      }
      fieldDef(channel) {
        return this.facet[channel];
      }
      parseData() {
        this.component.data = parseData(this);
        this.child.parseData();
      }
      parseLayoutSize() {
        parseChildrenLayoutSize(this);
      }
      parseSelections() {
        this.child.parseSelections();
        this.component.selection = this.child.component.selection;
        Object.values(this.component.selection).some(selCmpt => isTimerSelection(selCmpt)) && error("Animation involving facet, layer, or concat is currently unsupported.");
      }
      parseMarkGroup() {
        this.child.parseMarkGroup();
      }
      parseAxesAndHeaders() {
        this.child.parseAxesAndHeaders();
        for (const channel of FACET_CHANNELS) {
          const {facet, config, child, component} = this;
          if (this.channelHasField(channel)) {
            const fieldDef = facet[channel];
            var titleConfig = getHeaderProperty("title", null, config, channel);
            titleConfig = title(fieldDef, config, {allowDisabling:!0, includeDefault:titleConfig === void 0 || !!titleConfig});
            child.component.layoutHeaders[channel].title && (titleConfig = vega.isArray(titleConfig) ? titleConfig.join(", ") : titleConfig, titleConfig += ` / ${child.component.layoutHeaders[channel].title}`, child.component.layoutHeaders[channel].title = null);
            var labelOrient = getHeaderProperty("labelOrient", fieldDef.header, config, channel);
            const labels = fieldDef.header !== null ? getFirstDefined(fieldDef.header?.labels, config.header.labels, !0) : !1;
            labelOrient = contains(["bottom", "right"], labelOrient) ? "footer" : "header";
            component.layoutHeaders[channel] = {title:fieldDef.header !== null ? titleConfig : null, facetFieldDef:fieldDef, [labelOrient]:channel === "facet" ? [] : [makeHeaderComponent(this, channel, labels)]};
          }
        }
        mergeChildAxis(this, "x");
        mergeChildAxis(this, "y");
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.child.assembleSelectionTopLevelSignals(signals);
      }
      assembleSignals() {
        this.child.assembleSignals();
        return [];
      }
      assembleSelectionData(data) {
        return this.child.assembleSelectionData(data);
      }
      getHeaderLayoutMixins() {
        const layoutMixins = {};
        for (const channel of FACET_CHANNELS) {
          for (const headerType of HEADER_TYPES) {
            const layoutHeaderComponent = this.component.layoutHeaders[channel];
            var headerComponent = layoutHeaderComponent[headerType], {facetFieldDef} = layoutHeaderComponent;
            if (facetFieldDef && (facetFieldDef = getHeaderProperty("titleOrient", facetFieldDef.header, this.config, channel), ["right", "bottom"].includes(facetFieldDef))) {
              facetFieldDef = getHeaderChannel(channel, facetFieldDef);
              let $jscomp$logical$assign$tmp730812712$23;
              ($jscomp$logical$assign$tmp730812712$23 = layoutMixins).titleAnchor ?? ($jscomp$logical$assign$tmp730812712$23.titleAnchor = {});
              layoutMixins.titleAnchor[facetFieldDef] = "end";
            }
            if (headerComponent?.[0]) {
              headerComponent = channel === "row" ? "height" : "width";
              facetFieldDef = headerType === "header" ? "headerBand" : "footerBand";
              if (channel !== "facet" && !this.child.component.layoutSize.get(headerComponent)) {
                let $jscomp$logical$assign$tmp730812712$24, $jscomp$logical$assign$tmpindex730812712$24;
                ($jscomp$logical$assign$tmp730812712$24 = layoutMixins)[$jscomp$logical$assign$tmpindex730812712$24 = facetFieldDef] ?? ($jscomp$logical$assign$tmp730812712$24[$jscomp$logical$assign$tmpindex730812712$24] = {});
                layoutMixins[facetFieldDef][channel] = 0.5;
              }
              if (layoutHeaderComponent.title) {
                let $jscomp$logical$assign$tmp730812712$25;
                ($jscomp$logical$assign$tmp730812712$25 = layoutMixins).offset ?? ($jscomp$logical$assign$tmp730812712$25.offset = {});
                layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
              }
            }
          }
        }
        return layoutMixins;
      }
      assembleDefaultLayout() {
        const {column, row} = this.facet, columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
        let align = "all";
        row || this.component.resolve.scale.x !== "independent" ? column || this.component.resolve.scale.y !== "independent" || (align = "none") : align = "none";
        return {...this.getHeaderLayoutMixins(), ...(columns ? {columns} : {}), bounds:"full", align};
      }
      assembleLayoutSignals() {
        return this.child.assembleLayoutSignals();
      }
      columnDistinctSignal() {
        if (!(this.parent && this.parent instanceof FacetModel)) {
          return {signal:`length(data('${this.getName("column_domain")}'))`};
        }
      }
      assembleGroupStyle() {
      }
      assembleGroup(signals) {
        return this.parent && this.parent instanceof FacetModel ? {...(this.channelHasField("column") ? {encode:{update:{columns:{field:vgField(this.facet.column, {prefix:"distinct"})}}}} : {}), ...super.assembleGroup(signals)} : super.assembleGroup(signals);
      }
      getCardinalityAggregateForChild() {
        const fields = [], ops = [], as = [];
        if (this.child instanceof FacetModel) {
          if (this.child.channelHasField("column")) {
            var field = vgField(this.child.facet.column);
            fields.push(field);
            ops.push("distinct");
            as.push(`distinct_${field}`);
          }
        } else {
          for (field of POSITION_SCALE_CHANNELS) {
            var childScaleComponent = this.child.component.scales[field];
            if (childScaleComponent && !childScaleComponent.merged) {
              var type = childScaleComponent.get("type");
              childScaleComponent = childScaleComponent.get("range");
              hasDiscreteDomain(type) && isVgRangeStep(childScaleComponent) && (type = assembleDomain(this.child, field), (type = getFieldFromDomain(type)) ? (fields.push(type), ops.push("distinct"), as.push(`distinct_${type}`)) : warn(unknownField(field)));
            }
          }
        }
        return {fields, ops, as};
      }
      assembleFacet() {
        const {name, data} = this.component.data.facetRoot, {row, column} = this.facet, {fields, ops, as} = this.getCardinalityAggregateForChild(), groupby = [];
        for (var channel of FACET_CHANNELS) {
          var fieldDef = this.facet[channel];
          if (fieldDef) {
            groupby.push(vgField(fieldDef));
            const {bin, sort} = fieldDef;
            isBinning(bin) && groupby.push(vgField(fieldDef, {binSuffix:"end"}));
            if (isSortField(sort)) {
              const {field, op = "min"} = sort;
              fieldDef = facetSortFieldName(fieldDef, sort);
              row && column ? (fields.push(fieldDef), ops.push("max")) : (fields.push(field), ops.push(op));
              as.push(fieldDef);
            } else {
              vega.isArray(sort) && (fieldDef = sortArrayIndexField(fieldDef, channel), fields.push(fieldDef), ops.push("max"), as.push(fieldDef));
            }
          }
        }
        channel = !!row && !!column;
        return {name, data, groupby, ...(channel || fields.length > 0 ? {aggregate:{...(channel ? {cross:channel} : {}), ...(fields.length ? {fields, ops, as} : {})}} : {})};
      }
      facetSortFields(channel) {
        var {facet} = this;
        return (facet = facet[channel]) ? isSortField(facet.sort) ? [facetSortFieldName(facet, facet.sort, {expr:"datum"})] : vega.isArray(facet.sort) ? [sortArrayIndexField(facet, channel, {expr:"datum"})] : [vgField(facet, {expr:"datum"})] : [];
      }
      facetSortOrder(channel) {
        const {facet} = this;
        return (channel = facet[channel]) ? ({sort:channel} = channel, [(isSortField(channel) ? channel.order : !vega.isArray(channel) && channel) || "ascending"]) : [];
      }
      assembleLabelTitle() {
        const {facet, config} = this;
        if (facet.facet) {
          return assembleLabelTitle(facet.facet, "facet", config);
        }
        const ORTHOGONAL_ORIENT = {row:["top", "bottom"], column:["left", "right"]};
        for (const channel of HEADER_CHANNELS) {
          if (facet[channel]) {
            const labelOrient = getHeaderProperty("labelOrient", facet[channel]?.header, config, channel);
            if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {
              return assembleLabelTitle(facet[channel], channel, config);
            }
          }
        }
      }
      assembleMarks() {
        const {child} = this, data = assembleFacetData(this.component.data.facetRoot), encodeEntry = child.assembleGroupEncodeEntry(!1), title = this.assembleLabelTitle() || child.assembleTitle(), style = child.assembleGroupStyle();
        return [{name:this.getName("cell"), type:"group", ...(title ? {title} : {}), ...(style ? {style} : {}), from:{facet:this.assembleFacet()}, sort:{field:FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(), order:FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()}, ...(data.length > 0 ? {data} : {}), ...(encodeEntry ? {encode:{update:encodeEntry}} : {}), ...child.assembleGroup(assembleFacetSignals(this, []))}];
      }
      getMapping() {
        return this.facet;
      }
    }
    class ConcatModel extends Model {
      constructor(spec, parent, parentGivenName, config) {
        super(spec, "concat", parent, parentGivenName, config, spec.resolve);
        spec.resolve?.axis?.x !== "shared" && spec.resolve?.axis?.y !== "shared" || warn("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).");
        this.children = this.getChildren(spec).map((child, i) => buildModel(child, this, this.getName(`concat_${i}`), void 0, config));
      }
      parseData() {
        this.component.data = parseData(this);
        for (const child of this.children) {
          child.parseData();
        }
      }
      parseSelections() {
        this.component.selection = {};
        for (const child of this.children) {
          child.parseSelections();
          for (const key of keys(child.component.selection)) {
            this.component.selection[key] = child.component.selection[key];
          }
        }
        Object.values(this.component.selection).some(selCmpt => isTimerSelection(selCmpt)) && error("Animation involving facet, layer, or concat is currently unsupported.");
      }
      parseMarkGroup() {
        for (const child of this.children) {
          child.parseMarkGroup();
        }
      }
      parseAxesAndHeaders() {
        for (const child of this.children) {
          child.parseAxesAndHeaders();
        }
      }
      getChildren(spec) {
        return hasProperty(spec, "vconcat") ? spec.vconcat : hasProperty(spec, "hconcat") ? spec.hconcat : spec.concat;
      }
      parseLayoutSize() {
        parseChildrenLayoutSize(this);
        const heightType = this.layout.columns === void 0 ? "height" : "childHeight";
        parseNonUnitLayoutSizeForChannel(this, this.layout.columns === 1 ? "width" : "childWidth");
        parseNonUnitLayoutSizeForChannel(this, heightType);
      }
      parseAxisGroup() {
        return null;
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
      }
      assembleSignals() {
        this.children.forEach(child => child.assembleSignals());
        return [];
      }
      assembleLayoutSignals() {
        const layoutSignals = assembleLayoutSignals(this);
        for (const child of this.children) {
          layoutSignals.push(...child.assembleLayoutSignals());
        }
        return layoutSignals;
      }
      assembleSelectionData(data) {
        return this.children.reduce((db, child) => child.assembleSelectionData(db), data);
      }
      assembleMarks() {
        return this.children.map(child => {
          const title = child.assembleTitle(), style = child.assembleGroupStyle(), encodeEntry = child.assembleGroupEncodeEntry(!1);
          return {type:"group", name:child.getName("group"), ...(title ? {title} : {}), ...(style ? {style} : {}), ...(encodeEntry ? {encode:{update:encodeEntry}} : {}), ...child.assembleGroup()};
        });
      }
      assembleGroupStyle() {
      }
      assembleDefaultLayout() {
        const columns = this.layout.columns;
        return {...(columns != null ? {columns} : {}), bounds:"full", align:"each"};
      }
    }
    const AXIS_COMPONENT_PROPERTIES = keys({disable:1, gridScale:1, scale:1, ...COMMON_AXIS_PROPERTIES_INDEX, labelExpr:1, encode:1});
    class AxisComponent extends Split {
      constructor() {
        let explicit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, implicit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, mainExtracted = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        super();
        this.explicit = explicit;
        this.implicit = implicit;
        this.mainExtracted = mainExtracted;
      }
      clone() {
        return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
      }
      hasAxisPart(part) {
        if (part === "axis") {
          return !0;
        }
        if (part === "grid" || part === "title") {
          return !!this.get(part);
        }
        part = this.get(part);
        return !(part === !1 || part === null);
      }
      hasOrientSignalRef() {
        return isSignalRef(this.explicit.orient);
      }
    }
    const OPPOSITE_ORIENT = {bottom:"top", top:"bottom", left:"right", right:"left"}, propsToAlwaysIncludeConfig = new Set("grid translate format formatType orient labelExpr tickCount position tickMinStep".split(" ")), markCompiler = {arc:{vgMark:"arc", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", size:"ignore", orient:"ignore", theta:"ignore"}), ...pointPosition("x", model, {defaultPos:"mid"}), ...pointPosition("y", model, {defaultPos:"mid"}), 
    ...rectPosition(model, "radius"), ...rectPosition(model, "theta")})}, area:{vgMark:"area", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", orient:"include", size:"ignore", theta:"ignore"}), ...pointOrRangePosition("x", model, {defaultPos:"zeroOrMin", defaultPos2:"zeroOrMin", range:model.markDef.orient === "horizontal"}), ...pointOrRangePosition("y", model, {defaultPos:"zeroOrMin", defaultPos2:"zeroOrMin", range:model.markDef.orient === "vertical"}), 
    ...defined(model)})}, bar:{vgMark:"rect", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", orient:"ignore", size:"ignore", theta:"ignore"}), ...rectPosition(model, "x"), ...rectPosition(model, "y")})}, circle:{vgMark:"symbol", encodeEntry:model => encodeEntry(model, "circle")}, geoshape:{vgMark:"shape", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", size:"ignore", orient:"ignore", theta:"ignore"})}), 
    postEncodingTransform:model => {
      var {encoding} = model;
      encoding = encoding.shape;
      return [{type:"geoshape", projection:model.projectionName(), ...(encoding && isFieldDef(encoding) && encoding.type === "geojson" ? {field:vgField(encoding, {expr:"datum"})} : {})}];
    }}, image:{vgMark:"image", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"ignore", orient:"ignore", size:"ignore", theta:"ignore"}), ...rectPosition(model, "x"), ...rectPosition(model, "y"), ...text$1(model, "url")})}, line:{vgMark:"line", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", size:"ignore", orient:"ignore", theta:"ignore"}), ...pointPosition("x", model, {defaultPos:"mid"}), ...pointPosition("y", 
    model, {defaultPos:"mid"}), ...nonPosition("size", model, {vgChannel:"strokeWidth"}), ...defined(model)})}, point:{vgMark:"symbol", encodeEntry:model => encodeEntry(model)}, rect:{vgMark:"rect", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", orient:"ignore", size:"ignore", theta:"ignore"}), ...rectPosition(model, "x"), ...rectPosition(model, "y")})}, rule:{vgMark:"rule", encodeEntry:model => {
      var {markDef} = model;
      markDef = markDef.orient;
      return model.encoding.x || model.encoding.y || model.encoding.latitude || model.encoding.longitude ? {...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", orient:"ignore", size:"ignore", theta:"ignore"}), ...pointOrRangePosition("x", model, {defaultPos:markDef === "horizontal" ? "zeroOrMax" : "mid", defaultPos2:"zeroOrMin", range:markDef !== "vertical"}), ...pointOrRangePosition("y", model, {defaultPos:markDef === "vertical" ? "zeroOrMax" : "mid", defaultPos2:"zeroOrMin", 
      range:markDef !== "horizontal"}), ...nonPosition("size", model, {vgChannel:"strokeWidth"})} : {};
    }}, square:{vgMark:"symbol", encodeEntry:model => encodeEntry(model, "square")}, text:{vgMark:"text", encodeEntry:model => {
      var {config} = model, JSCompiler_temp_const = {...baseEncodeEntry(model, {align:"include", baseline:"include", color:"include", size:"ignore", orient:"ignore", theta:"include"})}, JSCompiler_temp_const$jscomp$0 = {...pointPosition("x", model, {defaultPos:"mid"})}, JSCompiler_temp_const$jscomp$1 = {...pointPosition("y", model, {defaultPos:"mid"})}, JSCompiler_temp_const$jscomp$2 = {...text$1(model)}, JSCompiler_temp_const$jscomp$3 = {...nonPosition("size", model, {vgChannel:"fontSize"})}, JSCompiler_temp_const$jscomp$4 = 
      {...nonPosition("angle", model)};
      var JSCompiler_inline_result = getMarkPropOrConfig("align", model.markDef, config) === void 0 ? "center" : void 0;
      JSCompiler_inline_result = {...valueIfDefined("align", JSCompiler_inline_result)};
      config = getMarkPropOrConfig("baseline", model.markDef, config) === void 0 ? "middle" : void 0;
      return {...JSCompiler_temp_const, ...JSCompiler_temp_const$jscomp$0, ...JSCompiler_temp_const$jscomp$1, ...JSCompiler_temp_const$jscomp$2, ...JSCompiler_temp_const$jscomp$3, ...JSCompiler_temp_const$jscomp$4, ...JSCompiler_inline_result, ...valueIfDefined("baseline", config), ...pointPosition("radius", model, {defaultPos:null}), ...pointPosition("theta", model, {defaultPos:null})};
    }}, tick:{vgMark:"rect", encodeEntry:model => {
      const {config, markDef} = model;
      var orient = markDef.orient;
      const vgSizeAxisChannel = orient === "horizontal" ? "x" : "y", vgThicknessAxisChannel = orient === "horizontal" ? "y" : "x";
      orient = orient === "horizontal" ? "height" : "width";
      return {...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", orient:"ignore", size:"ignore", theta:"ignore"}), ...rectPosition(model, vgSizeAxisChannel), ...pointPosition(vgThicknessAxisChannel, model, {defaultPos:"mid", vgChannel:vgThicknessAxisChannel === "y" ? "yc" : "xc"}), [orient]:signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config))};
    }}, trail:{vgMark:"trail", encodeEntry:model => ({...baseEncodeEntry(model, {align:"ignore", baseline:"ignore", color:"include", size:"include", orient:"ignore", theta:"ignore"}), ...pointPosition("x", model, {defaultPos:"mid"}), ...pointPosition("y", model, {defaultPos:"mid"}), ...nonPosition("size", model), ...defined(model)})}};
    class UnitModel extends ModelWithField {
      specifiedScales={};
      specifiedAxes={};
      specifiedLegends={};
      specifiedProjection={};
      selection=[];
      children=[];
      constructor(spec, parent, parentGivenName) {
        let parentGivenSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, config = arguments.length > 4 ? arguments[4] : void 0;
        super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
        const markDef = isMarkDef(spec.mark) ? {...spec.mark} : {type:spec.mark}, mark = markDef.type;
        markDef.filled === void 0 && (markDef.filled = defaultFilled(markDef, config, {graticule:spec.data && hasProperty(spec.data, "graticule")}));
        const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);
        this.markDef = initMarkdef(markDef, encoding, config);
        this.size = initLayoutSize({encoding, size:isFrameMixins(spec) ? {...parentGivenSize, ...(spec.width ? {width:spec.width} : {}), ...(spec.height ? {height:spec.height} : {})} : parentGivenSize});
        this.stack = stack(this.markDef, encoding);
        this.specifiedScales = this.initScales(mark, encoding);
        this.specifiedAxes = this.initAxes(encoding);
        this.specifiedLegends = this.initLegends(encoding);
        this.specifiedProjection = spec.projection;
        this.selection = (spec.params ?? []).filter(p => !!p?.select);
      }
      get hasProjection() {
        const {encoding} = this, isGeoShapeMark = this.mark === GEOSHAPE, hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));
        return isGeoShapeMark || hasGeoPosition;
      }
      scaleDomain(channel) {
        return (channel = this.specifiedScales[channel]) ? channel.domain : void 0;
      }
      axis(channel) {
        return this.specifiedAxes[channel];
      }
      legend(channel) {
        return this.specifiedLegends[channel];
      }
      initScales(mark, encoding) {
        return SCALE_CHANNELS.reduce((scales, channel) => {
          const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
          fieldOrDatumDef && (scales[channel] = this.initScale(fieldOrDatumDef.scale ?? {}));
          return scales;
        }, {});
      }
      initScale(scale) {
        const {domain, range} = scale;
        scale = replaceExprRef(scale);
        vega.isArray(domain) && (scale.domain = domain.map(signalRefOrValue));
        vega.isArray(range) && (scale.range = range.map(signalRefOrValue));
        return scale;
      }
      initAxes(encoding) {
        return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
          var channelDef = encoding[channel];
          if (isFieldOrDatumDef(channelDef) || channel === "x" && isFieldOrDatumDef(encoding.x2) || channel === "y" && isFieldOrDatumDef(encoding.y2)) {
            channelDef = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0, _axis[channel] = channelDef ? this.initAxis({...channelDef}) : channelDef;
          }
          return _axis;
        }, {});
      }
      initAxis(axis) {
        var props = keys(axis);
        const axisInternal = {};
        for (const prop of props) {
          props = axis[prop], axisInternal[prop] = props?.condition ? signalOrValueRefWithCondition(props) : signalRefOrValue(props);
        }
        return axisInternal;
      }
      initLegends(encoding) {
        return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
          var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]), JSCompiler_temp;
          if (JSCompiler_temp = fieldOrDatumDef) {
            a: {
              switch(channel) {
                case "color":
                case "fill":
                case "stroke":
                case "size":
                case "shape":
                case "opacity":
                case "strokeWidth":
                case "strokeDash":
                  JSCompiler_temp = !0;
                  break a;
                case "fillOpacity":
                case "strokeOpacity":
                case "angle":
                case "time":
                  JSCompiler_temp = !1;
                  break a;
              }
              JSCompiler_temp = void 0;
            }
          }
          JSCompiler_temp && (fieldOrDatumDef = fieldOrDatumDef.legend, _legend[channel] = fieldOrDatumDef ? replaceExprRef(fieldOrDatumDef) : fieldOrDatumDef);
          return _legend;
        }, {});
      }
      parseData() {
        this.component.data = parseData(this);
      }
      parseLayoutSize() {
        const {size, component} = this;
        for (const channel of POSITION_SCALE_CHANNELS) {
          const sizeType = getSizeChannel(channel);
          if (size[sizeType]) {
            var specifiedSize = size[sizeType];
            component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, !0);
          } else {
            specifiedSize = defaultUnitSize(this, sizeType), component.layoutSize.set(sizeType, specifiedSize, !1);
          }
        }
      }
      parseSelections() {
        var JSCompiler_temp_const = this.component;
        {
          var selDefs = this.selection;
          const selCmpts = {}, selectionConfig = this.config.selection;
          if (selDefs && selDefs.length) {
            var JSCompiler_inline_result = 0;
            for (const def of selDefs) {
              selDefs = varName(def.name);
              var selDef = def.select, type = vega.isString(selDef) ? selDef : selDef.type;
              selDef = vega.isObject(selDef) ? duplicate(selDef) : {type};
              const cfg = selectionConfig[type];
              for (const key in cfg) {
                key !== "fields" && key !== "encodings" && (key === "mark" && (selDef.mark = {...cfg.mark, ...selDef.mark}), selDef[key] === void 0 || selDef[key] === !0) && (selDef[key] = duplicate(cfg[key] ?? selDef[key]));
              }
              type = selCmpts[selDefs] = {...selDef, name:selDefs, type, init:def.value, bind:def.bind, events:vega.isString(selDef.on) ? vega.parseSelector(selDef.on, "scope") : vega.array(duplicate(selDef.on))};
              if (isTimerSelection(type) && (JSCompiler_inline_result++, JSCompiler_inline_result > 1)) {
                delete selCmpts[selDefs];
                continue;
              }
              selDefs = duplicate(def);
              for (const c of selectionCompilers) {
                c.defined(type) && c.parse && c.parse(this, type, selDefs);
              }
            }
            JSCompiler_inline_result > 1 && warn("Multiple timer selections in one unit spec are not supported. Ignoring all but the first.");
          }
          JSCompiler_inline_result = selCmpts;
        }
        JSCompiler_temp_const.selection = JSCompiler_inline_result;
      }
      parseMarkGroup() {
        this.component.mark = parseMarkGroups(this);
      }
      parseAxesAndHeaders() {
        this.component.axes = parseUnitAxes(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return assembleTopLevelSignals(this, signals);
      }
      assembleSignals() {
        var JSCompiler_temp_const = [...assembleAxisSignals(this)];
        var JSCompiler_inline_result = [];
        for (const selCmpt of vals(this.component.selection ?? {})) {
          const name = selCmpt.name;
          let modifyExpr = `${name}${"_tuple"}, ${selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(this)}}`}`;
          for (const c of selectionCompilers) {
            c.defined(selCmpt) && (c.signals && (JSCompiler_inline_result = c.signals(this, selCmpt, JSCompiler_inline_result)), c.modifyExpr && (modifyExpr = c.modifyExpr(this, selCmpt, modifyExpr)));
          }
          JSCompiler_inline_result.push({name:name + "_modify", on:[{events:{signal:selCmpt.name + "_tuple"}, update:`modify(${vega.stringValue(selCmpt.name + "_store")}, ${modifyExpr})`}]});
        }
        JSCompiler_inline_result = cleanupEmptyOnArray(JSCompiler_inline_result);
        return [...JSCompiler_temp_const, ...JSCompiler_inline_result];
      }
      assembleSelectionData(data) {
        return assembleUnitSelectionData(this, data);
      }
      assembleLayout() {
        return null;
      }
      assembleLayoutSignals() {
        return assembleLayoutSignals(this);
      }
      correctDataNames=mark => {
        mark.from?.data && (mark.from.data = this.lookupDataSource(mark.from.data), "time" in this.encoding && (mark.from.data += "_curr"));
        mark.from?.facet?.data && (mark.from.facet.data = this.lookupDataSource(mark.from.facet.data));
        return mark;
      };
      assembleMarks() {
        let marks = this.component.mark ?? [];
        this.parent && isLayerModel(this.parent) || (marks = assembleUnitSelectionMarks(this, marks));
        return marks.map(this.correctDataNames);
      }
      assembleGroupStyle() {
        const {style} = this.view || {};
        return style !== void 0 ? style : this.encoding.x || this.encoding.y ? "cell" : "view";
      }
      getMapping() {
        return this.encoding;
      }
      get mark() {
        return this.markDef.type;
      }
      channelHasField(channel) {
        return channelHasField(this.encoding, channel);
      }
      fieldDef(channel) {
        return getFieldDef(this.encoding[channel]);
      }
      typedFieldDef(channel) {
        channel = this.fieldDef(channel);
        return isTypedFieldDef(channel) ? channel : null;
      }
    }
    class LayerModel extends Model {
      constructor(spec, parent, parentGivenName, parentGivenSize, config) {
        super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
        const layoutSize = {...parentGivenSize, ...(spec.width ? {width:spec.width} : {}), ...(spec.height ? {height:spec.height} : {})};
        this.children = spec.layer.map((layer, i) => {
          if (hasProperty(layer, "layer")) {
            return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
          }
          if (isUnitSpec(layer)) {
            return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
          }
          throw Error(invalidSpec(layer));
        });
      }
      parseData() {
        this.component.data = parseData(this);
        for (const child of this.children) {
          child.parseData();
        }
      }
      parseLayoutSize() {
        parseChildrenLayoutSize(this);
        parseNonUnitLayoutSizeForChannel(this, "width");
        parseNonUnitLayoutSizeForChannel(this, "height");
      }
      parseSelections() {
        this.component.selection = {};
        for (const child of this.children) {
          child.parseSelections();
          for (const key of keys(child.component.selection)) {
            this.component.selection[key] = child.component.selection[key];
          }
        }
        Object.values(this.component.selection).some(selCmpt => isTimerSelection(selCmpt)) && error("Animation involving facet, layer, or concat is currently unsupported.");
      }
      parseMarkGroup() {
        for (const child of this.children) {
          child.parseMarkGroup();
        }
      }
      parseAxesAndHeaders() {
        const {axes, resolve} = this.component, axisCount = {top:0, bottom:0, right:0, left:0};
        for (var child$jscomp$0 of this.children) {
          child$jscomp$0.parseAxesAndHeaders();
          for (const channel of keys(child$jscomp$0.component.axes)) {
            resolve.axis[channel] = parseGuideResolve(this.component.resolve, channel), resolve.axis[channel] === "shared" && (axes[channel] = mergeAxisComponents(axes[channel], child$jscomp$0.component.axes[channel]), axes[channel] || (resolve.axis[channel] = "independent", delete axes[channel]));
          }
        }
        for (const channel of POSITION_SCALE_CHANNELS) {
          for (const child of this.children) {
            if (child.component.axes[channel]) {
              if (resolve.axis[channel] === "independent") {
                axes[channel] = (axes[channel] ?? []).concat(child.component.axes[channel]);
                for (const axisComponent of child.component.axes[channel]) {
                  const {value:orient, explicit} = axisComponent.getWithExplicit("orient");
                  isSignalRef(orient) || (axisCount[orient] > 0 && !explicit && (child$jscomp$0 = OPPOSITE_ORIENT[orient], axisCount[orient] > axisCount[child$jscomp$0] && axisComponent.set("orient", child$jscomp$0, !1)), axisCount[orient]++);
                }
              }
              delete child.component.axes[channel];
            }
          }
          if (resolve.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
            for (const [index, axisCmpt] of (axes[channel] || []).entries()) {
              index > 0 && axisCmpt.get("grid") && !axisCmpt.explicit.grid && (axisCmpt.implicit.grid = !1);
            }
          }
        }
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
      }
      assembleSignals() {
        return this.children.reduce((signals, child) => signals.concat(child.assembleSignals()), assembleAxisSignals(this));
      }
      assembleLayoutSignals() {
        return this.children.reduce((signals, child) => signals.concat(child.assembleLayoutSignals()), assembleLayoutSignals(this));
      }
      assembleSelectionData(data) {
        return this.children.reduce((db, child) => child.assembleSelectionData(db), data);
      }
      assembleGroupStyle() {
        var uniqueStyles = new Set();
        for (const child of this.children) {
          for (const style of vega.array(child.assembleGroupStyle())) {
            uniqueStyles.add(style);
          }
        }
        uniqueStyles = Array.from(uniqueStyles);
        return uniqueStyles.length > 1 ? uniqueStyles : uniqueStyles.length === 1 ? uniqueStyles[0] : void 0;
      }
      assembleTitle() {
        let title = super.assembleTitle();
        if (title) {
          return title;
        }
        for (const child of this.children) {
          if (title = child.assembleTitle()) {
            return title;
          }
        }
      }
      assembleLayout() {
        return null;
      }
      assembleMarks() {
        return assembleLayerSelectionMarks(this, this.children.flatMap(child => child.assembleMarks()));
      }
      assembleLegends() {
        return this.children.reduce((legends, child) => legends.concat(child.assembleLegends()), assembleLegends(this));
      }
    }
    exports.accessPathDepth = accessPathDepth;
    exports.accessPathWithDatum = accessPathWithDatum;
    exports.accessWithDatumToUnescapedPath = accessWithDatumToUnescapedPath;
    exports.compile = function(inputSpec) {
      let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      opt.logger && (current = opt.logger);
      opt.fieldTitle && (titleFormatter = opt.fieldTitle);
      try {
        const config = initConfig(vega.mergeConfig(opt.config, inputSpec.config)), spec = normalize(inputSpec, config), model = buildModel(spec, null, "", void 0, config);
        model.parse();
        var data = model.component.data;
        checkLinks(data.sources);
        var firstPassCounter = 0;
        let secondPassCounter = 0;
        for (var i = 0; i < 5 && optimizationDataflowHelper(data, model, !0); i++) {
          firstPassCounter++;
        }
        data.sources.map(moveFacetDown);
        for (i = 0; i < 5 && optimizationDataflowHelper(data, model, !1); i++) {
          secondPassCounter++;
        }
        checkLinks(data.sources);
        Math.max(firstPassCounter, secondPassCounter) === 5 && warn("Maximum optimization runs(5) reached.");
        var autosize = spec.autosize;
        const width = model.component.layoutSize.get("width"), height = model.component.layoutSize.get("height");
        autosize === void 0 ? (autosize = {type:"pad"}, model.hasAxisOrientSignalRef() && (autosize.resize = !0)) : vega.isString(autosize) && (autosize = {type:autosize});
        if (width && height && ["fit", "fit-x", "fit-y"].includes(autosize.type)) {
          if (width === "step" && height === "step") {
            warn(droppingFit()), autosize.type = "pad";
          } else if (width === "step" || height === "step") {
            firstPassCounter = width === "step" ? "width" : "height";
            warn(droppingFit(getPositionScaleChannel(firstPassCounter)));
            data = autosize;
            var JSCompiler_inline_result = (firstPassCounter = firstPassCounter === "width" ? "height" : "width", `fit-${getPositionScaleChannel(firstPassCounter)}`);
            data.type = JSCompiler_inline_result;
          }
        }
        var JSCompiler_inline_result$jscomp$0 = {...(keys(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : {autosize:autosize.type} : {autosize}), ...extractTopLevelProperties(config, !1), ...extractTopLevelProperties(inputSpec, !0)};
        return {spec:assembleTopLevelModel(model, JSCompiler_inline_result$jscomp$0, inputSpec.datasets, inputSpec.usermeta), normalized:spec};
      } finally {
        opt.logger && (current = main), opt.fieldTitle && (titleFormatter = defaultTitleFormatter);
      }
    };
    exports.contains = contains;
    exports.deepEqual = deepEqual;
    exports.deleteNestedProperty = deleteNestedProperty;
    exports.duplicate = duplicate;
    exports.entries = entries$1;
    exports.every = every;
    exports.fieldIntersection = fieldIntersection;
    exports.flatAccessWithDatum = flatAccessWithDatum;
    exports.getFirstDefined = getFirstDefined;
    exports.hasIntersection = hasIntersection;
    exports.hasProperty = hasProperty;
    exports.hash = hash;
    exports.internalField = internalField;
    exports.isBoolean = isBoolean;
    exports.isEmpty = isEmpty;
    exports.isEqual = function(dict, other) {
      const dictKeys = keys(dict), otherKeys = keys(other);
      if (dictKeys.length !== otherKeys.length) {
        return !1;
      }
      for (const key of dictKeys) {
        if (dict[key] !== other[key]) {
          return !1;
        }
      }
      return !0;
    };
    exports.isInternalField = isInternalField;
    exports.isNullOrFalse = isNullOrFalse;
    exports.isNumeric = isNumeric;
    exports.keys = keys;
    exports.logicalExpr = logicalExpr;
    exports.mergeDeep = mergeDeep;
    exports.never = never;
    exports.normalize = normalize;
    exports.normalizeAngle = normalizeAngle;
    exports.omit = omit;
    exports.pick = pick;
    exports.prefixGenerator = prefixGenerator;
    exports.removePathFromField = removePathFromField;
    exports.replaceAll = replaceAll;
    exports.replacePathInField = replacePathInField;
    exports.resetIdCounter = function() {
      idCounter = 42;
    };
    exports.setEqual = setEqual;
    exports.some = some;
    exports.stringify = stringify;
    exports.titleCase = titleCase;
    exports.unique = unique;
    exports.uniqueId = uniqueId;
    exports.vals = vals;
    exports.varName = varName;
    exports.version = "5.23.0";
  });
};

//# sourceMappingURL=module$node_modules$vega_lite$build$vega_lite.js.map
