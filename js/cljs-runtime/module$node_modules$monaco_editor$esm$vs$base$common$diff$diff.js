shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$diff$diff = function(require, module, exports) {
  function stringDiff(original, modified, pretty) {
    return (new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified))).ComputeDiff(pretty).changes;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LcsDiff:{enumerable:!0, get:function() {
    return LcsDiff;
  }}, StringDiffSequence:{enumerable:!0, get:function() {
    return StringDiffSequence;
  }}, stringDiff:{enumerable:!0, get:function() {
    return stringDiff;
  }}});
  var require$_DOT__SLASH_diffChange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$diff$diffChange"), require$_DOT__DOT__SLASH_hash_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$hash");
  class StringDiffSequence {
    constructor(source) {
      this.source = source;
    }
    getElements() {
      const source = this.source, characters = new Int32Array(source.length);
      for (let i = 0, len = source.length; i < len; i++) {
        characters[i] = source.charCodeAt(i);
      }
      return characters;
    }
  }
  class Debug {
    static Assert(condition, message) {
      if (!condition) {
        throw Error(message);
      }
    }
  }
  class MyArray {
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
  }
  class DiffChangeHelper {
    constructor() {
      this.m_changes = [];
      this.m_modifiedStart = this.m_originalStart = 1073741824;
      this.m_modifiedCount = this.m_originalCount = 0;
    }
    MarkNextChange() {
      (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
      this.m_modifiedCount = this.m_originalCount = 0;
      this.m_modifiedStart = this.m_originalStart = 1073741824;
    }
    AddOriginalElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_originalCount++;
    }
    AddModifiedElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_modifiedCount++;
    }
    getChanges() {
      (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange();
      return this.m_changes;
    }
    getReverseChanges() {
      (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange();
      this.m_changes.reverse();
      return this.m_changes;
    }
  }
  class LcsDiff {
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
      this.ContinueProcessingPredicate = continueProcessingPredicate;
      this._originalSequence = originalSequence;
      this._modifiedSequence = modifiedSequence;
      const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence), [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
      this._hasStrings = originalHasStrings && modifiedHasStrings;
      this._originalStringElements = originalStringElements;
      this._originalElementsOrHash = originalElementsOrHash;
      this._modifiedStringElements = modifiedStringElements;
      this._modifiedElementsOrHash = modifiedElementsOrHash;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
      return arr.length > 0 && typeof arr[0] === "string";
    }
    static _getElements(sequence) {
      sequence = sequence.getElements();
      if (LcsDiff._isStringArray(sequence)) {
        const hashes = new Int32Array(sequence.length);
        for (let i = 0, len = sequence.length; i < len; i++) {
          hashes[i] = (0,require$_DOT__DOT__SLASH_hash_DOT_js.stringHash)(sequence[i], 0);
        }
        return [sequence, hashes, !0];
      }
      return sequence instanceof Int32Array ? [[], sequence, !1] : [[], new Int32Array(sequence), !1];
    }
    ElementsAreEqual(originalIndex, newIndex) {
      return this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex] ? !1 : this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : !0;
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
      if (!this.ElementsAreEqual(originalIndex, newIndex)) {
        return !1;
      }
      originalIndex = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
      newIndex = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
      return originalIndex === newIndex;
    }
    static _getStrictElement(sequence, index) {
      return typeof sequence.getStrictElement === "function" ? sequence.getStrictElement(index) : null;
    }
    OriginalElementsAreEqual(index1, index2) {
      return this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2] ? !1 : this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : !0;
    }
    ModifiedElementsAreEqual(index1, index2) {
      return this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2] ? !1 : this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : !0;
    }
    ComputeDiff(pretty) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
      const quitEarlyArr = [!1];
      originalStart = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
      pretty && (originalStart = this.PrettifyChanges(originalStart));
      return {quitEarly:quitEarlyArr[0], changes:originalStart};
    }
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
      for (quitEarlyArr[0] = !1; originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart);) {
        originalStart++, modifiedStart++;
      }
      for (; originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd);) {
        originalEnd--, modifiedEnd--;
      }
      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
        return modifiedStart <= modifiedEnd ? (Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd"), originalEnd = [new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)]) : originalStart <= originalEnd ? (Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd"), originalEnd = [new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(originalStart, 
        originalEnd - originalStart + 1, modifiedStart, 0)]) : (Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd"), Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd"), originalEnd = []), originalEnd;
      }
      var midOriginalArr = [0], midModifiedArr = [0];
      const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
      midOriginalArr = midOriginalArr[0];
      midModifiedArr = midModifiedArr[0];
      return result !== null ? result : quitEarlyArr[0] ? [new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)] : (originalStart = this.ComputeDiffRecursive(originalStart, midOriginalArr, modifiedStart, midModifiedArr, quitEarlyArr), originalEnd = quitEarlyArr[0] ? [new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(midOriginalArr + 1, originalEnd - (midOriginalArr + 1) + 1, midModifiedArr + 1, modifiedEnd - 
      (midModifiedArr + 1) + 1)] : this.ComputeDiffRecursive(midOriginalArr + 1, originalEnd, midModifiedArr + 1, modifiedEnd, quitEarlyArr), this.ConcatenateChanges(originalStart, originalEnd));
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
      let changeHelper = new DiffChangeHelper();
      modifiedIndex = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
      let lastOriginalIndex = -1073741824, historyIndex = this.m_forwardHistory.length - 1;
      do {
        const diagonal = modifiedIndex + diagonalForwardBase;
        diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1] ? (originalIndex = forwardPoints[diagonal + 1], modifiedIndex = originalIndex - modifiedIndex - diagonalForwardOffset, originalIndex < lastOriginalIndex && changeHelper.MarkNextChange(), lastOriginalIndex = originalIndex, changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex), modifiedIndex = diagonal + 1 - diagonalForwardBase) : (originalIndex = forwardPoints[diagonal - 
        1] + 1, modifiedIndex = originalIndex - modifiedIndex - diagonalForwardOffset, originalIndex < lastOriginalIndex && changeHelper.MarkNextChange(), lastOriginalIndex = originalIndex - 1, changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1), modifiedIndex = diagonal - 1 - diagonalForwardBase);
        historyIndex >= 0 && (forwardPoints = this.m_forwardHistory[historyIndex], diagonalForwardBase = forwardPoints[0], diagonalForwardStart = 1, diagonalForwardEnd = forwardPoints.length - 1);
      } while (--historyIndex >= -1);
      diagonalForwardBase = changeHelper.getReverseChanges();
      if (quitEarlyArr[0]) {
        diagonalReverseBase = midOriginalArr[0] + 1, diagonalReverseOffset = midModifiedArr[0] + 1, diagonalForwardBase !== null && diagonalForwardBase.length > 0 && (reversePoints = diagonalForwardBase[diagonalForwardBase.length - 1], diagonalReverseBase = Math.max(diagonalReverseBase, reversePoints.getOriginalEnd()), diagonalReverseOffset = Math.max(diagonalReverseOffset, reversePoints.getModifiedEnd())), originalEnd = [new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(diagonalReverseBase, originalEnd - 
        diagonalReverseBase + 1, diagonalReverseOffset, modifiedEnd - diagonalReverseOffset + 1)];
      } else {
        changeHelper = new DiffChangeHelper();
        diagonalForwardStart = diagonalReverseStart;
        diagonalForwardEnd = diagonalReverseEnd;
        modifiedIndex = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
        lastOriginalIndex = 1073741824;
        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          originalEnd = modifiedIndex + diagonalReverseBase, originalEnd === diagonalForwardStart || originalEnd < diagonalForwardEnd && reversePoints[originalEnd - 1] >= reversePoints[originalEnd + 1] ? (originalIndex = reversePoints[originalEnd + 1] - 1, modifiedIndex = originalIndex - modifiedIndex - diagonalReverseOffset, originalIndex > lastOriginalIndex && changeHelper.MarkNextChange(), lastOriginalIndex = originalIndex + 1, changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 
          1), modifiedIndex = originalEnd + 1 - diagonalReverseBase) : (originalIndex = reversePoints[originalEnd - 1], modifiedIndex = originalIndex - modifiedIndex - diagonalReverseOffset, originalIndex > lastOriginalIndex && changeHelper.MarkNextChange(), lastOriginalIndex = originalIndex, changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1), modifiedIndex = originalEnd - 1 - diagonalReverseBase), historyIndex >= 0 && (reversePoints = this.m_reverseHistory[historyIndex], diagonalReverseBase = 
          reversePoints[0], diagonalForwardStart = 1, diagonalForwardEnd = reversePoints.length - 1);
        } while (--historyIndex >= -1);
        originalEnd = changeHelper.getChanges();
      }
      return this.ConcatenateChanges(diagonalForwardBase, originalEnd);
    }
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
      let originalIndex = 0, modifiedIndex = 0, diagonalForwardStart = 0, diagonalForwardEnd = 0, diagonalReverseStart = 0, diagonalReverseEnd = 0;
      originalStart--;
      modifiedStart--;
      midOriginalArr[0] = 0;
      midModifiedArr[0] = 0;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
      const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart), numDiagonals = maxDifferences + 1, forwardPoints = new Int32Array(numDiagonals), reversePoints = new Int32Array(numDiagonals), diagonalForwardBase = modifiedEnd - modifiedStart, diagonalReverseBase = originalEnd - originalStart, diagonalForwardOffset = originalStart - modifiedStart, diagonalReverseOffset = originalEnd - modifiedEnd, deltaIsEven = (diagonalReverseBase - diagonalForwardBase) % 2 === 0;
      forwardPoints[diagonalForwardBase] = originalStart;
      reversePoints[diagonalReverseBase] = originalEnd;
      quitEarlyArr[0] = !1;
      for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
        var furthestOriginalIndex = 0, furthestModifiedIndex = 0;
        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        for (var diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
          originalIndex = diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1] ? forwardPoints[diagonal + 1] : forwardPoints[diagonal - 1] + 1;
          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
          const tempOriginalIndex = originalIndex;
          for (; originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1);) {
            originalIndex++, modifiedIndex++;
          }
          forwardPoints[diagonal] = originalIndex;
          originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex && (furthestOriginalIndex = originalIndex, furthestModifiedIndex = modifiedIndex);
          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1 && originalIndex >= reversePoints[diagonal]) {
            return midOriginalArr[0] = originalIndex, midModifiedArr[0] = modifiedIndex, tempOriginalIndex <= reversePoints[diagonal] && numDifferences <= 1448 ? this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) : null;
          }
        }
        diagonal = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, diagonal)) {
          if (quitEarlyArr[0] = !0, midOriginalArr[0] = furthestOriginalIndex, midModifiedArr[0] = furthestModifiedIndex, diagonal > 0 && numDifferences <= 1448) {
            break;
          } else {
            return originalStart++, modifiedStart++, [new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];
          }
        }
        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        for (furthestOriginalIndex = diagonalReverseStart; furthestOriginalIndex <= diagonalReverseEnd; furthestOriginalIndex += 2) {
          originalIndex = furthestOriginalIndex === diagonalReverseStart || furthestOriginalIndex < diagonalReverseEnd && reversePoints[furthestOriginalIndex - 1] >= reversePoints[furthestOriginalIndex + 1] ? reversePoints[furthestOriginalIndex + 1] - 1 : reversePoints[furthestOriginalIndex - 1];
          modifiedIndex = originalIndex - (furthestOriginalIndex - diagonalReverseBase) - diagonalReverseOffset;
          for (furthestModifiedIndex = originalIndex; originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex);) {
            originalIndex--, modifiedIndex--;
          }
          reversePoints[furthestOriginalIndex] = originalIndex;
          if (deltaIsEven && Math.abs(furthestOriginalIndex - diagonalForwardBase) <= numDifferences && originalIndex <= forwardPoints[furthestOriginalIndex]) {
            return midOriginalArr[0] = originalIndex, midModifiedArr[0] = modifiedIndex, furthestModifiedIndex >= forwardPoints[furthestOriginalIndex] && numDifferences <= 1448 ? this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) : 
            null;
          }
        }
        numDifferences <= 1447 && (furthestOriginalIndex = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2), furthestOriginalIndex[0] = diagonalForwardBase - diagonalForwardStart + 1, MyArray.Copy2(forwardPoints, diagonalForwardStart, furthestOriginalIndex, 1, diagonalForwardEnd - diagonalForwardStart + 1), this.m_forwardHistory.push(furthestOriginalIndex), furthestOriginalIndex = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2), furthestOriginalIndex[0] = diagonalReverseBase - 
        diagonalReverseStart + 1, MyArray.Copy2(reversePoints, diagonalReverseStart, furthestOriginalIndex, 1, diagonalReverseEnd - diagonalReverseStart + 1), this.m_reverseHistory.push(furthestOriginalIndex));
      }
      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    PrettifyChanges(changes) {
      for (var i$jscomp$0 = 0; i$jscomp$0 < changes.length; i$jscomp$0++) {
        for (var change = changes[i$jscomp$0], originalStop = i$jscomp$0 < changes.length - 1 ? changes[i$jscomp$0 + 1].originalStart : this._originalElementsOrHash.length, modifiedStop = i$jscomp$0 < changes.length - 1 ? changes[i$jscomp$0 + 1].modifiedStart : this._modifiedElementsOrHash.length, checkOriginal = change.originalLength > 0, checkModified = change.modifiedLength > 0; change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && 
        (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength));) {
          var startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
          if (this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength) && !startStrictEqual) {
            break;
          }
          change.originalStart++;
          change.modifiedStart++;
        }
        change = [null];
        i$jscomp$0 < changes.length - 1 && this.ChangesOverlap(changes[i$jscomp$0], changes[i$jscomp$0 + 1], change) && (changes[i$jscomp$0] = change[0], changes.splice(i$jscomp$0 + 1, 1), i$jscomp$0--);
      }
      for (i$jscomp$0 = changes.length - 1; i$jscomp$0 >= 0; i$jscomp$0--) {
        change = changes[i$jscomp$0];
        modifiedStop = originalStop = 0;
        i$jscomp$0 > 0 && (modifiedStop = changes[i$jscomp$0 - 1], originalStop = modifiedStop.originalStart + modifiedStop.originalLength, modifiedStop = modifiedStop.modifiedStart + modifiedStop.modifiedLength);
        checkOriginal = change.originalLength > 0;
        checkModified = change.modifiedLength > 0;
        startStrictEqual = 0;
        var bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
        for (var delta = 1;; delta++) {
          var originalStart = change.originalStart - delta;
          const modifiedStart = change.modifiedStart - delta;
          if (originalStart < originalStop || modifiedStart < modifiedStop) {
            break;
          }
          if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
            break;
          }
          if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
            break;
          }
          originalStart = (originalStart === originalStop && modifiedStart === modifiedStop ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
          originalStart > bestScore && (bestScore = originalStart, startStrictEqual = delta);
        }
        change.originalStart -= startStrictEqual;
        change.modifiedStart -= startStrictEqual;
        change = [null];
        i$jscomp$0 > 0 && this.ChangesOverlap(changes[i$jscomp$0 - 1], changes[i$jscomp$0], change) && (changes[i$jscomp$0 - 1] = change[0], changes.splice(i$jscomp$0, 1), i$jscomp$0++);
      }
      if (this._hasStrings) {
        for (let i = 1, len = changes.length; i < len; i++) {
          if (i$jscomp$0 = changes[i - 1], change = changes[i], originalStop = change.originalStart - i$jscomp$0.originalStart - i$jscomp$0.originalLength, checkModified = i$jscomp$0.originalStart, modifiedStop = change.originalStart + change.originalLength, startStrictEqual = modifiedStop - checkModified, bestScore = i$jscomp$0.modifiedStart, checkOriginal = change.modifiedStart + change.modifiedLength, delta = checkOriginal - bestScore, originalStop < 5 && startStrictEqual < 20 && delta < 20 && 
          (checkModified = this._findBetterContiguousSequence(checkModified, startStrictEqual, bestScore, delta, originalStop))) {
            const [originalMatchStart, modifiedMatchStart] = checkModified;
            if (originalMatchStart !== i$jscomp$0.originalStart + i$jscomp$0.originalLength || modifiedMatchStart !== i$jscomp$0.modifiedStart + i$jscomp$0.modifiedLength) {
              i$jscomp$0.originalLength = originalMatchStart - i$jscomp$0.originalStart, i$jscomp$0.modifiedLength = modifiedMatchStart - i$jscomp$0.modifiedStart, change.originalStart = originalMatchStart + originalStop, change.modifiedStart = modifiedMatchStart + originalStop, change.originalLength = modifiedStop - change.originalStart, change.modifiedLength = checkOriginal - change.modifiedStart;
            }
          }
        }
      }
      return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
      if (originalLength < desiredLength || modifiedLength < desiredLength) {
        return null;
      }
      originalLength = originalStart + originalLength - desiredLength + 1;
      modifiedLength = modifiedStart + modifiedLength - desiredLength + 1;
      let bestScore = 0, bestOriginalStart = 0, bestModifiedStart = 0;
      for (; originalStart < originalLength; originalStart++) {
        for (let j = modifiedStart; j < modifiedLength; j++) {
          const score = this._contiguousSequenceScore(originalStart, j, desiredLength);
          score > 0 && score > bestScore && (bestScore = score, bestOriginalStart = originalStart, bestModifiedStart = j);
        }
      }
      return bestScore > 0 ? [bestOriginalStart, bestModifiedStart] : null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length) {
      let score = 0;
      for (let l = 0; l < length; l++) {
        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
          return 0;
        }
        score += this._originalStringElements[originalStart + l].length;
      }
      return score;
    }
    _OriginalIsBoundary(index) {
      return index <= 0 || index >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
      return this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1) || originalLength > 0 && (originalStart += originalLength, this._OriginalIsBoundary(originalStart - 1) || this._OriginalIsBoundary(originalStart)) ? !0 : !1;
    }
    _ModifiedIsBoundary(index) {
      return index <= 0 || index >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
      return this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1) || modifiedLength > 0 && (modifiedStart += modifiedLength, this._ModifiedIsBoundary(modifiedStart - 1) || this._ModifiedIsBoundary(modifiedStart)) ? !0 : !1;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
      originalStart = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
      modifiedStart = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
      return originalStart + modifiedStart;
    }
    ConcatenateChanges(left, right) {
      var mergedChangeArr = [];
      if (left.length === 0 || right.length === 0) {
        return right.length > 0 ? right : left;
      }
      if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
        const result = Array(left.length + right.length - 1);
        MyArray.Copy(left, 0, result, 0, left.length - 1);
        result[left.length - 1] = mergedChangeArr[0];
        MyArray.Copy(right, 1, result, left.length, right.length - 1);
        return result;
      }
      mergedChangeArr = Array(left.length + right.length);
      MyArray.Copy(left, 0, mergedChangeArr, 0, left.length);
      MyArray.Copy(right, 0, mergedChangeArr, left.length, right.length);
      return mergedChangeArr;
    }
    ChangesOverlap(left, right, mergedChangeArr) {
      Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
      Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        const originalStart = left.originalStart;
        let originalLength = left.originalLength;
        const modifiedStart = left.modifiedStart;
        let modifiedLength = left.modifiedLength;
        left.originalStart + left.originalLength >= right.originalStart && (originalLength = right.originalStart + right.originalLength - left.originalStart);
        left.modifiedStart + left.modifiedLength >= right.modifiedStart && (modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart);
        mergedChangeArr[0] = new require$_DOT__SLASH_diffChange_DOT_js.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
        return !0;
      }
      mergedChangeArr[0] = null;
      return !1;
    }
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
      if (diagonal >= 0 && diagonal < numDiagonals) {
        return diagonal;
      }
      numDifferences = numDifferences % 2 === 0;
      return diagonal < 0 ? numDifferences === (diagonalBaseIndex % 2 === 0) ? 0 : 1 : numDifferences === ((numDiagonals - diagonalBaseIndex - 1) % 2 === 0) ? numDiagonals - 1 : numDiagonals - 2;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$diff$diff.js.map
