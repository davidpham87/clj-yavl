shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$standalone$common$monarch$monarchCompile = function(require, module, exports) {
  function isArrayOf(elemType, obj) {
    if (!obj || !Array.isArray(obj)) {
      return !1;
    }
    for (const el of obj) {
      if (!elemType(el)) {
        return !1;
      }
    }
    return !0;
  }
  function bool(prop, defValue) {
    return typeof prop === "boolean" ? prop : defValue;
  }
  function string(prop, defValue) {
    return typeof prop === "string" ? prop : defValue;
  }
  function arrayToHash(array) {
    const result = {};
    for (const e of array) {
      result[e] = !0;
    }
    return result;
  }
  function createKeywordMatcher(arr, caseInsensitive = !1) {
    caseInsensitive && (arr = arr.map(function(x) {
      return x.toLowerCase();
    }));
    const hash = arrayToHash(arr);
    return caseInsensitive ? function(word) {
      return hash[word.toLowerCase()] !== void 0 && hash.hasOwnProperty(word.toLowerCase());
    } : function(word) {
      return hash[word] !== void 0 && hash.hasOwnProperty(word);
    };
  }
  function compileRegExp(lexer, str) {
    str = str.replace(/@@/g, "");
    let n = 0, hadExpansion;
    do {
      hadExpansion = !1, str = str.replace(/@(\w+)/g, function(s, attr) {
        hadExpansion = !0;
        if (typeof lexer[attr] === "string") {
          s = lexer[attr];
        } else if (lexer[attr] && lexer[attr] instanceof RegExp) {
          s = lexer[attr].source;
        } else {
          if (lexer[attr] === void 0) {
            throw monarchCommon.createError(lexer, "language definition does not contain attribute '" + attr + "', used at: " + str);
          }
          throw monarchCommon.createError(lexer, "attribute reference '" + attr + "' must be a string, used at: " + str);
        }
        return monarchCommon.empty(s) ? "" : "(?:" + s + ")";
      }), n++;
    } while (hadExpansion && n < 5);
    str = str.replace(/\x01/g, "@");
    return new RegExp(str, (lexer.ignoreCase ? "i" : "") + (lexer.unicode ? "u" : ""));
  }
  function createGuard(lexer, ruleName, tkey, val) {
    let scrut = -1;
    var oppat = tkey;
    let matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
    matches && (matches[3] && (scrut = parseInt(matches[3]), matches[2] && (scrut += 100)), oppat = matches[4]);
    let op = "~", pat = oppat;
    if (oppat && oppat.length !== 0) {
      if (/^\w*$/.test(pat)) {
        op = "\x3d\x3d";
      } else {
        if (matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/)) {
          op = matches[1], pat = matches[2];
        }
      }
    } else {
      op = "!\x3d", pat = "";
    }
    let tester;
    if (op !== "~" && op !== "!~" || !/^(\w|\|)*$/.test(pat)) {
      if (op === "@" || op === "!@") {
        oppat = lexer[pat];
        if (!oppat) {
          throw monarchCommon.createError(lexer, "the @ match target '" + pat + "' is not defined, in rule: " + ruleName);
        }
        if (!isArrayOf(function(elem) {
          return typeof elem === "string";
        }, oppat)) {
          throw monarchCommon.createError(lexer, "the @ match target '" + pat + "' must be an array of strings, in rule: " + ruleName);
        }
        const inWords = createKeywordMatcher(oppat, lexer.ignoreCase);
        tester = function(s) {
          return op === "@" ? inWords(s) : !inWords(s);
        };
      } else if (op === "~" || op === "!~") {
        if (pat.indexOf("$") < 0) {
          const re = compileRegExp(lexer, "^" + pat + "$");
          tester = function(s) {
            return op === "~" ? re.test(s) : !re.test(s);
          };
        } else {
          tester = function(s, id, matches, state) {
            return compileRegExp(lexer, "^" + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + "$").test(s);
          };
        }
      } else {
        if (pat.indexOf("$") < 0) {
          const patx = monarchCommon.fixCase(lexer, pat);
          tester = function(s) {
            return op === "\x3d\x3d" ? s === patx : s !== patx;
          };
        } else {
          const patx = monarchCommon.fixCase(lexer, pat);
          tester = function(s, id, matches, state, eos) {
            id = monarchCommon.substituteMatches(lexer, patx, id, matches, state);
            return op === "\x3d\x3d" ? s === id : s !== id;
          };
        }
      }
    } else {
      const inWords = createKeywordMatcher(pat.split("|"), lexer.ignoreCase);
      tester = function(s) {
        return op === "~" ? inWords(s) : !inWords(s);
      };
    }
    return scrut === -1 ? {name:tkey, value:val, test:function(id, matches, state, eos) {
      return tester(id, id, matches, state, eos);
    }} : {name:tkey, value:val, test:function(id, matches, state, eos) {
      a: {
        var JSCompiler_inline_result = scrut;
        if (JSCompiler_inline_result < 0) {
          JSCompiler_inline_result = id;
        } else {
          if (JSCompiler_inline_result < matches.length) {
            JSCompiler_inline_result = matches[JSCompiler_inline_result];
          } else {
            if (JSCompiler_inline_result >= 100) {
              JSCompiler_inline_result -= 100;
              const parts = state.split(".");
              parts.unshift(state);
              if (JSCompiler_inline_result < parts.length) {
                JSCompiler_inline_result = parts[JSCompiler_inline_result];
                break a;
              }
            }
            JSCompiler_inline_result = null;
          }
        }
      }
      return tester(JSCompiler_inline_result ? JSCompiler_inline_result : "", id, matches, state, eos);
    }};
  }
  function compileAction(lexer, ruleName, action) {
    if (action) {
      if (typeof action === "string") {
        return action;
      }
      if (action.token || action.token === "") {
        if (typeof action.token !== "string") {
          throw monarchCommon.createError(lexer, "a 'token' attribute must be of type string, in rule: " + ruleName);
        }
        var newAction = {token:action.token};
        action.token.indexOf("$") >= 0 && (newAction.tokenSubst = !0);
        if (typeof action.bracket === "string") {
          if (action.bracket === "@open") {
            newAction.bracket = 1;
          } else if (action.bracket === "@close") {
            newAction.bracket = -1;
          } else {
            throw monarchCommon.createError(lexer, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + ruleName);
          }
        }
        if (action.next) {
          if (typeof action.next !== "string") {
            throw monarchCommon.createError(lexer, "the next state must be a string value in rule: " + ruleName);
          }
          var next = action.next;
          if (!/^(@pop|@push|@popall)$/.test(next) && (next[0] === "@" && (next = next.substr(1)), next.indexOf("$") < 0 && !monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, "", [], "")))) {
            throw monarchCommon.createError(lexer, "the next state '" + action.next + "' is not defined in rule: " + ruleName);
          }
          newAction.next = next;
        }
        typeof action.goBack === "number" && (newAction.goBack = action.goBack);
        typeof action.switchTo === "string" && (newAction.switchTo = action.switchTo);
        typeof action.log === "string" && (newAction.log = action.log);
        typeof action.nextEmbedded === "string" && (newAction.nextEmbedded = action.nextEmbedded, lexer.usesEmbedded = !0);
        return newAction;
      }
      if (Array.isArray(action)) {
        newAction = [];
        for (let i = 0, len = action.length; i < len; i++) {
          newAction[i] = compileAction(lexer, ruleName, action[i]);
        }
        return {group:newAction};
      }
      if (action.cases) {
        const cases = [];
        for (newAction in action.cases) {
          action.cases.hasOwnProperty(newAction) && (next = compileAction(lexer, ruleName, action.cases[newAction]), newAction === "@default" || newAction === "@" || newAction === "" ? cases.push({test:void 0, value:next, name:newAction}) : newAction === "@eos" ? cases.push({test:function(id, matches, state, eos) {
            return eos;
          }, value:next, name:newAction}) : cases.push(createGuard(lexer, ruleName, newAction, next)));
        }
        const def = lexer.defaultToken;
        return {test:function(id, matches, state, eos) {
          for (const _case of cases) {
            if (!_case.test || _case.test(id, matches, state, eos)) {
              return _case.value;
            }
          }
          return def;
        }};
      }
      throw monarchCommon.createError(lexer, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + ruleName);
    }
    return {token:""};
  }
  function compile(languageId, json) {
    function addRules(state, newrules, rules) {
      for (const rule of rules) {
        if (rules = rule.include) {
          if (typeof rules !== "string") {
            throw monarchCommon.createError(lexer, "an 'include' attribute must be a string at: " + state);
          }
          rules[0] === "@" && (rules = rules.substr(1));
          if (!json.tokenizer[rules]) {
            throw monarchCommon.createError(lexer, "include target '" + rules + "' is not defined at: " + state);
          }
          addRules(state + "." + rules, newrules, json.tokenizer[rules]);
        } else {
          rules = new Rule(state);
          if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
            if (rules.setRegex(lexerMin, rule[0]), rule.length >= 3) {
              if (typeof rule[1] === "string") {
                rules.setAction(lexerMin, {token:rule[1], next:rule[2]});
              } else if (typeof rule[1] === "object") {
                const rule1 = rule[1];
                rule1.next = rule[2];
                rules.setAction(lexerMin, rule1);
              } else {
                throw monarchCommon.createError(lexer, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + state);
              }
            } else {
              rules.setAction(lexerMin, rule[1]);
            }
          } else {
            if (!rule.regex) {
              throw monarchCommon.createError(lexer, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + state);
            }
            rule.name && typeof rule.name === "string" && (rules.name = rule.name);
            rule.matchOnlyAtStart && (rules.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, !1));
            rules.setRegex(lexerMin, rule.regex);
            rules.setAction(lexerMin, rule.action);
          }
          newrules.push(rules);
        }
      }
    }
    if (!json || typeof json !== "object") {
      throw Error("Monarch: expecting a language definition object");
    }
    const lexer = {};
    lexer.languageId = languageId;
    lexer.includeLF = bool(json.includeLF, !1);
    lexer.noThrow = !1;
    lexer.maxStack = 100;
    lexer.start = typeof json.start === "string" ? json.start : null;
    lexer.ignoreCase = bool(json.ignoreCase, !1);
    lexer.unicode = bool(json.unicode, !1);
    lexer.tokenPostfix = string(json.tokenPostfix, "." + lexer.languageId);
    lexer.defaultToken = string(json.defaultToken, "source");
    lexer.usesEmbedded = !1;
    const lexerMin = json;
    lexerMin.languageId = languageId;
    lexerMin.includeLF = lexer.includeLF;
    lexerMin.ignoreCase = lexer.ignoreCase;
    lexerMin.unicode = lexer.unicode;
    lexerMin.noThrow = lexer.noThrow;
    lexerMin.usesEmbedded = lexer.usesEmbedded;
    lexerMin.stateNames = json.tokenizer;
    lexerMin.defaultToken = lexer.defaultToken;
    if (!json.tokenizer || typeof json.tokenizer !== "object") {
      throw monarchCommon.createError(lexer, "a language definition must define the 'tokenizer' attribute as an object");
    }
    lexer.tokenizer = [];
    for (var key in json.tokenizer) {
      json.tokenizer.hasOwnProperty(key) && (lexer.start || (lexer.start = key), languageId = json.tokenizer[key], lexer.tokenizer[key] = [], addRules("tokenizer." + key, lexer.tokenizer[key], languageId));
    }
    lexer.usesEmbedded = lexerMin.usesEmbedded;
    if (json.brackets) {
      if (!Array.isArray(json.brackets)) {
        throw monarchCommon.createError(lexer, "the 'brackets' attribute must be defined as an array");
      }
    } else {
      json.brackets = [{open:"{", close:"}", token:"delimiter.curly"}, {open:"[", close:"]", token:"delimiter.square"}, {open:"(", close:")", token:"delimiter.parenthesis"}, {open:"\x3c", close:"\x3e", token:"delimiter.angle"}];
    }
    key = [];
    for (const el of json.brackets) {
      (languageId = el) && Array.isArray(languageId) && languageId.length === 3 && (languageId = {token:languageId[2], open:languageId[0], close:languageId[1]});
      if (languageId.open === languageId.close) {
        throw monarchCommon.createError(lexer, "open and close brackets in a 'brackets' attribute must be different: " + languageId.open + "\n hint: use the 'bracket' attribute if matching on equal brackets is required.");
      }
      if (typeof languageId.open === "string" && typeof languageId.token === "string" && typeof languageId.close === "string") {
        key.push({token:languageId.token + lexer.tokenPostfix, open:monarchCommon.fixCase(lexer, languageId.open), close:monarchCommon.fixCase(lexer, languageId.close)});
      } else {
        throw monarchCommon.createError(lexer, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
      }
    }
    lexer.brackets = key;
    lexer.noThrow = !0;
    return lexer;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, compile:{enumerable:!0, get:function() {
    return compile;
  }}});
  var monarchCommon = require("module$node_modules$monaco_editor$esm$vs$editor$standalone$common$monarch$monarchCommon");
  class Rule {
    constructor(name) {
      this.regex = RegExp("");
      this.action = {token:""};
      this.matchOnlyAtLineStart = !1;
      this.name = "";
      this.name = name;
    }
    setRegex(lexer, re) {
      if (typeof re !== "string") {
        if (re instanceof RegExp) {
          re = re.source;
        } else {
          throw monarchCommon.createError(lexer, "rules must start with a match string or regular expression: " + this.name);
        }
      }
      this.matchOnlyAtLineStart = re.length > 0 && re[0] === "^";
      this.name = this.name + ": " + re;
      this.regex = compileRegExp(lexer, "^(?:" + (this.matchOnlyAtLineStart ? re.substr(1) : re) + ")");
    }
    setAction(lexer, act) {
      this.action = compileAction(lexer, this.name, act);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$standalone$common$monarch$monarchCompile.js.map
