shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewLayer = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, RenderedLinesCollection:{enumerable:!0, get:function() {
    return RenderedLinesCollection;
  }}, VisibleLinesCollection:{enumerable:!0, get:function() {
    return VisibleLinesCollection;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode");
  module = require("module$node_modules$monaco_editor$esm$vs$base$browser$trustedTypes");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors");
  require = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder");
  class RenderedLinesCollection {
    constructor(createLine) {
      this._createLine = createLine;
      this._set(1, []);
    }
    flush() {
      this._set(1, []);
    }
    _set(rendLineNumberStart, lines) {
      this._lines = lines;
      this._rendLineNumberStart = rendLineNumberStart;
    }
    _get() {
      return {rendLineNumberStart:this._rendLineNumberStart, lines:this._lines};
    }
    getStartLineNumber() {
      return this._rendLineNumberStart;
    }
    getEndLineNumber() {
      return this._rendLineNumberStart + this._lines.length - 1;
    }
    getCount() {
      return this._lines.length;
    }
    getLine(lineNumber) {
      lineNumber -= this._rendLineNumberStart;
      if (lineNumber < 0 || lineNumber >= this._lines.length) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      return this._lines[lineNumber];
    }
    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {
      if (this.getCount() === 0) {
        return null;
      }
      const startLineNumber = this.getStartLineNumber(), endLineNumber = this.getEndLineNumber();
      if (deleteToLineNumber < startLineNumber) {
        return this._rendLineNumberStart -= deleteToLineNumber - deleteFromLineNumber + 1, null;
      }
      if (deleteFromLineNumber > endLineNumber) {
        return null;
      }
      let deleteStartIndex = 0, deleteCount = 0;
      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        const lineIndex = lineNumber - this._rendLineNumberStart;
        deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber && (deleteCount === 0 ? (deleteStartIndex = lineIndex, deleteCount = 1) : deleteCount++);
      }
      deleteFromLineNumber < startLineNumber && (this._rendLineNumberStart -= deleteToLineNumber < startLineNumber ? deleteToLineNumber - deleteFromLineNumber + 1 : startLineNumber - deleteFromLineNumber);
      return this._lines.splice(deleteStartIndex, deleteCount);
    }
    onLinesChanged(changeFromLineNumber, changeCount) {
      changeCount = changeFromLineNumber + changeCount - 1;
      if (this.getCount() === 0) {
        return !1;
      }
      const startLineNumber = this.getStartLineNumber(), endLineNumber = this.getEndLineNumber();
      let someoneNotified = !1;
      for (; changeFromLineNumber <= changeCount; changeFromLineNumber++) {
        changeFromLineNumber >= startLineNumber && changeFromLineNumber <= endLineNumber && (this._lines[changeFromLineNumber - this._rendLineNumberStart].onContentChanged(), someoneNotified = !0);
      }
      return someoneNotified;
    }
    onLinesInserted(insertFromLineNumber, insertToLineNumber) {
      if (this.getCount() === 0) {
        return null;
      }
      insertToLineNumber = insertToLineNumber - insertFromLineNumber + 1;
      var startLineNumber = this.getStartLineNumber(), endLineNumber = this.getEndLineNumber();
      if (insertFromLineNumber <= startLineNumber) {
        return this._rendLineNumberStart += insertToLineNumber, null;
      }
      if (insertFromLineNumber > endLineNumber) {
        return null;
      }
      if (insertToLineNumber + insertFromLineNumber > endLineNumber) {
        return this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);
      }
      startLineNumber = [];
      for (endLineNumber = 0; endLineNumber < insertToLineNumber; endLineNumber++) {
        startLineNumber[endLineNumber] = this._createLine();
      }
      endLineNumber = insertFromLineNumber - this._rendLineNumberStart;
      insertFromLineNumber = this._lines.slice(0, endLineNumber);
      endLineNumber = this._lines.slice(endLineNumber, this._lines.length - insertToLineNumber);
      insertToLineNumber = this._lines.slice(this._lines.length - insertToLineNumber, this._lines.length);
      this._lines = insertFromLineNumber.concat(startLineNumber).concat(endLineNumber);
      return insertToLineNumber;
    }
    onTokensChanged(ranges) {
      if (this.getCount() === 0) {
        return !1;
      }
      const startLineNumber = this.getStartLineNumber(), endLineNumber = this.getEndLineNumber();
      let notifiedSomeone = !1;
      for (let i = 0, len = ranges.length; i < len; i++) {
        var rng = ranges[i];
        if (!(rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber)) {
          var from = Math.max(startLineNumber, rng.fromLineNumber);
          for (rng = Math.min(endLineNumber, rng.toLineNumber); from <= rng; from++) {
            this._lines[from - this._rendLineNumberStart].onTokensChanged(), notifiedSomeone = !0;
          }
        }
      }
      return notifiedSomeone;
    }
  }
  class VisibleLinesCollection {
    constructor(host) {
      this._host = host;
      this.domNode = this._createDomNode();
      this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());
    }
    _createDomNode() {
      const domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      domNode.setClassName("view-layer");
      domNode.setPosition("absolute");
      domNode.domNode.setAttribute("role", "presentation");
      domNode.domNode.setAttribute("aria-hidden", "true");
      return domNode;
    }
    onConfigurationChanged(e) {
      return e.hasChanged(143) ? !0 : !1;
    }
    onFlushed(e) {
      this._linesCollection.flush();
      return !0;
    }
    onLinesChanged(e) {
      return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
    }
    onLinesDeleted(e) {
      if (e = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber)) {
        for (let i = 0, len = e.length; i < len; i++) {
          const lineDomNode = e[i].getDomNode();
          lineDomNode && this.domNode.domNode.removeChild(lineDomNode);
        }
      }
      return !0;
    }
    onLinesInserted(e) {
      if (e = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber)) {
        for (let i = 0, len = e.length; i < len; i++) {
          const lineDomNode = e[i].getDomNode();
          lineDomNode && this.domNode.domNode.removeChild(lineDomNode);
        }
      }
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onTokensChanged(e) {
      return this._linesCollection.onTokensChanged(e.ranges);
    }
    onZonesChanged(e) {
      return !0;
    }
    getStartLineNumber() {
      return this._linesCollection.getStartLineNumber();
    }
    getEndLineNumber() {
      return this._linesCollection.getEndLineNumber();
    }
    getVisibleLine(lineNumber) {
      return this._linesCollection.getLine(lineNumber);
    }
    renderLines(viewportData) {
      const inp = this._linesCollection._get();
      viewportData = (new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData)).render({rendLineNumberStart:inp.rendLineNumberStart, lines:inp.lines, linesLength:inp.lines.length}, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);
      this._linesCollection._set(viewportData.rendLineNumberStart, viewportData.lines);
    }
  }
  class ViewLayerRenderer {
    constructor(domNode, host, viewportData) {
      this.domNode = domNode;
      this.host = host;
      this.viewportData = viewportData;
    }
    render(inContext, startLineNumber, stopLineNumber, deltaTop) {
      inContext = {rendLineNumberStart:inContext.rendLineNumberStart, lines:inContext.lines.slice(0), linesLength:inContext.linesLength};
      if (inContext.rendLineNumberStart + inContext.linesLength - 1 < startLineNumber || stopLineNumber < inContext.rendLineNumberStart) {
        inContext.rendLineNumberStart = startLineNumber;
        inContext.linesLength = stopLineNumber - startLineNumber + 1;
        inContext.lines = [];
        for (var x = startLineNumber; x <= stopLineNumber; x++) {
          inContext.lines[x - startLineNumber] = this.host.createVisibleLine();
        }
        this._finishRendering(inContext, !0, deltaTop);
        return inContext;
      }
      this._renderUntouchedLines(inContext, Math.max(startLineNumber - inContext.rendLineNumberStart, 0), Math.min(stopLineNumber - inContext.rendLineNumberStart, inContext.linesLength - 1), deltaTop, startLineNumber);
      inContext.rendLineNumberStart > startLineNumber ? (x = Math.min(stopLineNumber, inContext.rendLineNumberStart - 1), startLineNumber <= x && (this._insertLinesBefore(inContext, startLineNumber, x, deltaTop, startLineNumber), inContext.linesLength += x - startLineNumber + 1)) : inContext.rendLineNumberStart < startLineNumber && (x = Math.min(inContext.linesLength, startLineNumber - inContext.rendLineNumberStart), x > 0 && (this._removeLinesBefore(inContext, x), inContext.linesLength -= x));
      inContext.rendLineNumberStart = startLineNumber;
      inContext.rendLineNumberStart + inContext.linesLength - 1 < stopLineNumber ? (x = inContext.rendLineNumberStart + inContext.linesLength, x <= stopLineNumber && (this._insertLinesAfter(inContext, x, stopLineNumber, deltaTop, startLineNumber), inContext.linesLength += stopLineNumber - x + 1)) : inContext.rendLineNumberStart + inContext.linesLength - 1 > stopLineNumber && (startLineNumber = inContext.linesLength - 1 - Math.max(0, stopLineNumber - inContext.rendLineNumberStart + 1) + 1, startLineNumber > 
      0 && (this._removeLinesAfter(inContext, startLineNumber), inContext.linesLength -= startLineNumber));
      this._finishRendering(inContext, !1, deltaTop);
      return inContext;
    }
    _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {
      const rendLineNumberStart = ctx.rendLineNumberStart;
      for (ctx = ctx.lines; startIndex <= endIndex; startIndex++) {
        const lineNumber = rendLineNumberStart + startIndex;
        ctx[startIndex].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);
      }
    }
    _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
      deltaTop = [];
      for (deltaLN = 0; fromLineNumber <= toLineNumber; fromLineNumber++) {
        deltaTop[deltaLN++] = this.host.createVisibleLine();
      }
      ctx.lines = deltaTop.concat(ctx.lines);
    }
    _removeLinesBefore(ctx, removeCount) {
      for (let i = 0; i < removeCount; i++) {
        const lineDomNode = ctx.lines[i].getDomNode();
        lineDomNode && this.domNode.removeChild(lineDomNode);
      }
      ctx.lines.splice(0, removeCount);
    }
    _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
      deltaTop = [];
      for (deltaLN = 0; fromLineNumber <= toLineNumber; fromLineNumber++) {
        deltaTop[deltaLN++] = this.host.createVisibleLine();
      }
      ctx.lines = ctx.lines.concat(deltaTop);
    }
    _removeLinesAfter(ctx, removeCount) {
      const removeIndex = ctx.linesLength - removeCount;
      for (let i = 0; i < removeCount; i++) {
        const lineDomNode = ctx.lines[removeIndex + i].getDomNode();
        lineDomNode && this.domNode.removeChild(lineDomNode);
      }
      ctx.lines.splice(removeIndex, removeCount);
    }
    _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {
      ViewLayerRenderer._ttPolicy && (newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML));
      var lastChild = this.domNode.lastChild;
      domNodeIsEmpty || !lastChild ? this.domNode.innerHTML = newLinesHTML : lastChild.insertAdjacentHTML("afterend", newLinesHTML);
      domNodeIsEmpty = this.domNode.lastChild;
      for (newLinesHTML = ctx.linesLength - 1; newLinesHTML >= 0; newLinesHTML--) {
        lastChild = ctx.lines[newLinesHTML], wasNew[newLinesHTML] && (lastChild.setDomNode(domNodeIsEmpty), domNodeIsEmpty = domNodeIsEmpty.previousSibling);
      }
    }
    _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {
      const hugeDomNode = document.createElement("div");
      ViewLayerRenderer._ttPolicy && (invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML));
      hugeDomNode.innerHTML = invalidLinesHTML;
      for (invalidLinesHTML = 0; invalidLinesHTML < ctx.linesLength; invalidLinesHTML++) {
        const line = ctx.lines[invalidLinesHTML];
        if (wasInvalid[invalidLinesHTML]) {
          const source = hugeDomNode.firstChild, lineDomNode = line.getDomNode();
          lineDomNode.parentNode.replaceChild(source, lineDomNode);
          line.setDomNode(source);
        }
      }
    }
    _finishRendering(ctx, domNodeIsEmpty, deltaTop) {
      const sb = ViewLayerRenderer._sb, linesLength = ctx.linesLength, lines = ctx.lines, rendLineNumberStart = ctx.rendLineNumberStart, wasNew = [];
      sb.reset();
      var hadNewLine = !1;
      for (var i = 0; i < linesLength; i++) {
        var line = lines[i];
        wasNew[i] = !1;
        !line.getDomNode() && line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb) && (hadNewLine = wasNew[i] = !0);
      }
      hadNewLine && this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);
      sb.reset();
      domNodeIsEmpty = !1;
      hadNewLine = [];
      for (i = 0; i < linesLength; i++) {
        line = lines[i], hadNewLine[i] = !1, !wasNew[i] && line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb) && (domNodeIsEmpty = hadNewLine[i] = !0);
      }
      domNodeIsEmpty && this._finishRenderingInvalidLines(ctx, sb.build(), hadNewLine);
    }
  }
  ViewLayerRenderer._ttPolicy = (0,module.createTrustedTypesPolicy)("editorViewLayer", {createHTML:value => value});
  ViewLayerRenderer._sb = new require.StringBuilder(100000);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewLayer.js.map
