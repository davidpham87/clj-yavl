shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaState = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, PagedScreenReaderStrategy:{enumerable:!0, get:function() {
    return PagedScreenReaderStrategy;
  }}, TextAreaState:{enumerable:!0, get:function() {
    return TextAreaState;
  }}, _debugComposition:{enumerable:!0, get:function() {
    return !1;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class TextAreaState {
    constructor(value, selectionStart, selectionEnd, selection, newlineCountBeforeSelection) {
      this.value = value;
      this.selectionStart = selectionStart;
      this.selectionEnd = selectionEnd;
      this.selection = selection;
      this.newlineCountBeforeSelection = newlineCountBeforeSelection;
    }
    toString() {
      return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
    }
    static readFromTextArea(textArea, previousState) {
      const value = textArea.getValue(), selectionStart = textArea.getSelectionStart();
      textArea = textArea.getSelectionEnd();
      let newlineCountBeforeSelection = void 0;
      if (previousState) {
        const valueBeforeSelectionStart = value.substring(0, selectionStart), previousValueBeforeSelectionStart = previousState.value.substring(0, previousState.selectionStart);
        valueBeforeSelectionStart === previousValueBeforeSelectionStart && (newlineCountBeforeSelection = previousState.newlineCountBeforeSelection);
      }
      return new TextAreaState(value, selectionStart, textArea, null, newlineCountBeforeSelection);
    }
    collapseSelection() {
      return this.selectionStart === this.value.length ? this : new TextAreaState(this.value, this.value.length, this.value.length, null, void 0);
    }
    writeToTextArea(reason, textArea, select) {
      textArea.setValue(reason, this.value);
      select && textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);
    }
    deduceEditorPosition(offset) {
      var _a, _b, _c, _d, _e, _f, _h;
      if (offset <= this.selectionStart) {
        var _g = this.value.substring(offset, this.selectionStart);
        return this._finishDeduceEditorPosition((_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.getStartPosition()) !== null && _b !== void 0 ? _b : null, _g, -1);
      }
      if (offset >= this.selectionEnd) {
        return _g = this.value.substring(this.selectionEnd, offset), this._finishDeduceEditorPosition((_d = (_c = this.selection) === null || _c === void 0 ? void 0 : _c.getEndPosition()) !== null && _d !== void 0 ? _d : null, _g, 1);
      }
      _a = this.value.substring(this.selectionStart, offset);
      if (_a.indexOf(String.fromCharCode(8230)) === -1) {
        return this._finishDeduceEditorPosition((_f = (_e = this.selection) === null || _e === void 0 ? void 0 : _e.getStartPosition()) !== null && _f !== void 0 ? _f : null, _a, 1);
      }
      offset = this.value.substring(offset, this.selectionEnd);
      return this._finishDeduceEditorPosition((_h = (_g = this.selection) === null || _g === void 0 ? void 0 : _g.getEndPosition()) !== null && _h !== void 0 ? _h : null, offset, -1);
    }
    _finishDeduceEditorPosition(anchor, deltaText, signum) {
      let lineFeedCnt = 0, lastLineFeedIndex = -1;
      for (; (lastLineFeedIndex = deltaText.indexOf("\n", lastLineFeedIndex + 1)) !== -1;) {
        lineFeedCnt++;
      }
      return [anchor, signum * deltaText.length, lineFeedCnt];
    }
    static deduceInput(previousState, currentState, couldBeEmojiInput) {
      if (!previousState) {
        return {text:"", replacePrevCharCnt:0, replaceNextCharCnt:0, positionDelta:0};
      }
      couldBeEmojiInput = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);
      var suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);
      previousState.value.substring(couldBeEmojiInput, previousState.value.length - suffixLength);
      suffixLength = currentState.value.substring(couldBeEmojiInput, currentState.value.length - suffixLength);
      return currentState.selectionStart - couldBeEmojiInput === currentState.selectionEnd - couldBeEmojiInput ? {text:suffixLength, replacePrevCharCnt:previousState.selectionStart - couldBeEmojiInput, replaceNextCharCnt:0, positionDelta:0} : {text:suffixLength, replacePrevCharCnt:previousState.selectionEnd - couldBeEmojiInput - (previousState.selectionStart - couldBeEmojiInput), replaceNextCharCnt:0, positionDelta:0};
    }
    static deduceAndroidCompositionInput(previousState, currentState) {
      if (!previousState) {
        return {text:"", replacePrevCharCnt:0, replaceNextCharCnt:0, positionDelta:0};
      }
      if (previousState.value === currentState.value) {
        return {text:"", replacePrevCharCnt:0, replaceNextCharCnt:0, positionDelta:currentState.selectionEnd - previousState.selectionEnd};
      }
      const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);
      var suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);
      const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);
      suffixLength = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);
      previousState = previousState.selectionEnd - prefixLength;
      return {text:suffixLength, replacePrevCharCnt:previousState, replaceNextCharCnt:previousValue.length - previousState, positionDelta:currentState.selectionEnd - prefixLength - suffixLength.length};
    }
  }
  TextAreaState.EMPTY = new TextAreaState("", 0, 0, null, void 0);
  class PagedScreenReaderStrategy {
    static _getPageOfLine(lineNumber, linesPerPage) {
      return Math.floor((lineNumber - 1) / linesPerPage);
    }
    static _getRangeForPage(page, linesPerPage) {
      page *= linesPerPage;
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(page + 1, 1, page + linesPerPage + 1, 1);
    }
    static fromEditorSelection(model, selection, linesPerPage, trimLongText) {
      var selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage), selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);
      const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage), selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);
      linesPerPage = selectionStartPageRange.intersectRanges(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(1, 1, selection.startLineNumber, selection.startColumn));
      if (trimLongText && model.getValueLengthInRange(linesPerPage, 1) > 500) {
        var pretextStart = model.modifyPosition(linesPerPage.getEndPosition(), -500);
        linesPerPage = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(pretextStart, linesPerPage.getEndPosition());
      }
      pretextStart = model.getValueInRange(linesPerPage, 1);
      var lastLine = model.getLineCount(), lastLineMaxColumn = model.getLineMaxColumn(lastLine);
      lastLine = selectionEndPageRange.intersectRanges(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));
      trimLongText && model.getValueLengthInRange(lastLine, 1) > 500 && (lastLineMaxColumn = model.modifyPosition(lastLine.getStartPosition(), 500), lastLine = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(lastLine.getStartPosition(), lastLineMaxColumn));
      lastLine = model.getValueInRange(lastLine, 1);
      selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage ? model = model.getValueInRange(selection, 1) : (selectionStartPage = selectionStartPageRange.intersectRanges(selection), selectionStartPageRange = selectionEndPageRange.intersectRanges(selection), model = model.getValueInRange(selectionStartPage, 1) + String.fromCharCode(8230) + model.getValueInRange(selectionStartPageRange, 1));
      trimLongText && model.length > 1E3 && (model = model.substring(0, 500) + String.fromCharCode(8230) + model.substring(model.length - 500, model.length));
      return new TextAreaState(pretextStart + model + lastLine, pretextStart.length, pretextStart.length + model.length, selection, linesPerPage.endLineNumber - linesPerPage.startLineNumber);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaState.js.map
