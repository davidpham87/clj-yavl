shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$rowCache = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, RowCache:{enumerable:!0, get:function() {
    return RowCache;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom");
  class RowCache {
    constructor(renderers) {
      this.renderers = renderers;
      this.cache = new Map();
      this.transactionNodesPendingRemoval = new Set();
      this.inTransaction = !1;
    }
    alloc(templateId) {
      var result = this.getTemplateCache(templateId).pop();
      let isStale = !1;
      if (result) {
        (isStale = this.transactionNodesPendingRemoval.has(result.domNode)) && this.transactionNodesPendingRemoval.delete(result.domNode);
      } else {
        result = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-list-row");
        const templateData = this.getRenderer(templateId).renderTemplate(result);
        result = {domNode:result, templateId, templateData};
      }
      return {row:result, isReusingConnectedDomNode:isStale};
    }
    release(row) {
      row && this.releaseRow(row);
    }
    transact(makeChanges) {
      if (this.inTransaction) {
        throw Error("Already in transaction");
      }
      this.inTransaction = !0;
      try {
        makeChanges();
      } finally {
        for (const domNode of this.transactionNodesPendingRemoval) {
          this.doRemoveNode(domNode);
        }
        this.transactionNodesPendingRemoval.clear();
        this.inTransaction = !1;
      }
    }
    releaseRow(row) {
      const {domNode, templateId} = row;
      domNode && (this.inTransaction ? this.transactionNodesPendingRemoval.add(domNode) : this.doRemoveNode(domNode));
      this.getTemplateCache(templateId).push(row);
    }
    doRemoveNode(domNode) {
      domNode.classList.remove("scrolling");
      var _a;
      try {
        (_a = domNode.parentElement) === null || _a === void 0 || _a.removeChild(domNode);
      } catch (e) {
      }
    }
    getTemplateCache(templateId) {
      let result = this.cache.get(templateId);
      result || (result = [], this.cache.set(templateId, result));
      return result;
    }
    dispose() {
      this.cache.forEach((cachedRows, templateId) => {
        for (const cachedRow of cachedRows) {
          this.getRenderer(templateId).disposeTemplate(cachedRow.templateData), cachedRow.templateData = null;
        }
      });
      this.cache.clear();
      this.transactionNodesPendingRemoval.clear();
    }
    getRenderer(templateId) {
      const renderer = this.renderers.get(templateId);
      if (!renderer) {
        throw Error(`No renderer found for ${templateId}`);
      }
      return renderer;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$rowCache.js.map
