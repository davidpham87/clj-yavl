shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$marked$marked = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Lexer:{enumerable:!0, get:function() {
    return Lexer;
  }}, Parser:{enumerable:!0, get:function() {
    return Parser;
  }}, Renderer:{enumerable:!0, get:function() {
    return Renderer;
  }}, Slugger:{enumerable:!0, get:function() {
    return Slugger;
  }}, TextRenderer:{enumerable:!0, get:function() {
    return TextRenderer;
  }}, Tokenizer:{enumerable:!0, get:function() {
    return Tokenizer;
  }}, getDefaults:{enumerable:!0, get:function() {
    return getDefaults;
  }}, lexer:{enumerable:!0, get:function() {
    return lexer;
  }}, marked:{enumerable:!0, get:function() {
    return marked;
  }}, options:{enumerable:!0, get:function() {
    return options;
  }}, parse:{enumerable:!0, get:function() {
    return parse;
  }}, parseInline:{enumerable:!0, get:function() {
    return parseInline;
  }}, parser:{enumerable:!0, get:function() {
    return parser;
  }}, setOptions:{enumerable:!0, get:function() {
    return setOptions;
  }}, use:{enumerable:!0, get:function() {
    return use;
  }}, walkTokens:{enumerable:!0, get:function() {
    return walkTokens;
  }}});
  let __marked_exports = {};
  (function() {
    function define(deps, factory) {
      factory(__marked_exports);
    }
    define.amd = !0;
    (function(global, factory) {
      typeof define === "function" && define.amd ? factory(__marked_exports) : typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.marked = {}));
    })(this, function(exports) {
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1;
          descriptor.configurable = !0;
          "value" in descriptor && (descriptor.writable = !0);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        protoProps && _defineProperties(Constructor.prototype, protoProps);
        staticProps && _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {writable:!1});
        return Constructor;
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (o) {
          if (typeof o === "string") {
            return _arrayLikeToArray(o, minLen);
          }
          var n = Object.prototype.toString.call(o).slice(8, -1);
          n === "Object" && o.constructor && (n = o.constructor.name);
          if (n === "Map" || n === "Set") {
            return Array.from(o);
          }
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
            return _arrayLikeToArray(o, minLen);
          }
        }
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) {
          len = arr.length;
        }
        for (var i = 0, arr2 = Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) {
          return (it = it.call(o)).next.bind(it);
        }
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          it && (o = it);
          var i = 0;
          return function() {
            return i >= o.length ? {done:!0} : {done:!1, value:o[i++]};
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function getDefaults() {
        return {async:!1, baseUrl:null, breaks:!1, extensions:null, gfm:!0, headerIds:!0, headerPrefix:"", highlight:null, langPrefix:"language-", mangle:!0, pedantic:!1, renderer:null, sanitize:!1, sanitizer:null, silent:!1, smartLists:!1, smartypants:!1, tokenizer:null, walkTokens:null, xhtml:!1};
      }
      function escape(html, encode) {
        if (encode) {
          if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
          }
        } else {
          if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
          }
        }
        return html;
      }
      function unescape(html) {
        return html.replace(unescapeTest, function(_, n) {
          n = n.toLowerCase();
          return n === "colon" ? ":" : n.charAt(0) === "#" ? n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1)) : "";
        });
      }
      function edit(regex, opt) {
        regex = typeof regex === "string" ? regex : regex.source;
        opt = opt || "";
        var obj = {replace:function(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        }, getRegex:function() {
          return new RegExp(regex, opt);
        }};
        return obj;
      }
      function cleanUrl(sanitize, base, href) {
        if (sanitize) {
          try {
            var prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
          } catch (e) {
            return null;
          }
          if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
            return null;
          }
        }
        base && !originIndependentUrl.test(href) && (sanitize = base, baseUrls[" " + sanitize] || (justDomain.test(sanitize) ? baseUrls[" " + sanitize] = sanitize + "/" : baseUrls[" " + sanitize] = rtrim(sanitize, "/", !0)), sanitize = baseUrls[" " + sanitize], base = sanitize.indexOf(":") === -1, href = href.substring(0, 2) === "//" ? base ? href : sanitize.replace(protocol, "$1") + href : href.charAt(0) === "/" ? base ? href : sanitize.replace(domain, "$1") + href : sanitize + href);
        try {
          href = encodeURI(href).replace(/%25/g, "%");
        } catch (e) {
          return null;
        }
        return href;
      }
      function merge(obj) {
        for (var i = 1, target, key; i < arguments.length; i++) {
          for (key in target = arguments[i], target) {
            Object.prototype.hasOwnProperty.call(target, key) && (obj[key] = target[key]);
          }
        }
        return obj;
      }
      function splitCells(tableRow, count) {
        tableRow = tableRow.replace(/\|/g, function(match, offset, str) {
          for (match = !1; --offset >= 0 && str[offset] === "\\";) {
            match = !match;
          }
          return match ? "|" : " |";
        }).split(/ \|/);
        var i = 0;
        tableRow[0].trim() || tableRow.shift();
        tableRow.length > 0 && !tableRow[tableRow.length - 1].trim() && tableRow.pop();
        if (tableRow.length > count) {
          tableRow.splice(count);
        } else {
          for (; tableRow.length < count;) {
            tableRow.push("");
          }
        }
        for (; i < tableRow.length; i++) {
          tableRow[i] = tableRow[i].trim().replace(/\\\|/g, "|");
        }
        return tableRow;
      }
      function rtrim(str, c, invert) {
        var l = str.length;
        if (l === 0) {
          return "";
        }
        for (var suffLen = 0; suffLen < l;) {
          var currChar = str.charAt(l - suffLen - 1);
          if (currChar !== c || invert) {
            if (currChar !== c && invert) {
              suffLen++;
            } else {
              break;
            }
          } else {
            suffLen++;
          }
        }
        return str.slice(0, l - suffLen);
      }
      function checkSanitizeDeprecation(opt) {
        opt && opt.sanitize && !opt.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
      function repeatString(pattern, count) {
        if (count < 1) {
          return "";
        }
        for (var result = ""; count > 1;) {
          count & 1 && (result += pattern), count >>= 1, pattern += pattern;
        }
        return result + pattern;
      }
      function outputLink(cap, link, raw, lexer) {
        var href = link.href;
        link = link.title ? escape(link.title) : null;
        var text = cap[1].replace(/\\([\[\]])/g, "$1");
        return cap[0].charAt(0) !== "!" ? (lexer.state.inLink = !0, cap = {type:"link", raw, href, title:link, text, tokens:lexer.inlineTokens(text)}, lexer.state.inLink = !1, cap) : {type:"image", raw, href, title:link, text:escape(text)};
      }
      function indentCodeCompensation(raw, text) {
        raw = raw.match(/^(\s+)(?:```)/);
        if (raw === null) {
          return text;
        }
        var indentToCode = raw[1];
        return text.split("\n").map(function(node) {
          var matchIndentInNode = node.match(/^\s+/);
          return matchIndentInNode === null ? node : matchIndentInNode[0].length >= indentToCode.length ? node.slice(indentToCode.length) : node;
        }).join("\n");
      }
      function smartypants(text) {
        return text.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
      }
      function mangle(text) {
        var out = "", i, l = text.length;
        for (i = 0; i < l; i++) {
          var ch = text.charCodeAt(i);
          Math.random() > 0.5 && (ch = "x" + ch.toString(16));
          out += "\x26#" + ch + ";";
        }
        return out;
      }
      function marked(src, opt, callback) {
        function onError(e) {
          e.message += "\nPlease report this to https://github.com/markedjs/marked.";
          if (opt.silent) {
            return "\x3cp\x3eAn error occurred:\x3c/p\x3e\x3cpre\x3e" + escape(e.message + "", !0) + "\x3c/pre\x3e";
          }
          throw e;
        }
        if (typeof src === "undefined" || src === null) {
          throw Error("marked(): input parameter is undefined or null");
        }
        if (typeof src !== "string") {
          throw Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
        }
        typeof opt === "function" && (callback = opt, opt = null);
        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);
        if (callback) {
          var highlight = opt.highlight;
          try {
            var tokens = Lexer.lex(src, opt);
          } catch (e) {
            return callback(e);
          }
          var done = function(err) {
            if (!err) {
              try {
                opt.walkTokens && marked.walkTokens(tokens, opt.walkTokens);
                var out = Parser.parse(tokens, opt);
              } catch (e) {
                err = e;
              }
            }
            opt.highlight = highlight;
            return err ? callback(err) : callback(null, out);
          };
          if (!highlight || highlight.length < 3) {
            return done();
          }
          delete opt.highlight;
          if (!tokens.length) {
            return done();
          }
          var pending = 0;
          marked.walkTokens(tokens, function(token) {
            token.type === "code" && (pending++, setTimeout(function() {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                code != null && code !== token.text && (token.text = code, token.escaped = !0);
                pending--;
                pending === 0 && done();
              });
            }, 0));
          });
          pending === 0 && done();
        } else {
          try {
            var _tokens = Lexer.lex(src, opt);
            if (opt.walkTokens) {
              if (opt.async) {
                return Promise.all(marked.walkTokens(_tokens, opt.walkTokens)).then(function() {
                  return Parser.parse(_tokens, opt);
                })["catch"](onError);
              }
              marked.walkTokens(_tokens, opt.walkTokens);
            }
            return Parser.parse(_tokens, opt);
          } catch (e) {
            onError(e);
          }
        }
      }
      exports.defaults = getDefaults();
      var escapeTest = /[&<>"']/, escapeReplace = /[&<>"']/g, escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/, escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g, escapeReplacements = {"\x26":"\x26amp;", "\x3c":"\x26lt;", "\x3e":"\x26gt;", '"':"\x26quot;", "'":"\x26#39;"}, getEscapeReplacement = function(ch) {
        return escapeReplacements[ch];
      }, unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret = /(^|[^\[])\^/g, nonWordAndColonTest = /[^\w:]/g, originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i, baseUrls = {}, justDomain = /^[^:]+:\/*[^/]*$/, protocol = /^([^:]+:)[\s\S]*$/, domain = /^([^:]+:\/*[^/]*)[\s\S]*$/, noopTest = {exec:function() {
      }}, Tokenizer = function() {
        function Tokenizer(options) {
          this.options = options || exports.defaults;
        }
        var _proto = Tokenizer.prototype;
        _proto.space = function(src) {
          if ((src = this.rules.block.newline.exec(src)) && src[0].length > 0) {
            return {type:"space", raw:src[0]};
          }
        };
        _proto.code = function(src) {
          if (src = this.rules.block.code.exec(src)) {
            var text = src[0].replace(/^ {1,4}/gm, "");
            return {type:"code", raw:src[0], codeBlockStyle:"indented", text:this.options.pedantic ? text : rtrim(text, "\n")};
          }
        };
        _proto.fences = function(src) {
          if (src = this.rules.block.fences.exec(src)) {
            var raw = src[0], text = indentCodeCompensation(raw, src[3] || "");
            return {type:"code", raw, lang:src[2] ? src[2].trim() : src[2], text};
          }
        };
        _proto.heading = function(src) {
          if (src = this.rules.block.heading.exec(src)) {
            var text = src[2].trim();
            if (/#$/.test(text)) {
              var trimmed = rtrim(text, "#");
              if (this.options.pedantic) {
                text = trimmed.trim();
              } else if (!trimmed || / $/.test(trimmed)) {
                text = trimmed.trim();
              }
            }
            return {type:"heading", raw:src[0], depth:src[1].length, text, tokens:this.lexer.inline(text)};
          }
        };
        _proto.hr = function(src) {
          if (src = this.rules.block.hr.exec(src)) {
            return {type:"hr", raw:src[0]};
          }
        };
        _proto.blockquote = function(src) {
          if (src = this.rules.block.blockquote.exec(src)) {
            var text = src[0].replace(/^ *>[ \t]?/gm, "");
            return {type:"blockquote", raw:src[0], tokens:this.lexer.blockTokens(text, []), text};
          }
        };
        _proto.list = function(src) {
          var cap = this.rules.block.list.exec(src);
          if (cap) {
            var istask, endsWithBlankLine;
            var indent = cap[1].trim();
            var line = indent.length > 1;
            var list = {type:"list", raw:"", ordered:line, start:line ? +indent.slice(0, -1) : "", loose:!1, items:[]};
            indent = line ? "\\d{1,9}\\" + indent.slice(-1) : "\\" + indent;
            this.options.pedantic && (indent = line ? indent : "[*+-]");
            for (var itemRegex = new RegExp("^( {0,3}" + indent + ")((?:[\t ][^\\n]*)?(?:\\n|$))"); src;) {
              var endEarly = !1;
              if (!(cap = itemRegex.exec(src))) {
                break;
              }
              if (this.rules.block.hr.test(src)) {
                break;
              }
              var raw = cap[0];
              src = src.substring(raw.length);
              line = cap[2].split("\n", 1)[0];
              var nextLine = src.split("\n", 1)[0];
              if (this.options.pedantic) {
                indent = 2;
                var itemContents = line.trimLeft();
              } else {
                indent = cap[2].search(/[^ ]/), indent = indent > 4 ? 1 : indent, itemContents = line.slice(indent), indent += cap[1].length;
              }
              cap = !1;
              !line && /^ *$/.test(nextLine) && (raw += nextLine + "\n", src = src.substring(nextLine.length + 1), endEarly = !0);
              if (!endEarly) {
                endEarly = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))");
                for (var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"), fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)"), headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#"); src;) {
                  line = nextLine = src.split("\n", 1)[0];
                  this.options.pedantic && (line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  "));
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (endEarly.test(line)) {
                    break;
                  }
                  if (hrRegex.test(src)) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= indent || !line.trim()) {
                    itemContents += "\n" + line.slice(indent);
                  } else if (cap) {
                    break;
                  } else {
                    itemContents += "\n" + line;
                  }
                  cap || line.trim() || (cap = !0);
                  raw += nextLine + "\n";
                  src = src.substring(nextLine.length + 1);
                }
              }
              list.loose || (endsWithBlankLine ? list.loose = !0 : /\n *\n *$/.test(raw) && (endsWithBlankLine = !0));
              if (this.options.gfm && (istask = /^\[[ xX]\] /.exec(itemContents))) {
                var ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
              list.items.push({type:"list_item", raw, task:!!istask, checked:ischecked, loose:!1, text:itemContents});
              list.raw += raw;
            }
            list.items[list.items.length - 1].raw = raw.trimRight();
            list.items[list.items.length - 1].text = itemContents.trimRight();
            list.raw = list.raw.trimRight();
            raw = list.items.length;
            for (src = 0; src < raw; src++) {
              this.lexer.state.top = !1, list.items[src].tokens = this.lexer.blockTokens(list.items[src].text, []), istask = list.items[src].tokens.filter(function(t) {
                return t.type === "space";
              }), ischecked = istask.every(function(t) {
                var chars = t.raw.split("");
                t = 0;
                chars = _createForOfIteratorHelperLoose(chars);
                for (var _step; !(_step = chars()).done;) {
                  if (_step.value === "\n" && (t += 1), t > 1) {
                    return !0;
                  }
                }
                return !1;
              }), !list.loose && istask.length && ischecked && (list.loose = !0, list.items[src].loose = !0);
            }
            return list;
          }
        };
        _proto.html = function(src) {
          var cap = this.rules.block.html.exec(src);
          if (cap) {
            return src = {type:"html", raw:cap[0], pre:!this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"), text:cap[0]}, this.options.sanitize && (cap = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]), src.type = "paragraph", src.text = cap, src.tokens = this.lexer.inline(cap)), src;
          }
        };
        _proto.def = function(src) {
          if (src = this.rules.block.def.exec(src)) {
            return src[3] && (src[3] = src[3].substring(1, src[3].length - 1)), {type:"def", tag:src[1].toLowerCase().replace(/\s+/g, " "), raw:src[0], href:src[2], title:src[3]};
          }
        };
        _proto.table = function(src) {
          var cap = this.rules.block.table.exec(src);
          if (cap && (src = {type:"table", header:splitCells(cap[1]).map(function(c) {
            return {text:c};
          }), align:cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows:cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []}, src.header.length === src.align.length)) {
            src.raw = cap[0];
            cap = src.align.length;
            var i, k;
            for (i = 0; i < cap; i++) {
              /^ *-+: *$/.test(src.align[i]) ? src.align[i] = "right" : /^ *:-+: *$/.test(src.align[i]) ? src.align[i] = "center" : /^ *:-+ *$/.test(src.align[i]) ? src.align[i] = "left" : src.align[i] = null;
            }
            cap = src.rows.length;
            for (i = 0; i < cap; i++) {
              src.rows[i] = splitCells(src.rows[i], src.header.length).map(function(c) {
                return {text:c};
              });
            }
            cap = src.header.length;
            for (i = 0; i < cap; i++) {
              src.header[i].tokens = this.lexer.inline(src.header[i].text);
            }
            cap = src.rows.length;
            for (i = 0; i < cap; i++) {
              var row = src.rows[i];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return src;
          }
        };
        _proto.lheading = function(src) {
          if (src = this.rules.block.lheading.exec(src)) {
            return {type:"heading", raw:src[0], depth:src[2].charAt(0) === "\x3d" ? 1 : 2, text:src[1], tokens:this.lexer.inline(src[1])};
          }
        };
        _proto.paragraph = function(src) {
          if (src = this.rules.block.paragraph.exec(src)) {
            var text = src[1].charAt(src[1].length - 1) === "\n" ? src[1].slice(0, -1) : src[1];
            return {type:"paragraph", raw:src[0], text, tokens:this.lexer.inline(text)};
          }
        };
        _proto.text = function(src) {
          if (src = this.rules.block.text.exec(src)) {
            return {type:"text", raw:src[0], text:src[0], tokens:this.lexer.inline(src[0])};
          }
        };
        _proto.escape = function(src) {
          if (src = this.rules.inline.escape.exec(src)) {
            return {type:"escape", raw:src[0], text:escape(src[1])};
          }
        };
        _proto.tag = function(src) {
          if (src = this.rules.inline.tag.exec(src)) {
            return !this.lexer.state.inLink && /^<a /i.test(src[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(src[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(src[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(src[0]) && (this.lexer.state.inRawBlock = !1), {type:this.options.sanitize ? "text" : "html", raw:src[0], inLink:this.lexer.state.inLink, 
            inRawBlock:this.lexer.state.inRawBlock, text:this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(src[0]) : escape(src[0]) : src[0]};
          }
        };
        _proto.link = function(src) {
          if (src = this.rules.inline.link.exec(src)) {
            var trimmedUrl = src[2].trim();
            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
              if (!/>$/.test(trimmedUrl)) {
                return;
              }
              var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                return;
              }
            } else {
              a: {
                rtrimSlash = src[2];
                if (rtrimSlash.indexOf(")") !== -1) {
                  for (var l = rtrimSlash.length, level = 0, i = 0; i < l; i++) {
                    if (rtrimSlash[i] === "\\") {
                      i++;
                    } else if (rtrimSlash[i] === "(") {
                      level++;
                    } else if (rtrimSlash[i] === ")" && (level--, level < 0)) {
                      rtrimSlash = i;
                      break a;
                    }
                  }
                }
                rtrimSlash = -1;
              }
              rtrimSlash > -1 && (l = (src[0].indexOf("!") === 0 ? 5 : 4) + src[1].length + rtrimSlash, src[2] = src[2].substring(0, rtrimSlash), src[0] = src[0].substring(0, l).trim(), src[3] = "");
            }
            rtrimSlash = src[2];
            l = "";
            if (this.options.pedantic) {
              if (level = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(rtrimSlash)) {
                rtrimSlash = level[1], l = level[3];
              }
            } else {
              l = src[3] ? src[3].slice(1, -1) : "";
            }
            rtrimSlash = rtrimSlash.trim();
            /^</.test(rtrimSlash) && (rtrimSlash = this.options.pedantic && !/>$/.test(trimmedUrl) ? rtrimSlash.slice(1) : rtrimSlash.slice(1, -1));
            return outputLink(src, {href:rtrimSlash ? rtrimSlash.replace(this.rules.inline._escapes, "$1") : rtrimSlash, title:l ? l.replace(this.rules.inline._escapes, "$1") : l}, src[0], this.lexer);
          }
        };
        _proto.reflink = function(src, links) {
          var cap;
          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
            return src = (cap[2] || cap[1]).replace(/\s+/g, " "), src = links[src.toLowerCase()], src && src.href ? outputLink(cap, src, cap[0], this.lexer) : (links = cap[0].charAt(0), {type:"text", raw:links, text:links});
          }
        };
        _proto.emStrong = function(src, maskedSrc, prevChar) {
          prevChar === void 0 && (prevChar = "");
          var match = this.rules.inline.emStrong.lDelim.exec(src);
          if (match && (!match[3] || !prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))) {
            var nextChar = match[1] || match[2] || "";
            if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
              var delimTotal = prevChar = match[0].length - 1, midDelimTotal = 0, endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              endReg.lastIndex = 0;
              for (maskedSrc = maskedSrc.slice(-1 * src.length + prevChar); (match = endReg.exec(maskedSrc)) != null;) {
                if (nextChar = match[1] || match[2] || match[3] || match[4] || match[5] || match[6]) {
                  if (nextChar = nextChar.length, match[3] || match[4]) {
                    delimTotal += nextChar;
                  } else if ((match[5] || match[6]) && prevChar % 3 && !((prevChar + nextChar) % 3)) {
                    midDelimTotal += nextChar;
                  } else {
                    if (delimTotal -= nextChar, !(delimTotal > 0)) {
                      nextChar = Math.min(nextChar, nextChar + delimTotal + midDelimTotal);
                      if (Math.min(prevChar, nextChar) % 2) {
                        return maskedSrc = src.slice(1, prevChar + match.index + nextChar), {type:"em", raw:src.slice(0, prevChar + match.index + nextChar + 1), text:maskedSrc, tokens:this.lexer.inlineTokens(maskedSrc)};
                      }
                      maskedSrc = src.slice(2, prevChar + match.index + nextChar - 1);
                      return {type:"strong", raw:src.slice(0, prevChar + match.index + nextChar + 1), text:maskedSrc, tokens:this.lexer.inlineTokens(maskedSrc)};
                    }
                  }
                }
              }
            }
          }
        };
        _proto.codespan = function(src) {
          if (src = this.rules.inline.code.exec(src)) {
            var text = src[2].replace(/\n/g, " "), hasNonSpaceChars = /[^ ]/.test(text), hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
            hasNonSpaceChars && hasSpaceCharsOnBothEnds && (text = text.substring(1, text.length - 1));
            text = escape(text, !0);
            return {type:"codespan", raw:src[0], text};
          }
        };
        _proto.br = function(src) {
          if (src = this.rules.inline.br.exec(src)) {
            return {type:"br", raw:src[0]};
          }
        };
        _proto.del = function(src) {
          if (src = this.rules.inline.del.exec(src)) {
            return {type:"del", raw:src[0], text:src[2], tokens:this.lexer.inlineTokens(src[2])};
          }
        };
        _proto.autolink = function(src, mangle) {
          if (src = this.rules.inline.autolink.exec(src)) {
            if (src[2] === "@") {
              mangle = escape(this.options.mangle ? mangle(src[1]) : src[1]);
              var href = "mailto:" + mangle;
            } else {
              href = mangle = escape(src[1]);
            }
            return {type:"link", raw:src[0], text:mangle, href, tokens:[{type:"text", raw:mangle, text:mangle}]};
          }
        };
        _proto.url = function(src, mangle) {
          if (src = this.rules.inline.url.exec(src)) {
            if (src[2] === "@") {
              mangle = escape(this.options.mangle ? mangle(src[0]) : src[0]);
              var href = "mailto:" + mangle;
            } else {
              do {
                mangle = src[0], src[0] = this.rules.inline._backpedal.exec(src[0])[0];
              } while (mangle !== src[0]);
              mangle = escape(src[0]);
              href = src[1] === "www." ? "http://" + mangle : mangle;
            }
            return {type:"link", raw:src[0], text:mangle, href, tokens:[{type:"text", raw:mangle, text:mangle}]};
          }
        };
        _proto.inlineText = function(src, smartypants) {
          if (src = this.rules.inline.text.exec(src)) {
            return smartypants = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(src[0]) : escape(src[0]) : src[0] : escape(this.options.smartypants ? smartypants(src[0]) : src[0]), {type:"text", raw:src[0], text:smartypants};
          }
        };
        return Tokenizer;
      }(), block = {newline:/^(?: *(?:\n|$))+/, code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences:/^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/, html:"^ {0,3}(?:\x3c(script|pre|style|textarea)[\\s\x3e][\\s\\S]*?(?:\x3c/\\1\x3e[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|\x3c\\?[\\s\\S]*?(?:\\?\x3e\\n*|$)|\x3c![A-Z][\\s\\S]*?(?:\x3e\\n*|$)|\x3c!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]\x3e\\n*|$)|\x3c/?(tag)(?: +|\\n|/?\x3e)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|\x3c(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?\x3e(?\x3d[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|\x3c/(?!script|pre|style|textarea)[a-z][\\w-]*\\s*\x3e(?\x3d[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", 
      def:/^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table:noopTest, lheading:/^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text:/^[^\n]+/, _label:/(?!\s*\])(?:\\.|[^\[\]\\])+/, _title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/};
      block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
      block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
      block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
      block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?\x3d\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?\x3d" + block.def.source + ")").getRegex();
      block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
      block._comment = /\x3c!--(?!-?>)[\s\S]*?(?:--\x3e|$)/;
      block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
      block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}\x3e").replace("fences", " {0,3}(?:`{3,}(?\x3d[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "\x3c/?(?:tag)(?: +|\\n|/?\x3e)|\x3c(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
      block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
      block.normal = merge({}, block);
      block.gfm = merge({}, block.normal, {table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"});
      block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}\x3e").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?\x3d[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "\x3c/?(?:tag)(?: +|\\n|/?\x3e)|\x3c(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
      block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}\x3e").replace("fences", " {0,3}(?:`{3,}(?\x3d[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "\x3c/?(?:tag)(?: +|\\n|/?\x3e)|\x3c(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
      block.pedantic = merge({}, block.normal, {html:edit("^ *(?:comment *(?:\\n|\\s*$)|\x3c(tag)[\\s\\S]+?\x3c/\\1\x3e *(?:\\n{2,}|\\s*$)|\x3ctag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/\x3e\\s]*)*?/?\x3e *(?:\\n{2,}|\\s*$))").replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, 
      heading:/^(#{1,6})(.*)(?:\n+|$)/, fences:noopTest, paragraph:edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}\x3e").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()});
      var inline = {escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url:noopTest, tag:"^comment|^\x3c/[a-zA-Z][\\w:-]*\\s*\x3e|^\x3c[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?\x3e|^\x3c\\?[\\s\\S]*?\\?\x3e|^\x3c![a-zA-Z]+\\s[\\s\\S]*?\x3e|^\x3c!\\[CDATA\\[[\\s\\S]*?\\]\\]\x3e", link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink:/^!?\[(label)\]\[(ref)\]/, nolink:/^!?\[(ref)\](?:\[\])?/, reflinkSearch:"reflink|nolink(?!\\()", emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, 
      rDelimAst:/^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/, rDelimUnd:/^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](_+)(?=[\s]|$)|[^punct*_\s](_+)(?=[punct*\s]|$)|[punct*\s](_+)(?=[^punct*_\s])|[\s](_+)(?=[punct*])|[punct*](_+)(?=[punct*])/}, code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br:/^( {2,}|\\)\n(?!\s*$)/, 
      del:noopTest, text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation:/^([\spunctuation])/, _punctuation:"!\"#$%\x26'()+\\-.,/:;\x3c\x3d\x3e?@\\[\\]`^{|}~"};
      inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
      inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
      inline.escapedEmSt = /\\\*|\\_/g;
      inline._comment = edit(block._comment).replace("(?:--\x3e|$)", "--\x3e").getRegex();
      inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
      inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
      inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
      inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
      inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
      inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
      inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
      inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
      inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
      inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
      inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
      inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
      inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
      inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
      inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
      inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
      inline.normal = merge({}, inline);
      inline.pedantic = merge({}, inline.normal, {strong:{start:/^__|\*\*/, middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst:/\*\*(?!\*)/g, endUnd:/__(?!_)/g}, em:{start:/^_|\*/, middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst:/\*(?!\*)/g, endUnd:/_(?!_)/g}, link:edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(), reflink:edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()});
      inline.gfm = merge({}, inline.normal, {escape:edit(inline.escape).replace("])", "~|])").getRegex(), _extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/, del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/});
      inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
      inline.breaks = merge({}, inline.gfm, {br:edit(inline.br).replace("{2,}", "*").getRegex(), text:edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()});
      var Lexer = function() {
        function Lexer(options) {
          this.tokens = [];
          this.tokens.links = Object.create(null);
          this.options = options || exports.defaults;
          this.options.tokenizer = this.options.tokenizer || new Tokenizer();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          this.tokenizer.lexer = this;
          this.inlineQueue = [];
          this.state = {inLink:!1, inRawBlock:!1, top:!0};
          options = {block:block.normal, inline:inline.normal};
          this.options.pedantic ? (options.block = block.pedantic, options.inline = inline.pedantic) : this.options.gfm && (options.block = block.gfm, options.inline = this.options.breaks ? inline.breaks : inline.gfm);
          this.tokenizer.rules = options;
        }
        Lexer.lex = function(src, options) {
          return (new Lexer(options)).lex(src);
        };
        Lexer.lexInline = function(src, options) {
          return (new Lexer(options)).inlineTokens(src);
        };
        var _proto = Lexer.prototype;
        _proto.lex = function(src) {
          src = src.replace(/\r\n|\r/g, "\n");
          for (this.blockTokens(src, this.tokens); src = this.inlineQueue.shift();) {
            this.inlineTokens(src.src, src.tokens);
          }
          return this.tokens;
        };
        _proto.blockTokens = function(src, tokens) {
          var _this = this;
          tokens === void 0 && (tokens = []);
          src = this.options.pedantic ? src.replace(/\t/g, "    ").replace(/^ +$/gm, "") : src.replace(/^( *)(\t+)/gm, function(_, leading, tabs) {
            return leading + "    ".repeat(tabs.length);
          });
          for (var token, lastToken, cutSrc, lastParagraphClipped; src;) {
            if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
              return (token = extTokenizer.call({lexer:_this}, src, tokens)) ? (src = src.substring(token.raw.length), tokens.push(token), !0) : !1;
            }))) {
              if (token = this.tokenizer.space(src)) {
                src = src.substring(token.raw.length), token.raw.length === 1 && tokens.length > 0 ? tokens[tokens.length - 1].raw += "\n" : tokens.push(token);
              } else {
                if (token = this.tokenizer.code(src)) {
                  src = src.substring(token.raw.length), lastToken = tokens[tokens.length - 1], !lastToken || lastToken.type !== "paragraph" && lastToken.type !== "text" ? tokens.push(token) : (lastToken.raw += "\n" + token.raw, lastToken.text += "\n" + token.text, this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text);
                } else {
                  if (token = this.tokenizer.fences(src)) {
                    src = src.substring(token.raw.length), tokens.push(token);
                  } else {
                    if (token = this.tokenizer.heading(src)) {
                      src = src.substring(token.raw.length), tokens.push(token);
                    } else {
                      if (token = this.tokenizer.hr(src)) {
                        src = src.substring(token.raw.length), tokens.push(token);
                      } else {
                        if (token = this.tokenizer.blockquote(src)) {
                          src = src.substring(token.raw.length), tokens.push(token);
                        } else {
                          if (token = this.tokenizer.list(src)) {
                            src = src.substring(token.raw.length), tokens.push(token);
                          } else {
                            if (token = this.tokenizer.html(src)) {
                              src = src.substring(token.raw.length), tokens.push(token);
                            } else {
                              if (token = this.tokenizer.def(src)) {
                                src = src.substring(token.raw.length), lastToken = tokens[tokens.length - 1], !lastToken || lastToken.type !== "paragraph" && lastToken.type !== "text" ? this.tokens.links[token.tag] || (this.tokens.links[token.tag] = {href:token.href, title:token.title}) : (lastToken.raw += "\n" + token.raw, lastToken.text += "\n" + token.raw, this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text);
                              } else {
                                if (token = this.tokenizer.table(src)) {
                                  src = src.substring(token.raw.length), tokens.push(token);
                                } else {
                                  if (token = this.tokenizer.lheading(src)) {
                                    src = src.substring(token.raw.length), tokens.push(token);
                                  } else {
                                    if (cutSrc = src, this.options.extensions && this.options.extensions.startBlock && function() {
                                      var startIndex = Infinity, tempSrc = src.slice(1), tempStart = void 0;
                                      _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                                        tempStart = getStartIndex.call({lexer:this}, tempSrc);
                                        typeof tempStart === "number" && tempStart >= 0 && (startIndex = Math.min(startIndex, tempStart));
                                      });
                                      startIndex < Infinity && startIndex >= 0 && (cutSrc = src.substring(0, startIndex + 1));
                                    }(), this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                                      lastToken = tokens[tokens.length - 1], lastParagraphClipped && lastToken.type === "paragraph" ? (lastToken.raw += "\n" + token.raw, lastToken.text += "\n" + token.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text) : tokens.push(token), lastParagraphClipped = cutSrc.length !== src.length, src = src.substring(token.raw.length);
                                    } else {
                                      if (token = this.tokenizer.text(src)) {
                                        src = src.substring(token.raw.length), (lastToken = tokens[tokens.length - 1]) && lastToken.type === "text" ? (lastToken.raw += "\n" + token.raw, lastToken.text += "\n" + token.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text) : tokens.push(token);
                                      } else {
                                        if (src) {
                                          if (lastToken = "Infinite loop on byte: " + src.charCodeAt(0), this.options.silent) {
                                            console.error(lastToken);
                                            break;
                                          } else {
                                            throw Error(lastToken);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          this.state.top = !0;
          return tokens;
        };
        _proto.inline = function(src, tokens) {
          tokens === void 0 && (tokens = []);
          this.inlineQueue.push({src, tokens});
          return tokens;
        };
        _proto.inlineTokens = function(src, tokens) {
          var _this2 = this;
          tokens === void 0 && (tokens = []);
          var token, lastToken, maskedSrc = src, prevChar;
          if (this.tokens.links) {
            var links = Object.keys(this.tokens.links);
            if (links.length > 0) {
              for (; (lastToken = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null;) {
                links.includes(lastToken[0].slice(lastToken[0].lastIndexOf("[") + 1, -1)) && (maskedSrc = maskedSrc.slice(0, lastToken.index) + "[" + repeatString("a", lastToken[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
              }
            }
          }
          for (; (lastToken = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null;) {
            maskedSrc = maskedSrc.slice(0, lastToken.index) + "[" + repeatString("a", lastToken[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }
          for (; (lastToken = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null;) {
            maskedSrc = maskedSrc.slice(0, lastToken.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          }
          for (; src;) {
            keepPrevChar || (prevChar = "");
            var keepPrevChar = !1;
            if (!(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
              return (token = extTokenizer.call({lexer:_this2}, src, tokens)) ? (src = src.substring(token.raw.length), tokens.push(token), !0) : !1;
            }))) {
              if (token = this.tokenizer.escape(src)) {
                src = src.substring(token.raw.length), tokens.push(token);
              } else {
                if (token = this.tokenizer.tag(src)) {
                  src = src.substring(token.raw.length), (lastToken = tokens[tokens.length - 1]) && token.type === "text" && lastToken.type === "text" ? (lastToken.raw += token.raw, lastToken.text += token.text) : tokens.push(token);
                } else {
                  if (token = this.tokenizer.link(src)) {
                    src = src.substring(token.raw.length), tokens.push(token);
                  } else {
                    if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                      src = src.substring(token.raw.length), (lastToken = tokens[tokens.length - 1]) && token.type === "text" && lastToken.type === "text" ? (lastToken.raw += token.raw, lastToken.text += token.text) : tokens.push(token);
                    } else {
                      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                        src = src.substring(token.raw.length), tokens.push(token);
                      } else {
                        if (token = this.tokenizer.codespan(src)) {
                          src = src.substring(token.raw.length), tokens.push(token);
                        } else {
                          if (token = this.tokenizer.br(src)) {
                            src = src.substring(token.raw.length), tokens.push(token);
                          } else {
                            if (token = this.tokenizer.del(src)) {
                              src = src.substring(token.raw.length), tokens.push(token);
                            } else {
                              if (token = this.tokenizer.autolink(src, mangle)) {
                                src = src.substring(token.raw.length), tokens.push(token);
                              } else {
                                if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
                                  src = src.substring(token.raw.length), tokens.push(token);
                                } else {
                                  var cutSrc = src;
                                  this.options.extensions && this.options.extensions.startInline && function() {
                                    var startIndex = Infinity, tempSrc = src.slice(1), tempStart = void 0;
                                    _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                                      tempStart = getStartIndex.call({lexer:this}, tempSrc);
                                      typeof tempStart === "number" && tempStart >= 0 && (startIndex = Math.min(startIndex, tempStart));
                                    });
                                    startIndex < Infinity && startIndex >= 0 && (cutSrc = src.substring(0, startIndex + 1));
                                  }();
                                  if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
                                    src = src.substring(token.raw.length), token.raw.slice(-1) !== "_" && (prevChar = token.raw.slice(-1)), keepPrevChar = !0, (lastToken = tokens[tokens.length - 1]) && lastToken.type === "text" ? (lastToken.raw += token.raw, lastToken.text += token.text) : tokens.push(token);
                                  } else {
                                    if (src) {
                                      if (maskedSrc = "Infinite loop on byte: " + src.charCodeAt(0), this.options.silent) {
                                        console.error(maskedSrc);
                                        break;
                                      } else {
                                        throw Error(maskedSrc);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return tokens;
        };
        _createClass(Lexer, null, [{key:"rules", get:function() {
          return {block, inline};
        }}]);
        return Lexer;
      }(), Renderer = function() {
        function Renderer(options) {
          this.options = options || exports.defaults;
        }
        var _proto = Renderer.prototype;
        _proto.code = function(_code, infostring, escaped) {
          infostring = (infostring || "").match(/\S*/)[0];
          if (this.options.highlight) {
            var out = this.options.highlight(_code, infostring);
            out != null && out !== _code && (escaped = !0, _code = out);
          }
          _code = _code.replace(/\n$/, "") + "\n";
          return infostring ? '\x3cpre\x3e\x3ccode class\x3d"' + this.options.langPrefix + escape(infostring, !0) + '"\x3e' + (escaped ? _code : escape(_code, !0)) + "\x3c/code\x3e\x3c/pre\x3e\n" : "\x3cpre\x3e\x3ccode\x3e" + (escaped ? _code : escape(_code, !0)) + "\x3c/code\x3e\x3c/pre\x3e\n";
        };
        _proto.blockquote = function(quote) {
          return "\x3cblockquote\x3e\n" + quote + "\x3c/blockquote\x3e\n";
        };
        _proto.html = function(_html) {
          return _html;
        };
        _proto.heading = function(text, level, raw, slugger) {
          return this.options.headerIds ? (raw = this.options.headerPrefix + slugger.slug(raw), "\x3ch" + level + ' id\x3d"' + raw + '"\x3e' + text + "\x3c/h" + level + "\x3e\n") : "\x3ch" + level + "\x3e" + text + "\x3c/h" + level + "\x3e\n";
        };
        _proto.hr = function() {
          return this.options.xhtml ? "\x3chr/\x3e\n" : "\x3chr\x3e\n";
        };
        _proto.list = function(body, ordered, start) {
          var type = ordered ? "ol" : "ul";
          return "\x3c" + type + (ordered && start !== 1 ? ' start\x3d"' + start + '"' : "") + "\x3e\n" + body + "\x3c/" + type + "\x3e\n";
        };
        _proto.listitem = function(text) {
          return "\x3cli\x3e" + text + "\x3c/li\x3e\n";
        };
        _proto.checkbox = function(checked) {
          return "\x3cinput " + (checked ? 'checked\x3d"" ' : "") + 'disabled\x3d"" type\x3d"checkbox"' + (this.options.xhtml ? " /" : "") + "\x3e ";
        };
        _proto.paragraph = function(text) {
          return "\x3cp\x3e" + text + "\x3c/p\x3e\n";
        };
        _proto.table = function(header, body) {
          body &&= "\x3ctbody\x3e" + body + "\x3c/tbody\x3e";
          return "\x3ctable\x3e\n\x3cthead\x3e\n" + header + "\x3c/thead\x3e\n" + body + "\x3c/table\x3e\n";
        };
        _proto.tablerow = function(content) {
          return "\x3ctr\x3e\n" + content + "\x3c/tr\x3e\n";
        };
        _proto.tablecell = function(content, flags) {
          var type = flags.header ? "th" : "td";
          return (flags.align ? "\x3c" + type + ' align\x3d"' + flags.align + '"\x3e' : "\x3c" + type + "\x3e") + content + ("\x3c/" + type + "\x3e\n");
        };
        _proto.strong = function(text) {
          return "\x3cstrong\x3e" + text + "\x3c/strong\x3e";
        };
        _proto.em = function(text) {
          return "\x3cem\x3e" + text + "\x3c/em\x3e";
        };
        _proto.codespan = function(text) {
          return "\x3ccode\x3e" + text + "\x3c/code\x3e";
        };
        _proto.br = function() {
          return this.options.xhtml ? "\x3cbr/\x3e" : "\x3cbr\x3e";
        };
        _proto.del = function(text) {
          return "\x3cdel\x3e" + text + "\x3c/del\x3e";
        };
        _proto.link = function(href, title, text) {
          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
          if (href === null) {
            return text;
          }
          href = '\x3ca href\x3d"' + escape(href) + '"';
          title && (href += ' title\x3d"' + title + '"');
          return href + ("\x3e" + text + "\x3c/a\x3e");
        };
        _proto.image = function(href, title, text) {
          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
          if (href === null) {
            return text;
          }
          href = '\x3cimg src\x3d"' + href + '" alt\x3d"' + text + '"';
          title && (href += ' title\x3d"' + title + '"');
          return href += this.options.xhtml ? "/\x3e" : "\x3e";
        };
        _proto.text = function(_text) {
          return _text;
        };
        return Renderer;
      }(), TextRenderer = function() {
        function TextRenderer() {
        }
        var _proto = TextRenderer.prototype;
        _proto.strong = function(text) {
          return text;
        };
        _proto.em = function(text) {
          return text;
        };
        _proto.codespan = function(text) {
          return text;
        };
        _proto.del = function(text) {
          return text;
        };
        _proto.html = function(text) {
          return text;
        };
        _proto.text = function(_text) {
          return _text;
        };
        _proto.link = function(href, title, text) {
          return "" + text;
        };
        _proto.image = function(href, title, text) {
          return "" + text;
        };
        _proto.br = function() {
          return "";
        };
        return TextRenderer;
      }(), Slugger = function() {
        function Slugger() {
          this.seen = {};
        }
        var _proto = Slugger.prototype;
        _proto.serialize = function(value) {
          return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
        };
        _proto.getNextSafeSlug = function(originalSlug, isDryRun) {
          var slug = originalSlug, occurenceAccumulator = 0;
          if (this.seen.hasOwnProperty(slug)) {
            occurenceAccumulator = this.seen[originalSlug];
            do {
              occurenceAccumulator++, slug = originalSlug + "-" + occurenceAccumulator;
            } while (this.seen.hasOwnProperty(slug));
          }
          isDryRun || (this.seen[originalSlug] = occurenceAccumulator, this.seen[slug] = 0);
          return slug;
        };
        _proto.slug = function(value, options) {
          options === void 0 && (options = {});
          value = this.serialize(value);
          return this.getNextSafeSlug(value, options.dryrun);
        };
        return Slugger;
      }(), Parser = function() {
        function Parser(options) {
          this.options = options || exports.defaults;
          this.options.renderer = this.options.renderer || new Renderer();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.textRenderer = new TextRenderer();
          this.slugger = new Slugger();
        }
        Parser.parse = function(tokens, options) {
          return (new Parser(options)).parse(tokens);
        };
        Parser.parseInline = function(tokens, options) {
          return (new Parser(options)).parseInline(tokens);
        };
        var _proto = Parser.prototype;
        _proto.parse = function(tokens, top) {
          top === void 0 && (top = !0);
          var out = "", i, k, header, l = tokens.length;
          for (i = 0; i < l; i++) {
            var token = tokens[i];
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
              var j = this.options.extensions.renderers[token.type].call({parser:this}, token);
              if (j !== !1 || !"space hr heading code table blockquote list html paragraph text".split(" ").includes(token.type)) {
                out += j || "";
                continue;
              }
            }
            switch(token.type) {
              case "space":
                continue;
              case "hr":
                out += this.renderer.hr();
                continue;
              case "heading":
                out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                continue;
              case "code":
                out += this.renderer.code(token.text, token.lang, token.escaped);
                continue;
              case "table":
                var cell = header = "";
                var l2 = token.header.length;
                for (j = 0; j < l2; j++) {
                  cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {header:!0, align:token.align[j]});
                }
                header += this.renderer.tablerow(cell);
                var body = "";
                l2 = token.rows.length;
                for (j = 0; j < l2; j++) {
                  var row = token.rows[j];
                  cell = "";
                  var l3 = row.length;
                  for (k = 0; k < l3; k++) {
                    cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {header:!1, align:token.align[k]});
                  }
                  body += this.renderer.tablerow(cell);
                }
                out += this.renderer.table(header, body);
                continue;
              case "blockquote":
                body = this.parse(token.tokens);
                out += this.renderer.blockquote(body);
                continue;
              case "list":
                k = token.ordered;
                l3 = token.start;
                row = token.loose;
                l2 = token.items.length;
                body = "";
                for (j = 0; j < l2; j++) {
                  header = token.items[j];
                  var checked = header.checked;
                  var task = header.task;
                  cell = "";
                  if (header.task) {
                    var checkbox = this.renderer.checkbox(checked);
                    row ? header.tokens.length > 0 && header.tokens[0].type === "paragraph" ? (header.tokens[0].text = checkbox + " " + header.tokens[0].text, header.tokens[0].tokens && header.tokens[0].tokens.length > 0 && header.tokens[0].tokens[0].type === "text" && (header.tokens[0].tokens[0].text = checkbox + " " + header.tokens[0].tokens[0].text)) : header.tokens.unshift({type:"text", text:checkbox}) : cell += checkbox;
                  }
                  cell += this.parse(header.tokens, row);
                  body += this.renderer.listitem(cell, task, checked);
                }
                out += this.renderer.list(body, k, l3);
                continue;
              case "html":
                out += this.renderer.html(token.text);
                continue;
              case "paragraph":
                out += this.renderer.paragraph(this.parseInline(token.tokens));
                continue;
              case "text":
                for (body = token.tokens ? this.parseInline(token.tokens) : token.text; i + 1 < l && tokens[i + 1].type === "text";) {
                  token = tokens[++i], body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
                }
                out += top ? this.renderer.paragraph(body) : body;
                continue;
              default:
                tokens = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(tokens);
                  return;
                }
                throw Error(tokens);
            }
          }
          return out;
        };
        _proto.parseInline = function(tokens, renderer) {
          renderer = renderer || this.renderer;
          var out = "", i, l = tokens.length;
          for (i = 0; i < l; i++) {
            var token = tokens[i];
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
              var ret = this.options.extensions.renderers[token.type].call({parser:this}, token);
              if (ret !== !1 || !"escape html link image strong em codespan br del text".split(" ").includes(token.type)) {
                out += ret || "";
                continue;
              }
            }
            switch(token.type) {
              case "escape":
                out += renderer.text(token.text);
                break;
              case "html":
                out += renderer.html(token.text);
                break;
              case "link":
                out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
                break;
              case "image":
                out += renderer.image(token.href, token.title, token.text);
                break;
              case "strong":
                out += renderer.strong(this.parseInline(token.tokens, renderer));
                break;
              case "em":
                out += renderer.em(this.parseInline(token.tokens, renderer));
                break;
              case "codespan":
                out += renderer.codespan(token.text);
                break;
              case "br":
                out += renderer.br();
                break;
              case "del":
                out += renderer.del(this.parseInline(token.tokens, renderer));
                break;
              case "text":
                out += renderer.text(token.text);
                break;
              default:
                tokens = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(tokens);
                  return;
                }
                throw Error(tokens);
            }
          }
          return out;
        };
        return Parser;
      }();
      marked.options = marked.setOptions = function(opt) {
        merge(marked.defaults, opt);
        exports.defaults = marked.defaults;
        return marked;
      };
      marked.getDefaults = getDefaults;
      marked.defaults = exports.defaults;
      marked.use = function() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var opts = merge.apply(void 0, [{}].concat(args)), extensions = marked.defaults.extensions || {renderers:{}, childTokens:{}}, hasExtensions;
        args.forEach(function(pack) {
          pack.extensions && (hasExtensions = !0, pack.extensions.forEach(function(ext) {
            if (!ext.name) {
              throw Error("extension name required");
            }
            if (ext.renderer) {
              var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              extensions.renderers[ext.name] = prevRenderer ? function() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                _len2 = ext.renderer.apply(this, args);
                _len2 === !1 && (_len2 = prevRenderer.apply(this, args));
                return _len2;
              } : ext.renderer;
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw Error("extension level must be 'block' or 'inline'");
              }
              extensions[ext.level] ? extensions[ext.level].unshift(ext.tokenizer) : extensions[ext.level] = [ext.tokenizer];
              ext.start && (ext.level === "block" ? extensions.startBlock ? extensions.startBlock.push(ext.start) : extensions.startBlock = [ext.start] : ext.level === "inline" && (extensions.startInline ? extensions.startInline.push(ext.start) : extensions.startInline = [ext.start]));
            }
            ext.childTokens && (extensions.childTokens[ext.name] = ext.childTokens);
          }));
          pack.renderer && function() {
            var renderer = marked.defaults.renderer || new Renderer(), _loop = function(prop) {
              var prevRenderer = renderer[prop];
              renderer[prop] = function() {
                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }
                _len3 = pack.renderer[prop].apply(renderer, args);
                _len3 === !1 && (_len3 = prevRenderer.apply(renderer, args));
                return _len3;
              };
            }, prop;
            for (prop in pack.renderer) {
              _loop(prop);
            }
            opts.renderer = renderer;
          }();
          pack.tokenizer && function() {
            var tokenizer = marked.defaults.tokenizer || new Tokenizer(), _loop2 = function(prop) {
              var prevTokenizer = tokenizer[prop];
              tokenizer[prop] = function() {
                for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args[_key4] = arguments[_key4];
                }
                _len4 = pack.tokenizer[prop].apply(tokenizer, args);
                _len4 === !1 && (_len4 = prevTokenizer.apply(tokenizer, args));
                return _len4;
              };
            }, prop;
            for (prop in pack.tokenizer) {
              _loop2(prop);
            }
            opts.tokenizer = tokenizer;
          }();
          if (pack.walkTokens) {
            var _walkTokens = marked.defaults.walkTokens;
            opts.walkTokens = function(token) {
              var values = [];
              values.push(pack.walkTokens.call(this, token));
              _walkTokens && (values = values.concat(_walkTokens.call(this, token)));
              return values;
            };
          }
          hasExtensions && (opts.extensions = extensions);
          marked.setOptions(opts);
        });
      };
      marked.walkTokens = function(tokens, callback) {
        var values = [], _loop3 = function() {
          var token = _step.value;
          values = values.concat(callback.call(marked, token));
          switch(token.type) {
            case "table":
              for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
                values = values.concat(marked.walkTokens(_step2.value.tokens, callback));
              }
              for (_iterator2 = _createForOfIteratorHelperLoose(token.rows); !(_step2 = _iterator2()).done;) {
                _step2 = _createForOfIteratorHelperLoose(_step2.value);
                for (var _step4; !(_step4 = _step2()).done;) {
                  values = values.concat(marked.walkTokens(_step4.value.tokens, callback));
                }
              }
              break;
            case "list":
              values = values.concat(marked.walkTokens(token.items, callback));
              break;
            default:
              marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type] ? marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              }) : token.tokens && (values = values.concat(marked.walkTokens(token.tokens, callback)));
          }
        };
        tokens = _createForOfIteratorHelperLoose(tokens);
        for (var _step; !(_step = tokens()).done;) {
          _loop3();
        }
        return values;
      };
      marked.parseInline = function(src, opt) {
        if (typeof src === "undefined" || src === null) {
          throw Error("marked.parseInline(): input parameter is undefined or null");
        }
        if (typeof src !== "string") {
          throw Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
        }
        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);
        try {
          var tokens = Lexer.lexInline(src, opt);
          opt.walkTokens && marked.walkTokens(tokens, opt.walkTokens);
          return Parser.parseInline(tokens, opt);
        } catch (e) {
          e.message += "\nPlease report this to https://github.com/markedjs/marked.";
          if (opt.silent) {
            return "\x3cp\x3eAn error occurred:\x3c/p\x3e\x3cpre\x3e" + escape(e.message + "", !0) + "\x3c/pre\x3e";
          }
          throw e;
        }
      };
      marked.Parser = Parser;
      marked.parser = Parser.parse;
      marked.Renderer = Renderer;
      marked.TextRenderer = TextRenderer;
      marked.Lexer = Lexer;
      marked.lexer = Lexer.lex;
      marked.Tokenizer = Tokenizer;
      marked.Slugger = Slugger;
      marked.parse = marked;
      noopTest = marked.options;
      var setOptions = marked.setOptions, use = marked.use, walkTokens = marked.walkTokens, parseInline = marked.parseInline, parser = Parser.parse, lexer = Lexer.lex;
      exports.Lexer = Lexer;
      exports.Parser = Parser;
      exports.Renderer = Renderer;
      exports.Slugger = Slugger;
      exports.TextRenderer = TextRenderer;
      exports.Tokenizer = Tokenizer;
      exports.getDefaults = getDefaults;
      exports.lexer = lexer;
      exports.marked = marked;
      exports.options = noopTest;
      exports.parse = marked;
      exports.parseInline = parseInline;
      exports.parser = parser;
      exports.setOptions = setOptions;
      exports.use = use;
      exports.walkTokens = walkTokens;
      Object.defineProperty(exports, "__esModule", {value:!0});
    });
  })();
  var Lexer = __marked_exports.Lexer || exports.Lexer, Parser = __marked_exports.Parser || exports.Parser, Renderer = __marked_exports.Renderer || exports.Renderer, Slugger = __marked_exports.Slugger || exports.Slugger, TextRenderer = __marked_exports.TextRenderer || exports.TextRenderer, Tokenizer = __marked_exports.Tokenizer || exports.Tokenizer, getDefaults = __marked_exports.getDefaults || exports.getDefaults, lexer = __marked_exports.lexer || exports.lexer, marked = __marked_exports.marked || 
  exports.marked, options = __marked_exports.options || exports.options, parse = __marked_exports.parse || exports.parse, parseInline = __marked_exports.parseInline || exports.parseInline, parser = __marked_exports.parser || exports.parser, setOptions = __marked_exports.setOptions || exports.setOptions, use = __marked_exports.use || exports.use, walkTokens = __marked_exports.walkTokens || exports.walkTokens;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$marked$marked.js.map
