shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$instantiationService = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, InstantiationService:{enumerable:!0, get:function() {
    return InstantiationService;
  }}, Trace:{enumerable:!0, get:function() {
    return Trace;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), 
  require$_DOT__SLASH_descriptors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$descriptors"), require$_DOT__SLASH_graph_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$graph"), require$_DOT__SLASH_instantiation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$instantiation"), require$_DOT__SLASH_serviceCollection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$serviceCollection"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_linkedList_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$linkedList");
  class CyclicDependencyError extends Error {
    constructor(graph) {
      var _a;
      super("cyclic dependency between services");
      this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \n${graph.toString()}`;
    }
  }
  class InstantiationService {
    constructor(_services = new require$_DOT__SLASH_serviceCollection_DOT_js.ServiceCollection(), _strict = !1, _parent, _enableTracing = !1) {
      var _a;
      this._services = _services;
      this._strict = _strict;
      this._parent = _parent;
      this._enableTracing = _enableTracing;
      this._activeInstantiations = new Set();
      this._services.set(require$_DOT__SLASH_instantiation_DOT_js.IInstantiationService, this);
      this._globalGraph = _enableTracing ? (_a = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _a !== void 0 ? _a : new require$_DOT__SLASH_graph_DOT_js.Graph(e => e) : void 0;
    }
    createChild(services) {
      return new InstantiationService(services, this._strict, this, this._enableTracing);
    }
    invokeFunction(fn, ...args) {
      const _trace = Trace.traceInvocation(this._enableTracing, fn);
      let _done = !1;
      try {
        return fn({get:id => {
          if (_done) {
            throw (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.illegalState)("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id, _trace);
          if (!result) {
            throw Error(`[invokeFunction] unknown service '${id}'`);
          }
          return result;
        }}, ...args);
      } finally {
        _done = !0, _trace.stop();
      }
    }
    createInstance(ctorOrDescriptor, ...rest) {
      let _trace;
      ctorOrDescriptor instanceof require$_DOT__SLASH_descriptors_DOT_js.SyncDescriptor ? (_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor), ctorOrDescriptor = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace)) : (_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor), ctorOrDescriptor = this._createInstance(ctorOrDescriptor, rest, _trace));
      _trace.stop();
      return ctorOrDescriptor;
    }
    _createInstance(ctor, args = [], _trace) {
      var serviceDependencies = require$_DOT__SLASH_instantiation_DOT_js._util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
      const serviceArgs = [];
      for (const dependency of serviceDependencies) {
        const service = this._getOrCreateServiceInstance(dependency.id, _trace);
        service || this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, !1);
        serviceArgs.push(service);
      }
      _trace = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
      args.length !== _trace && (console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${_trace + 1} conflicts with ${args.length} static arguments`), serviceDependencies = _trace - args.length, args = serviceDependencies > 0 ? args.concat(Array(serviceDependencies)) : args.slice(0, _trace));
      return Reflect.construct(ctor, args.concat(serviceArgs));
    }
    _setServiceInstance(id, instance) {
      if (this._services.get(id) instanceof require$_DOT__SLASH_descriptors_DOT_js.SyncDescriptor) {
        this._services.set(id, instance);
      } else if (this._parent) {
        this._parent._setServiceInstance(id, instance);
      } else {
        throw Error("illegalState - setting UNKNOWN service instance");
      }
    }
    _getServiceInstanceOrDescriptor(id) {
      const instanceOrDesc = this._services.get(id);
      return !instanceOrDesc && this._parent ? this._parent._getServiceInstanceOrDescriptor(id) : instanceOrDesc;
    }
    _getOrCreateServiceInstance(id, _trace) {
      this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));
      const thing = this._getServiceInstanceOrDescriptor(id);
      if (thing instanceof require$_DOT__SLASH_descriptors_DOT_js.SyncDescriptor) {
        return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, !0));
      }
      _trace.branch(id, !1);
      return thing;
    }
    _safeCreateAndCacheServiceInstance(id, desc, _trace) {
      if (this._activeInstantiations.has(id)) {
        throw Error(`illegal state - RECURSIVELY instantiating service '${id}'`);
      }
      this._activeInstantiations.add(id);
      try {
        return this._createAndCacheServiceInstance(id, desc, _trace);
      } finally {
        this._activeInstantiations.delete(id);
      }
    }
    _createAndCacheServiceInstance(id, desc, _trace) {
      var _a;
      const graph = new require$_DOT__SLASH_graph_DOT_js.Graph(data => data.id.toString());
      let cycleCount = 0;
      for (desc = [{id, desc, _trace}]; desc.length;) {
        _trace = desc.pop();
        graph.lookupOrInsertNode(_trace);
        if (cycleCount++ > 1000) {
          throw new CyclicDependencyError(graph);
        }
        for (const dependency of require$_DOT__SLASH_instantiation_DOT_js._util.getServiceDependencies(_trace.desc.ctor)) {
          var instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
          instanceOrDesc || this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, !0);
          (_a = this._globalGraph) === null || _a === void 0 || _a.insertEdge(String(_trace.id), String(dependency.id));
          instanceOrDesc instanceof require$_DOT__SLASH_descriptors_DOT_js.SyncDescriptor && (instanceOrDesc = {id:dependency.id, desc:instanceOrDesc, _trace:_trace._trace.branch(dependency.id, !0)}, graph.insertEdge(_trace, instanceOrDesc), desc.push(instanceOrDesc));
        }
      }
      for (;;) {
        _a = graph.roots();
        if (_a.length === 0) {
          if (!graph.isEmpty()) {
            throw new CyclicDependencyError(graph);
          }
          break;
        }
        for (const {data} of _a) {
          this._getServiceInstanceOrDescriptor(data.id) instanceof require$_DOT__SLASH_descriptors_DOT_js.SyncDescriptor && (_a = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace), this._setServiceInstance(data.id, _a)), graph.removeNode(data);
        }
      }
      return this._getServiceInstanceOrDescriptor(id);
    }
    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
      if (this._services.get(id) instanceof require$_DOT__SLASH_descriptors_DOT_js.SyncDescriptor) {
        return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace);
      }
      if (this._parent) {
        return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);
      }
      throw Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
    _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
      if (supportsDelayedInstantiation) {
        const child = new InstantiationService(void 0, this._strict, this, this._enableTracing);
        child._globalGraphImplicitDependency = String(id);
        const earlyListeners = new Map(), idle = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.GlobalIdleValue(() => {
          const result = child._createInstance(ctor, args, _trace);
          for (const [key, values] of earlyListeners) {
            const candidate = result[key];
            if (typeof candidate === "function") {
              for (const listener of values) {
                candidate.apply(result, listener);
              }
            }
          }
          earlyListeners.clear();
          return result;
        });
        return new Proxy(Object.create(null), {get(target, key) {
          if (!idle.isInitialized && typeof key === "string" && (key.startsWith("onDid") || key.startsWith("onWill"))) {
            let list = earlyListeners.get(key);
            list || (list = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_linkedList_DOT_js.LinkedList(), earlyListeners.set(key, list));
            return (callback, thisArg, disposables) => {
              callback = list.push([callback, thisArg, disposables]);
              return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(callback);
            };
          }
          if (key in target) {
            return target[key];
          }
          const obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          return target[key] = prop;
        }, set(_target, p, value) {
          idle.value[p] = value;
          return !0;
        }, getPrototypeOf(_target) {
          return ctor.prototype;
        }});
      }
      return this._createInstance(ctor, args, _trace);
    }
    _throwIfStrict(msg, printWarning) {
      printWarning && console.warn(msg);
      if (this._strict) {
        throw Error(msg);
      }
    }
  }
  class Trace {
    static traceInvocation(_enableTracing, ctor) {
      return _enableTracing ? new Trace(2, ctor.name || Error().stack.split("\n").slice(3, 4).join("\n")) : Trace._None;
    }
    static traceCreation(_enableTracing, ctor) {
      return _enableTracing ? new Trace(1, ctor.name) : Trace._None;
    }
    constructor(type, name) {
      this.type = type;
      this.name = name;
      this._start = Date.now();
      this._dep = [];
    }
    branch(id, first) {
      const child = new Trace(3, id.toString());
      this._dep.push([id, first, child]);
      return child;
    }
    stop() {
      function printChild(n, trace) {
        const res = [], prefix = Array(n + 1).join("\t");
        for (const [id, first, child] of trace._dep) {
          first && child ? (causedCreation = !0, res.push(`${prefix}CREATES -> ${id}`), (trace = printChild(n + 1, child)) && res.push(trace)) : res.push(`${prefix}uses -> ${id}`);
        }
        return res.join("\n");
      }
      const dur = Date.now() - this._start;
      Trace._totals += dur;
      let causedCreation = !1;
      const lines = [`${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`, `${printChild(1, this)}`, `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];
      (dur > 2 || causedCreation) && Trace.all.add(lines.join("\n"));
    }
  }
  Trace.all = new Set();
  Trace._None = new class extends Trace {
    constructor() {
      super(0, null);
    }
    stop() {
    }
    branch() {
      return this;
    }
  }();
  Trace._totals = 0;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$instantiationService.js.map
