shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$compressedObjectTreeModel = function(require, module, exports) {
  function noCompress(element) {
    return {element:{elements:[element.element], incompressible:element.incompressible || !1}, children:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.from(element.children), noCompress), collapsible:element.collapsible, collapsed:element.collapsed};
  }
  function compress(element) {
    const elements = [element.element], incompressible = element.incompressible || !1;
    let childrenIterator, children;
    for (;;) {
      [children, childrenIterator] = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.consume(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.from(element.children), 2);
      if (children.length !== 1) {
        break;
      }
      if (children[0].incompressible) {
        break;
      }
      element = children[0];
      elements.push(element.element);
    }
    return {element:{elements, incompressible}, children:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.concat(children, childrenIterator), compress), collapsible:element.collapsible, collapsed:element.collapsed};
  }
  function _decompress(element, index = 0) {
    let children;
    children = index < element.element.elements.length - 1 ? [_decompress(element, index + 1)] : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.from(element.children), el => _decompress(el, 0));
    return index === 0 && element.element.incompressible ? {element:element.element.elements[index], children, incompressible:!0, collapsible:element.collapsible, collapsed:element.collapsed} : {element:element.element.elements[index], children, collapsible:element.collapsible, collapsed:element.collapsed};
  }
  function decompress(element) {
    return _decompress(element, 0);
  }
  function splice(treeElement, element, children) {
    return treeElement.element === element ? {...treeElement, children} : {...treeElement, children:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.from(treeElement.children), e => splice(e, element, children))};
  }
  function mapList(nodeMapper, list) {
    return {splice(start, deleteCount, toInsert) {
      list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));
    }, updateElementHeight(index, height) {
      list.updateElementHeight(index, height);
    }};
  }
  function mapOptions(compressedNodeUnwrapper, options) {
    return {...options, identityProvider:options.identityProvider && {getId(node) {
      return options.identityProvider.getId(compressedNodeUnwrapper(node));
    }}, sorter:options.sorter && {compare(node, otherNode) {
      return options.sorter.compare(node.elements[0], otherNode.elements[0]);
    }}, filter:options.filter && {filter(node, parentVisibility) {
      return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);
    }}};
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CompressedObjectTreeModel:{enumerable:!0, get:function() {
    return CompressedObjectTreeModel;
  }}, CompressibleObjectTreeModel:{enumerable:!0, get:function() {
    return CompressibleObjectTreeModel;
  }}, DefaultElementMapper:{enumerable:!0, get:function() {
    return DefaultElementMapper;
  }}, compress:{enumerable:!0, get:function() {
    return compress;
  }}, decompress:{enumerable:!0, get:function() {
    return decompress;
  }}});
  var require$_DOT__SLASH_objectTreeModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$objectTreeModel"), require$_DOT__SLASH_tree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$tree"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator");
  const wrapIdentityProvider = base => ({getId(node) {
    return node.elements.map(e => base.getId(e).toString()).join("\x00");
  }});
  class CompressedObjectTreeModel {
    get onDidSplice() {
      return this.model.onDidSplice;
    }
    get onDidChangeCollapseState() {
      return this.model.onDidChangeCollapseState;
    }
    get onDidChangeRenderNodeCount() {
      return this.model.onDidChangeRenderNodeCount;
    }
    constructor(user, list, options = {}) {
      this.user = user;
      this.rootRef = null;
      this.nodes = new Map();
      this.model = new require$_DOT__SLASH_objectTreeModel_DOT_js.ObjectTreeModel(user, list, options);
      this.enabled = typeof options.compressionEnabled === "undefined" ? !0 : options.compressionEnabled;
      this.identityProvider = options.identityProvider;
    }
    setChildren(element, children = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), options) {
      const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);
      if (element === null) {
        var compressedChildren = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(children, this.enabled ? compress : noCompress);
        this._setChildren(null, compressedChildren, {diffIdentityProvider, diffDepth:Infinity});
      } else {
        compressedChildren = this.nodes.get(element);
        if (!compressedChildren) {
          throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Unknown compressed tree node");
        }
        var node = this.model.getNode(compressedChildren), compressedParentNode = this.model.getParentNodeLocation(compressedChildren);
        compressedParentNode = this.model.getNode(compressedParentNode);
        var decompressedElement = decompress(node);
        element = splice(decompressedElement, element, children);
        var recompressedElement = (this.enabled ? compress : noCompress)(element);
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.equals)(recompressedElement.element.elements, node.element.elements, options.diffIdentityProvider ? (a, b) => options.diffIdentityProvider.getId(a) === options.diffIdentityProvider.getId(b) : void 0) ? this._setChildren(compressedChildren, recompressedElement.children || require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), {diffIdentityProvider, diffDepth:1}) : 
        (compressedChildren = compressedParentNode.children.map(child => child === node ? recompressedElement : child), this._setChildren(compressedParentNode.element, compressedChildren, {diffIdentityProvider, diffDepth:node.depth - compressedParentNode.depth}));
      }
    }
    setCompressionEnabled(enabled) {
      if (enabled !== this.enabled) {
        this.enabled = enabled;
        var rootChildren = this.model.getNode().children;
        rootChildren = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(rootChildren, decompress);
        enabled = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(rootChildren, enabled ? compress : noCompress);
        this._setChildren(null, enabled, {diffIdentityProvider:this.identityProvider, diffDepth:Infinity});
      }
    }
    _setChildren(node, children, options) {
      const insertedElements = new Set();
      this.model.setChildren(node, children, {...options, onDidCreateNode:node => {
        for (const element of node.element.elements) {
          insertedElements.add(element), this.nodes.set(element, node.element);
        }
      }, onDidDeleteNode:node => {
        for (const element of node.element.elements) {
          insertedElements.has(element) || this.nodes.delete(element);
        }
      }});
    }
    has(element) {
      return this.nodes.has(element);
    }
    getListIndex(location) {
      location = this.getCompressedNode(location);
      return this.model.getListIndex(location);
    }
    getListRenderCount(location) {
      location = this.getCompressedNode(location);
      return this.model.getListRenderCount(location);
    }
    getNode(location) {
      if (typeof location === "undefined") {
        return this.model.getNode();
      }
      location = this.getCompressedNode(location);
      return this.model.getNode(location);
    }
    getNodeLocation(node) {
      node = this.model.getNodeLocation(node);
      return node === null ? null : node.elements[node.elements.length - 1];
    }
    getParentNodeLocation(location) {
      location = this.getCompressedNode(location);
      location = this.model.getParentNodeLocation(location);
      return location === null ? null : location.elements[location.elements.length - 1];
    }
    getFirstElementChild(location) {
      location = this.getCompressedNode(location);
      return this.model.getFirstElementChild(location);
    }
    isCollapsible(location) {
      location = this.getCompressedNode(location);
      return this.model.isCollapsible(location);
    }
    setCollapsible(location, collapsible) {
      location = this.getCompressedNode(location);
      return this.model.setCollapsible(location, collapsible);
    }
    isCollapsed(location) {
      location = this.getCompressedNode(location);
      return this.model.isCollapsed(location);
    }
    setCollapsed(location, collapsed, recursive) {
      location = this.getCompressedNode(location);
      return this.model.setCollapsed(location, collapsed, recursive);
    }
    expandTo(location) {
      location = this.getCompressedNode(location);
      this.model.expandTo(location);
    }
    rerender(location) {
      location = this.getCompressedNode(location);
      this.model.rerender(location);
    }
    refilter() {
      this.model.refilter();
    }
    getCompressedNode(element) {
      if (element === null) {
        return null;
      }
      const node = this.nodes.get(element);
      if (!node) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, `Tree element not found: ${element}`);
      }
      return node;
    }
  }
  const DefaultElementMapper = elements => elements[elements.length - 1];
  class CompressedTreeNodeWrapper {
    get element() {
      return this.node.element === null ? null : this.unwrapper(this.node.element);
    }
    get children() {
      return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node));
    }
    get depth() {
      return this.node.depth;
    }
    get visibleChildrenCount() {
      return this.node.visibleChildrenCount;
    }
    get visibleChildIndex() {
      return this.node.visibleChildIndex;
    }
    get collapsible() {
      return this.node.collapsible;
    }
    get collapsed() {
      return this.node.collapsed;
    }
    get visible() {
      return this.node.visible;
    }
    get filterData() {
      return this.node.filterData;
    }
    constructor(unwrapper, node) {
      this.unwrapper = unwrapper;
      this.node = node;
    }
  }
  class CompressibleObjectTreeModel {
    get onDidSplice() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.model.onDidSplice, ({insertedNodes, deletedNodes}) => ({insertedNodes:insertedNodes.map(node => this.nodeMapper.map(node)), deletedNodes:deletedNodes.map(node => this.nodeMapper.map(node))}));
    }
    get onDidChangeCollapseState() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.model.onDidChangeCollapseState, ({node, deep}) => ({node:this.nodeMapper.map(node), deep}));
    }
    get onDidChangeRenderNodeCount() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));
    }
    constructor(user, list, options = {}) {
      this.rootRef = null;
      this.elementMapper = options.elementMapper || DefaultElementMapper;
      const compressedNodeUnwrapper = node => this.elementMapper(node.elements);
      this.nodeMapper = new require$_DOT__SLASH_tree_DOT_js.WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));
      this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));
    }
    setChildren(element, children = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), options = {}) {
      this.model.setChildren(element, children, options);
    }
    setCompressionEnabled(enabled) {
      this.model.setCompressionEnabled(enabled);
    }
    has(location) {
      return this.model.has(location);
    }
    getListIndex(location) {
      return this.model.getListIndex(location);
    }
    getListRenderCount(location) {
      return this.model.getListRenderCount(location);
    }
    getNode(location) {
      return this.nodeMapper.map(this.model.getNode(location));
    }
    getNodeLocation(node) {
      return node.element;
    }
    getParentNodeLocation(location) {
      return this.model.getParentNodeLocation(location);
    }
    getFirstElementChild(location) {
      location = this.model.getFirstElementChild(location);
      return location === null || typeof location === "undefined" ? location : this.elementMapper(location.elements);
    }
    isCollapsible(location) {
      return this.model.isCollapsible(location);
    }
    setCollapsible(location, collapsed) {
      return this.model.setCollapsible(location, collapsed);
    }
    isCollapsed(location) {
      return this.model.isCollapsed(location);
    }
    setCollapsed(location, collapsed, recursive) {
      return this.model.setCollapsed(location, collapsed, recursive);
    }
    expandTo(location) {
      return this.model.expandTo(location);
    }
    rerender(location) {
      return this.model.rerender(location);
    }
    refilter() {
      return this.model.refilter();
    }
    getCompressedTreeNode(location = null) {
      return this.model.getNode(location);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$compressedObjectTreeModel.js.map
