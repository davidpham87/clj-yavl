shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$viewModelImpl = function(require, module, exports) {
  function rangeArraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return !1;
    }
    for (let i = 0; i < arr1.length; i++) {
      if (!arr1[i].equalsRange(arr2[i])) {
        return !1;
      }
    }
    return !0;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ViewModel:{enumerable:!0, get:function() {
    return ViewModel;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$color");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_config_SLASH_editorOptions_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$config$editorOptions"), require$_DOT__DOT__SLASH_cursor_SLASH_cursor_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursor"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), textModelEvents = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents"), require$_DOT__DOT__SLASH_languages_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages"), 
  require$_DOT__DOT__SLASH_languages_SLASH_modesRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$modesRegistry"), require$_DOT__DOT__SLASH_languages_SLASH_textToHtmlTokenizer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$textToHtmlTokenizer"), viewEvents = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewEvents"), require$_DOT__DOT__SLASH_viewLayout_SLASH_viewLayout_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$viewLayout"), 
  require$_DOT__SLASH_minimapTokensColorTracker_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$minimapTokensColorTracker"), require$_DOT__DOT__SLASH_viewModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel"), require$_DOT__SLASH_viewModelDecorations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$viewModelDecorations"), require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModelEventDispatcher"), 
  require$_DOT__SLASH_viewModelLines_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$viewModelLines");
  class ViewModel extends module.Disposable {
    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView) {
      super();
      this.languageConfigurationService = languageConfigurationService;
      this._themeService = _themeService;
      this._attachedView = _attachedView;
      this.hiddenAreasModel = new HiddenAreasModel();
      this.previousHiddenAreas = [];
      this._editorId = editorId;
      this._configuration = configuration;
      this.model = model;
      this._eventDispatcher = new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ViewModelEventDispatcher();
      this.onEvent = this._eventDispatcher.onEvent;
      this.cursorConfig = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);
      this._updateConfigurationViewLineCount = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));
      this._hasFocus = !1;
      this._viewportStart = ViewportStart.create(this.model);
      this.model.isTooLargeForTokenization() ? this._lines = new require$_DOT__SLASH_viewModelLines_DOT_js.ViewModelLinesFromModelAsIs(this.model) : (_attachedView = this._configuration.options, editorId = _attachedView.get(50), configuration = _attachedView.get(137), languageConfigurationService = _attachedView.get(144), _themeService = _attachedView.get(136), _attachedView = _attachedView.get(128), this._lines = new require$_DOT__SLASH_viewModelLines_DOT_js.ViewModelLinesFromProjectedModel(this._editorId, 
      this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, editorId, this.model.getOptions().tabSize, configuration, languageConfigurationService.wrappingColumn, _themeService, _attachedView));
      this.coordinatesConverter = this._lines.createCoordinatesConverter();
      this._cursor = this._register(new require$_DOT__DOT__SLASH_cursor_SLASH_cursor_DOT_js.CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));
      this.viewLayout = this._register(new require$_DOT__DOT__SLASH_viewLayout_SLASH_viewLayout_DOT_js.ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));
      this._register(this.viewLayout.onDidScroll(e => {
        e.scrollTopChanged && this._handleVisibleLinesChanged();
        e.scrollTopChanged && this._viewportStart.invalidate();
        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));
        this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));
      }));
      this._register(this.viewLayout.onDidContentSizeChange(e => {
        this._eventDispatcher.emitOutgoingEvent(e);
      }));
      this._decorations = new require$_DOT__SLASH_viewModelDecorations_DOT_js.ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);
      this._registerModelEvents();
      this._register(this._configuration.onDidChangeFast(e => {
        try {
          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
          this._onConfigurationChanged(eventsCollector, e);
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
      }));
      this._register(require$_DOT__SLASH_minimapTokensColorTracker_DOT_js.MinimapTokensColorTracker.getInstance().onDidChange(() => {
        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());
      }));
      this._register(this._themeService.onDidColorThemeChange(theme => {
        this._invalidateDecorationsColorCache();
        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));
      }));
      this._updateConfigurationViewLineCountNow();
    }
    dispose() {
      super.dispose();
      this._decorations.dispose();
      this._lines.dispose();
      this._viewportStart.dispose();
      this._eventDispatcher.dispose();
    }
    createLineBreaksComputer() {
      return this._lines.createLineBreaksComputer();
    }
    addViewEventHandler(eventHandler) {
      this._eventDispatcher.addViewEventHandler(eventHandler);
    }
    removeViewEventHandler(eventHandler) {
      this._eventDispatcher.removeViewEventHandler(eventHandler);
    }
    _updateConfigurationViewLineCountNow() {
      this._configuration.setViewLineCount(this._lines.getViewLineCount());
    }
    getModelVisibleRanges() {
      var linesViewportData = this.viewLayout.getLinesViewportData();
      linesViewportData = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));
      return this._toModelVisibleRanges(linesViewportData);
    }
    visibleLinesStabilized() {
      const modelVisibleRanges = this.getModelVisibleRanges();
      this._attachedView.setVisibleLines(modelVisibleRanges, !0);
    }
    _handleVisibleLinesChanged() {
      const modelVisibleRanges = this.getModelVisibleRanges();
      this._attachedView.setVisibleLines(modelVisibleRanges, !1);
    }
    setHasFocus(hasFocus) {
      this._hasFocus = hasFocus;
      this._cursor.setHasFocus(hasFocus);
      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));
      this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.FocusChangedEvent(!hasFocus, hasFocus));
    }
    onCompositionStart() {
      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());
    }
    onCompositionEnd() {
      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());
    }
    _captureStableViewport() {
      if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {
        var previousViewportStartViewPosition = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));
        previousViewportStartViewPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);
        return new StableViewport(previousViewportStartViewPosition, this._viewportStart.startLineDelta);
      }
      return new StableViewport(null, 0);
    }
    _onConfigurationChanged(eventsCollector, e) {
      const stableViewport = this._captureStableViewport();
      var options = this._configuration.options;
      const fontInfo = options.get(50), wrappingStrategy = options.get(137), wrappingInfo = options.get(144), wrappingIndent = options.get(136);
      options = options.get(128);
      this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, options) && (eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent()), eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent()), eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null)), this._cursor.onLineMappingChanged(eventsCollector), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this._updateConfigurationViewLineCount.schedule());
      e.hasChanged(90) && (this._decorations.reset(), eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null)));
      e.hasChanged(97) && (this._decorations.reset(), eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null)));
      eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));
      this.viewLayout.onConfigurationChanged(e);
      stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
      require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorConfiguration.shouldRecreate(e) && (this.cursorConfig = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
    }
    _registerModelEvents() {
      this._register(this.model.onDidChangeContentOrInjectedText(e => {
        try {
          var eventsCollector = this._eventDispatcher.beginEmitViewEvents();
          let hadOtherModelChange = !1, hadModelLineChangeThatChangedLineMapping = !1;
          const changes = e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes, versionId = e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null, lineBreaksComputer = this._lines.createLineBreaksComputer();
          for (const change of changes) {
            switch(change.changeType) {
              case 4:
                for (var lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {
                  const line = change.detail[lineIdx];
                  let injectedText = change.injectedTexts[lineIdx];
                  injectedText &&= injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);
                  lineBreaksComputer.addRequest(line, injectedText, null);
                }
                break;
              case 2:
                lineIdx = null, change.injectedText && (lineIdx = change.injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId)), lineBreaksComputer.addRequest(change.detail, lineIdx, null);
            }
          }
          const lineBreaks = lineBreaksComputer.finalize(), lineBreakQueue = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.ArrayQueue(lineBreaks);
          for (const change of changes) {
            switch(change.changeType) {
              case 1:
                this._lines.onModelFlushed();
                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());
                this._decorations.reset();
                this.viewLayout.onFlushed(this.getLineCount());
                hadOtherModelChange = !0;
                break;
              case 3:
                const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);
                linesDeletedEvent !== null && (eventsCollector.emitViewEvent(linesDeletedEvent), this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber));
                hadOtherModelChange = !0;
                break;
              case 4:
                const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length), linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);
                linesInsertedEvent !== null && (eventsCollector.emitViewEvent(linesInsertedEvent), this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber));
                hadOtherModelChange = !0;
                break;
              case 2:
                const changedLineBreakData = lineBreakQueue.dequeue(), [lineMappingChanged, linesChangedEvent, linesInsertedEvent$jscomp$0, linesDeletedEvent$jscomp$0] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);
                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;
                linesChangedEvent && eventsCollector.emitViewEvent(linesChangedEvent);
                linesInsertedEvent$jscomp$0 && (eventsCollector.emitViewEvent(linesInsertedEvent$jscomp$0), this.viewLayout.onLinesInserted(linesInsertedEvent$jscomp$0.fromLineNumber, linesInsertedEvent$jscomp$0.toLineNumber));
                linesDeletedEvent$jscomp$0 && (eventsCollector.emitViewEvent(linesDeletedEvent$jscomp$0), this.viewLayout.onLinesDeleted(linesDeletedEvent$jscomp$0.fromLineNumber, linesDeletedEvent$jscomp$0.toLineNumber));
            }
          }
          versionId !== null && this._lines.acceptVersionId(versionId);
          this.viewLayout.onHeightMaybeChanged();
          !hadOtherModelChange && hadModelLineChangeThatChangedLineMapping && (eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent()), eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null)), this._cursor.onLineMappingChanged(eventsCollector), this._decorations.onLineMappingChanged());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        eventsCollector = this._viewportStart.isValid;
        this._viewportStart.invalidate();
        this._configuration.setModelLineCount(this.model.getLineCount());
        this._updateConfigurationViewLineCountNow();
        !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && eventsCollector && (eventsCollector = this.model._getTrackedRange(this._viewportStart.modelTrackedRange)) && (eventsCollector = this.coordinatesConverter.convertModelPositionToViewPosition(eventsCollector.getStartPosition()), eventsCollector = this.viewLayout.getVerticalOffsetForLineNumber(eventsCollector.lineNumber), this.viewLayout.setScrollPosition({scrollTop:eventsCollector + this._viewportStart.startLineDelta}, 1));
        try {
          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
          e instanceof textModelEvents.InternalModelContentChangeEvent && eventsCollector.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ModelContentChangedEvent(e.contentChangedEvent));
          this._cursor.onModelContentChanged(eventsCollector, e);
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._handleVisibleLinesChanged();
      }));
      this._register(this.model.onDidChangeTokens(e => {
        const viewRanges = [];
        for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {
          var modelRange = e.ranges[j];
          const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(modelRange.fromLineNumber, 1)).lineNumber;
          modelRange = this.coordinatesConverter.convertModelPositionToViewPosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;
          viewRanges[j] = {fromLineNumber:viewStartLineNumber, toLineNumber:modelRange};
        }
        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));
        this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ModelTokensChangedEvent(e));
      }));
      this._register(this.model.onDidChangeLanguageConfiguration(e => {
        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());
        this.cursorConfig = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);
        this._cursor.updateConfiguration(this.cursorConfig);
        this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ModelLanguageConfigurationChangedEvent(e));
      }));
      this._register(this.model.onDidChangeLanguage(e => {
        this.cursorConfig = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);
        this._cursor.updateConfiguration(this.cursorConfig);
        this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ModelLanguageChangedEvent(e));
      }));
      this._register(this.model.onDidChangeOptions(e => {
        if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
          try {
            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());
            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());
            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));
            this._cursor.onLineMappingChanged(eventsCollector);
            this._decorations.onLineMappingChanged();
            this.viewLayout.onFlushed(this.getLineCount());
          } finally {
            this._eventDispatcher.endEmitViewEvents();
          }
          this._updateConfigurationViewLineCount.schedule();
        }
        this.cursorConfig = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);
        this._cursor.updateConfiguration(this.cursorConfig);
        this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ModelOptionsChangedEvent(e));
      }));
      this._register(this.model.onDidChangeDecorations(e => {
        this._decorations.onModelDecorationsChanged();
        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));
        this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ModelDecorationsChangedEvent(e));
      }));
    }
    setHiddenAreas(ranges, source) {
      var _a;
      this.hiddenAreasModel.setHiddenAreas(source, ranges);
      ranges = this.hiddenAreasModel.getMergedRanges();
      if (ranges !== this.previousHiddenAreas) {
        this.previousHiddenAreas = ranges;
        source = this._captureStableViewport();
        var lineMappingChanged = !1;
        try {
          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
          if (lineMappingChanged = this._lines.setHiddenAreas(ranges)) {
            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent()), eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent()), eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null)), this._cursor.onLineMappingChanged(eventsCollector), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged();
          }
          const firstModelLineInViewPort = (_a = source.viewportStartModelPosition) === null || _a === void 0 ? void 0 : _a.lineNumber;
          firstModelLineInViewPort && ranges.some(range => range.startLineNumber <= firstModelLineInViewPort && firstModelLineInViewPort <= range.endLineNumber) || source.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
        lineMappingChanged && this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.HiddenAreasChangedEvent());
      }
    }
    getVisibleRangesPlusViewportAboveBelow() {
      var layoutInfo = this._configuration.options.get(143), lineHeight = this._configuration.options.get(66);
      lineHeight = Math.max(20, Math.round(layoutInfo.height / lineHeight));
      const partialData = this.viewLayout.getLinesViewportData();
      layoutInfo = Math.max(1, partialData.completelyVisibleStartLineNumber - lineHeight);
      lineHeight = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + lineHeight);
      return this._toModelVisibleRanges(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(layoutInfo, this.getLineMinColumn(layoutInfo), lineHeight, this.getLineMaxColumn(lineHeight)));
    }
    getVisibleRanges() {
      const visibleViewRange = this.getCompletelyVisibleViewRange();
      return this._toModelVisibleRanges(visibleViewRange);
    }
    getHiddenAreas() {
      return this._lines.getHiddenAreas();
    }
    _toModelVisibleRanges(visibleViewRange) {
      var visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);
      visibleViewRange = this._lines.getHiddenAreas();
      if (visibleViewRange.length === 0) {
        return [visibleRange];
      }
      const result = [];
      let resultLen = 0, startLineNumber = visibleRange.startLineNumber, startColumn = visibleRange.startColumn;
      const endLineNumber = visibleRange.endLineNumber;
      visibleRange = visibleRange.endColumn;
      for (let i = 0, len = visibleViewRange.length; i < len; i++) {
        const hiddenStartLineNumber = visibleViewRange[i].startLineNumber, hiddenEndLineNumber = visibleViewRange[i].endLineNumber;
        hiddenEndLineNumber < startLineNumber || hiddenStartLineNumber > endLineNumber || (startLineNumber < hiddenStartLineNumber && (result[resultLen++] = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1))), startLineNumber = hiddenEndLineNumber + 1, startColumn = 1);
      }
      if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < visibleRange) {
        result[resultLen++] = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, startColumn, endLineNumber, visibleRange);
      }
      return result;
    }
    getCompletelyVisibleViewRange() {
      var partialData = this.viewLayout.getLinesViewportData();
      const startViewLineNumber = partialData.completelyVisibleStartLineNumber;
      partialData = partialData.completelyVisibleEndLineNumber;
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), partialData, this.getLineMaxColumn(partialData));
    }
    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {
      var partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);
      scrollTop = partialData.completelyVisibleStartLineNumber;
      partialData = partialData.completelyVisibleEndLineNumber;
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(scrollTop, this.getLineMinColumn(scrollTop), partialData, this.getLineMaxColumn(partialData));
    }
    saveState() {
      const compatViewState = this.viewLayout.saveState();
      var scrollTop = compatViewState.scrollTop;
      const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop), firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));
      scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;
      return {scrollLeft:compatViewState.scrollLeft, firstPosition, firstPositionDeltaTop:scrollTop};
    }
    reduceRestoreState(state) {
      if (typeof state.firstPosition === "undefined") {
        return this._reduceRestoreStateCompatibility(state);
      }
      var modelPosition = this.model.validatePosition(state.firstPosition);
      modelPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
      modelPosition = this.viewLayout.getVerticalOffsetForLineNumber(modelPosition.lineNumber) - state.firstPositionDeltaTop;
      return {scrollLeft:state.scrollLeft, scrollTop:modelPosition};
    }
    _reduceRestoreStateCompatibility(state) {
      return {scrollLeft:state.scrollLeft, scrollTop:state.scrollTopWithoutViewZones};
    }
    getTabSize() {
      return this.model.getOptions().tabSize;
    }
    getLineCount() {
      return this._lines.getViewLineCount();
    }
    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {
      this._viewportStart.update(this, startLineNumber);
    }
    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
      return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);
    }
    getLinesIndentGuides(startLineNumber, endLineNumber) {
      return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);
    }
    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {
      return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);
    }
    getLineContent(lineNumber) {
      return this._lines.getViewLineContent(lineNumber);
    }
    getLineLength(lineNumber) {
      return this._lines.getViewLineLength(lineNumber);
    }
    getLineMinColumn(lineNumber) {
      return this._lines.getViewLineMinColumn(lineNumber);
    }
    getLineMaxColumn(lineNumber) {
      return this._lines.getViewLineMaxColumn(lineNumber);
    }
    getLineFirstNonWhitespaceColumn(lineNumber) {
      lineNumber = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
      return lineNumber === -1 ? 0 : lineNumber + 1;
    }
    getLineLastNonWhitespaceColumn(lineNumber) {
      lineNumber = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
      return lineNumber === -1 ? 0 : lineNumber + 2;
    }
    getMinimapDecorationsInRange(range) {
      return this._decorations.getMinimapDecorationsInRange(range);
    }
    getDecorationsInViewport(visibleRange) {
      return this._decorations.getDecorationsViewportData(visibleRange).decorations;
    }
    getInjectedTextAt(viewPosition) {
      return this._lines.getInjectedTextAt(viewPosition);
    }
    getViewportViewLineRenderingData(visibleRange, lineNumber) {
      visibleRange = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations[lineNumber - visibleRange.startLineNumber];
      return this._getViewLineRenderingData(lineNumber, visibleRange);
    }
    getViewLineRenderingData(lineNumber) {
      const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);
      return this._getViewLineRenderingData(lineNumber, inlineDecorations);
    }
    _getViewLineRenderingData(lineNumber, inlineDecorations) {
      const mightContainRTL = this.model.mightContainRTL(), mightContainNonBasicASCII = this.model.mightContainNonBasicASCII(), tabSize = this.getTabSize(), lineData = this._lines.getViewLineData(lineNumber);
      lineData.inlineDecorations && (inlineDecorations = [...inlineDecorations, ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))]);
      return new require$_DOT__DOT__SLASH_viewModel_DOT_js.ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);
    }
    getViewLineData(lineNumber) {
      return this._lines.getViewLineData(lineNumber);
    }
    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {
      startLineNumber = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);
      return new require$_DOT__DOT__SLASH_viewModel_DOT_js.MinimapLinesRenderingData(this.getTabSize(), startLineNumber);
    }
    getAllOverviewRulerDecorations(theme) {
      var decorations = this.model.getOverviewRulerDecorations(this._editorId, (0,require$_DOT__DOT__SLASH_config_SLASH_editorOptions_DOT_js.filterValidationDecorations)(this._configuration.options));
      const result = new OverviewRulerDecorations();
      for (const decoration of decorations) {
        decorations = decoration.options;
        var opts = decorations.overviewRuler;
        if (!opts) {
          continue;
        }
        const lane = opts.position;
        if (lane === 0) {
          continue;
        }
        opts = opts.getColor(theme.value);
        const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn), viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);
        result.accept(opts, decorations.zIndex, viewStartLineNumber, viewEndLineNumber, lane);
      }
      return result.asArray;
    }
    _invalidateDecorationsColorCache() {
      var decorations = this.model.getOverviewRulerDecorations();
      for (const decoration of decorations) {
        decorations = decoration.options.overviewRuler, decorations === null || decorations === void 0 || decorations.invalidateCachedColor(), decorations = decoration.options.minimap, decorations === null || decorations === void 0 || decorations.invalidateCachedColor();
      }
    }
    getValueInRange(range, eol) {
      range = this.coordinatesConverter.convertViewRangeToModelRange(range);
      return this.model.getValueInRange(range, eol);
    }
    getValueLengthInRange(range, eol) {
      range = this.coordinatesConverter.convertViewRangeToModelRange(range);
      return this.model.getValueLengthInRange(range, eol);
    }
    modifyPosition(position, offset) {
      position = this.coordinatesConverter.convertViewPositionToModelPosition(position);
      return this.model.modifyPosition(position, offset);
    }
    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {
      viewAnchorPosition = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);
      this.model.getEOL().length === 2 && (deltaOffset = deltaOffset < 0 ? deltaOffset - lineFeedCnt : deltaOffset + lineFeedCnt);
      lineFeedCnt = this.model.getOffsetAt(viewAnchorPosition);
      return this.model.getPositionAt(lineFeedCnt + deltaOffset);
    }
    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {
      var newLineCharacter = forceCRLF ? "\r\n" : this.model.getEOL();
      modelRanges = modelRanges.slice(0);
      modelRanges.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
      let hasEmptyRange = !1, hasNonEmptyRange = !1;
      for (const range of modelRanges) {
        range.isEmpty() ? hasEmptyRange = !0 : hasNonEmptyRange = !0;
      }
      if (!hasNonEmptyRange) {
        if (!emptySelectionClipboard) {
          return "";
        }
        forceCRLF = modelRanges.map(r => r.startLineNumber);
        modelRanges = "";
        for (var i = 0; i < forceCRLF.length; i++) {
          i > 0 && forceCRLF[i - 1] === forceCRLF[i] || (modelRanges += this.model.getLineContent(forceCRLF[i]) + newLineCharacter);
        }
        return modelRanges;
      }
      if (hasEmptyRange && emptySelectionClipboard) {
        newLineCharacter = [];
        var prevModelLineNumber = 0;
        for (i of modelRanges) {
          modelRanges = i.startLineNumber, i.isEmpty() ? modelRanges !== prevModelLineNumber && newLineCharacter.push(this.model.getLineContent(modelRanges)) : newLineCharacter.push(this.model.getValueInRange(i, forceCRLF ? 2 : 0)), prevModelLineNumber = modelRanges;
        }
        return newLineCharacter.length === 1 ? newLineCharacter[0] : newLineCharacter;
      }
      newLineCharacter = [];
      for (prevModelLineNumber of modelRanges) {
        prevModelLineNumber.isEmpty() || newLineCharacter.push(this.model.getValueInRange(prevModelLineNumber, forceCRLF ? 2 : 0));
      }
      return newLineCharacter.length === 1 ? newLineCharacter[0] : newLineCharacter;
    }
    getRichTextToCopy(modelRanges, emptySelectionClipboard) {
      const languageId = this.model.getLanguageId();
      if (languageId === require$_DOT__DOT__SLASH_languages_SLASH_modesRegistry_DOT_js.PLAINTEXT_LANGUAGE_ID || modelRanges.length !== 1) {
        return null;
      }
      modelRanges = modelRanges[0];
      if (modelRanges.isEmpty()) {
        if (!emptySelectionClipboard) {
          return null;
        }
        modelRanges = modelRanges.startLineNumber;
        modelRanges = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(modelRanges, this.model.getLineMinColumn(modelRanges), modelRanges, this.model.getLineMaxColumn(modelRanges));
      }
      emptySelectionClipboard = this._configuration.options.get(50);
      const colorMap = this._getColorMap();
      let fontFamily;
      /[:;\\\/<>]/.test(emptySelectionClipboard.fontFamily) || emptySelectionClipboard.fontFamily === require$_DOT__DOT__SLASH_config_SLASH_editorOptions_DOT_js.EDITOR_FONT_DEFAULTS.fontFamily ? fontFamily = require$_DOT__DOT__SLASH_config_SLASH_editorOptions_DOT_js.EDITOR_FONT_DEFAULTS.fontFamily : (fontFamily = emptySelectionClipboard.fontFamily, fontFamily = fontFamily.replace(/"/g, "'"), /[,']/.test(fontFamily) || /[+ ]/.test(fontFamily) && (fontFamily = `'${fontFamily}'`), fontFamily = `${fontFamily}, ${require$_DOT__DOT__SLASH_config_SLASH_editorOptions_DOT_js.EDITOR_FONT_DEFAULTS.fontFamily}`);
      return {mode:languageId, html:'\x3cdiv style\x3d"' + `color: ${colorMap[1]};` + `background-color: ${colorMap[2]};` + `font-family: ${fontFamily};` + `font-weight: ${emptySelectionClipboard.fontWeight};` + `font-size: ${emptySelectionClipboard.fontSize}px;` + `line-height: ${emptySelectionClipboard.lineHeight}px;` + 'white-space: pre;"\x3e' + this._getHTMLToCopy(modelRanges, colorMap) + "\x3c/div\x3e"};
    }
    _getHTMLToCopy(modelRange, colorMap) {
      const startLineNumber = modelRange.startLineNumber, startColumn = modelRange.startColumn, endLineNumber = modelRange.endLineNumber;
      modelRange = modelRange.endColumn;
      const tabSize = this.getTabSize();
      let result = "";
      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        const lineTokens = this.model.tokenization.getLineTokens(lineNumber), lineContent = lineTokens.getLineContent(), startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0, endOffset = lineNumber === endLineNumber ? modelRange - 1 : lineContent.length;
        result = lineContent === "" ? result + "\x3cbr\x3e" : result + (0,require$_DOT__DOT__SLASH_languages_SLASH_textToHtmlTokenizer_DOT_js.tokenizeLineToHTML)(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);
      }
      return result;
    }
    _getColorMap() {
      const colorMap = require$_DOT__DOT__SLASH_languages_DOT_js.TokenizationRegistry.getColorMap(), result = ["#000000"];
      if (colorMap) {
        for (let i = 1, len = colorMap.length; i < len; i++) {
          result[i] = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.Format.CSS.formatHex(colorMap[i]);
        }
      }
      return result;
    }
    getPrimaryCursorState() {
      return this._cursor.getPrimaryCursorState();
    }
    getLastAddedCursorIndex() {
      return this._cursor.getLastAddedCursorIndex();
    }
    getCursorStates() {
      return this._cursor.getCursorStates();
    }
    setCursorStates(source, reason, states) {
      return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));
    }
    getCursorColumnSelectData() {
      return this._cursor.getCursorColumnSelectData();
    }
    getCursorAutoClosedCharacters() {
      return this._cursor.getAutoClosedCharacters();
    }
    setCursorColumnSelectData(columnSelectData) {
      this._cursor.setCursorColumnSelectData(columnSelectData);
    }
    getPrevEditOperationType() {
      return this._cursor.getPrevEditOperationType();
    }
    setPrevEditOperationType(type) {
      this._cursor.setPrevEditOperationType(type);
    }
    getSelection() {
      return this._cursor.getSelection();
    }
    getSelections() {
      return this._cursor.getSelections();
    }
    getPosition() {
      return this._cursor.getPrimaryCursorState().modelState.position;
    }
    setSelections(source, selections, reason = 0) {
      this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));
    }
    saveCursorState() {
      return this._cursor.saveState();
    }
    restoreCursorState(states) {
      this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));
    }
    _executeCursorEdit(callback) {
      this._cursor.context.cursorConfig.readOnly ? this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ReadOnlyEditAttemptEvent()) : this._withViewEventsCollector(callback);
    }
    executeEdits(source, edits, cursorStateComputer) {
      this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));
    }
    startComposition() {
      this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));
    }
    endComposition(source) {
      this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));
    }
    type(text, source) {
      this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));
    }
    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {
      this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));
    }
    paste(text, pasteOnNewLine, multicursorText, source) {
      this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));
    }
    cut(source) {
      this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));
    }
    executeCommand(command, source) {
      this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));
    }
    executeCommands(commands, source) {
      this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));
    }
    revealPrimaryCursor(source, revealHorizontal, minimalReveal = !1) {
      this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0, revealHorizontal, 0));
    }
    revealTopMostCursor(source) {
      const viewPosition = this._cursor.getTopMostViewPosition(), viewRange = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
      this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, !1, viewRange, null, 0, !0, 0)));
    }
    revealBottomMostCursor(source) {
      const viewPosition = this._cursor.getBottomMostViewPosition(), viewRange = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
      this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, !1, viewRange, null, 0, !0, 0)));
    }
    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {
      this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, !1, viewRange, null, verticalType, revealHorizontal, scrollType)));
    }
    changeWhitespace(callback) {
      this.viewLayout.changeWhitespace(callback) && (this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent()), this._eventDispatcher.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.ViewZonesChangedEvent()));
    }
    _withViewEventsCollector(callback) {
      try {
        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();
        return callback(eventsCollector);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    }
    normalizePosition(position, affinity) {
      return this._lines.normalizePosition(position, affinity);
    }
    getLineIndentColumn(lineNumber) {
      return this._lines.getLineIndentColumn(lineNumber);
    }
  }
  class ViewportStart {
    static create(model) {
      const viewportStartLineTrackedRange = model._setTrackedRange(null, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, 1, 1), 1);
      return new ViewportStart(model, 1, !1, viewportStartLineTrackedRange, 0);
    }
    get viewLineNumber() {
      return this._viewLineNumber;
    }
    get isValid() {
      return this._isValid;
    }
    get modelTrackedRange() {
      return this._modelTrackedRange;
    }
    get startLineDelta() {
      return this._startLineDelta;
    }
    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {
      this._model = _model;
      this._viewLineNumber = _viewLineNumber;
      this._isValid = _isValid;
      this._modelTrackedRange = _modelTrackedRange;
      this._startLineDelta = _startLineDelta;
    }
    dispose() {
      this._model._setTrackedRange(this._modelTrackedRange, null, 1);
    }
    update(viewModel, startLineNumber) {
      var position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));
      position = viewModel.model._setTrackedRange(this._modelTrackedRange, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, position.column, position.lineNumber, position.column), 1);
      const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);
      viewModel = viewModel.viewLayout.getCurrentScrollTop();
      this._viewLineNumber = startLineNumber;
      this._isValid = !0;
      this._modelTrackedRange = position;
      this._startLineDelta = viewModel - viewportStartLineTop;
    }
    invalidate() {
      this._isValid = !1;
    }
  }
  class OverviewRulerDecorations {
    constructor() {
      this._asMap = Object.create(null);
      this.asArray = [];
    }
    accept(color, zIndex, startLineNumber, endLineNumber, lane) {
      const prevGroup = this._asMap[color];
      prevGroup ? (color = prevGroup.data, zIndex = color[color.length - 1], color[color.length - 3] === lane && zIndex + 1 >= startLineNumber ? endLineNumber > zIndex && (color[color.length - 1] = endLineNumber) : color.push(lane, startLineNumber, endLineNumber)) : (startLineNumber = new require$_DOT__DOT__SLASH_viewModel_DOT_js.OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]), this._asMap[color] = startLineNumber, this.asArray.push(startLineNumber));
    }
  }
  class HiddenAreasModel {
    constructor() {
      this.hiddenAreas = new Map();
      this.shouldRecompute = !1;
      this.ranges = [];
    }
    setHiddenAreas(source, ranges) {
      const existing = this.hiddenAreas.get(source);
      existing && rangeArraysEqual(existing, ranges) || (this.hiddenAreas.set(source, ranges), this.shouldRecompute = !0);
    }
    getMergedRanges() {
      if (!this.shouldRecompute) {
        return this.ranges;
      }
      this.shouldRecompute = !1;
      const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => {
        const result = [];
        let i = 0, j = 0;
        for (; i < r.length && j < hiddenAreas.length;) {
          const item1 = r[i], item2 = hiddenAreas[j];
          item1.endLineNumber < item2.startLineNumber - 1 ? result.push(r[i++]) : item2.endLineNumber < item1.startLineNumber - 1 ? result.push(hiddenAreas[j++]) : (result.push(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(Math.min(item1.startLineNumber, item2.startLineNumber), 1, Math.max(item1.endLineNumber, item2.endLineNumber), 1)), i++, j++);
        }
        for (; i < r.length;) {
          result.push(r[i++]);
        }
        for (; j < hiddenAreas.length;) {
          result.push(hiddenAreas[j++]);
        }
        return result;
      }, []);
      return rangeArraysEqual(this.ranges, newRanges) ? this.ranges : this.ranges = newRanges;
    }
  }
  class StableViewport {
    constructor(viewportStartModelPosition, startLineDelta) {
      this.viewportStartModelPosition = viewportStartModelPosition;
      this.startLineDelta = startLineDelta;
    }
    recoverViewportStart(coordinatesConverter, viewLayout) {
      this.viewportStartModelPosition && (coordinatesConverter = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition), coordinatesConverter = viewLayout.getVerticalOffsetForLineNumber(coordinatesConverter.lineNumber), viewLayout.setScrollPosition({scrollTop:coordinatesConverter + this.startLineDelta}, 1));
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$viewModelImpl.js.map
