shadow$provide.module$node_modules$papaparse$papaparse_min = function(require, module, exports) {
  ((e, t) => {
    "function" == typeof define && define.amd ? define([], t) : "object" == typeof module && "undefined" != typeof exports ? module.exports = t() : e.Papa = t();
  })(this, function r() {
    function u(e) {
      this._handle = null;
      this._halted = this._completed = this._finished = !1;
      this._input = null;
      this._baseIndex = 0;
      this._partialLine = "";
      this._start = this._rowCount = 0;
      this._nextChunk = null;
      this.isFirstChunk = !0;
      this._completeResults = {data:[], errors:[], meta:{}};
      (function(e) {
        var t = b(e);
        t.chunkSize = parseInt(t.chunkSize);
        e.step || e.chunk || (t.chunkSize = null);
        this._handle = new i(t);
        (this._handle.streamer = this)._config = t;
      }).call(this, e);
      this.parseChunk = function(t, e) {
        var i = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && 0 < i) {
          let e = this._config.newline;
          e || (r = this._config.quoteChar || '"', e = this._handle.guessLineEndings(t, r));
          t = [...t.split(e).slice(i)].join(e);
        }
        this.isFirstChunk && U(this._config.beforeFirstChunk) && void 0 !== (r = this._config.beforeFirstChunk(t)) && (t = r);
        this._halted = this.isFirstChunk = !1;
        i = this._partialLine + t;
        var r = (this._partialLine = "", this._handle.parse(i, this._baseIndex, !this._finished));
        if (!this._handle.paused() && !this._handle.aborted()) {
          t = r.meta.cursor;
          i = (this._finished || (this._partialLine = i.substring(t - this._baseIndex), this._baseIndex = t), r && r.data && (this._rowCount += r.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview);
          if (a) {
            n.postMessage({results:r, workerId:v.WORKER_ID, finished:i});
          } else if (U(this._config.chunk) && !e) {
            if (this._config.chunk(r, this._handle), this._handle.paused() || this._handle.aborted()) {
              return void(this._halted = !0);
            }
            this._completeResults = r = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(r.data), this._completeResults.errors = this._completeResults.errors.concat(r.errors), this._completeResults.meta = r.meta), this._completed || !i || !U(this._config.complete) || r && r.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), i || r && r.meta.paused || this._nextChunk(), r;
        }
        this._halted = !0;
      };
      this._sendError = function(e) {
        U(this._config.error) ? this._config.error(e) : a && this._config.error && n.postMessage({workerId:v.WORKER_ID, error:e, finished:!1});
      };
    }
    function f(e) {
      var r;
      (e = e || {}).chunkSize || (e.chunkSize = v.RemoteChunkSize);
      u.call(this, e);
      this._nextChunk = s ? function() {
        this._readChunk();
        this._chunkLoaded();
      } : function() {
        this._readChunk();
      };
      this.stream = function(e) {
        this._input = e;
        this._nextChunk();
      };
      this._readChunk = function() {
        if (this._finished) {
          this._chunkLoaded();
        } else {
          if (r = new XMLHttpRequest(), this._config.withCredentials && (r.withCredentials = this._config.withCredentials), s || (r.onload = y(this._chunkLoaded, this), r.onerror = y(this._chunkError, this)), r.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
            var e, t = this._config.downloadRequestHeaders;
            for (e in t) {
              r.setRequestHeader(e, t[e]);
            }
          }
          var i;
          this._config.chunkSize && (i = this._start + this._config.chunkSize - 1, r.setRequestHeader("Range", "bytes\x3d" + this._start + "-" + i));
          try {
            r.send(this._config.downloadRequestBody);
          } catch (e) {
            this._chunkError(e.message);
          }
          s && 0 === r.status && this._chunkError();
        }
      };
      this._chunkLoaded = function() {
        if (4 === r.readyState) {
          if (r.status < 200 || 400 <= r.status) {
            this._chunkError();
          } else {
            this._start += this._config.chunkSize || r.responseText.length;
            var JSCompiler_temp;
            if (!(JSCompiler_temp = !this._config.chunkSize)) {
              JSCompiler_temp = this._start;
              var e = r;
              var JSCompiler_inline_result = null !== (e = e.getResponseHeader("Content-Range")) ? parseInt(e.substring(e.lastIndexOf("/") + 1)) : -1;
              JSCompiler_temp = JSCompiler_temp >= JSCompiler_inline_result;
            }
            this._finished = JSCompiler_temp;
            this.parseChunk(r.responseText);
          }
        }
      };
      this._chunkError = function(e) {
        e = r.statusText || e;
        this._sendError(Error(e));
      };
    }
    function l(e) {
      (e = e || {}).chunkSize || (e.chunkSize = v.LocalChunkSize);
      u.call(this, e);
      var i, r, n = "undefined" != typeof FileReader;
      this.stream = function(e) {
        this._input = e;
        r = e.slice || e.webkitSlice || e.mozSlice;
        n ? ((i = new FileReader()).onload = y(this._chunkLoaded, this), i.onerror = y(this._chunkError, this)) : i = new FileReaderSync();
        this._nextChunk();
      };
      this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      };
      this._readChunk = function() {
        var e = this._input, t = (this._config.chunkSize && (t = Math.min(this._start + this._config.chunkSize, this._input.size), e = r.call(e, this._start, t)), i.readAsText(e, this._config.encoding));
        n || this._chunkLoaded({target:{result:t}});
      };
      this._chunkLoaded = function(e) {
        this._start += this._config.chunkSize;
        this._finished = !this._config.chunkSize || this._start >= this._input.size;
        this.parseChunk(e.target.result);
      };
      this._chunkError = function() {
        this._sendError(i.error);
      };
    }
    function c(e) {
      var i;
      u.call(this, e = e || {});
      this.stream = function(e) {
        return i = e, this._nextChunk();
      };
      this._nextChunk = function() {
        var e, t;
        if (!this._finished) {
          return e = this._config.chunkSize, i = e ? (t = i.substring(0, e), i.substring(e)) : (t = i, ""), this._finished = !i, this.parseChunk(t);
        }
      };
    }
    function p(e) {
      u.call(this, e = e || {});
      var t = [], i = !0, r = !1;
      this.pause = function() {
        u.prototype.pause.apply(this, arguments);
        this._input.pause();
      };
      this.resume = function() {
        u.prototype.resume.apply(this, arguments);
        this._input.resume();
      };
      this.stream = function(e) {
        this._input = e;
        this._input.on("data", this._streamData);
        this._input.on("end", this._streamEnd);
        this._input.on("error", this._streamError);
      };
      this._checkIsFinished = function() {
        r && 1 === t.length && (this._finished = !0);
      };
      this._nextChunk = function() {
        this._checkIsFinished();
        t.length ? this.parseChunk(t.shift()) : i = !0;
      };
      this._streamData = y(function(e) {
        try {
          t.push("string" == typeof e ? e : e.toString(this._config.encoding)), i && (i = !1, this._checkIsFinished(), this.parseChunk(t.shift()));
        } catch (e) {
          this._streamError(e);
        }
      }, this);
      this._streamError = y(function(e) {
        this._streamCleanUp();
        this._sendError(e);
      }, this);
      this._streamEnd = y(function() {
        this._streamCleanUp();
        r = !0;
        this._streamData("");
      }, this);
      this._streamCleanUp = y(function() {
        this._input.removeListener("data", this._streamData);
        this._input.removeListener("end", this._streamEnd);
        this._input.removeListener("error", this._streamError);
      }, this);
    }
    function i(m) {
      function y(e) {
        return "greedy" === m.skipEmptyLines ? "" === e.join("").trim() : 1 === e.length && 0 === e[0].length;
      }
      function g$jscomp$0() {
        function i(e, t) {
          for (var i = m.header ? {} : [], r = 0; r < e.length; r++) {
            var n = r, s = e[r];
            s = ((e, t) => (e => (m.dynamicTypingFunction && void 0 === m.dynamicTyping[e] && (m.dynamicTyping[e] = m.dynamicTypingFunction(e)), !0 === (m.dynamicTyping[e] || m.dynamicTyping)))(e) ? "true" === t || "TRUE" === t || "false" !== t && "FALSE" !== t && ((e => {
              if (u.test(e) && (e = parseFloat(e), -9007199254740992 < e && e < 9007199254740992)) {
                return 1;
              }
            })(t) ? parseFloat(t) : d.test(t) ? new Date(t) : "" === t ? null : t) : t)(n = m.header ? r >= c.length ? "__parsed_extra" : c[r] : n, s = m.transform ? m.transform(s, n) : s);
            "__parsed_extra" === n ? (i[n] = i[n] || [], i[n].push(s)) : i[n] = s;
          }
          return m.header && (r > c.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + c.length + " fields but parsed " + r, f + t) : r < c.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + c.length + " fields but parsed " + r, f + t)), i;
        }
        if (p$jscomp$0 && a$jscomp$0 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + v.DefaultDelimiter + "'"), a$jscomp$0 = !1), m.skipEmptyLines && (p$jscomp$0.data = p$jscomp$0.data.filter(function(e) {
          return !y(e);
        })), m.header && 0 === c.length) {
          if (p$jscomp$0) {
            if (Array.isArray(p$jscomp$0.data[0])) {
              for (var e = 0; m.header && 0 === c.length && e < p$jscomp$0.data.length; e++) {
                p$jscomp$0.data[e].forEach(t);
              }
              p$jscomp$0.data.splice(0, 1);
            } else {
              p$jscomp$0.data.forEach(t);
            }
          }
          function t(e, t) {
            U(m.transformHeader) && (e = m.transformHeader(e, t));
            c.push(e);
          }
        }
        var r;
        p$jscomp$0 && (m.header || m.dynamicTyping || m.transform) && (r = 1, !p$jscomp$0.data.length || Array.isArray(p$jscomp$0.data[0]) ? (p$jscomp$0.data = p$jscomp$0.data.map(i), r = p$jscomp$0.data.length) : p$jscomp$0.data = i(p$jscomp$0.data, 0), m.header && p$jscomp$0.meta && (p$jscomp$0.meta.fields = c), f += r);
      }
      function k(e, t, i, r) {
        e = {type:e, code:t, message:i};
        void 0 !== r && (e.row = r);
        p$jscomp$0.errors.push(e);
      }
      var n$jscomp$0, s$jscomp$0, a$jscomp$0, t, u = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, d = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, i = this, r = 0, f = 0, l$jscomp$0 = !1, e = !1, c = [], p$jscomp$0 = {data:[], errors:[], meta:{}};
      U(m.step) && (t = m.step, m.step = function(e) {
        p$jscomp$0 = e;
        m.header && 0 === c.length ? g$jscomp$0() : (g$jscomp$0(), 0 !== p$jscomp$0.data.length && (r += e.data.length, m.preview && r > m.preview ? s$jscomp$0.abort() : (p$jscomp$0.data = p$jscomp$0.data[0], t(p$jscomp$0, i))));
      });
      this.parse = function(e, t$jscomp$0, i$jscomp$0) {
        var r = m.quoteChar || '"';
        m.newline || (m.newline = this.guessLineEndings(e, r));
        a$jscomp$0 = !1;
        if (m.delimiter) {
          U(m.delimiter) && (m.delimiter = m.delimiter(e), p$jscomp$0.meta.delimiter = m.delimiter);
        } else {
          var t = m.newline, i = m.skipEmptyLines, r$jscomp$0 = m.comments, n = m.delimitersToGuess, s, a, o, h;
          n = n || [",", "\t", "|", ";", v.RECORD_SEP, v.UNIT_SEP];
          for (var u = 0; u < n.length; u++) {
            for (var d, f = n[u], l = 0, c = 0, p = 0, g = (o = void 0, (new E({comments:r$jscomp$0, delimiter:f, newline:t, preview:10})).parse(e)), _ = 0; _ < g.data.length; _++) {
              i && y(g.data[_]) ? p++ : (d = g.data[_].length, c += d, void 0 === o ? o = d : 0 < d && (l += Math.abs(d - o), o = d));
            }
            0 < g.data.length && (c /= g.data.length - p);
            (void 0 === a || l <= a) && (void 0 === h || h < c) && 1.99 < c && (a = l, s = f, h = c);
          }
          (r = {successful:!!(m.delimiter = s), bestDelimiter:s}).successful ? m.delimiter = r.bestDelimiter : (a$jscomp$0 = !0, m.delimiter = v.DefaultDelimiter);
          p$jscomp$0.meta.delimiter = m.delimiter;
        }
        r = b(m);
        return m.preview && m.header && r.preview++, n$jscomp$0 = e, s$jscomp$0 = new E(r), p$jscomp$0 = s$jscomp$0.parse(n$jscomp$0, t$jscomp$0, i$jscomp$0), g$jscomp$0(), l$jscomp$0 ? {meta:{paused:!0}} : p$jscomp$0 || {meta:{paused:!1}};
      };
      this.paused = function() {
        return l$jscomp$0;
      };
      this.pause = function() {
        l$jscomp$0 = !0;
        s$jscomp$0.abort();
        n$jscomp$0 = U(m.chunk) ? "" : n$jscomp$0.substring(s$jscomp$0.getCharIndex());
      };
      this.resume = function() {
        i.streamer._halted ? (l$jscomp$0 = !1, i.streamer.parseChunk(n$jscomp$0, !0)) : setTimeout(i.resume, 3);
      };
      this.aborted = function() {
        return e;
      };
      this.abort = function() {
        e = !0;
        s$jscomp$0.abort();
        p$jscomp$0.meta.aborted = !0;
        U(m.complete) && m.complete(p$jscomp$0);
        n$jscomp$0 = "";
      };
      this.guessLineEndings = function(e, t) {
        e = e.substring(0, 1048576);
        t = new RegExp(P(t) + "([^]*?)" + P(t), "gm");
        var i = (e = e.replace(t, "")).split("\r");
        t = e.split("\n");
        e = 1 < t.length && t[0].length < i[0].length;
        if (1 === i.length || e) {
          return "\n";
        }
        for (t = e = 0; t < i.length; t++) {
          "\n" === i[t][0] && e++;
        }
        return e >= i.length / 2 ? "\r\n" : "\r";
      };
    }
    function P(e) {
      return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$\x26");
    }
    function E(C) {
      var S = (C = C || {}).delimiter, O = C.newline, x = C.comments, I = C.step, A = C.preview, T = C.fastMode, D = null, L = !1, F = null == C.quoteChar ? '"' : C.quoteChar, j = F;
      if (void 0 !== C.escapeChar && (j = C.escapeChar), ("string" != typeof S || -1 < v.BAD_DELIMITERS.indexOf(S)) && (S = ","), x === S) {
        throw Error("Comment character same as delimiter");
      }
      !0 === x ? x = "#" : ("string" != typeof x || -1 < v.BAD_DELIMITERS.indexOf(x)) && (x = !1);
      "\n" !== O && "\r" !== O && "\r\n" !== O && (O = "\n");
      var z = 0, M = !1;
      this.parse = function(i, t, r) {
        function k(e) {
          h.push(e);
          f = z;
        }
        function v(e) {
          return -1 !== e && (e = i.substring(m + 1, e)) && "" === e.trim() ? e.length : 0;
        }
        function E(e) {
          return r || (void 0 === e && (e = i.substring(z)), d.push(e), z = n, k(d), o && R()), w();
        }
        function b(e) {
          z = e;
          k(d);
          d = [];
          g = i.indexOf(O, z);
        }
        function w(e) {
          if (C.header && !t && h.length && !L) {
            var s = h[0], a = Object.create(null), o = new Set(s), n = !1;
            for (let r = 0; r < s.length; r++) {
              let i = s[r];
              if (a[i = U(C.transformHeader) ? C.transformHeader(i, r) : i]) {
                let e;
                for (n = a[i]; e = i + "_" + n, n++, o.has(e);) {
                }
                o.add(e);
                s[r] = e;
                a[i]++;
                n = !0;
                (D = null === D ? {} : D)[e] = i;
              } else {
                a[i] = 1, s[r] = i;
              }
              o.add(i);
            }
            n && console.warn("Duplicate headers found and renamed.");
            L = !0;
          }
          return {data:h, errors:u, meta:{delimiter:S, linebreak:O, aborted:M, truncated:!!e, cursor:f + (t || 0), renamedHeaders:D}};
        }
        function R() {
          I(w());
          h = [];
          u = [];
        }
        if ("string" != typeof i) {
          throw Error("Input must be a string");
        }
        var n = i.length, e = S.length, s = O.length, a = x.length, o = U(I), h = [], u = [], d = [], f = z = 0;
        if (!i) {
          return w();
        }
        if (T || !1 !== T && -1 === i.indexOf(F)) {
          e = i.split(O);
          for (s = 0; s < e.length; s++) {
            if (d = e[s], z += d.length, s !== e.length - 1) {
              z += O.length;
            } else if (r) {
              break;
            }
            if (!x || d.substring(0, a) !== x) {
              if (o) {
                if (h = [], k(d.split(S)), R(), M) {
                  break;
                }
              } else {
                k(d.split(S));
              }
              if (A && A <= s) {
                return h = h.slice(0, A), w(!0);
              }
            }
          }
          return w();
        }
        for (var p = i.indexOf(S, z), g = i.indexOf(O, z), _ = new RegExp(P(j) + P(F), "g"), m = i.indexOf(F, z);;) {
          if (i[z] === F) {
            for (m = z, z++;;) {
              if (-1 === (m = i.indexOf(F, m + 1))) {
                return r || u.push({type:"Quotes", code:"MissingQuotes", message:"Quoted field unterminated", row:h.length, index:z}), E();
              }
              if (m === n - 1) {
                return E(i.substring(z, m).replace(_, F));
              }
              if (F === j && i[m + 1] === j) {
                m++;
              } else if (F === j || 0 === m || i[m - 1] !== j) {
                -1 !== p && p < m + 1 && (p = i.indexOf(S, m + 1));
                var y = v(-1 === (g = -1 !== g && g < m + 1 ? i.indexOf(O, m + 1) : g) ? p : Math.min(p, g));
                if (i.substr(m + 1 + y, e) === S) {
                  d.push(i.substring(z, m).replace(_, F));
                  i[z = m + 1 + y + e] !== F && (m = i.indexOf(F, z));
                  p = i.indexOf(S, z);
                  g = i.indexOf(O, z);
                  break;
                }
                y = v(g);
                if (i.substring(m + 1 + y, m + 1 + y + s) === O) {
                  if (d.push(i.substring(z, m).replace(_, F)), b(m + 1 + y + s), p = i.indexOf(S, z), m = i.indexOf(F, z), o && (R(), M)) {
                    return w();
                  }
                  if (A && h.length >= A) {
                    return w(!0);
                  }
                  break;
                }
                u.push({type:"Quotes", code:"InvalidQuotes", message:"Trailing quote on quoted field is malformed", row:h.length, index:z});
                m++;
              }
            }
          } else if (x && 0 === d.length && i.substring(z, z + a) === x) {
            if (-1 === g) {
              return w();
            }
            z = g + s;
            g = i.indexOf(O, z);
            p = i.indexOf(S, z);
          } else if (-1 !== p && (p < g || -1 === g)) {
            d.push(i.substring(z, p)), z = p + e, p = i.indexOf(S, z);
          } else {
            if (-1 === g) {
              break;
            }
            if (d.push(i.substring(z, g)), b(g + s), o && (R(), M)) {
              return w();
            }
            if (A && h.length >= A) {
              return w(!0);
            }
          }
        }
        return E();
      };
      this.abort = function() {
        M = !0;
      };
      this.getCharIndex = function() {
        return z;
      };
    }
    function g(e) {
      var t = e.data;
      e = o[t.workerId];
      var r = !1;
      if (t.error) {
        e.userError(t.error, t.file);
      } else if (t.results && t.results.data) {
        var n = {abort:function() {
          r = !0;
          _(t.workerId, {data:[], errors:[], meta:{aborted:!0}});
        }, pause:m, resume:m};
        if (U(e.userStep)) {
          for (var s = 0; s < t.results.data.length && (e.userStep({data:t.results.data[s], errors:t.results.errors, meta:t.results.meta}, n), !r); s++) {
          }
          delete t.results;
        } else {
          U(e.userChunk) && (e.userChunk(t.results, n, t.file), delete t.results);
        }
      }
      t.finished && !r && _(t.workerId, t.results);
    }
    function _(e, t) {
      var i = o[e];
      U(i.userComplete) && i.userComplete(t);
      i.terminate();
      delete o[e];
    }
    function m() {
      throw Error("Not implemented.");
    }
    function b(e) {
      if ("object" != typeof e || null === e) {
        return e;
      }
      var t, i = Array.isArray(e) ? [] : {};
      for (t in e) {
        i[t] = b(e[t]);
      }
      return i;
    }
    function y(e, t) {
      return function() {
        e.apply(t, arguments);
      };
    }
    function U(e) {
      return "function" == typeof e;
    }
    var n = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n ? n : {}, d, s = !n.document && !!n.postMessage, a = n.IS_PAPA_WORKER || !1, o = {}, h = 0, v = {};
    return v.parse = function(e, t) {
      var i = (t = t || {}).dynamicTyping || !1;
      U(i) && (t.dynamicTypingFunction = i, i = {});
      if (t.dynamicTyping = i, t.transform = !!U(t.transform) && t.transform, !t.worker || !v.WORKERS_SUPPORTED) {
        return i = null, v.NODE_STREAM_INPUT, "string" == typeof e ? (e = (e => 65279 !== e.charCodeAt(0) ? e : e.slice(1))(e), i = new (t.download ? f : c)(t)) : !0 === e.readable && U(e.read) && U(e.on) ? i = new p(t) : (n.File && e instanceof File || e instanceof Object) && (i = new l(t)), i.stream(e);
      }
      (i = (() => {
        var e, JSCompiler_temp;
        if (JSCompiler_temp = !!v.WORKERS_SUPPORTED) {
          JSCompiler_temp = n.URL || n.webkitURL || null;
          var t = r.toString();
          JSCompiler_temp = (e = v.BLOB_URL || (v.BLOB_URL = JSCompiler_temp.createObjectURL(new Blob(["var global \x3d (function() { if (typeof self !\x3d\x3d 'undefined') { return self; } if (typeof window !\x3d\x3d 'undefined') { return window; } if (typeof global !\x3d\x3d 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER\x3dtrue; ", "(", t, ")();"], {type:"text/javascript"}))), (e = new n.Worker(e)).onmessage = g, e.id = h++, o[e.id] = e);
        }
        return JSCompiler_temp;
      })()).userStep = t.step;
      i.userChunk = t.chunk;
      i.userComplete = t.complete;
      i.userError = t.error;
      t.step = U(t.step);
      t.chunk = U(t.chunk);
      t.complete = U(t.complete);
      t.error = U(t.error);
      delete t.worker;
      i.postMessage({input:e, config:t, workerId:i.id});
    }, v.unparse = function(e, t) {
      function u(e, t, i) {
        var r = "", n = ("string" == typeof e && (e = JSON.parse(e)), "string" == typeof t && (t = JSON.parse(t)), Array.isArray(e) && 0 < e.length), s = !Array.isArray(t[0]);
        if (n && _) {
          for (var a = 0; a < e.length; a++) {
            0 < a && (r += m), r += k(e[a], a);
          }
          0 < t.length && (r += y);
        }
        for (a = 0; a < t.length; a++) {
          var h = (n ? e : t[a]).length, u = !1, d = n ? 0 === Object.keys(t[a]).length : 0 === t[a].length;
          if (i && !n && (u = "greedy" === i ? "" === t[a].join("").trim() : 1 === t[a].length && 0 === t[a][0].length), "greedy" === i && n) {
            u = [];
            for (var l = 0; l < h; l++) {
              u.push(t[a][s ? e[l] : l]);
            }
            u = "" === u.join("").trim();
          }
          if (!u) {
            for (u = 0; u < h; u++) {
              0 < u && !d && (r += m), r += k(t[a][n && s ? e[u] : u], u);
            }
            a < t.length - 1 && (!i || 0 < h && !d) && (r += y);
          }
        }
        return r;
      }
      function k(e, t) {
        if (null == e) {
          var i = "";
        } else {
          if (e.constructor === Date) {
            i = JSON.stringify(e).slice(1, 25);
          } else {
            var r = !1;
            o && "string" == typeof e && o.test(e) && (e = "'" + e, r = !0);
            i = e.toString().replace(h, a);
            if (!(e = r || !0 === n || "function" == typeof n && n(e, t) || Array.isArray(n) && n[t])) {
              a: {
                e = v.BAD_DELIMITERS;
                for (t = 0; t < e.length; t++) {
                  if (-1 < i.indexOf(e[t])) {
                    e = !0;
                    break a;
                  }
                }
                e = !1;
              }
            }
            i = e || -1 < i.indexOf(m) || " " === i.charAt(0) || " " === i.charAt(i.length - 1) ? s + i + s : i;
          }
        }
        return i;
      }
      var n = !1, _ = !0, m = ",", y = "\r\n", s = '"', a = s + s, i = !1, r = null, o = !1, h = ((() => {
        if ("object" == typeof t) {
          if ("string" != typeof t.delimiter || v.BAD_DELIMITERS.filter(function(e) {
            return -1 !== t.delimiter.indexOf(e);
          }).length || (m = t.delimiter), "boolean" != typeof t.quotes && "function" != typeof t.quotes && !Array.isArray(t.quotes) || (n = t.quotes), "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i = t.skipEmptyLines), "string" == typeof t.newline && (y = t.newline), "string" == typeof t.quoteChar && (s = t.quoteChar), "boolean" == typeof t.header && (_ = t.header), Array.isArray(t.columns)) {
            if (0 === t.columns.length) {
              throw Error("Option columns is empty");
            }
            r = t.columns;
          }
          void 0 !== t.escapeChar && (a = t.escapeChar + s);
          t.escapeFormulae instanceof RegExp ? o = t.escapeFormulae : "boolean" == typeof t.escapeFormulae && t.escapeFormulae && (o = /^[=+\-@\t\r].*$/);
        }
      })(), new RegExp(P(s), "g"));
      "string" == typeof e && (e = JSON.parse(e));
      if (Array.isArray(e)) {
        if (!e.length || Array.isArray(e[0])) {
          return u(null, e, i);
        }
        if ("object" == typeof e[0]) {
          return u(r || Object.keys(e[0]), e, i);
        }
      } else if ("object" == typeof e) {
        return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), u(e.fields || [], e.data || [], i);
      }
      throw Error("Unable to serialize unrecognized input");
    }, v.RECORD_SEP = String.fromCharCode(30), v.UNIT_SEP = String.fromCharCode(31), v.BYTE_ORDER_MARK = "ï»¿", v.BAD_DELIMITERS = ["\r", "\n", '"', v.BYTE_ORDER_MARK], v.WORKERS_SUPPORTED = !s && !!n.Worker, v.NODE_STREAM_INPUT = 1, v.LocalChunkSize = 10485760, v.RemoteChunkSize = 5242880, v.DefaultDelimiter = ",", v.Parser = E, v.ParserHandle = i, v.NetworkStreamer = f, v.FileStreamer = l, v.StringStreamer = c, v.ReadableStreamStreamer = p, n.jQuery && ((d = n.jQuery).fn.parse = function(o) {
      function e() {
        if (0 === h.length) {
          U(o.complete) && o.complete();
        } else {
          var t, i, r, n = h[0];
          if (U(o.before)) {
            var s = o.before(n.file, n.inputElem);
            if ("object" == typeof s) {
              if ("abort" === s.action) {
                return t = n.file, i = n.inputElem, r = s.reason, void(U(o.error) && o.error({name:"AbortError"}, t, i, r));
              }
              if ("skip" === s.action) {
                return void u();
              }
              "object" == typeof s.config && (n.instanceConfig = d.extend(n.instanceConfig, s.config));
            } else if ("skip" === s) {
              return void u();
            }
          }
          var a = n.instanceConfig.complete;
          n.instanceConfig.complete = function(e) {
            U(a) && a(e, n.file, n.inputElem);
            u();
          };
          v.parse(n.file, n.instanceConfig);
        }
      }
      function u() {
        h.splice(0, 1);
        e();
      }
      var i = o.config || {}, h = [];
      return this.each(function(e) {
        if ("INPUT" !== d(this).prop("tagName").toUpperCase() || "file" !== d(this).attr("type").toLowerCase() || !n.FileReader || !this.files || 0 === this.files.length) {
          return !0;
        }
        for (e = 0; e < this.files.length; e++) {
          h.push({file:this.files[e], inputElem:this, instanceConfig:d.extend({}, i)});
        }
      }), e(), this;
    }), a && (n.onmessage = function(e) {
      e = e.data;
      void 0 === v.WORKER_ID && e && (v.WORKER_ID = e.workerId);
      "string" == typeof e.input ? n.postMessage({workerId:v.WORKER_ID, results:v.parse(e.input, e.config), finished:!0}) : (n.File && e.input instanceof File || e.input instanceof Object) && (e = v.parse(e.input, e.config)) && n.postMessage({workerId:v.WORKER_ID, results:e, finished:!0});
    }), (f.prototype = Object.create(u.prototype)).constructor = f, (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(c.prototype)).constructor = c, (p.prototype = Object.create(u.prototype)).constructor = p, v;
  });
};

//# sourceMappingURL=module$node_modules$papaparse$papaparse_min.js.map
