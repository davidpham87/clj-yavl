shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$touch = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, EventType:{enumerable:!0, get:function() {
    return EventType;
  }}, Gesture:{enumerable:!0, get:function() {
    return Gesture;
  }}});
  var DomUtils = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__SLASH_window_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$window"), arrays = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$decorators");
  var require$_DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH_common_SLASH_linkedList_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$linkedList");
  require = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var EventType;
  (function(EventType) {
    EventType.Tap = "-monaco-gesturetap";
    EventType.Change = "-monaco-gesturechange";
    EventType.Start = "-monaco-gesturestart";
    EventType.End = "-monaco-gesturesend";
    EventType.Contextmenu = "-monaco-gesturecontextmenu";
  })(EventType ||= {});
  class Gesture extends require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor() {
      super();
      this.dispatched = !1;
      this.targets = new require$_DOT__DOT__SLASH_common_SLASH_linkedList_DOT_js.LinkedList();
      this.ignoreTargets = new require$_DOT__DOT__SLASH_common_SLASH_linkedList_DOT_js.LinkedList();
      this.activeTouches = {};
      this.handle = null;
      this._lastSetTapCountTime = 0;
      this._register(require$_DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.runAndSubscribe(DomUtils.onDidRegisterWindow, ({window, disposables}) => {
        disposables.add(DomUtils.addDisposableListener(window.document, "touchstart", e => this.onTouchStart(e), {passive:!1}));
        disposables.add(DomUtils.addDisposableListener(window.document, "touchend", e => this.onTouchEnd(window, e)));
        disposables.add(DomUtils.addDisposableListener(window.document, "touchmove", e => this.onTouchMove(e), {passive:!1}));
      }, {window:require$_DOT__SLASH_window_DOT_js.mainWindow, disposables:this._store}));
    }
    static addTarget(element) {
      if (!Gesture.isTouchDevice()) {
        return require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      }
      Gesture.INSTANCE || (Gesture.INSTANCE = (0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.markAsSingleton)(new Gesture()));
      element = Gesture.INSTANCE.targets.push(element);
      return (0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(element);
    }
    static ignoreTarget(element) {
      if (!Gesture.isTouchDevice()) {
        return require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      }
      Gesture.INSTANCE || (Gesture.INSTANCE = (0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.markAsSingleton)(new Gesture()));
      element = Gesture.INSTANCE.ignoreTargets.push(element);
      return (0,require$_DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(element);
    }
    static isTouchDevice() {
      return "ontouchstart" in require$_DOT__SLASH_window_DOT_js.mainWindow || navigator.maxTouchPoints > 0;
    }
    dispose() {
      this.handle && (this.handle.dispose(), this.handle = null);
      super.dispose();
    }
    onTouchStart(e) {
      const timestamp = Date.now();
      this.handle && (this.handle.dispose(), this.handle = null);
      for (let i = 0, len = e.targetTouches.length; i < len; i++) {
        const touch = e.targetTouches.item(i);
        this.activeTouches[touch.identifier] = {id:touch.identifier, initialTarget:touch.target, initialTimeStamp:timestamp, initialPageX:touch.pageX, initialPageY:touch.pageY, rollingTimestamps:[timestamp], rollingPageX:[touch.pageX], rollingPageY:[touch.pageY]};
        const evt = this.newGestureEvent(EventType.Start, touch.target);
        evt.pageX = touch.pageX;
        evt.pageY = touch.pageY;
        this.dispatchEvent(evt);
      }
      this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
    }
    onTouchEnd(targetWindow, e) {
      const timestamp = Date.now(), activeTouchCount = Object.keys(this.activeTouches).length;
      for (let i = 0, len = e.changedTouches.length; i < len; i++) {
        const touch = e.changedTouches.item(i);
        if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
          console.warn("move of an UNKNOWN touch", touch);
          continue;
        }
        const data = this.activeTouches[touch.identifier];
        var holdTime = Date.now() - data.initialTimeStamp;
        if (holdTime < Gesture.HOLD_DELAY && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {
          holdTime = this.newGestureEvent(EventType.Tap, data.initialTarget), holdTime.pageX = arrays.tail(data.rollingPageX), holdTime.pageY = arrays.tail(data.rollingPageY), this.dispatchEvent(holdTime);
        } else if (holdTime >= Gesture.HOLD_DELAY && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {
          holdTime = this.newGestureEvent(EventType.Contextmenu, data.initialTarget), holdTime.pageX = arrays.tail(data.rollingPageX), holdTime.pageY = arrays.tail(data.rollingPageY), this.dispatchEvent(holdTime);
        } else if (activeTouchCount === 1) {
          holdTime = arrays.tail(data.rollingPageX);
          const finalY = arrays.tail(data.rollingPageY), deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0], deltaX = holdTime - data.rollingPageX[0], deltaY = finalY - data.rollingPageY[0], dispatchTo = [...this.targets].filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));
          this.inertia(targetWindow, dispatchTo, timestamp, Math.abs(deltaX) / deltaT, deltaX > 0 ? 1 : -1, holdTime, Math.abs(deltaY) / deltaT, deltaY > 0 ? 1 : -1, finalY);
        }
        this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));
        delete this.activeTouches[touch.identifier];
      }
      this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
    }
    newGestureEvent(type, initialTarget) {
      const event = document.createEvent("CustomEvent");
      event.initEvent(type, !1, !0);
      event.initialTarget = initialTarget;
      event.tapCount = 0;
      return event;
    }
    dispatchEvent(event) {
      if (event.type === EventType.Tap) {
        const currentTime = (new Date()).getTime();
        let setTapCount;
        setTapCount = currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME ? 1 : 2;
        this._lastSetTapCountTime = currentTime;
        event.tapCount = setTapCount;
      } else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {
        this._lastSetTapCountTime = 0;
      }
      if (event.initialTarget instanceof Node) {
        for (const ignoreTarget of this.ignoreTargets) {
          if (ignoreTarget.contains(event.initialTarget)) {
            return;
          }
        }
        for (const target of this.targets) {
          target.contains(event.initialTarget) && (target.dispatchEvent(event), this.dispatched = !0);
        }
      }
    }
    inertia(targetWindow, dispatchTo, t1, vX, dirX, x, vY, dirY, y) {
      this.handle = DomUtils.scheduleAtNextAnimationFrame(targetWindow, () => {
        const now = Date.now(), deltaT = now - t1;
        let delta_pos_x = 0, delta_pos_y = 0, stopped = !0;
        vX += Gesture.SCROLL_FRICTION * deltaT;
        vY += Gesture.SCROLL_FRICTION * deltaT;
        vX > 0 && (stopped = !1, delta_pos_x = dirX * vX * deltaT);
        vY > 0 && (stopped = !1, delta_pos_y = dirY * vY * deltaT);
        const evt = this.newGestureEvent(EventType.Change);
        evt.translationX = delta_pos_x;
        evt.translationY = delta_pos_y;
        dispatchTo.forEach(d => d.dispatchEvent(evt));
        stopped || this.inertia(targetWindow, dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
      });
    }
    onTouchMove(e) {
      const timestamp = Date.now();
      for (let i = 0, len = e.changedTouches.length; i < len; i++) {
        const touch = e.changedTouches.item(i);
        if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
          console.warn("end of an UNKNOWN touch", touch);
          continue;
        }
        const data = this.activeTouches[touch.identifier], evt = this.newGestureEvent(EventType.Change, data.initialTarget);
        evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);
        evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);
        evt.pageX = touch.pageX;
        evt.pageY = touch.pageY;
        this.dispatchEvent(evt);
        data.rollingPageX.length > 3 && (data.rollingPageX.shift(), data.rollingPageY.shift(), data.rollingTimestamps.shift());
        data.rollingPageX.push(touch.pageX);
        data.rollingPageY.push(touch.pageY);
        data.rollingTimestamps.push(timestamp);
      }
      this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
    }
  }
  Gesture.SCROLL_FRICTION = -0.005;
  Gesture.HOLD_DELAY = 700;
  Gesture.CLEAR_TAP_COUNT_TIME = 400;
  require([module.memoize], Gesture, "isTouchDevice", null);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$touch.js.map
