shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$path = function(require, module, exports) {
  function validateString(value, name) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name, "string", value);
    }
  }
  function isPathSeparator(code) {
    return code === 47 || code === 92;
  }
  function isPosixPathSeparator(code) {
    return code === 47;
  }
  function isWindowsDeviceRoot(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    var lastSegmentLength = 0;
    let lastSlash = -1, dots = 0, code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator(code)) {
        break;
      } else {
        code = 47;
      }
      if (isPathSeparator(code)) {
        if (lastSlash !== i - 1 && dots !== 1) {
          if (dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                lastSegmentLength = res.lastIndexOf(separator);
                lastSegmentLength === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSegmentLength), lastSegmentLength = res.length - 1 - res.lastIndexOf(separator));
                lastSlash = i;
                dots = 0;
                continue;
              } else if (res.length !== 0) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            allowAboveRoot && (res += res.length > 0 ? `${separator}..` : "..", lastSegmentLength = 2);
          } else {
            res = res.length > 0 ? res + `${separator}${path.slice(lastSlash + 1, i)}` : path.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;
          }
        }
        lastSlash = i;
        dots = 0;
      } else {
        code === 46 && dots !== -1 ? ++dots : dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType("pathObject", "Object", pathObject);
    }
    const dir = pathObject.dir || pathObject.root, base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    return dir ? dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}` : base;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, basename:{enumerable:!0, get:function() {
    return basename;
  }}, dirname:{enumerable:!0, get:function() {
    return dirname;
  }}, extname:{enumerable:!0, get:function() {
    return extname;
  }}, normalize:{enumerable:!0, get:function() {
    return normalize;
  }}, posix:{enumerable:!0, get:function() {
    return posix;
  }}, relative:{enumerable:!0, get:function() {
    return relative;
  }}, resolve:{enumerable:!0, get:function() {
    return resolve;
  }}, sep:{enumerable:!0, get:function() {
    return sep;
  }}, win32:{enumerable:!0, get:function() {
    return win32;
  }}});
  var process = require("module$node_modules$monaco_editor$esm$vs$base$common$process");
  class ErrorInvalidArgType extends Error {
    constructor(name, expected, actual) {
      let determiner;
      typeof expected === "string" && expected.indexOf("not ") === 0 ? (determiner = "must not be", expected = expected.replace(/^not /, "")) : determiner = "must be";
      const type = name.indexOf(".") !== -1 ? "property" : "argument";
      super(`The "${name}" ${type} ${determiner} of type ${expected}` + `. Received type ${typeof actual}`);
      this.code = "ERR_INVALID_ARG_TYPE";
    }
  }
  const platformIsWin32 = process.platform === "win32", win32 = {resolve(...pathSegments) {
    let resolvedDevice = "", resolvedTail = "", resolvedAbsolute = !1;
    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        if (path = pathSegments[i], validateString(path, "path"), path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = process.cwd();
      } else {
        if (path = process.env[`=${resolvedDevice}`] || process.cwd(), path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === 92) {
          path = `${resolvedDevice}\\`;
        }
      }
      const len = path.length;
      let rootEnd = 0, device = "", isAbsolute = !1;
      var code = path.charCodeAt(0);
      if (len === 1) {
        isPathSeparator(code) && (rootEnd = 1, isAbsolute = !0);
      } else if (isPathSeparator(code)) {
        if (isAbsolute = !0, isPathSeparator(path.charCodeAt(1))) {
          let last = code = 2;
          for (; code < len && !isPathSeparator(path.charCodeAt(code));) {
            code++;
          }
          if (code < len && code !== last) {
            const firstPart = path.slice(last, code);
            for (last = code; code < len && isPathSeparator(path.charCodeAt(code));) {
              code++;
            }
            if (code < len && code !== last) {
              for (last = code; code < len && !isPathSeparator(path.charCodeAt(code));) {
                code++;
              }
              if (code === len || code !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, code)}`, rootEnd = code;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else {
        isWindowsDeviceRoot(code) && path.charCodeAt(1) === 58 && (device = path.slice(0, 2), rootEnd = 2, len > 2 && isPathSeparator(path.charCodeAt(2)) && (isAbsolute = !0, rootEnd = 3));
      }
      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }
      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        if (resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`, (resolvedAbsolute = isAbsolute) && resolvedDevice.length > 0) {
          break;
        }
      }
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
  }, normalize(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    var rootEnd = 0;
    let device, isAbsolute = !1;
    var code = path.charCodeAt(0);
    if (len === 1) {
      return code === 47 ? "\\" : path;
    }
    if (isPathSeparator(code)) {
      if (isAbsolute = !0, isPathSeparator(path.charCodeAt(1))) {
        let last = code = 2;
        for (; code < len && !isPathSeparator(path.charCodeAt(code));) {
          code++;
        }
        if (code < len && code !== last) {
          const firstPart = path.slice(last, code);
          for (last = code; code < len && isPathSeparator(path.charCodeAt(code));) {
            code++;
          }
          if (code < len && code !== last) {
            for (last = code; code < len && !isPathSeparator(path.charCodeAt(code));) {
              code++;
            }
            if (code === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }
            code !== last && (device = `\\\\${firstPart}\\${path.slice(last, code)}`, rootEnd = code);
          }
        }
      } else {
        rootEnd = 1;
      }
    } else {
      isWindowsDeviceRoot(code) && path.charCodeAt(1) === 58 && (device = path.slice(0, 2), rootEnd = 2, len > 2 && isPathSeparator(path.charCodeAt(2)) && (isAbsolute = !0, rootEnd = 3));
    }
    rootEnd = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
    rootEnd.length !== 0 || isAbsolute || (rootEnd = ".");
    rootEnd.length > 0 && isPathSeparator(path.charCodeAt(len - 1)) && (rootEnd += "\\");
    return device === void 0 ? isAbsolute ? `\\${rootEnd}` : rootEnd : isAbsolute ? `${device}\\${rootEnd}` : `${device}${rootEnd}`;
  }, isAbsolute(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return !1;
    }
    const code = path.charCodeAt(0);
    return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === 58 && isPathSeparator(path.charCodeAt(2));
  }, join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined, firstPart;
    for (var i = 0; i < paths.length; ++i) {
      var arg = paths[i];
      validateString(arg, "path");
      arg.length > 0 && (joined = joined === void 0 ? firstPart = arg : joined + `\\${arg}`);
    }
    if (joined === void 0) {
      return ".";
    }
    paths = !0;
    i = 0;
    typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0)) && (++i, arg = firstPart.length, arg > 1 && isPathSeparator(firstPart.charCodeAt(1)) && (++i, arg > 2 && (isPathSeparator(firstPart.charCodeAt(2)) ? ++i : paths = !1)));
    if (paths) {
      for (; i < joined.length && isPathSeparator(joined.charCodeAt(i));) {
        i++;
      }
      i >= 2 && (joined = `\\${joined.slice(i)}`);
    }
    return win32.normalize(joined);
  }, relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = win32.resolve(from);
    const toOrig = win32.resolve(to);
    if (from === toOrig) {
      return "";
    }
    from = from.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) {
      return "";
    }
    let fromStart = 0;
    for (; fromStart < from.length && from.charCodeAt(fromStart) === 92;) {
      fromStart++;
    }
    let fromEnd = from.length;
    for (; fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === 92;) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    for (; toStart < to.length && to.charCodeAt(toStart) === 92;) {
      toStart++;
    }
    let toEnd = to.length;
    for (; toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === 92;) {
      toEnd--;
    }
    const toLen = toEnd - toStart, length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1, i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else {
        fromCode === 92 && (lastCommonSep = i);
      }
    }
    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 92) {
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      fromLen > length && (from.charCodeAt(fromStart + i) === 92 ? lastCommonSep = i : i === 2 && (lastCommonSep = 3));
      lastCommonSep === -1 && (lastCommonSep = 0);
    }
    to = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 92) {
        to += to.length === 0 ? ".." : "\\..";
      }
    }
    toStart += lastCommonSep;
    if (to.length > 0) {
      return `${to}${toOrig.slice(toStart, toEnd)}`;
    }
    toOrig.charCodeAt(toStart) === 92 && ++toStart;
    return toOrig.slice(toStart, toEnd);
  }, toNamespacedPath(path) {
    if (typeof path !== "string" || path.length === 0) {
      return path;
    }
    const resolvedPath = win32.resolve(path);
    if (resolvedPath.length <= 2) {
      return path;
    }
    if (resolvedPath.charCodeAt(0) === 92) {
      if (resolvedPath.charCodeAt(1) === 92) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== 63 && code !== 46) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
      return `\\\\?\\${resolvedPath}`;
    }
    return path;
  }, dirname(path) {
    validateString(path, "path");
    var len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = -1, offset = 0;
    var code = path.charCodeAt(0);
    if (len === 1) {
      return isPathSeparator(code) ? path : ".";
    }
    if (isPathSeparator(code)) {
      if (rootEnd = offset = 1, isPathSeparator(path.charCodeAt(1))) {
        for (var last = code = 2; code < len && !isPathSeparator(path.charCodeAt(code));) {
          code++;
        }
        if (code < len && code !== last) {
          for (last = code; code < len && isPathSeparator(path.charCodeAt(code));) {
            code++;
          }
          if (code < len && code !== last) {
            for (last = code; code < len && !isPathSeparator(path.charCodeAt(code));) {
              code++;
            }
            if (code === len) {
              return path;
            }
            code !== last && (rootEnd = offset = code + 1);
          }
        }
      }
    } else {
      isWindowsDeviceRoot(code) && path.charCodeAt(1) === 58 && (offset = rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2);
    }
    code = -1;
    last = !0;
    for (--len; len >= offset; --len) {
      if (isPathSeparator(path.charCodeAt(len))) {
        if (!last) {
          code = len;
          break;
        }
      } else {
        last = !1;
      }
    }
    if (code === -1) {
      if (rootEnd === -1) {
        return ".";
      }
      code = rootEnd;
    }
    return path.slice(0, code);
  }, basename(path, ext) {
    ext !== void 0 && validateString(ext, "ext");
    validateString(path, "path");
    let start = 0, end = -1, matchedSlash = !0, i;
    path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === 58 && (start = 2);
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return "";
      }
      let extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          firstNonSlashEnd === -1 && (matchedSlash = !1, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i) : (extIdx = -1, end = firstNonSlashEnd));
        }
      }
      start === end ? end = firstNonSlashEnd : end === -1 && (end = path.length);
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        end === -1 && (matchedSlash = !1, end = i + 1);
      }
    }
    return end === -1 ? "" : path.slice(start, end);
  }, extname(path) {
    validateString(path, "path");
    let start = 0, startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0;
    path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0)) && (start = startPart = 2);
    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
      } else {
        end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
      }
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path.slice(startDot, end);
  }, format:_format.bind(null, "\\"), parse(path) {
    validateString(path, "path");
    const ret = {root:"", dir:"", base:"", ext:"", name:""};
    if (path.length === 0) {
      return ret;
    }
    var len = path.length;
    let rootEnd = 0;
    var code = path.charCodeAt(0);
    if (len === 1) {
      if (isPathSeparator(code)) {
        return ret.root = ret.dir = path, ret;
      }
      ret.base = ret.name = path;
      return ret;
    }
    if (isPathSeparator(code)) {
      if (rootEnd = 1, isPathSeparator(path.charCodeAt(1))) {
        for (var last = code = 2; code < len && !isPathSeparator(path.charCodeAt(code));) {
          code++;
        }
        if (code < len && code !== last) {
          for (last = code; code < len && isPathSeparator(path.charCodeAt(code));) {
            code++;
          }
          if (code < len && code !== last) {
            for (last = code; code < len && !isPathSeparator(path.charCodeAt(code));) {
              code++;
            }
            code === len ? rootEnd = code : code !== last && (rootEnd = code + 1);
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === 58) {
      if (len <= 2) {
        return ret.root = ret.dir = path, ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          return ret.root = ret.dir = path, ret;
        }
        rootEnd = 3;
      }
    }
    rootEnd > 0 && (ret.root = path.slice(0, rootEnd));
    len = -1;
    last = rootEnd;
    let end = -1, matchedSlash = !0, i = path.length - 1, preDotState = 0;
    for (; i >= rootEnd; --i) {
      if (code = path.charCodeAt(i), isPathSeparator(code)) {
        if (!matchedSlash) {
          last = i + 1;
          break;
        }
      } else {
        end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? len === -1 ? len = i : preDotState !== 1 && (preDotState = 1) : len !== -1 && (preDotState = -1);
      }
    }
    end !== -1 && (len === -1 || preDotState === 0 || preDotState === 1 && len === end - 1 && len === last + 1 ? ret.base = ret.name = path.slice(last, end) : (ret.name = path.slice(last, len), ret.base = path.slice(last, end), ret.ext = path.slice(len, end)));
    ret.dir = last > 0 && last !== rootEnd ? path.slice(0, last - 1) : ret.root;
    return ret;
  }, sep:"\\", delimiter:";", win32:null, posix:null}, posixCwd = (() => {
    if (platformIsWin32) {
      const regexp = /\\/g;
      return () => {
        const cwd = process.cwd().replace(regexp, "/");
        return cwd.slice(cwd.indexOf("/"));
      };
    }
    return () => process.cwd();
  })(), posix = {resolve(...pathSegments) {
    let resolvedPath = "", resolvedAbsolute = !1;
    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      const path = i >= 0 ? pathSegments[i] : posixCwd();
      validateString(path, "path");
      path.length !== 0 && (resolvedPath = `${path}/${resolvedPath}`, resolvedAbsolute = path.charCodeAt(0) === 47);
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    return resolvedAbsolute ? `/${resolvedPath}` : resolvedPath.length > 0 ? resolvedPath : ".";
  }, normalize(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const isAbsolute = path.charCodeAt(0) === 47, trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0) {
      return isAbsolute ? "/" : trailingSeparator ? "./" : ".";
    }
    trailingSeparator && (path += "/");
    return isAbsolute ? `/${path}` : path;
  }, isAbsolute(path) {
    validateString(path, "path");
    return path.length > 0 && path.charCodeAt(0) === 47;
  }, join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      arg.length > 0 && (joined = joined === void 0 ? arg : joined + `/${arg}`);
    }
    return joined === void 0 ? "." : posix.normalize(joined);
  }, relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) {
      return "";
    }
    const fromEnd = from.length;
    var fromLen = fromEnd - 1;
    const toLen = to.length - 1, length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1, i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(1 + i);
      if (fromCode !== to.charCodeAt(1 + i)) {
        break;
      } else {
        fromCode === 47 && (lastCommonSep = i);
      }
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(1 + i) === 47) {
          return to.slice(1 + i + 1);
        }
        if (i === 0) {
          return to.slice(1 + i);
        }
      } else {
        fromLen > length && (from.charCodeAt(1 + i) === 47 ? lastCommonSep = i : i === 0 && (lastCommonSep = 0));
      }
    }
    fromLen = "";
    for (i = 1 + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        fromLen += fromLen.length === 0 ? ".." : "/..";
      }
    }
    return `${fromLen}${to.slice(1 + lastCommonSep)}`;
  }, toNamespacedPath(path) {
    return path;
  }, dirname(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1, matchedSlash = !0;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = !1;
      }
    }
    return end === -1 ? hasRoot ? "/" : "." : hasRoot && end === 1 ? "//" : path.slice(0, end);
  }, basename(path, ext) {
    ext !== void 0 && validateString(ext, "ext");
    validateString(path, "path");
    let start = 0, end = -1, matchedSlash = !0, i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return "";
      }
      let extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          firstNonSlashEnd === -1 && (matchedSlash = !1, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i) : (extIdx = -1, end = firstNonSlashEnd));
        }
      }
      start === end ? end = firstNonSlashEnd : end === -1 && (end = path.length);
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        end === -1 && (matchedSlash = !1, end = i + 1);
      }
    }
    return end === -1 ? "" : path.slice(start, end);
  }, extname(path) {
    validateString(path, "path");
    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
      } else {
        end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
      }
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path.slice(startDot, end);
  }, format:_format.bind(null, "/"), parse(path) {
    validateString(path, "path");
    const ret = {root:"", dir:"", base:"", ext:"", name:""};
    if (path.length === 0) {
      return ret;
    }
    const isAbsolute = path.charCodeAt(0) === 47;
    if (isAbsolute) {
      ret.root = "/";
      var start = 1;
    } else {
      start = 0;
    }
    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, i = path.length - 1, preDotState = 0;
    for (; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
      } else {
        end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
      }
    }
    end !== -1 && (start = startPart === 0 && isAbsolute ? 1 : startPart, startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? ret.base = ret.name = path.slice(start, end) : (ret.name = path.slice(start, startDot), ret.base = path.slice(start, end), ret.ext = path.slice(startDot, end)));
    startPart > 0 ? ret.dir = path.slice(0, startPart - 1) : isAbsolute && (ret.dir = "/");
    return ret;
  }, sep:"/", delimiter:":", win32:null, posix:null};
  posix.win32 = win32.win32 = win32;
  posix.posix = win32.posix = posix;
  const normalize = platformIsWin32 ? win32.normalize : posix.normalize, resolve = platformIsWin32 ? win32.resolve : posix.resolve, relative = platformIsWin32 ? win32.relative : posix.relative, dirname = platformIsWin32 ? win32.dirname : posix.dirname, basename = platformIsWin32 ? win32.basename : posix.basename, extname = platformIsWin32 ? win32.extname : posix.extname, sep = platformIsWin32 ? win32.sep : posix.sep;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$path.js.map
