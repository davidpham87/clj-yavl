shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$autorun = function(require, module, exports) {
  function autorun(fn) {
    return new AutorunObserver(void 0, fn, void 0, void 0);
  }
  function autorunOpts(options, fn) {
    return new AutorunObserver(options.debugName, fn, void 0, void 0);
  }
  function autorunHandleChanges(options, fn) {
    return new AutorunObserver(options.debugName, fn, options.createEmptyChangeSummary, options.handleChange);
  }
  function autorunWithStore(fn) {
    const store = new require$_DOT__DOT__SLASH_lifecycle_DOT_js.DisposableStore(), disposable = autorunOpts({debugName:() => (0,require$_DOT__SLASH_base_DOT_js.getFunctionName)(fn) || "(anonymous)"}, reader => {
      store.clear();
      fn(reader, store);
    });
    return (0,require$_DOT__DOT__SLASH_lifecycle_DOT_js.toDisposable)(() => {
      disposable.dispose();
      store.dispose();
    });
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AutorunObserver:{enumerable:!0, get:function() {
    return AutorunObserver;
  }}, autorun:{enumerable:!0, get:function() {
    return autorun;
  }}, autorunHandleChanges:{enumerable:!0, get:function() {
    return autorunHandleChanges;
  }}, autorunOpts:{enumerable:!0, get:function() {
    return autorunOpts;
  }}, autorunWithStore:{enumerable:!0, get:function() {
    return autorunWithStore;
  }}});
  var require$_DOT__DOT__SLASH_assert_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$assert"), require$_DOT__DOT__SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__SLASH_base_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$base"), require$_DOT__SLASH_logging_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$logging");
  class AutorunObserver {
    get debugName() {
      if (typeof this._debugName === "string") {
        return this._debugName;
      }
      if (typeof this._debugName === "function") {
        var name = this._debugName();
        if (name !== void 0) {
          return name;
        }
      }
      name = (0,require$_DOT__SLASH_base_DOT_js.getFunctionName)(this._runFn);
      return name !== void 0 ? name : "(anonymous)";
    }
    constructor(_debugName, _runFn, createChangeSummary, _handleChange) {
      var _a, _b;
      this._debugName = _debugName;
      this._runFn = _runFn;
      this.createChangeSummary = createChangeSummary;
      this._handleChange = _handleChange;
      this.state = 2;
      this.updateCount = 0;
      this.disposed = !1;
      this.dependencies = new Set();
      this.dependenciesToBeRemoved = new Set();
      this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _b === void 0 || _b.handleAutorunCreated(this);
      this._runIfNeeded();
      (0,require$_DOT__DOT__SLASH_lifecycle_DOT_js.trackDisposable)(this);
    }
    dispose() {
      this.disposed = !0;
      for (const o of this.dependencies) {
        o.removeObserver(this);
      }
      this.dependencies.clear();
      (0,require$_DOT__DOT__SLASH_lifecycle_DOT_js.markAsDisposed)(this);
    }
    _runIfNeeded() {
      var _a, _b, _c;
      if (this.state !== 3) {
        var emptySet = this.dependenciesToBeRemoved;
        this.dependenciesToBeRemoved = this.dependencies;
        this.dependencies = emptySet;
        this.state = 3;
        emptySet = this.disposed;
        try {
          if (!emptySet) {
            (_a = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _a === void 0 || _a.handleAutorunTriggered(this);
            const changeSummary = this.changeSummary;
            this.changeSummary = (_b = this.createChangeSummary) === null || _b === void 0 ? void 0 : _b.call(this);
            this._runFn(this, changeSummary);
          }
        } finally {
          emptySet || (_c = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _c === void 0 || _c.handleAutorunFinished(this);
          for (const o of this.dependenciesToBeRemoved) {
            o.removeObserver(this);
          }
          this.dependenciesToBeRemoved.clear();
        }
      }
    }
    toString() {
      return `Autorun<${this.debugName}>`;
    }
    beginUpdate() {
      this.state === 3 && (this.state = 1);
      this.updateCount++;
    }
    endUpdate() {
      if (this.updateCount === 1) {
        do {
          if (this.state === 1) {
            this.state = 3;
            for (const d of this.dependencies) {
              if (d.reportChanges(), this.state === 2) {
                break;
              }
            }
          }
          this._runIfNeeded();
        } while (this.state !== 3);
      }
      this.updateCount--;
      (0,require$_DOT__DOT__SLASH_assert_DOT_js.assertFn)(() => this.updateCount >= 0);
    }
    handlePossibleChange(observable) {
      this.state === 3 && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable) && (this.state = 1);
    }
    handleChange(observable, change) {
      this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable) && (this._handleChange ? this._handleChange({changedObservable:observable, change, didChange:o => o === observable}, this.changeSummary) : 1) && (this.state = 2);
    }
    readObservable(observable) {
      if (this.disposed) {
        return observable.get();
      }
      observable.addObserver(this);
      const value = observable.get();
      this.dependencies.add(observable);
      this.dependenciesToBeRemoved.delete(observable);
      return value;
    }
  }
  (function(autorun) {
    autorun.Observer = AutorunObserver;
  })(autorun ||= {});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$autorun.js.map
