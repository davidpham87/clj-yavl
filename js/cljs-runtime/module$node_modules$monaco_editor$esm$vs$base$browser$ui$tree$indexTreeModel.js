shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$indexTreeModel = function(require, module, exports) {
  function isFilterResult(obj) {
    return typeof obj === "object" && "visibility" in obj && "data" in obj;
  }
  function getVisibleState(visibility) {
    switch(visibility) {
      case !0:
        return 1;
      case !1:
        return 0;
      default:
        return visibility;
    }
  }
  function isCollapsibleStateUpdate(update) {
    return typeof update.collapsible === "boolean";
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, IndexTreeModel:{enumerable:!0, get:function() {
    return IndexTreeModel;
  }}, getVisibleState:{enumerable:!0, get:function() {
    return getVisibleState;
  }}, isFilterResult:{enumerable:!0, get:function() {
    return isFilterResult;
  }}});
  var require$_DOT__SLASH_tree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$tree"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_symbols_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$symbols"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_diff_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$diff$diff"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator");
  class IndexTreeModel {
    constructor(user, list, rootElement, options = {}) {
      this.user = user;
      this.list = list;
      this.rootRef = [];
      this.eventBufferer = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.EventBufferer();
      this._onDidChangeCollapseState = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);
      this._onDidChangeRenderNodeCount = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);
      this._onDidSplice = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidSplice = this._onDidSplice.event;
      this.refilterDelayer = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.Delayer(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_symbols_DOT_js.MicrotaskDelay);
      this.collapseByDefault = typeof options.collapseByDefault === "undefined" ? !1 : options.collapseByDefault;
      this.filter = options.filter;
      this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === "undefined" ? !1 : options.autoExpandSingleChildren;
      this.root = {parent:void 0, element:rootElement, children:[], depth:0, visibleChildrenCount:0, visibleChildIndex:-1, collapsible:!1, collapsed:!1, renderNodeCount:0, visibility:1, visible:!0, filterData:void 0};
    }
    splice(location, deleteCount, toInsert = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), options = {}) {
      if (location.length === 0) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Invalid tree location");
      }
      options.diffIdentityProvider ? this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options) : this.spliceSimple(location, deleteCount, toInsert, options);
    }
    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {
      var _a;
      toInsertIterable === void 0 && (toInsertIterable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty());
      recurseLevels === void 0 && (recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0);
      const {parentNode} = this.getParentNodeWithListIndex(location);
      if (!parentNode.lastDiffIds) {
        return this.spliceSimple(location, deleteCount, toInsertIterable, options);
      }
      const toInsert = [...toInsertIterable], index = location[location.length - 1];
      toInsertIterable = (new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_diff_SLASH_diff_DOT_js.LcsDiff({getElements:() => parentNode.lastDiffIds}, {getElements:() => [...parentNode.children.slice(0, index), ...toInsert, ...parentNode.children.slice(index + deleteCount)].map(e => identity.getId(e.element).toString())})).ComputeDiff(!1);
      if (toInsertIterable.quitEarly) {
        return parentNode.lastDiffIds = void 0, this.spliceSimple(location, deleteCount, toInsert, options);
      }
      const locationPrefix = location.slice(0, -1);
      location = (fromOriginal, fromModified, count) => {
        if (recurseLevels > 0) {
          for (let i = 0; i < count; i++) {
            fromOriginal--, fromModified--, this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);
          }
        }
      };
      _a = Math.min(parentNode.children.length, index + deleteCount);
      let lastStartM = toInsert.length;
      for (const change of toInsertIterable.changes.sort((a, b) => b.originalStart - a.originalStart)) {
        location(_a, lastStartM, _a - (change.originalStart + change.originalLength)), _a = change.originalStart, lastStartM = change.modifiedStart - index, this.spliceSimple([...locationPrefix, _a], change.originalLength, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);
      }
      location(_a, lastStartM, _a);
    }
    spliceSimple(location, deleteCount, toInsert = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), {onDidCreateNode, onDidDeleteNode, diffIdentityProvider}) {
      const {parentNode, listIndex, revealed, visible} = this.getParentNodeWithListIndex(location), treeListElementsToInsert = [], nodesToInsertIterator = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 : 0, revealed, treeListElementsToInsert, onDidCreateNode));
      var lastIndex = location[location.length - 1];
      toInsert = parentNode.children.length > 0;
      let visibleChildStartIndex = 0;
      for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {
        var child = parentNode.children[i];
        if (child.visible) {
          visibleChildStartIndex = child.visibleChildIndex;
          break;
        }
      }
      i = [];
      let insertedVisibleChildrenCount = 0;
      child = 0;
      for (var child$jscomp$0 of nodesToInsertIterator) {
        i.push(child$jscomp$0), child += child$jscomp$0.renderNodeCount, child$jscomp$0.visible && (child$jscomp$0.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++);
      }
      child$jscomp$0 = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.splice)(parentNode.children, lastIndex, deleteCount, i);
      diffIdentityProvider ? parentNode.lastDiffIds ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.splice)(parentNode.lastDiffIds, lastIndex, deleteCount, i.map(n => diffIdentityProvider.getId(n.element).toString())) : parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString()) : parentNode.lastDiffIds = void 0;
      deleteCount = 0;
      for (var child$jscomp$1 of child$jscomp$0) {
        child$jscomp$1.visible && deleteCount++;
      }
      if (deleteCount !== 0) {
        for (child$jscomp$1 = lastIndex + i.length; child$jscomp$1 < parentNode.children.length; child$jscomp$1++) {
          lastIndex = parentNode.children[child$jscomp$1], lastIndex.visible && (lastIndex.visibleChildIndex -= deleteCount);
        }
      }
      parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deleteCount;
      revealed && visible && (child$jscomp$1 = child$jscomp$0.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0), this._updateAncestorsRenderNodeCount(parentNode, child - child$jscomp$1), this.list.splice(listIndex, child$jscomp$1, treeListElementsToInsert));
      if (child$jscomp$0.length > 0 && onDidDeleteNode) {
        const visit = node => {
          onDidDeleteNode(node);
          node.children.forEach(visit);
        };
        child$jscomp$0.forEach(visit);
      }
      this._onDidSplice.fire({insertedNodes:i, deletedNodes:child$jscomp$0});
      i = parentNode.children.length > 0;
      toInsert !== i && this.setCollapsible(location.slice(0, -1), i);
      for (location = parentNode; location;) {
        if (location.visibility === 2) {
          this.refilterDelayer.trigger(() => this.refilter());
          break;
        }
        location = location.parent;
      }
    }
    rerender(location) {
      if (location.length === 0) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Invalid tree location");
      }
      const {node, listIndex, revealed} = this.getTreeNodeWithListIndex(location);
      node.visible && revealed && this.list.splice(listIndex, 1, [node]);
    }
    has(location) {
      return this.hasTreeNode(location);
    }
    getListIndex(location) {
      const {listIndex, visible, revealed} = this.getTreeNodeWithListIndex(location);
      return visible && revealed ? listIndex : -1;
    }
    getListRenderCount(location) {
      return this.getTreeNode(location).renderNodeCount;
    }
    isCollapsible(location) {
      return this.getTreeNode(location).collapsible;
    }
    setCollapsible(location, collapsible) {
      const node = this.getTreeNode(location);
      typeof collapsible === "undefined" && (collapsible = !node.collapsible);
      const update = {collapsible};
      return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
    }
    isCollapsed(location) {
      return this.getTreeNode(location).collapsed;
    }
    setCollapsed(location, collapsed, recursive) {
      const node = this.getTreeNode(location);
      typeof collapsed === "undefined" && (collapsed = !node.collapsed);
      const update = {collapsed, recursive:recursive || !1};
      return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
    }
    _setCollapseState(location, update) {
      const {node, listIndex, revealed} = this.getTreeNodeWithListIndex(location), result = this._setListNodeCollapseState(node, listIndex, revealed, update);
      if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {
        let onlyVisibleChildIndex = -1;
        for (let i = 0; i < node.children.length; i++) {
          if (node.children[i].visible) {
            if (onlyVisibleChildIndex > -1) {
              onlyVisibleChildIndex = -1;
              break;
            } else {
              onlyVisibleChildIndex = i;
            }
          }
        }
        onlyVisibleChildIndex > -1 && this._setCollapseState([...location, onlyVisibleChildIndex], update);
      }
      return result;
    }
    _setListNodeCollapseState(node, listIndex, revealed, update) {
      update = this._setNodeCollapseState(node, update, !1);
      if (!revealed || !node.visible || !update) {
        return update;
      }
      revealed = node.renderNodeCount;
      node = this.updateNodeAfterCollapseChange(node);
      this.list.splice(listIndex + 1, revealed - (listIndex === -1 ? 0 : 1), node.slice(1));
      return update;
    }
    _setNodeCollapseState(node, update, deep) {
      let result;
      node === this.root ? result = !1 : (isCollapsibleStateUpdate(update) ? (result = node.collapsible !== update.collapsible, node.collapsible = update.collapsible) : node.collapsible ? (result = node.collapsed !== update.collapsed, node.collapsed = update.collapsed) : result = !1, result && this._onDidChangeCollapseState.fire({node, deep}));
      if (!isCollapsibleStateUpdate(update) && update.recursive) {
        for (const child of node.children) {
          result = this._setNodeCollapseState(child, update, !0) || result;
        }
      }
      return result;
    }
    expandTo(location) {
      this.eventBufferer.bufferEvents(() => {
        let node = this.getTreeNode(location);
        for (; node.parent;) {
          node = node.parent, location = location.slice(0, location.length - 1), node.collapsed && this._setCollapseState(location, {collapsed:!1, recursive:!1});
        }
      });
    }
    refilter() {
      const previousRenderNodeCount = this.root.renderNodeCount, toInsert = this.updateNodeAfterFilterChange(this.root);
      this.list.splice(0, previousRenderNodeCount, toInsert);
      this.refilterDelayer.cancel();
    }
    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {
      parent = {parent, element:treeElement.element, children:[], depth:parent.depth + 1, visibleChildrenCount:0, visibleChildIndex:-1, collapsible:typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : typeof treeElement.collapsed !== "undefined", collapsed:typeof treeElement.collapsed === "undefined" ? this.collapseByDefault : treeElement.collapsed, renderNodeCount:1, visibility:1, visible:!0, filterData:void 0};
      parentVisibility = this._filterNode(parent, parentVisibility);
      parent.visibility = parentVisibility;
      revealed && treeListElements.push(parent);
      var childElements = treeElement.children || require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty();
      treeElement = revealed && parentVisibility !== 0 && !parent.collapsed;
      let visibleChildrenCount = 0, renderNodeCount = 1;
      for (const el of childElements) {
        childElements = this.createTreeNode(el, parent, parentVisibility, treeElement, treeListElements, onDidCreateNode), parent.children.push(childElements), renderNodeCount += childElements.renderNodeCount, childElements.visible && (childElements.visibleChildIndex = visibleChildrenCount++);
      }
      parent.collapsible = parent.collapsible || parent.children.length > 0;
      parent.visibleChildrenCount = visibleChildrenCount;
      parent.visible = parentVisibility === 2 ? visibleChildrenCount > 0 : parentVisibility === 1;
      parent.visible ? parent.collapsed || (parent.renderNodeCount = renderNodeCount) : (parent.renderNodeCount = 0, revealed && treeListElements.pop());
      onDidCreateNode === null || onDidCreateNode === void 0 || onDidCreateNode(parent);
      return parent;
    }
    updateNodeAfterCollapseChange(node) {
      const previousRenderNodeCount = node.renderNodeCount, result = [];
      this._updateNodeAfterCollapseChange(node, result);
      this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
      return result;
    }
    _updateNodeAfterCollapseChange(node, result) {
      if (node.visible === !1) {
        return 0;
      }
      result.push(node);
      node.renderNodeCount = 1;
      if (!node.collapsed) {
        for (const child of node.children) {
          node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);
        }
      }
      this._onDidChangeRenderNodeCount.fire(node);
      return node.renderNodeCount;
    }
    updateNodeAfterFilterChange(node) {
      const previousRenderNodeCount = node.renderNodeCount, result = [];
      this._updateNodeAfterFilterChange(node, node.visible ? 1 : 0, result);
      this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
      return result;
    }
    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = !0) {
      let visibility;
      if (node !== this.root) {
        visibility = this._filterNode(node, parentVisibility);
        if (visibility === 0) {
          return node.visible = !1, node.renderNodeCount = 0, !1;
        }
        revealed && result.push(node);
      }
      parentVisibility = result.length;
      node.renderNodeCount = node === this.root ? 0 : 1;
      let hasVisibleDescendants = !1;
      if (node.collapsed && visibility === 0) {
        node.visibleChildrenCount = 0;
      } else {
        let visibleChildIndex = 0;
        for (const child of node.children) {
          hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants, child.visible && (child.visibleChildIndex = visibleChildIndex++);
        }
        node.visibleChildrenCount = visibleChildIndex;
      }
      node !== this.root && (node.visible = visibility === 2 ? hasVisibleDescendants : visibility === 1, node.visibility = visibility);
      node.visible ? node.collapsed || (node.renderNodeCount += result.length - parentVisibility) : (node.renderNodeCount = 0, revealed && result.pop());
      this._onDidChangeRenderNodeCount.fire(node);
      return node.visible;
    }
    _updateAncestorsRenderNodeCount(node, diff) {
      if (diff !== 0) {
        for (; node;) {
          node.renderNodeCount += diff, this._onDidChangeRenderNodeCount.fire(node), node = node.parent;
        }
      }
    }
    _filterNode(node, parentVisibility) {
      parentVisibility = this.filter ? this.filter.filter(node.element, parentVisibility) : 1;
      if (typeof parentVisibility === "boolean") {
        return node.filterData = void 0, parentVisibility ? 1 : 0;
      }
      if (isFilterResult(parentVisibility)) {
        return node.filterData = parentVisibility.data, getVisibleState(parentVisibility.visibility);
      }
      node.filterData = void 0;
      return getVisibleState(parentVisibility);
    }
    hasTreeNode(location, node = this.root) {
      if (!location || location.length === 0) {
        return !0;
      }
      const [index, ...rest] = location;
      return index < 0 || index > node.children.length ? !1 : this.hasTreeNode(rest, node.children[index]);
    }
    getTreeNode(location, node = this.root) {
      if (!location || location.length === 0) {
        return node;
      }
      const [index, ...rest] = location;
      if (index < 0 || index > node.children.length) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Invalid tree location");
      }
      return this.getTreeNode(rest, node.children[index]);
    }
    getTreeNodeWithListIndex(location) {
      if (location.length === 0) {
        return {node:this.root, listIndex:-1, revealed:!0, visible:!1};
      }
      const {parentNode, listIndex, revealed, visible} = this.getParentNodeWithListIndex(location);
      location = location[location.length - 1];
      if (location < 0 || location > parentNode.children.length) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Invalid tree location");
      }
      location = parentNode.children[location];
      return {node:location, listIndex, revealed, visible:visible && location.visible};
    }
    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = !0, visible = !0) {
      const [index, ...rest] = location;
      if (index < 0 || index > node.children.length) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Invalid tree location");
      }
      for (location = 0; location < index; location++) {
        listIndex += node.children[location].renderNodeCount;
      }
      revealed = revealed && !node.collapsed;
      visible = visible && node.visible;
      return rest.length === 0 ? {parentNode:node, listIndex, revealed, visible} : this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);
    }
    getNode(location = []) {
      return this.getTreeNode(location);
    }
    getNodeLocation(node) {
      const location = [];
      for (; node.parent;) {
        location.push(node.parent.children.indexOf(node)), node = node.parent;
      }
      return location.reverse();
    }
    getParentNodeLocation(location) {
      if (location.length !== 0) {
        return location.length === 1 ? [] : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.tail2)(location)[0];
      }
    }
    getFirstElementChild(location) {
      location = this.getTreeNode(location);
      if (location.children.length !== 0) {
        return location.children[0].element;
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$indexTreeModel.js.map
