shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$event = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DebounceEmitter:{enumerable:!0, get:function() {
    return DebounceEmitter;
  }}, Emitter:{enumerable:!0, get:function() {
    return Emitter;
  }}, Event:{enumerable:!0, get:function() {
    return Event;
  }}, EventBufferer:{enumerable:!0, get:function() {
    return EventBufferer;
  }}, EventMultiplexer:{enumerable:!0, get:function() {
    return EventMultiplexer;
  }}, EventProfiling:{enumerable:!0, get:function() {
    return EventProfiling;
  }}, MicrotaskEmitter:{enumerable:!0, get:function() {
    return MicrotaskEmitter;
  }}, PauseableEmitter:{enumerable:!0, get:function() {
    return PauseableEmitter;
  }}, Relay:{enumerable:!0, get:function() {
    return Relay;
  }}, createEventDeliveryQueue:{enumerable:!0, get:function() {
    return createEventDeliveryQueue;
  }}});
  var require$_DOT__SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__SLASH_functional_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$functional"), require$_DOT__SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__SLASH_linkedList_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$linkedList"), require$_DOT__SLASH_stopwatch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$stopwatch"), 
  Event;
  (function(Event) {
    function once(event) {
      return (listener, thisArgs = null, disposables) => {
        let didFire = !1, result = void 0;
        result = event(e => {
          if (!didFire) {
            return result ? result.dispose() : didFire = !0, listener.call(thisArgs, e);
          }
        }, null, disposables);
        didFire && result.dispose();
        return result;
      };
    }
    function map(event, map, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);
    }
    function filter(event, filter, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);
    }
    function snapshot(event, disposable) {
      let listener;
      const emitter = new Emitter({onWillAddFirstListener() {
        listener = event(emitter.fire, emitter);
      }, onDidRemoveLastListener() {
        listener === null || listener === void 0 || listener.dispose();
      }});
      disposable === null || disposable === void 0 || disposable.add(emitter);
      return emitter.event;
    }
    function addAndReturnDisposable(d, store) {
      store instanceof Array ? store.push(d) : store && store.add(d);
      return d;
    }
    function debounce(event, merge, delay = 100, leading = !1, flushOnListenerRemove = !1, leakWarningThreshold, disposable) {
      let subscription, output = void 0, handle = void 0, numDebouncedCalls = 0, doFire;
      const emitter = new Emitter({leakWarningThreshold, onWillAddFirstListener() {
        subscription = event(cur => {
          numDebouncedCalls++;
          output = merge(output, cur);
          leading && !handle && (emitter.fire(output), output = void 0);
          doFire = () => {
            const _output = output;
            handle = output = void 0;
            (!leading || numDebouncedCalls > 1) && emitter.fire(_output);
            numDebouncedCalls = 0;
          };
          typeof delay === "number" ? (clearTimeout(handle), handle = setTimeout(doFire, delay)) : handle === void 0 && (handle = 0, queueMicrotask(doFire));
        });
      }, onWillRemoveListener() {
        flushOnListenerRemove && numDebouncedCalls > 0 && (doFire === null || doFire === void 0 || doFire());
      }, onDidRemoveLastListener() {
        doFire = void 0;
        subscription.dispose();
      }});
      disposable === null || disposable === void 0 || disposable.add(emitter);
      return emitter.event;
    }
    Event.None = () => require$_DOT__SLASH_lifecycle_DOT_js.Disposable.None;
    Event.defer = function(event, disposable) {
      return debounce(event, () => {
      }, 0, void 0, !0, void 0, disposable);
    };
    Event.once = once;
    Event.map = map;
    Event.forEach = function(event, each, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event(i => {
        each(i);
        listener.call(thisArgs, i);
      }, null, disposables), disposable);
    };
    Event.filter = filter;
    Event.signal = function(event) {
      return event;
    };
    Event.any = function(...events) {
      return (listener, thisArgs = null, disposables) => {
        const disposable = (0,require$_DOT__SLASH_lifecycle_DOT_js.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e))));
        return addAndReturnDisposable(disposable, disposables);
      };
    };
    Event.reduce = function(event, merge, initial, disposable) {
      let output = initial;
      return map(event, e => output = merge(output, e), disposable);
    };
    Event.debounce = debounce;
    Event.accumulate = function(event, delay = 0, disposable) {
      return Event.debounce(event, (last, e) => {
        if (!last) {
          return [e];
        }
        last.push(e);
        return last;
      }, delay, void 0, !0, void 0, disposable);
    };
    Event.latch = function(event, equals = (a, b) => a === b, disposable) {
      let firstCall = !0, cache;
      return filter(event, value => {
        const shouldEmit = firstCall || !equals(value, cache);
        firstCall = !1;
        cache = value;
        return shouldEmit;
      }, disposable);
    };
    Event.split = function(event, isT, disposable) {
      return [Event.filter(event, isT, disposable), Event.filter(event, e => !isT(e), disposable)];
    };
    Event.buffer = function(event, flushAfterTimeout = !1, _buffer = [], disposable) {
      let buffer = _buffer.slice(), listener = event(e => {
        buffer ? buffer.push(e) : emitter.fire(e);
      });
      disposable && disposable.add(listener);
      const flush = () => {
        buffer === null || buffer === void 0 || buffer.forEach(e => emitter.fire(e));
        buffer = null;
      }, emitter = new Emitter({onWillAddFirstListener() {
        listener || (listener = event(e => emitter.fire(e)), disposable && disposable.add(listener));
      }, onDidAddFirstListener() {
        buffer && (flushAfterTimeout ? setTimeout(flush) : flush());
      }, onDidRemoveLastListener() {
        listener && listener.dispose();
        listener = null;
      }});
      disposable && disposable.add(emitter);
      return emitter.event;
    };
    Event.chain = function(event, sythensize) {
      return (listener, thisArgs, disposables) => {
        const cs = sythensize(new ChainableSynthesis());
        return event(function(value) {
          value = cs.evaluate(value);
          value !== HaltChainable && listener.call(thisArgs, value);
        }, void 0, disposables);
      };
    };
    const HaltChainable = Symbol("HaltChainable");
    class ChainableSynthesis {
      constructor() {
        this.steps = [];
      }
      map(fn) {
        this.steps.push(fn);
        return this;
      }
      forEach(fn) {
        this.steps.push(v => {
          fn(v);
          return v;
        });
        return this;
      }
      filter(fn) {
        this.steps.push(v => fn(v) ? v : HaltChainable);
        return this;
      }
      reduce(merge, initial) {
        let last = initial;
        this.steps.push(v => last = merge(last, v));
        return this;
      }
      latch(equals = (a, b) => a === b) {
        let firstCall = !0, cache;
        this.steps.push(value => {
          const shouldEmit = firstCall || !equals(value, cache);
          firstCall = !1;
          cache = value;
          return shouldEmit ? value : HaltChainable;
        });
        return this;
      }
      evaluate(value) {
        for (const step of this.steps) {
          if (value = step(value), value === HaltChainable) {
            break;
          }
        }
        return value;
      }
    }
    Event.fromNodeEventEmitter = function(emitter, eventName, map = id => id) {
      const fn = (...args) => result.fire(map(...args)), result = new Emitter({onWillAddFirstListener:() => emitter.on(eventName, fn), onDidRemoveLastListener:() => emitter.removeListener(eventName, fn)});
      return result.event;
    };
    Event.fromDOMEventEmitter = function(emitter, eventName, map = id => id) {
      const fn = (...args) => result.fire(map(...args)), result = new Emitter({onWillAddFirstListener:() => emitter.addEventListener(eventName, fn), onDidRemoveLastListener:() => emitter.removeEventListener(eventName, fn)});
      return result.event;
    };
    Event.toPromise = function(event) {
      return new Promise(resolve => once(event)(resolve));
    };
    Event.fromPromise = function(promise) {
      const result = new Emitter();
      promise.then(res => {
        result.fire(res);
      }, () => {
        result.fire(void 0);
      }).finally(() => {
        result.dispose();
      });
      return result.event;
    };
    Event.runAndSubscribe = function(event, handler, initial) {
      handler(initial);
      return event(e => handler(e));
    };
    Event.runAndSubscribeWithStore = function(event, handler) {
      function run(e) {
        store === null || store === void 0 || store.dispose();
        store = new require$_DOT__SLASH_lifecycle_DOT_js.DisposableStore();
        handler(e, store);
      }
      let store = null;
      run(void 0);
      const disposable = event(e => run(e));
      return (0,require$_DOT__SLASH_lifecycle_DOT_js.toDisposable)(() => {
        disposable.dispose();
        store === null || store === void 0 || store.dispose();
      });
    };
    class EmitterObserver {
      constructor(_observable, store) {
        this._observable = _observable;
        this._counter = 0;
        this._hasChanged = !1;
        this.emitter = new Emitter({onWillAddFirstListener:() => {
          _observable.addObserver(this);
        }, onDidRemoveLastListener:() => {
          _observable.removeObserver(this);
        }});
        store && store.add(this.emitter);
      }
      beginUpdate(_observable) {
        this._counter++;
      }
      handlePossibleChange(_observable) {
      }
      handleChange(_observable, _change) {
        this._hasChanged = !0;
      }
      endUpdate(_observable) {
        this._counter--;
        this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
      }
    }
    Event.fromObservable = function(obs, store) {
      return (new EmitterObserver(obs, store)).emitter.event;
    };
    Event.fromObservableLight = function(observable) {
      return (listener, thisArgs, disposables) => {
        let count = 0, didChange = !1;
        const observer = {beginUpdate() {
          count++;
        }, endUpdate() {
          count--;
          count === 0 && (observable.reportChanges(), didChange && (didChange = !1, listener.call(thisArgs)));
        }, handlePossibleChange() {
        }, handleChange() {
          didChange = !0;
        }};
        observable.addObserver(observer);
        observable.reportChanges();
        const disposable = {dispose() {
          observable.removeObserver(observer);
        }};
        disposables instanceof require$_DOT__SLASH_lifecycle_DOT_js.DisposableStore ? disposables.add(disposable) : Array.isArray(disposables) && disposables.push(disposable);
        return disposable;
      };
    };
  })(Event ||= {});
  class EventProfiling {
    constructor(name) {
      this.elapsedOverall = this.invocationCount = this.listenerCount = 0;
      this.durations = [];
      this.name = `${name}_${EventProfiling._idPool++}`;
      EventProfiling.all.add(this);
    }
    start(listenerCount) {
      this._stopWatch = new require$_DOT__SLASH_stopwatch_DOT_js.StopWatch();
      this.listenerCount = listenerCount;
    }
    stop() {
      if (this._stopWatch) {
        const elapsed = this._stopWatch.elapsed();
        this.durations.push(elapsed);
        this.elapsedOverall += elapsed;
        this.invocationCount += 1;
        this._stopWatch = void 0;
      }
    }
  }
  EventProfiling.all = new Set();
  EventProfiling._idPool = 0;
  class LeakageMonitor {
    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
      this.threshold = threshold;
      this.name = name;
      this._warnCountdown = 0;
    }
    dispose() {
      var _a;
      (_a = this._stacks) === null || _a === void 0 || _a.clear();
    }
    check(stack, listenerCount) {
      var threshold = this.threshold;
      if (!(threshold <= 0 || listenerCount < threshold)) {
        this._stacks || (this._stacks = new Map());
        var count = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count + 1);
        --this._warnCountdown;
        if (this._warnCountdown <= 0) {
          this._warnCountdown = threshold * 0.5;
          let topStack;
          threshold = 0;
          for (const [stack, count] of this._stacks) {
            if (!topStack || threshold < count) {
              topStack = stack, threshold = count;
            }
          }
          console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${threshold}):`);
          console.warn(topStack);
        }
        return () => {
          const count = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count - 1);
        };
      }
    }
  }
  class Stacktrace {
    static create() {
      var _a;
      return new Stacktrace((_a = Error().stack) !== null && _a !== void 0 ? _a : "");
    }
    constructor(value) {
      this.value = value;
    }
    print() {
      console.warn(this.value.split("\n").slice(2).join("\n"));
    }
  }
  class UniqueContainer {
    constructor(value) {
      this.value = value;
    }
  }
  class Emitter {
    constructor(options) {
      var _a, _b, _c, _d, _e;
      this._size = 0;
      this._options = options;
      this._leakageMon = ((_a = this._options) === null || _a === void 0 ? 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : -1) : void 0;
      this._perfMon = ((_d = this._options) === null || _d === void 0 ? 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
      this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
    }
    dispose() {
      var _a, _b, _c, _d;
      this._disposed || (this._disposed = !0, ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 || _c.call(_b), (_d = this._leakageMon) === null || _d === void 0 || _d.dispose());
    }
    get event() {
      var _a;
      (_a = this._event) !== null && _a !== void 0 ? _a : this._event = (callback, thisArgs, disposables) => {
        var _a, _b, _c, _d, _e;
        if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
          return console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`), require$_DOT__SLASH_lifecycle_DOT_js.Disposable.None;
        }
        if (this._disposed) {
          return require$_DOT__SLASH_lifecycle_DOT_js.Disposable.None;
        }
        thisArgs && (callback = callback.bind(thisArgs));
        const contained = new UniqueContainer(callback);
        let removeMonitor;
        this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (contained.stack = Stacktrace.create(), removeMonitor = this._leakageMon.check(contained.stack, this._size + 1));
        this._listeners ? this._listeners instanceof UniqueContainer ? ((_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate(), this._listeners = [this._listeners, contained]) : this._listeners.push(contained) : ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 || _b.call(_a, this), this._listeners = contained, (_d = (_c = this._options) === null || _c === void 0 ? void 0 : 
        _c.onDidAddFirstListener) === null || _d === void 0 || _d.call(_c, this));
        this._size++;
        callback = (0,require$_DOT__SLASH_lifecycle_DOT_js.toDisposable)(() => {
          removeMonitor === null || removeMonitor === void 0 || removeMonitor();
          this._removeListener(contained);
        });
        disposables instanceof require$_DOT__SLASH_lifecycle_DOT_js.DisposableStore ? disposables.add(callback) : Array.isArray(disposables) && disposables.push(callback);
        return callback;
      };
      return this._event;
    }
    _removeListener(listener) {
      var _a, _b, _c, _d;
      (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 || _b.call(_a, this);
      if (this._listeners) {
        if (this._size === 1) {
          this._listeners = void 0, (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 || _d.call(_c, this), this._size = 0;
        } else {
          _a = this._listeners;
          listener = _a.indexOf(listener);
          if (listener === -1) {
            throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), Error("Attempted to dispose unknown listener");
          }
          this._size--;
          _a[listener] = void 0;
          listener = this._deliveryQueue.current === this;
          if (this._size * 2 <= _a.length) {
            _b = 0;
            for (_c = 0; _c < _a.length; _c++) {
              _a[_c] ? _a[_b++] = _a[_c] : listener && (this._deliveryQueue.end--, _b < this._deliveryQueue.i && this._deliveryQueue.i--);
            }
            _a.length = _b;
          }
        }
      }
    }
    _deliver(listener, value) {
      var _a;
      if (listener) {
        var errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || require$_DOT__SLASH_errors_DOT_js.onUnexpectedError;
        if (errorHandler) {
          try {
            listener.value(value);
          } catch (e) {
            errorHandler(e);
          }
        } else {
          listener.value(value);
        }
      }
    }
    _deliverQueue(dq) {
      const listeners = dq.current._listeners;
      for (; dq.i < dq.end;) {
        this._deliver(listeners[dq.i++], dq.value);
      }
      dq.reset();
    }
    fire(event) {
      var _a, _b, _c, _d;
      if ((_a = this._deliveryQueue) === null || _a === void 0 ? 0 : _a.current) {
        this._deliverQueue(this._deliveryQueue), (_b = this._perfMon) === null || _b === void 0 || _b.stop();
      }
      (_c = this._perfMon) === null || _c === void 0 || _c.start(this._size);
      this._listeners && (this._listeners instanceof UniqueContainer ? this._deliver(this._listeners, event) : (_a = this._deliveryQueue, _a.enqueue(this, event, this._listeners.length), this._deliverQueue(_a)));
      (_d = this._perfMon) === null || _d === void 0 || _d.stop();
    }
    hasListeners() {
      return this._size > 0;
    }
  }
  const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();
  class EventDeliveryQueuePrivate {
    constructor() {
      this.i = -1;
      this.end = 0;
    }
    enqueue(emitter, value, end) {
      this.i = 0;
      this.end = end;
      this.current = emitter;
      this.value = value;
    }
    reset() {
      this.i = this.end;
      this.value = this.current = void 0;
    }
  }
  class PauseableEmitter extends Emitter {
    constructor(options) {
      super(options);
      this._isPaused = 0;
      this._eventQueue = new require$_DOT__SLASH_linkedList_DOT_js.LinkedList();
      this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
    }
    pause() {
      this._isPaused++;
    }
    resume() {
      if (this._isPaused !== 0 && --this._isPaused === 0) {
        if (this._mergeFn) {
          if (this._eventQueue.size > 0) {
            const events = Array.from(this._eventQueue);
            this._eventQueue.clear();
            super.fire(this._mergeFn(events));
          }
        } else {
          for (; !this._isPaused && this._eventQueue.size !== 0;) {
            super.fire(this._eventQueue.shift());
          }
        }
      }
    }
    fire(event) {
      this._size && (this._isPaused !== 0 ? this._eventQueue.push(event) : super.fire(event));
    }
  }
  class DebounceEmitter extends PauseableEmitter {
    constructor(options) {
      var _a;
      super(options);
      this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;
    }
    fire(event) {
      this._handle || (this.pause(), this._handle = setTimeout(() => {
        this._handle = void 0;
        this.resume();
      }, this._delay));
      super.fire(event);
    }
  }
  class MicrotaskEmitter extends Emitter {
    constructor(options) {
      super(options);
      this._queuedEvents = [];
      this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
    }
    fire(event) {
      this.hasListeners() && (this._queuedEvents.push(event), this._queuedEvents.length === 1 && queueMicrotask(() => {
        this._mergeFn ? super.fire(this._mergeFn(this._queuedEvents)) : this._queuedEvents.forEach(e => super.fire(e));
        this._queuedEvents = [];
      }));
    }
  }
  class EventMultiplexer {
    constructor() {
      this.hasListeners = !1;
      this.events = [];
      this.emitter = new Emitter({onWillAddFirstListener:() => this.onFirstListenerAdd(), onDidRemoveLastListener:() => this.onLastListenerRemove()});
    }
    get event() {
      return this.emitter.event;
    }
    add(event) {
      const e = {event, listener:null};
      this.events.push(e);
      this.hasListeners && this.hook(e);
      return (0,require$_DOT__SLASH_lifecycle_DOT_js.toDisposable)((0,require$_DOT__SLASH_functional_DOT_js.createSingleCallFunction)(() => {
        this.hasListeners && this.unhook(e);
        const idx = this.events.indexOf(e);
        this.events.splice(idx, 1);
      }));
    }
    onFirstListenerAdd() {
      this.hasListeners = !0;
      this.events.forEach(e => this.hook(e));
    }
    onLastListenerRemove() {
      this.hasListeners = !1;
      this.events.forEach(e => this.unhook(e));
    }
    hook(e) {
      e.listener = e.event(r => this.emitter.fire(r));
    }
    unhook(e) {
      e.listener && e.listener.dispose();
      e.listener = null;
    }
    dispose() {
      this.emitter.dispose();
    }
  }
  class EventBufferer {
    constructor() {
      this.buffers = [];
    }
    wrapEvent(event) {
      return (listener, thisArgs, disposables) => event(i => {
        const buffer = this.buffers[this.buffers.length - 1];
        buffer ? buffer.push(() => listener.call(thisArgs, i)) : listener.call(thisArgs, i);
      }, void 0, disposables);
    }
    bufferEvents(fn) {
      const buffer = [];
      this.buffers.push(buffer);
      fn = fn();
      this.buffers.pop();
      buffer.forEach(flush => flush());
      return fn;
    }
  }
  class Relay {
    constructor() {
      this.listening = !1;
      this.inputEvent = Event.None;
      this.inputEventListener = require$_DOT__SLASH_lifecycle_DOT_js.Disposable.None;
      this.emitter = new Emitter({onDidAddFirstListener:() => {
        this.listening = !0;
        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      }, onDidRemoveLastListener:() => {
        this.listening = !1;
        this.inputEventListener.dispose();
      }});
      this.event = this.emitter.event;
    }
    set input(event) {
      this.inputEvent = event;
      this.listening && (this.inputEventListener.dispose(), this.inputEventListener = event(this.emitter.fire, this.emitter));
    }
    dispose() {
      this.inputEventListener.dispose();
      this.emitter.dispose();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$event.js.map
