shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfiguration = function(require, module, exports) {
  function appendEntry(target, key, value) {
    target.has(key) ? target.get(key).push(value) : target.set(key, [value]);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AutoClosingPairs:{enumerable:!0, get:function() {
    return AutoClosingPairs;
  }}, IndentAction:{enumerable:!0, get:function() {
    return IndentAction;
  }}, StandardAutoClosingPairConditional:{enumerable:!0, get:function() {
    return StandardAutoClosingPairConditional;
  }}});
  var IndentAction;
  (function(IndentAction) {
    IndentAction[IndentAction.None = 0] = "None";
    IndentAction[IndentAction.Indent = 1] = "Indent";
    IndentAction[IndentAction.IndentOutdent = 2] = "IndentOutdent";
    IndentAction[IndentAction.Outdent = 3] = "Outdent";
  })(IndentAction ||= {});
  class StandardAutoClosingPairConditional {
    constructor(source) {
      this._neutralCharacter = null;
      this._neutralCharacterSearched = !1;
      this.open = source.open;
      this.close = source.close;
      this._inRegEx = this._inComment = this._inString = !0;
      if (Array.isArray(source.notIn)) {
        for (let i = 0, len = source.notIn.length; i < len; i++) {
          switch(source.notIn[i]) {
            case "string":
              this._inString = !1;
              break;
            case "comment":
              this._inComment = !1;
              break;
            case "regex":
              this._inRegEx = !1;
          }
        }
      }
    }
    isOK(standardToken) {
      switch(standardToken) {
        case 0:
          return !0;
        case 1:
          return this._inComment;
        case 2:
          return this._inString;
        case 3:
          return this._inRegEx;
      }
    }
    shouldAutoClose(context, column) {
      if (context.getTokenCount() === 0) {
        return !0;
      }
      column = context.findTokenIndexAtOffset(column - 2);
      context = context.getStandardTokenType(column);
      return this.isOK(context);
    }
    _findNeutralCharacterInRange(fromCharCode, toCharCode) {
      for (; fromCharCode <= toCharCode; fromCharCode++) {
        const character = String.fromCharCode(fromCharCode);
        if (!this.open.includes(character) && !this.close.includes(character)) {
          return character;
        }
      }
      return null;
    }
    findNeutralCharacter() {
      this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(48, 57)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(97, 122)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(65, 90)));
      return this._neutralCharacter;
    }
  }
  class AutoClosingPairs {
    constructor(autoClosingPairs) {
      this.autoClosingPairsOpenByStart = new Map();
      this.autoClosingPairsOpenByEnd = new Map();
      this.autoClosingPairsCloseByStart = new Map();
      this.autoClosingPairsCloseByEnd = new Map();
      this.autoClosingPairsCloseSingleChar = new Map();
      for (const pair of autoClosingPairs) {
        appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair), appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair), appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair), appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair), pair.close.length === 1 && pair.open.length === 1 && appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfiguration.js.map
