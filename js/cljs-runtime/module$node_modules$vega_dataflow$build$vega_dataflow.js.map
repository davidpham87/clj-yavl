{
"version":3,
"file":"module$node_modules$vega_dataflow$build$vega_dataflow.js",
"lineCount":800,
"mappings":"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",
"sources":["node_modules/vega-dataflow/build/vega-dataflow.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vega_dataflow$build$vega_dataflow\"] = function(require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-loader'), require('vega-format')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-loader', 'vega-format'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega));\n})(this, (function (exports, vegaUtil, vegaLoader, vegaFormat) { 'use strict';\n\n  function UniqueList(idFunc) {\n    const $ = idFunc || vegaUtil.identity,\n      list = [],\n      ids = {};\n    list.add = _ => {\n      const id = $(_);\n      if (!ids[id]) {\n        ids[id] = 1;\n        list.push(_);\n      }\n      return list;\n    };\n    list.remove = _ => {\n      const id = $(_);\n      if (ids[id]) {\n        ids[id] = 0;\n        const idx = list.indexOf(_);\n        if (idx >= 0) list.splice(idx, 1);\n      }\n      return list;\n    };\n    return list;\n  }\n\n  /**\n   * Invoke and await a potentially async callback function. If\n   * an error occurs, trap it and route to Dataflow.error.\n   * @param {Dataflow} df - The dataflow instance\n   * @param {function} callback - A callback function to invoke\n   *   and then await. The dataflow will be passed as the single\n   *   argument to the function.\n   */\n  async function asyncCallback (df, callback) {\n    try {\n      await callback(df);\n    } catch (err) {\n      df.error(err);\n    }\n  }\n\n  const TUPLE_ID_KEY = Symbol('vega_id');\n  let TUPLE_ID = 1;\n\n  /**\n   * Checks if an input value is a registered tuple.\n   * @param {*} t - The value to check.\n   * @return {boolean} True if the input is a tuple, false otherwise.\n   */\n  function isTuple(t) {\n    return !!(t && tupleid(t));\n  }\n\n  /**\n   * Returns the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @return {*} the tuple id.\n   */\n  function tupleid(t) {\n    return t[TUPLE_ID_KEY];\n  }\n\n  /**\n   * Sets the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @param {*} id - The id value to set.\n   * @return {object} the input tuple.\n   */\n  function setid(t, id) {\n    t[TUPLE_ID_KEY] = id;\n    return t;\n  }\n\n  /**\n   * Ingest an object or value as a data tuple.\n   * If the input value is an object, an id field will be added to it. For\n   * efficiency, the input object is modified directly. A copy is not made.\n   * If the input value is a literal, it will be wrapped in a new object\n   * instance, with the value accessible as the 'data' property.\n   * @param datum - The value to ingest.\n   * @return {object} The ingested data tuple.\n   */\n  function ingest$1(datum) {\n    const t = datum === Object(datum) ? datum : {\n      data: datum\n    };\n    return tupleid(t) ? t : setid(t, TUPLE_ID++);\n  }\n\n  /**\n   * Given a source tuple, return a derived copy.\n   * @param {object} t - The source tuple.\n   * @return {object} The derived tuple.\n   */\n  function derive(t) {\n    return rederive(t, ingest$1({}));\n  }\n\n  /**\n   * Rederive a derived tuple by copying values from the source tuple.\n   * @param {object} t - The source tuple.\n   * @param {object} d - The derived tuple.\n   * @return {object} The derived tuple.\n   */\n  function rederive(t, d) {\n    for (const k in t) d[k] = t[k];\n    return d;\n  }\n\n  /**\n   * Replace an existing tuple with a new tuple.\n   * @param {object} t - The existing data tuple.\n   * @param {object} d - The new tuple that replaces the old.\n   * @return {object} The new tuple.\n   */\n  function replace(t, d) {\n    return setid(d, tupleid(t));\n  }\n\n  /**\n   * Generate an augmented comparator function that provides stable\n   * sorting by tuple id when the given comparator produces ties.\n   * @param {function} cmp - The comparator to augment.\n   * @param {function} [f] - Optional tuple accessor function.\n   * @return {function} An augmented comparator function.\n   */\n  function stableCompare(cmp, f) {\n    return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);\n  }\n\n  function isChangeSet(v) {\n    return v && v.constructor === changeset;\n  }\n  function changeset() {\n    const add = [],\n      // insert tuples\n      rem = [],\n      // remove tuples\n      mod = [],\n      // modify tuples\n      remp = [],\n      // remove by predicate\n      modp = []; // modify by predicate\n    let clean = null,\n      reflow = false;\n    return {\n      constructor: changeset,\n      insert(t) {\n        const d = vegaUtil.array(t),\n          n = d.length;\n        for (let i = 0; i < n; ++i) add.push(d[i]);\n        return this;\n      },\n      remove(t) {\n        const a = vegaUtil.isFunction(t) ? remp : rem,\n          d = vegaUtil.array(t),\n          n = d.length;\n        for (let i = 0; i < n; ++i) a.push(d[i]);\n        return this;\n      },\n      modify(t, field, value) {\n        const m = {\n          field: field,\n          value: vegaUtil.constant(value)\n        };\n        if (vegaUtil.isFunction(t)) {\n          m.filter = t;\n          modp.push(m);\n        } else {\n          m.tuple = t;\n          mod.push(m);\n        }\n        return this;\n      },\n      encode(t, set) {\n        if (vegaUtil.isFunction(t)) modp.push({\n          filter: t,\n          field: set\n        });else mod.push({\n          tuple: t,\n          field: set\n        });\n        return this;\n      },\n      clean(value) {\n        clean = value;\n        return this;\n      },\n      reflow() {\n        reflow = true;\n        return this;\n      },\n      pulse(pulse, tuples) {\n        const cur = {},\n          out = {};\n        let i, n, m, f, t, id;\n\n        // build lookup table of current tuples\n        for (i = 0, n = tuples.length; i < n; ++i) {\n          cur[tupleid(tuples[i])] = 1;\n        }\n\n        // process individual tuples to remove\n        for (i = 0, n = rem.length; i < n; ++i) {\n          t = rem[i];\n          cur[tupleid(t)] = -1;\n        }\n\n        // process predicate-based removals\n        for (i = 0, n = remp.length; i < n; ++i) {\n          f = remp[i];\n          tuples.forEach(t => {\n            if (f(t)) cur[tupleid(t)] = -1;\n          });\n        }\n\n        // process all add tuples\n        for (i = 0, n = add.length; i < n; ++i) {\n          t = add[i];\n          id = tupleid(t);\n          if (cur[id]) {\n            // tuple already resides in dataset\n            // if flagged for both add and remove, cancel\n            cur[id] = 1;\n          } else {\n            // tuple does not reside in dataset, add\n            pulse.add.push(ingest$1(add[i]));\n          }\n        }\n\n        // populate pulse rem list\n        for (i = 0, n = tuples.length; i < n; ++i) {\n          t = tuples[i];\n          if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n        }\n\n        // modify helper method\n        function modify(t, f, v) {\n          if (v) {\n            t[f] = v(t);\n          } else {\n            pulse.encode = f;\n          }\n          if (!reflow) out[tupleid(t)] = t;\n        }\n\n        // process individual tuples to modify\n        for (i = 0, n = mod.length; i < n; ++i) {\n          m = mod[i];\n          t = m.tuple;\n          f = m.field;\n          id = cur[tupleid(t)];\n          if (id > 0) {\n            modify(t, f, m.value);\n            pulse.modifies(f);\n          }\n        }\n\n        // process predicate-based modifications\n        for (i = 0, n = modp.length; i < n; ++i) {\n          m = modp[i];\n          f = m.filter;\n          tuples.forEach(t => {\n            if (f(t) && cur[tupleid(t)] > 0) {\n              modify(t, m.field, m.value);\n            }\n          });\n          pulse.modifies(m.field);\n        }\n\n        // upon reflow request, populate mod with all non-removed tuples\n        // otherwise, populate mod with modified tuples only\n        if (reflow) {\n          pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();\n        } else {\n          for (id in out) pulse.mod.push(out[id]);\n        }\n\n        // set pulse garbage collection request\n        if (clean || clean == null && (rem.length || remp.length)) {\n          pulse.clean(true);\n        }\n        return pulse;\n      }\n    };\n  }\n\n  const CACHE = '_:mod:_';\n\n  /**\n   * Hash that tracks modifications to assigned values.\n   * Callers *must* use the set method to update values.\n   */\n  function Parameters() {\n    Object.defineProperty(this, CACHE, {\n      writable: true,\n      value: {}\n    });\n  }\n  Parameters.prototype = {\n    /**\n     * Set a parameter value. If the parameter value changes, the parameter\n     * will be recorded as modified.\n     * @param {string} name - The parameter name.\n     * @param {number} index - The index into an array-value parameter. Ignored if\n     *   the argument is undefined, null or less than zero.\n     * @param {*} value - The parameter value to set.\n     * @param {boolean} [force=false] - If true, records the parameter as modified\n     *   even if the value is unchanged.\n     * @return {Parameters} - This parameter object.\n     */\n    set(name, index, value, force) {\n      const o = this,\n        v = o[name],\n        mod = o[CACHE];\n      if (index != null && index >= 0) {\n        if (v[index] !== value || force) {\n          v[index] = value;\n          mod[index + ':' + name] = -1;\n          mod[name] = -1;\n        }\n      } else if (v !== value || force) {\n        o[name] = value;\n        mod[name] = vegaUtil.isArray(value) ? 1 + value.length : -1;\n      }\n      return o;\n    },\n    /**\n     * Tests if one or more parameters has been modified. If invoked with no\n     * arguments, returns true if any parameter value has changed. If the first\n     * argument is array, returns trues if any parameter name in the array has\n     * changed. Otherwise, tests if the given name and optional array index has\n     * changed.\n     * @param {string} name - The parameter name to test.\n     * @param {number} [index=undefined] - The parameter array index to test.\n     * @return {boolean} - Returns true if a queried parameter was modified.\n     */\n    modified(name, index) {\n      const mod = this[CACHE];\n      if (!arguments.length) {\n        for (const k in mod) {\n          if (mod[k]) return true;\n        }\n        return false;\n      } else if (vegaUtil.isArray(name)) {\n        for (let k = 0; k < name.length; ++k) {\n          if (mod[name[k]]) return true;\n        }\n        return false;\n      }\n      return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];\n    },\n    /**\n     * Clears the modification records. After calling this method,\n     * all parameters are considered unmodified.\n     */\n    clear() {\n      this[CACHE] = {};\n      return this;\n    }\n  };\n\n  let OP_ID = 0;\n  const PULSE = 'pulse',\n    NO_PARAMS = new Parameters();\n\n  // Boolean Flags\n  const SKIP$1 = 1,\n    MODIFIED = 2;\n\n  /**\n   * An Operator is a processing node in a dataflow graph.\n   * Each operator stores a value and an optional value update function.\n   * Operators can accept a hash of named parameters. Parameter values can\n   * either be direct (JavaScript literals, arrays, objects) or indirect\n   * (other operators whose values will be pulled dynamically). Operators\n   * included as parameters will have this operator added as a dependency.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {function(object, Pulse)} [update] - An update function. Upon\n   *   evaluation of this operator, the update function will be invoked and the\n   *   return value will be used as the new value of this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @see parameters\n   */\n  function Operator(init, update, params, react) {\n    this.id = ++OP_ID;\n    this.value = init;\n    this.stamp = -1;\n    this.rank = -1;\n    this.qrank = -1;\n    this.flags = 0;\n    if (update) {\n      this._update = update;\n    }\n    if (params) this.parameters(params, react);\n  }\n  function flag(bit) {\n    return function (state) {\n      const f = this.flags;\n      if (arguments.length === 0) return !!(f & bit);\n      this.flags = state ? f | bit : f & ~bit;\n      return this;\n    };\n  }\n  Operator.prototype = {\n    /**\n     * Returns a list of target operators dependent on this operator.\n     * If this list does not exist, it is created and then returned.\n     * @return {UniqueList}\n     */\n    targets() {\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\n    },\n    /**\n     * Sets the value of this operator.\n     * @param {*} value - the value to set.\n     * @return {Number} Returns 1 if the operator value has changed\n     *   according to strict equality, returns 0 otherwise.\n     */\n    set(value) {\n      if (this.value !== value) {\n        this.value = value;\n        return 1;\n      } else {\n        return 0;\n      }\n    },\n    /**\n     * Indicates that operator evaluation should be skipped on the next pulse.\n     * This operator will still propagate incoming pulses, but its update function\n     * will not be invoked. The skip flag is reset after every pulse, so calling\n     * this method will affect processing of the next pulse only.\n     */\n    skip: flag(SKIP$1),\n    /**\n     * Indicates that this operator's value has been modified on its most recent\n     * pulse. Normally modification is checked via strict equality; however, in\n     * some cases it is more efficient to update the internal state of an object.\n     * In those cases, the modified flag can be used to trigger propagation. Once\n     * set, the modification flag persists across pulses until unset. The flag can\n     * be used with the last timestamp to test if a modification is recent.\n     */\n    modified: flag(MODIFIED),\n    /**\n     * Sets the parameters for this operator. The parameter values are analyzed for\n     * operator instances. If found, this operator will be added as a dependency\n     * of the parameterizing operator. Operator values are dynamically marshalled\n     * from each operator parameter prior to evaluation. If a parameter value is\n     * an array, the array will also be searched for Operator instances. However,\n     * the search does not recurse into sub-arrays or object properties.\n     * @param {object} params - A hash of operator parameters.\n     * @param {boolean} [react=true] - A flag indicating if this operator should\n     *   automatically update (react) when parameter values change. In other words,\n     *   this flag determines if the operator registers itself as a listener on\n     *   any upstream operators included in the parameters.\n     * @param {boolean} [initonly=false] - A flag indicating if this operator\n     *   should calculate an update only upon its initial evaluation, then\n     *   deregister dependencies and suppress all future update invocations.\n     * @return {Operator[]} - An array of upstream dependencies.\n     */\n    parameters(params, react, initonly) {\n      react = react !== false;\n      const argval = this._argval = this._argval || new Parameters(),\n        argops = this._argops = this._argops || [],\n        deps = [];\n      let name, value, n, i;\n      const add = (name, index, value) => {\n        if (value instanceof Operator) {\n          if (value !== this) {\n            if (react) value.targets().add(this);\n            deps.push(value);\n          }\n          argops.push({\n            op: value,\n            name: name,\n            index: index\n          });\n        } else {\n          argval.set(name, index, value);\n        }\n      };\n      for (name in params) {\n        value = params[name];\n        if (name === PULSE) {\n          vegaUtil.array(value).forEach(op => {\n            if (!(op instanceof Operator)) {\n              vegaUtil.error('Pulse parameters must be operator instances.');\n            } else if (op !== this) {\n              op.targets().add(this);\n              deps.push(op);\n            }\n          });\n          this.source = value;\n        } else if (vegaUtil.isArray(value)) {\n          argval.set(name, -1, Array(n = value.length));\n          for (i = 0; i < n; ++i) add(name, i, value[i]);\n        } else {\n          add(name, -1, value);\n        }\n      }\n      this.marshall().clear(); // initialize values\n      if (initonly) argops.initonly = true;\n      return deps;\n    },\n    /**\n     * Internal method for marshalling parameter values.\n     * Visits each operator dependency to pull the latest value.\n     * @return {Parameters} A Parameters object to pass to the update function.\n     */\n    marshall(stamp) {\n      const argval = this._argval || NO_PARAMS,\n        argops = this._argops;\n      let item, i, op, mod;\n      if (argops) {\n        const n = argops.length;\n        for (i = 0; i < n; ++i) {\n          item = argops[i];\n          op = item.op;\n          mod = op.modified() && op.stamp === stamp;\n          argval.set(item.name, item.index, op.value, mod);\n        }\n        if (argops.initonly) {\n          for (i = 0; i < n; ++i) {\n            item = argops[i];\n            item.op.targets().remove(this);\n          }\n          this._argops = null;\n          this._update = null;\n        }\n      }\n      return argval;\n    },\n    /**\n     * Detach this operator from the dataflow.\n     * Unregisters listeners on upstream dependencies.\n     */\n    detach() {\n      const argops = this._argops;\n      let i, n, item, op;\n      if (argops) {\n        for (i = 0, n = argops.length; i < n; ++i) {\n          item = argops[i];\n          op = item.op;\n          if (op._targets) {\n            op._targets.remove(this);\n          }\n        }\n      }\n\n      // remove references to the source and pulse object,\n      // if present, to prevent memory leaks of old data.\n      this.pulse = null;\n      this.source = null;\n    },\n    /**\n     * Delegate method to perform operator processing.\n     * Subclasses can override this method to perform custom processing.\n     * By default, it marshalls parameters and calls the update function\n     * if that function is defined. If the update function does not\n     * change the operator value then StopPropagation is returned.\n     * If no update function is defined, this method does nothing.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return The output pulse or StopPropagation. A falsy return value\n     *   (including undefined) will let the input pulse pass through.\n     */\n    evaluate(pulse) {\n      const update = this._update;\n      if (update) {\n        const params = this.marshall(pulse.stamp),\n          v = update.call(this, params, pulse);\n        params.clear();\n        if (v !== this.value) {\n          this.value = v;\n        } else if (!this.modified()) {\n          return pulse.StopPropagation;\n        }\n      }\n    },\n    /**\n     * Run this operator for the current pulse. If this operator has already\n     * been run at (or after) the pulse timestamp, returns StopPropagation.\n     * Internally, this method calls {@link evaluate} to perform processing.\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return the output pulse for this operator (or StopPropagation)\n     */\n    run(pulse) {\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n      let rv;\n      if (this.skip()) {\n        this.skip(false);\n        rv = 0;\n      } else {\n        rv = this.evaluate(pulse);\n      }\n      return this.pulse = rv || pulse;\n    }\n  };\n\n  /**\n   * Add an operator to the dataflow graph. This function accepts a\n   * variety of input argument types. The basic signature supports an\n   * initial value, update function and parameters. If the first parameter\n   * is an Operator instance, it will be added directly. If it is a\n   * constructor for an Operator subclass, a new instance will be instantiated.\n   * Otherwise, if the first parameter is a function instance, it will be used\n   * as the update function and a null initial value is assumed.\n   * @param {*} init - One of: the operator to add, the initial value of\n   *   the operator, an operator class to instantiate, or an update function.\n   * @param {function} [update] - The operator update function.\n   * @param {object} [params] - The operator parameters.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @return {Operator} - The added operator.\n   */\n  function add (init, update, params, react) {\n    let shift = 1,\n      op;\n    if (init instanceof Operator) {\n      op = init;\n    } else if (init && init.prototype instanceof Operator) {\n      op = new init();\n    } else if (vegaUtil.isFunction(init)) {\n      op = new Operator(null, init);\n    } else {\n      shift = 0;\n      op = new Operator(init, update);\n    }\n    this.rank(op);\n    if (shift) {\n      react = params;\n      params = update;\n    }\n    if (params) this.connect(op, op.parameters(params, react));\n    this.touch(op);\n    return op;\n  }\n\n  /**\n   * Connect a target operator as a dependent of source operators.\n   * If necessary, this method will rerank the target operator and its\n   * dependents to ensure propagation proceeds in a topologically sorted order.\n   * @param {Operator} target - The target operator.\n   * @param {Array<Operator>} - The source operators that should propagate\n   *   to the target operator.\n   */\n  function connect (target, sources) {\n    const targetRank = target.rank,\n      n = sources.length;\n    for (let i = 0; i < n; ++i) {\n      if (targetRank < sources[i].rank) {\n        this.rerank(target);\n        return;\n      }\n    }\n  }\n\n  let STREAM_ID = 0;\n\n  /**\n   * Models an event stream.\n   * @constructor\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @param {function(Object)} [receive] - Event callback function to invoke\n   *   upon receipt of a new event. Use to override standard event processing.\n   */\n  function EventStream(filter, apply, receive) {\n    this.id = ++STREAM_ID;\n    this.value = null;\n    if (receive) this.receive = receive;\n    if (filter) this._filter = filter;\n    if (apply) this._apply = apply;\n  }\n\n  /**\n   * Creates a new event stream instance with the provided\n   * (optional) filter, apply and receive functions.\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @see EventStream\n   */\n  function stream(filter, apply, receive) {\n    return new EventStream(filter, apply, receive);\n  }\n  EventStream.prototype = {\n    _filter: vegaUtil.truthy,\n    _apply: vegaUtil.identity,\n    targets() {\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\n    },\n    consume(_) {\n      if (!arguments.length) return !!this._consume;\n      this._consume = !!_;\n      return this;\n    },\n    receive(evt) {\n      if (this._filter(evt)) {\n        const val = this.value = this._apply(evt),\n          trg = this._targets,\n          n = trg ? trg.length : 0;\n        for (let i = 0; i < n; ++i) trg[i].receive(val);\n        if (this._consume) {\n          evt.preventDefault();\n          evt.stopPropagation();\n        }\n      }\n    },\n    filter(filter) {\n      const s = stream(filter);\n      this.targets().add(s);\n      return s;\n    },\n    apply(apply) {\n      const s = stream(null, apply);\n      this.targets().add(s);\n      return s;\n    },\n    merge() {\n      const s = stream();\n      this.targets().add(s);\n      for (let i = 0, n = arguments.length; i < n; ++i) {\n        arguments[i].targets().add(s);\n      }\n      return s;\n    },\n    throttle(pause) {\n      let t = -1;\n      return this.filter(() => {\n        const now = Date.now();\n        if (now - t > pause) {\n          t = now;\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n    },\n    debounce(delay) {\n      const s = stream();\n      this.targets().add(stream(null, null, vegaUtil.debounce(delay, e => {\n        const df = e.dataflow;\n        s.receive(e);\n        if (df && df.run) df.run();\n      })));\n      return s;\n    },\n    between(a, b) {\n      let active = false;\n      a.targets().add(stream(null, null, () => active = true));\n      b.targets().add(stream(null, null, () => active = false));\n      return this.filter(() => active);\n    },\n    detach() {\n      // ensures compatibility with operators (#2753)\n      // remove references to other streams and filter functions that may\n      // be bound to subcontexts that need to be garbage collected.\n      this._filter = vegaUtil.truthy;\n      this._targets = null;\n    }\n  };\n\n  /**\n   * Create a new event stream from an event source.\n   * @param {object} source - The event source to monitor. The input must\n   *  support the addEventListener method.\n   * @param {string} type - The event type.\n   * @param {function(object): boolean} [filter] - Event filter function.\n   * @param {function(object): *} [apply] - Event application function.\n   *   If provided, this function will be invoked and the result will be\n   *   used as the downstream event value.\n   * @return {EventStream}\n   */\n  function events (source, type, filter, apply) {\n    const df = this,\n      s = stream(filter, apply),\n      send = function (e) {\n        e.dataflow = df;\n        try {\n          s.receive(e);\n        } catch (error) {\n          df.error(error);\n        } finally {\n          df.run();\n        }\n      };\n    let sources;\n    if (typeof source === 'string' && typeof document !== 'undefined') {\n      sources = document.querySelectorAll(source);\n    } else {\n      sources = vegaUtil.array(source);\n    }\n    const n = sources.length;\n    for (let i = 0; i < n; ++i) {\n      sources[i].addEventListener(type, send);\n    }\n    return s;\n  }\n\n  function parse(data, format) {\n    const locale = this.locale();\n    return vegaLoader.read(data, format, locale.timeParse, locale.utcParse);\n  }\n\n  /**\n   * Ingests new data into the dataflow. First parses the data using the\n   * vega-loader read method, then pulses a changeset to the target operator.\n   * @param {Operator} target - The Operator to target with ingested data,\n   *   typically a Collect transform instance.\n   * @param {*} data - The input data, prior to parsing. For JSON this may\n   *   be a string or an object. For CSV, TSV, etc should be a string.\n   * @param {object} format - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @returns {Dataflow}\n   */\n  function ingest(target, data, format) {\n    data = this.parse(data, format);\n    return this.pulse(target, this.changeset().insert(data));\n  }\n\n  /**\n   * Request data from an external source, parse it, and return a Promise.\n   * @param {string} url - The URL from which to load the data. This string\n   *   is passed to the vega-loader load method.\n   * @param {object} [format] - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @return {Promise} A Promise that resolves upon completion of the request.\n   *   The resolved object contains the following properties:\n   *   - data: an array of parsed data (or null upon error)\n   *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n   */\n  async function request(url, format) {\n    const df = this;\n    let status = 0,\n      data;\n    try {\n      data = await df.loader().load(url, {\n        context: 'dataflow',\n        response: vegaLoader.responseType(format && format.type)\n      });\n      try {\n        data = df.parse(data, format);\n      } catch (err) {\n        status = -2;\n        df.warn('Data ingestion failed', url, err);\n      }\n    } catch (err) {\n      status = -1;\n      df.warn('Loading failed', url, err);\n    }\n    return {\n      data,\n      status\n    };\n  }\n  async function preload(target, url, format) {\n    const df = this,\n      pending = df._pending || loadPending(df);\n    pending.requests += 1;\n    const res = await df.request(url, format);\n    df.pulse(target, df.changeset().remove(vegaUtil.truthy).insert(res.data || []));\n    pending.done();\n    return res;\n  }\n  function loadPending(df) {\n    let accept;\n    const pending = new Promise(a => accept = a);\n    pending.requests = 0;\n    pending.done = () => {\n      if (--pending.requests === 0) {\n        df._pending = null;\n        accept(df);\n      }\n    };\n    return df._pending = pending;\n  }\n\n  const SKIP = {\n    skip: true\n  };\n\n  /**\n   * Perform operator updates in response to events. Applies an\n   * update function to compute a new operator value. If the update function\n   * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n   * changes. Otherwise, the operator value will be updated to the return value.\n   * @param {EventStream|Operator} source - The event source to react to.\n   *   This argument can be either an EventStream or an Operator.\n   * @param {Operator|function(object):Operator} target - The operator to update.\n   *   This argument can either be an Operator instance or (if the source\n   *   argument is an EventStream), a function that accepts an event object as\n   *   input and returns an Operator to target.\n   * @param {function(Parameters,Event): *} [update] - Optional update function\n   *   to compute the new operator value, or a literal value to set. Update\n   *   functions expect to receive a parameter object and event as arguments.\n   *   This function can either return a new operator value or (if the source\n   *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n   *   the target operator with tuple changes.\n   * @param {object} [params] - The update function parameters.\n   * @param {object} [options] - Additional options hash. If not overridden,\n   *   updated operators will be skipped by default.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *  be skipped: it will not be evaluated, but its dependents will be.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @return {Dataflow}\n   */\n  function on (source, target, update, params, options) {\n    const fn = source instanceof Operator ? onOperator : onStream;\n    fn(this, source, target, update, params, options);\n    return this;\n  }\n  function onStream(df, stream, target, update, params, options) {\n    const opt = vegaUtil.extend({}, options, SKIP);\n    let func, op;\n    if (!vegaUtil.isFunction(target)) target = vegaUtil.constant(target);\n    if (update === undefined) {\n      func = e => df.touch(target(e));\n    } else if (vegaUtil.isFunction(update)) {\n      op = new Operator(null, update, params, false);\n      func = e => {\n        op.evaluate(e);\n        const t = target(e),\n          v = op.value;\n        isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n      };\n    } else {\n      func = e => df.update(target(e), update, opt);\n    }\n    stream.apply(func);\n  }\n  function onOperator(df, source, target, update, params, options) {\n    if (update === undefined) {\n      source.targets().add(target);\n    } else {\n      const opt = options || {},\n        op = new Operator(null, updater(target, update), params, false);\n      op.modified(opt.force);\n      op.rank = source.rank; // immediately follow source\n      source.targets().add(op); // add dependency\n\n      if (target) {\n        op.skip(true); // skip first invocation\n        op.value = target.value; // initialize value\n        op.targets().add(target); // chain dependencies\n        df.connect(target, [op]); // rerank as needed, #1672\n      }\n    }\n  }\n  function updater(target, update) {\n    update = vegaUtil.isFunction(update) ? update : vegaUtil.constant(update);\n    return target ? function (_, pulse) {\n      const value = update(_, pulse);\n      if (!target.skip()) {\n        target.skip(value !== this.value).value = value;\n      }\n      return value;\n    } : update;\n  }\n\n  /**\n   * Assigns a rank to an operator. Ranks are assigned in increasing order\n   * by incrementing an internal rank counter.\n   * @param {Operator} op - The operator to assign a rank.\n   */\n  function rank(op) {\n    op.rank = ++this._rank;\n  }\n\n  /**\n   * Re-ranks an operator and all downstream target dependencies. This\n   * is necessary when upstream dependencies of higher rank are added to\n   * a target operator.\n   * @param {Operator} op - The operator to re-rank.\n   */\n  function rerank(op) {\n    const queue = [op];\n    let cur, list, i;\n    while (queue.length) {\n      this.rank(cur = queue.pop());\n      if (list = cur._targets) {\n        for (i = list.length; --i >= 0;) {\n          queue.push(cur = list[i]);\n          if (cur === op) vegaUtil.error('Cycle detected in dataflow graph.');\n        }\n      }\n    }\n  }\n\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n  const StopPropagation = {};\n\n  // Pulse visit type flags\n  const ADD = 1 << 0,\n    REM = 1 << 1,\n    MOD = 1 << 2,\n    ADD_REM = ADD | REM,\n    ADD_MOD = ADD | MOD,\n    ALL = ADD | REM | MOD,\n    REFLOW = 1 << 3,\n    SOURCE = 1 << 4,\n    NO_SOURCE = 1 << 5,\n    NO_FIELDS = 1 << 6;\n\n  /**\n   * A Pulse enables inter-operator communication during a run of the\n   * dataflow graph. In addition to the current timestamp, a pulse may also\n   * contain a change-set of added, removed or modified data tuples, as well as\n   * a pointer to a full backing data source. Tuple change sets may not\n   * be fully materialized; for example, to prevent needless array creation\n   * a change set may include larger arrays and corresponding filter functions.\n   * The pulse provides a {@link visit} method to enable proper and efficient\n   * iteration over requested data tuples.\n   *\n   * In addition, each pulse can track modification flags for data tuple fields.\n   * Responsible transform operators should call the {@link modifies} method to\n   * indicate changes to data fields. The {@link modified} method enables\n   * querying of this modification state.\n   *\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The current propagation timestamp.\n   * @param {string} [encode] - An optional encoding set name, which is then\n   *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n   *   setting as appropriate. This parameter can be used in conjunction with\n   *   the Encode transform in the vega-encode module.\n   */\n  function Pulse(dataflow, stamp, encode) {\n    this.dataflow = dataflow;\n    this.stamp = stamp == null ? -1 : stamp;\n    this.add = [];\n    this.rem = [];\n    this.mod = [];\n    this.fields = null;\n    this.encode = encode || null;\n  }\n  function materialize(data, filter) {\n    const out = [];\n    vegaUtil.visitArray(data, filter, _ => out.push(_));\n    return out;\n  }\n  function filter(pulse, flags) {\n    const map = {};\n    pulse.visit(flags, t => {\n      map[tupleid(t)] = 1;\n    });\n    return t => map[tupleid(t)] ? null : t;\n  }\n  function addFilter(a, b) {\n    return a ? (t, i) => a(t, i) && b(t, i) : b;\n  }\n  Pulse.prototype = {\n    /**\n     * Sentinel value indicating pulse propagation should stop.\n     */\n    StopPropagation,\n    /**\n     * Boolean flag indicating ADD (added) tuples.\n     */\n    ADD,\n    /**\n     * Boolean flag indicating REM (removed) tuples.\n     */\n    REM,\n    /**\n     * Boolean flag indicating MOD (modified) tuples.\n     */\n    MOD,\n    /**\n     * Boolean flag indicating ADD (added) and REM (removed) tuples.\n     */\n    ADD_REM,\n    /**\n     * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n     */\n    ADD_MOD,\n    /**\n     * Boolean flag indicating ADD, REM and MOD tuples.\n     */\n    ALL,\n    /**\n     * Boolean flag indicating all tuples in a data source\n     * except for the ADD, REM and MOD tuples.\n     */\n    REFLOW,\n    /**\n     * Boolean flag indicating a 'pass-through' to a\n     * backing data source, ignoring ADD, REM and MOD tuples.\n     */\n    SOURCE,\n    /**\n     * Boolean flag indicating that source data should be\n     * suppressed when creating a forked pulse.\n     */\n    NO_SOURCE,\n    /**\n     * Boolean flag indicating that field modifications should be\n     * suppressed when creating a forked pulse.\n     */\n    NO_FIELDS,\n    /**\n     * Creates a new pulse based on the values of this pulse.\n     * The dataflow, time stamp and field modification values are copied over.\n     * By default, new empty ADD, REM and MOD arrays are created.\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\n     *   tuple arrays should be copied to the new pulse. The supported flag values\n     *   are ADD, REM and MOD. Array references are copied directly: new array\n     *   instances are not created.\n     * @return {Pulse} - The forked pulse instance.\n     * @see init\n     */\n    fork(flags) {\n      return new Pulse(this.dataflow).init(this, flags);\n    },\n    /**\n     * Creates a copy of this pulse with new materialized array\n     * instances for the ADD, REM, MOD, and SOURCE arrays.\n     * The dataflow, time stamp and field modification values are copied over.\n     * @return {Pulse} - The cloned pulse instance.\n     * @see init\n     */\n    clone() {\n      const p = this.fork(ALL);\n      p.add = p.add.slice();\n      p.rem = p.rem.slice();\n      p.mod = p.mod.slice();\n      if (p.source) p.source = p.source.slice();\n      return p.materialize(ALL | SOURCE);\n    },\n    /**\n     * Returns a pulse that adds all tuples from a backing source. This is\n     * useful for cases where operators are added to a dataflow after an\n     * upstream data pipeline has already been processed, ensuring that\n     * new operators can observe all tuples within a stream.\n     * @return {Pulse} - A pulse instance with all source tuples included\n     *   in the add array. If the current pulse already has all source\n     *   tuples in its add array, it is returned directly. If the current\n     *   pulse does not have a backing source, it is returned directly.\n     */\n    addAll() {\n      let p = this;\n      const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)\n      || !p.rem.length && p.source.length === p.add.length;\n      if (reuse) {\n        return p;\n      } else {\n        p = new Pulse(this.dataflow).init(this);\n        p.add = p.source;\n        p.rem = []; // new operators can ignore rem #2769\n        return p;\n      }\n    },\n    /**\n     * Initialize this pulse based on the values of another pulse. This method\n     * is used internally by {@link fork} to initialize a new forked tuple.\n     * The dataflow, time stamp and field modification values are copied over.\n     * By default, new empty ADD, REM and MOD arrays are created.\n     * @param {Pulse} src - The source pulse to copy from.\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\n     *   tuple arrays should be copied to the new pulse. The supported flag values\n     *   are ADD, REM and MOD. Array references are copied directly: new array\n     *   instances are not created. By default, source data arrays are copied\n     *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n     * @return {Pulse} - Returns this Pulse instance.\n     */\n    init(src, flags) {\n      const p = this;\n      p.stamp = src.stamp;\n      p.encode = src.encode;\n      if (src.fields && !(flags & NO_FIELDS)) {\n        p.fields = src.fields;\n      }\n      if (flags & ADD) {\n        p.addF = src.addF;\n        p.add = src.add;\n      } else {\n        p.addF = null;\n        p.add = [];\n      }\n      if (flags & REM) {\n        p.remF = src.remF;\n        p.rem = src.rem;\n      } else {\n        p.remF = null;\n        p.rem = [];\n      }\n      if (flags & MOD) {\n        p.modF = src.modF;\n        p.mod = src.mod;\n      } else {\n        p.modF = null;\n        p.mod = [];\n      }\n      if (flags & NO_SOURCE) {\n        p.srcF = null;\n        p.source = null;\n      } else {\n        p.srcF = src.srcF;\n        p.source = src.source;\n        if (src.cleans) p.cleans = src.cleans;\n      }\n      return p;\n    },\n    /**\n     * Schedules a function to run after pulse propagation completes.\n     * @param {function} func - The function to run.\n     */\n    runAfter(func) {\n      this.dataflow.runAfter(func);\n    },\n    /**\n     * Indicates if tuples have been added, removed or modified.\n     * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n     *   Defaults to ALL, returning true if any tuple type has changed.\n     * @return {boolean} - Returns true if one or more queried tuple types have\n     *   changed, false otherwise.\n     */\n    changed(flags) {\n      const f = flags || ALL;\n      return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\n    },\n    /**\n     * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n     * source are added to the MOD set, unless already present in the ADD set.\n     * @param {boolean} [fork=false] - If true, returns a forked copy of this\n     *   pulse, and invokes reflow on that derived pulse.\n     * @return {Pulse} - The reflowed pulse instance.\n     */\n    reflow(fork) {\n      if (fork) return this.fork(ALL).reflow();\n      const len = this.add.length,\n        src = this.source && this.source.length;\n      if (src && src !== len) {\n        this.mod = this.source;\n        if (len) this.filter(MOD, filter(this, ADD));\n      }\n      return this;\n    },\n    /**\n     * Get/set metadata to pulse requesting garbage collection\n     * to reclaim currently unused resources.\n     */\n    clean(value) {\n      if (arguments.length) {\n        this.cleans = !!value;\n        return this;\n      } else {\n        return this.cleans;\n      }\n    },\n    /**\n     * Marks one or more data field names as modified to assist dependency\n     * tracking and incremental processing by transform operators.\n     * @param {string|Array<string>} _ - The field(s) to mark as modified.\n     * @return {Pulse} - This pulse instance.\n     */\n    modifies(_) {\n      const hash = this.fields || (this.fields = {});\n      if (vegaUtil.isArray(_)) {\n        _.forEach(f => hash[f] = true);\n      } else {\n        hash[_] = true;\n      }\n      return this;\n    },\n    /**\n     * Checks if one or more data fields have been modified during this pulse\n     * propagation timestamp.\n     * @param {string|Array<string>} _ - The field(s) to check for modified.\n     * @param {boolean} nomod - If true, will check the modified flag even if\n     *   no mod tuples exist. If false (default), mod tuples must be present.\n     * @return {boolean} - Returns true if any of the provided fields has been\n     *   marked as modified, false otherwise.\n     */\n    modified(_, nomod) {\n      const fields = this.fields;\n      return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : vegaUtil.isArray(_) ? _.some(f => fields[f]) : fields[_];\n    },\n    /**\n     * Adds a filter function to one more tuple sets. Filters are applied to\n     * backing tuple arrays, to determine the actual set of tuples considered\n     * added, removed or modified. They can be used to delay materialization of\n     * a tuple set in order to avoid expensive array copies. In addition, the\n     * filter functions can serve as value transformers: unlike standard predicate\n     * function (which return boolean values), Pulse filters should return the\n     * actual tuple value to process. If a tuple set is already filtered, the\n     * new filter function will be appended into a conjuntive ('and') query.\n     * @param {number} flags - Flags indicating the tuple set(s) to filter.\n     * @param {function(*):object} filter - Filter function that will be applied\n     *   to the tuple set array, and should return a data tuple if the value\n     *   should be included in the tuple set, and falsy (or null) otherwise.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    filter(flags, filter) {\n      const p = this;\n      if (flags & ADD) p.addF = addFilter(p.addF, filter);\n      if (flags & REM) p.remF = addFilter(p.remF, filter);\n      if (flags & MOD) p.modF = addFilter(p.modF, filter);\n      if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n      return p;\n    },\n    /**\n     * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n     * a registered filter function, it will be applied and the tuple set(s) will\n     * be replaced with materialized tuple arrays.\n     * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    materialize(flags) {\n      flags = flags || ALL;\n      const p = this;\n      if (flags & ADD && p.addF) {\n        p.add = materialize(p.add, p.addF);\n        p.addF = null;\n      }\n      if (flags & REM && p.remF) {\n        p.rem = materialize(p.rem, p.remF);\n        p.remF = null;\n      }\n      if (flags & MOD && p.modF) {\n        p.mod = materialize(p.mod, p.modF);\n        p.modF = null;\n      }\n      if (flags & SOURCE && p.srcF) {\n        p.source = p.source.filter(p.srcF);\n        p.srcF = null;\n      }\n      return p;\n    },\n    /**\n     * Visit one or more tuple sets in this pulse.\n     * @param {number} flags - Flags indicating the tuple set(s) to visit.\n     *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n     *   has been set).\n     * @param {function(object):*} - Visitor function invoked per-tuple.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    visit(flags, visitor) {\n      const p = this,\n        v = visitor;\n      if (flags & SOURCE) {\n        vegaUtil.visitArray(p.source, p.srcF, v);\n        return p;\n      }\n      if (flags & ADD) vegaUtil.visitArray(p.add, p.addF, v);\n      if (flags & REM) vegaUtil.visitArray(p.rem, p.remF, v);\n      if (flags & MOD) vegaUtil.visitArray(p.mod, p.modF, v);\n      const src = p.source;\n      if (flags & REFLOW && src) {\n        const sum = p.add.length + p.mod.length;\n        if (sum === src.length) ; else if (sum) {\n          vegaUtil.visitArray(src, filter(p, ADD_MOD), v);\n        } else {\n          // if no add/rem/mod tuples, visit source\n          vegaUtil.visitArray(src, p.srcF, v);\n        }\n      }\n      return p;\n    }\n  };\n\n  /**\n   * Represents a set of multiple pulses. Used as input for operators\n   * that accept multiple pulses at a time. Contained pulses are\n   * accessible via the public \"pulses\" array property. This pulse doe\n   * not carry added, removed or modified tuples directly. However,\n   * the visit method can be used to traverse all such tuples contained\n   * in sub-pulses with a timestamp matching this parent multi-pulse.\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The timestamp.\n   * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n   */\n  function MultiPulse(dataflow, stamp, pulses, encode) {\n    const p = this;\n    let c = 0;\n    this.dataflow = dataflow;\n    this.stamp = stamp;\n    this.fields = null;\n    this.encode = encode || null;\n    this.pulses = pulses;\n    for (const pulse of pulses) {\n      if (pulse.stamp !== stamp) continue;\n      if (pulse.fields) {\n        const hash = p.fields || (p.fields = {});\n        for (const f in pulse.fields) {\n          hash[f] = 1;\n        }\n      }\n      if (pulse.changed(p.ADD)) c |= p.ADD;\n      if (pulse.changed(p.REM)) c |= p.REM;\n      if (pulse.changed(p.MOD)) c |= p.MOD;\n    }\n    this.changes = c;\n  }\n  vegaUtil.inherits(MultiPulse, Pulse, {\n    /**\n     * Creates a new pulse based on the values of this pulse.\n     * The dataflow, time stamp and field modification values are copied over.\n     * @return {Pulse}\n     */\n    fork(flags) {\n      const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n      if (flags !== undefined) {\n        if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\n        if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\n        if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\n      }\n      return p;\n    },\n    changed(flags) {\n      return this.changes & flags;\n    },\n    modified(_) {\n      const p = this,\n        fields = p.fields;\n      return !(fields && p.changes & p.MOD) ? 0 : vegaUtil.isArray(_) ? _.some(f => fields[f]) : fields[_];\n    },\n    filter() {\n      vegaUtil.error('MultiPulse does not support filtering.');\n    },\n    materialize() {\n      vegaUtil.error('MultiPulse does not support materialization.');\n    },\n    visit(flags, visitor) {\n      const p = this,\n        pulses = p.pulses,\n        n = pulses.length;\n      let i = 0;\n      if (flags & p.SOURCE) {\n        for (; i < n; ++i) {\n          pulses[i].visit(flags, visitor);\n        }\n      } else {\n        for (; i < n; ++i) {\n          if (pulses[i].stamp === p.stamp) {\n            pulses[i].visit(flags, visitor);\n          }\n        }\n      }\n      return p;\n    }\n  });\n\n  /* eslint-disable require-atomic-updates */\n\n  /**\n   * Evaluates the dataflow and returns a Promise that resolves when pulse\n   * propagation completes. This method will increment the current timestamp\n   * and process all updated, pulsed and touched operators. When invoked for\n   * the first time, all registered operators will be processed. This method\n   * should not be invoked by third-party clients, use {@link runAsync} or\n   * {@link run} instead.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n  async function evaluate(encode, prerun, postrun) {\n    const df = this,\n      async = [];\n\n    // if the pulse value is set, this is a re-entrant call\n    if (df._pulse) return reentrant(df);\n\n    // wait for pending datasets to load\n    if (df._pending) await df._pending;\n\n    // invoke prerun function, if provided\n    if (prerun) await asyncCallback(df, prerun);\n\n    // exit early if there are no updates\n    if (!df._touched.length) {\n      df.debug('Dataflow invoked, but nothing to do.');\n      return df;\n    }\n\n    // increment timestamp clock\n    const stamp = ++df._clock;\n\n    // set the current pulse\n    df._pulse = new Pulse(df, stamp, encode);\n\n    // initialize priority queue, reset touched operators\n    df._touched.forEach(op => df._enqueue(op, true));\n    df._touched = UniqueList(vegaUtil.id);\n    let count = 0,\n      op,\n      next,\n      error;\n    try {\n      while (df._heap.size() > 0) {\n        // dequeue operator with highest priority\n        op = df._heap.pop();\n\n        // re-queue if rank changed\n        if (op.rank !== op.qrank) {\n          df._enqueue(op, true);\n          continue;\n        }\n\n        // otherwise, evaluate the operator\n        next = op.run(df._getPulse(op, encode));\n        if (next.then) {\n          // await if operator returns a promise directly\n          next = await next;\n        } else if (next.async) {\n          // queue parallel asynchronous execution\n          async.push(next.async);\n          next = StopPropagation;\n        }\n\n        // propagate evaluation, enqueue dependent operators\n        if (next !== StopPropagation) {\n          if (op._targets) op._targets.forEach(op => df._enqueue(op));\n        }\n\n        // increment visit counter\n        ++count;\n      }\n    } catch (err) {\n      df._heap.clear();\n      error = err;\n    }\n\n    // reset pulse map\n    df._input = {};\n    df._pulse = null;\n    df.debug(`Pulse ${stamp}: ${count} operators`);\n    if (error) {\n      df._postrun = [];\n      df.error(error);\n    }\n\n    // invoke callbacks queued via runAfter\n    if (df._postrun.length) {\n      const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n      df._postrun = [];\n      for (let i = 0; i < pr.length; ++i) {\n        await asyncCallback(df, pr[i].callback);\n      }\n    }\n\n    // invoke postrun function, if provided\n    if (postrun) await asyncCallback(df, postrun);\n\n    // handle non-blocking asynchronous callbacks\n    if (async.length) {\n      Promise.all(async).then(cb => df.runAsync(null, () => {\n        cb.forEach(f => {\n          try {\n            f(df);\n          } catch (err) {\n            df.error(err);\n          }\n        });\n      }));\n    }\n    return df;\n  }\n\n  /**\n   * Queues dataflow evaluation to run once any other queued evaluations have\n   * completed and returns a Promise that resolves when the queued pulse\n   * propagation completes. If provided, a callback function will be invoked\n   * immediately before evaluation commences. This method will ensure a\n   * separate evaluation is invoked for each time it is called.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n  async function runAsync(encode, prerun, postrun) {\n    // await previously queued functions\n    while (this._running) await this._running;\n\n    // run dataflow, manage running promise\n    const clear = () => this._running = null;\n    (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\n    return this._running;\n  }\n\n  /**\n   * Requests dataflow evaluation and the immediately returns this dataflow\n   * instance. If there are pending data loading or other asynchronous\n   * operations, the dataflow will evaluate asynchronously after this method\n   * has been invoked. To track when dataflow evaluation completes, use the\n   * {@link runAsync} method instead. This method will raise an error if\n   * invoked while the dataflow is already in the midst of evaluation.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode module.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Dataflow} - This dataflow instance.\n   */\n  function run(encode, prerun, postrun) {\n    return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\n  }\n\n  /**\n   * Schedules a callback function to be invoked after the current pulse\n   * propagation completes. If no propagation is currently occurring,\n   * the function is invoked immediately. Callbacks scheduled via runAfter\n   * are invoked immediately upon completion of the current cycle, before\n   * any request queued via runAsync. This method is primarily intended for\n   * internal use. Third-party callers using runAfter to schedule a callback\n   * that invokes {@link run} or {@link runAsync} should not use this method,\n   * but instead use {@link runAsync} with prerun or postrun arguments.\n   * @param {function(Dataflow)} callback - The callback function to run.\n   *   The callback will be invoked with this Dataflow instance as its\n   *   sole argument.\n   * @param {boolean} enqueue - A boolean flag indicating that the\n   *   callback should be queued up to run after the next propagation\n   *   cycle, suppressing immediate invocation when propagation is not\n   *   currently occurring.\n   * @param {number} [priority] - A priority value used to sort registered\n   *   callbacks to determine execution order. This argument is intended\n   *   for internal Vega use only.\n   */\n  function runAfter(callback, enqueue, priority) {\n    if (this._pulse || enqueue) {\n      // pulse propagation is currently running, queue to run after\n      this._postrun.push({\n        priority: priority || 0,\n        callback: callback\n      });\n    } else {\n      // pulse propagation already complete, invoke immediately\n      try {\n        callback(this);\n      } catch (err) {\n        this.error(err);\n      }\n    }\n  }\n\n  /**\n   * Raise an error for re-entrant dataflow evaluation.\n   */\n  function reentrant(df) {\n    df.error('Dataflow already running. Use runAsync() to chain invocations.');\n    return df;\n  }\n\n  /**\n   * Enqueue an operator into the priority queue for evaluation. The operator\n   * will be enqueued if it has no registered pulse for the current cycle, or if\n   * the force argument is true. Upon enqueue, this method also sets the\n   * operator's qrank to the current rank value.\n   * @param {Operator} op - The operator to enqueue.\n   * @param {boolean} [force] - A flag indicating if the operator should be\n   *   forceably added to the queue, even if it has already been previously\n   *   enqueued during the current pulse propagation. This is useful when the\n   *   dataflow graph is dynamically modified and the operator rank changes.\n   */\n  function enqueue(op, force) {\n    const q = op.stamp < this._clock;\n    if (q) op.stamp = this._clock;\n    if (q || force) {\n      op.qrank = op.rank;\n      this._heap.push(op);\n    }\n  }\n\n  /**\n   * Provide a correct pulse for evaluating an operator. If the operator has an\n   * explicit source operator, we will try to pull the pulse(s) from it.\n   * If there is an array of source operators, we build a multi-pulse.\n   * Otherwise, we return a current pulse with correct source data.\n   * If the pulse is the pulse map has an explicit target set, we use that.\n   * Else if the pulse on the upstream source operator is current, we use that.\n   * Else we use the pulse from the pulse map, but copy the source tuple array.\n   * @param {Operator} op - The operator for which to get an input pulse.\n   * @param {string} [encode] - An (optional) encoding set name with which to\n   *   annotate the returned pulse. See {@link run} for more information.\n   */\n  function getPulse(op, encode) {\n    const s = op.source,\n      stamp = this._clock;\n    return s && vegaUtil.isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n  }\n  function singlePulse(p, s) {\n    if (s && s.stamp === p.stamp) {\n      return s;\n    }\n    p = p.fork();\n    if (s && s !== StopPropagation) {\n      p.source = s.source;\n    }\n    return p;\n  }\n\n  const NO_OPT = {\n    skip: false,\n    force: false\n  };\n\n  /**\n   * Touches an operator, scheduling it to be evaluated. If invoked outside of\n   * a pulse propagation, the operator will be evaluated the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the operator\n   * will be queued for evaluation if and only if the operator has not yet been\n   * evaluated on the current propagation timestamp.\n   * @param {Operator} op - The operator to touch.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function touch(op, options) {\n    const opt = options || NO_OPT;\n    if (this._pulse) {\n      // if in midst of propagation, add to priority queue\n      this._enqueue(op);\n    } else {\n      // otherwise, queue for next propagation\n      this._touched.add(op);\n    }\n    if (opt.skip) op.skip(true);\n    return this;\n  }\n\n  /**\n   * Updates the value of the given operator.\n   * @param {Operator} op - The operator to update.\n   * @param {*} value - The value to set.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function update(op, value, options) {\n    const opt = options || NO_OPT;\n    if (op.set(value) || opt.force) {\n      this.touch(op, opt);\n    }\n    return this;\n  }\n\n  /**\n   * Pulses an operator with a changeset of tuples. If invoked outside of\n   * a pulse propagation, the pulse will be applied the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n   * will be added to the set of active pulses and will be applied if and\n   * only if the target operator has not yet been evaluated on the current\n   * propagation timestamp.\n   * @param {Operator} op - The operator to pulse.\n   * @param {ChangeSet} value - The tuple changeset to apply.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n  function pulse(op, changeset, options) {\n    this.touch(op, options || NO_OPT);\n    const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n      t = op.pulse && op.pulse.source || [];\n    p.target = op;\n    this._input[op.id] = changeset.pulse(p, t);\n    return this;\n  }\n\n  function Heap(cmp) {\n    let nodes = [];\n    return {\n      clear: () => nodes = [],\n      size: () => nodes.length,\n      peek: () => nodes[0],\n      push: x => {\n        nodes.push(x);\n        return siftdown(nodes, 0, nodes.length - 1, cmp);\n      },\n      pop: () => {\n        const last = nodes.pop();\n        let item;\n        if (nodes.length) {\n          item = nodes[0];\n          nodes[0] = last;\n          siftup(nodes, 0, cmp);\n        } else {\n          item = last;\n        }\n        return item;\n      }\n    };\n  }\n  function siftdown(array, start, idx, cmp) {\n    let parent, pidx;\n    const item = array[idx];\n    while (idx > start) {\n      pidx = idx - 1 >> 1;\n      parent = array[pidx];\n      if (cmp(item, parent) < 0) {\n        array[idx] = parent;\n        idx = pidx;\n        continue;\n      }\n      break;\n    }\n    return array[idx] = item;\n  }\n  function siftup(array, idx, cmp) {\n    const start = idx,\n      end = array.length,\n      item = array[idx];\n    let cidx = (idx << 1) + 1,\n      ridx;\n    while (cidx < end) {\n      ridx = cidx + 1;\n      if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n        cidx = ridx;\n      }\n      array[idx] = array[cidx];\n      idx = cidx;\n      cidx = (idx << 1) + 1;\n    }\n    array[idx] = item;\n    return siftdown(array, start, idx, cmp);\n  }\n\n  /**\n   * A dataflow graph for reactive processing of data streams.\n   * @constructor\n   */\n  function Dataflow() {\n    this.logger(vegaUtil.logger());\n    this.logLevel(vegaUtil.Error);\n    this._clock = 0;\n    this._rank = 0;\n    this._locale = vegaFormat.defaultLocale();\n    try {\n      this._loader = vegaLoader.loader();\n    } catch (e) {\n      // do nothing if loader module is unavailable\n    }\n    this._touched = UniqueList(vegaUtil.id);\n    this._input = {};\n    this._pulse = null;\n    this._heap = Heap((a, b) => a.qrank - b.qrank);\n    this._postrun = [];\n  }\n  function logMethod(method) {\n    return function () {\n      return this._log[method].apply(this, arguments);\n    };\n  }\n  Dataflow.prototype = {\n    /**\n     * The current timestamp of this dataflow. This value reflects the\n     * timestamp of the previous dataflow run. The dataflow is initialized\n     * with a stamp value of 0. The initial run of the dataflow will have\n     * a timestap of 1, and so on. This value will match the\n     * {@link Pulse.stamp} property.\n     * @return {number} - The current timestamp value.\n     */\n    stamp() {\n      return this._clock;\n    },\n    /**\n     * Gets or sets the loader instance to use for data file loading. A\n     * loader object must provide a \"load\" method for loading files and a\n     * \"sanitize\" method for checking URL/filename validity. Both methods\n     * should accept a URI and options hash as arguments, and return a Promise\n     * that resolves to the loaded file contents (load) or a hash containing\n     * sanitized URI data with the sanitized url assigned to the \"href\" property\n     * (sanitize).\n     * @param {object} _ - The loader instance to use.\n     * @return {object|Dataflow} - If no arguments are provided, returns\n     *   the current loader instance. Otherwise returns this Dataflow instance.\n     */\n    loader(_) {\n      if (arguments.length) {\n        this._loader = _;\n        return this;\n      } else {\n        return this._loader;\n      }\n    },\n    /**\n     * Gets or sets the locale instance to use for formatting and parsing\n     * string values. The locale object should be provided by the\n     * vega-format library, and include methods such as format, timeFormat,\n     * utcFormat, timeParse, and utcParse.\n     * @param {object} _ - The locale instance to use.\n     * @return {object|Dataflow} - If no arguments are provided, returns\n     *   the current locale instance. Otherwise returns this Dataflow instance.\n     */\n    locale(_) {\n      if (arguments.length) {\n        this._locale = _;\n        return this;\n      } else {\n        return this._locale;\n      }\n    },\n    /**\n     * Get or set the logger instance used to log messages. If no arguments are\n     * provided, returns the current logger instance. Otherwise, sets the logger\n     * and return this Dataflow instance. Provided loggers must support the full\n     * API of logger objects generated by the vega-util logger method. Note that\n     * by default the log level of the new logger will be used; use the logLevel\n     * method to adjust the log level as needed.\n     */\n    logger(logger) {\n      if (arguments.length) {\n        this._log = logger;\n        return this;\n      } else {\n        return this._log;\n      }\n    },\n    /**\n     * Logs an error message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit error messages.\n     */\n    error: logMethod('error'),\n    /**\n     * Logs a warning message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit warning messages.\n     */\n    warn: logMethod('warn'),\n    /**\n     * Logs a information message. By default, logged messages are written to\n     * console output. The message will only be logged if the current log level is\n     * high enough to permit information messages.\n     */\n    info: logMethod('info'),\n    /**\n     * Logs a debug message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit debug messages.\n     */\n    debug: logMethod('debug'),\n    /**\n     * Get or set the current log level. If an argument is provided, it\n     * will be used as the new log level.\n     * @param {number} [level] - Should be one of None, Warn, Info\n     * @return {number} - The current log level.\n     */\n    logLevel: logMethod('level'),\n    /**\n     * Empty entry threshold for garbage cleaning. Map data structures will\n     * perform cleaning once the number of empty entries exceeds this value.\n     */\n    cleanThreshold: 1e4,\n    // OPERATOR REGISTRATION\n    add,\n    connect,\n    rank,\n    rerank,\n    // OPERATOR UPDATES\n    pulse,\n    touch,\n    update,\n    changeset,\n    // DATA LOADING\n    ingest,\n    parse,\n    preload,\n    request,\n    // EVENT HANDLING\n    events,\n    on,\n    // PULSE PROPAGATION\n    evaluate,\n    run,\n    runAsync,\n    runAfter,\n    _enqueue: enqueue,\n    _getPulse: getPulse\n  };\n\n  /**\n   * Abstract class for operators that process data tuples.\n   * Subclasses must provide a {@link transform} method for operator processing.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {Operator} [source] - The operator from which to receive pulses.\n   */\n  function Transform(init, params) {\n    Operator.call(this, init, null, params);\n  }\n  vegaUtil.inherits(Transform, Operator, {\n    /**\n     * Overrides {@link Operator.evaluate} for transform operators.\n     * Internally, this method calls {@link evaluate} to perform processing.\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return the output pulse for this operator (or StopPropagation)\n     */\n    run(pulse) {\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n      let rv;\n      if (this.skip()) {\n        this.skip(false);\n      } else {\n        rv = this.evaluate(pulse);\n      }\n      rv = rv || pulse;\n      if (rv.then) {\n        rv = rv.then(_ => this.pulse = _);\n      } else if (rv !== pulse.StopPropagation) {\n        this.pulse = rv;\n      }\n      return rv;\n    },\n    /**\n     * Overrides {@link Operator.evaluate} for transform operators.\n     * Marshalls parameter values and then invokes {@link transform}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n         value (including undefined) will let the input pulse pass through.\n    */\n    evaluate(pulse) {\n      const params = this.marshall(pulse.stamp),\n        out = this.transform(params, pulse);\n      params.clear();\n      return out;\n    },\n    /**\n     * Process incoming pulses.\n     * Subclasses should override this method to implement transforms.\n     * @param {Parameters} _ - The operator parameter values.\n     * @param {Pulse} pulse - The current dataflow pulse.\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n     *   value (including undefined) will let the input pulse pass through.\n     */\n    transform() {}\n  });\n\n  const transforms = {};\n  function definition(type) {\n    const t = transform(type);\n    return t && t.Definition || null;\n  }\n  function transform(type) {\n    type = type && type.toLowerCase();\n    return vegaUtil.hasOwnProperty(transforms, type) ? transforms[type] : null;\n  }\n\n  exports.Dataflow = Dataflow;\n  exports.EventStream = EventStream;\n  exports.MultiPulse = MultiPulse;\n  exports.Operator = Operator;\n  exports.Parameters = Parameters;\n  exports.Pulse = Pulse;\n  exports.Transform = Transform;\n  exports.UniqueList = UniqueList;\n  exports.asyncCallback = asyncCallback;\n  exports.changeset = changeset;\n  exports.definition = definition;\n  exports.derive = derive;\n  exports.ingest = ingest$1;\n  exports.isChangeSet = isChangeSet;\n  exports.isTuple = isTuple;\n  exports.rederive = rederive;\n  exports.replace = replace;\n  exports.stableCompare = stableCompare;\n  exports.transform = transform;\n  exports.transforms = transforms;\n  exports.tupleid = tupleid;\n\n}));\n\n};"],
"names":["shadow$provide","require","module","exports","global","factory","define","amd","globalThis","self","vega","vegaUtil","vegaLoader","vegaFormat","UniqueList","idFunc","$","identity","list","ids","add","_","list.add","id","push","remove","list.remove","idx","indexOf","splice","asyncCallback","df","callback","err","error","tupleid","t","TUPLE_ID_KEY","ingest$1","datum","Object","data","rederive","d","k","isChangeSet","v","constructor","changeset","rem","mod","remp","modp","clean","reflow","insert","array","n","length","i","a","isFunction","modify","field","value","m","constant","filter","tuple","encode","set","pulse","tuples","f","out","cur","forEach","modifies","slice","Parameters","defineProperty","CACHE","writable","Operator","init","update","params","react","OP_ID","qrank","rank","stamp","flags","_update","parameters","flag","bit","state","arguments","EventStream","apply","receive","STREAM_ID","_filter","_apply","stream","loadPending","accept","pending","Promise","requests","done","pending.done","_pending","onStream","target","options","opt","extend","SKIP","op","undefined","func","e","touch","evaluate","onOperator","source","targets","updater","modified","force","skip","connect","Pulse","dataflow","fields","materialize","visitArray","map","visit","addFilter","b","MultiPulse","pulses","c","hash","p","changed","ADD","REM","MOD","changes","reentrant","singlePulse","s","fork","StopPropagation","Heap","cmp","nodes","clear","size","peek","x","siftdown","pop","last","item","start","end","cidx","ridx","parent","pidx","Dataflow","logger","logLevel","Error","_rank","_clock","_locale","defaultLocale","_loader","loader","_touched","_input","_pulse","_heap","_postrun","logMethod","method","_log","Transform","call","transform","type","toLowerCase","hasOwnProperty","transforms","Symbol","TUPLE_ID","prototype","name","index","o","isArray","NO_PARAMS","_targets","SKIP$1","MODIFIED","initonly","argval","_argval","argops","_argops","deps","PULSE","Array","marshall","detach","run","rv","truthy","consume","_consume","evt","val","trg","preventDefault","stopPropagation","merge","throttle","pause","now","Date","debounce","delay","between","active","ADD_REM","ADD_MOD","ALL","REFLOW","SOURCE","NO_SOURCE","NO_FIELDS","clone","addAll","src","addF","remF","modF","srcF","cleans","runAfter","len","nomod","some","visitor","sum","inherits","NO_OPT","locale","warn","info","debug","cleanThreshold","shift","sources","targetRank","rerank","queue","_enqueue","ingest","format","parse","read","timeParse","utcParse","preload","url","res","request","status","load","context","response","responseType","events","send","document","querySelectorAll","addEventListener","on","fn","prerun","postrun","async","count","next","_getPulse","then","pr","sort","priority","all","cb","runAsync","_running","enqueue","q","getPulse","definition","Definition","derive","isTuple","replace","stableCompare"]
}
