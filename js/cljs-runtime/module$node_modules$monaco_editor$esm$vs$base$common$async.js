shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$async = function(require, module, exports) {
  function isThenable(obj) {
    return !!obj && typeof obj.then === "function";
  }
  function createCancelablePromise(callback) {
    const source = new require$_DOT__SLASH_cancellation_DOT_js.CancellationTokenSource(), thenable = callback(source.token), promise = new Promise((resolve, reject) => {
      const subscription = source.token.onCancellationRequested(() => {
        subscription.dispose();
        source.dispose();
        reject(new require$_DOT__SLASH_errors_DOT_js.CancellationError());
      });
      Promise.resolve(thenable).then(value => {
        subscription.dispose();
        source.dispose();
        resolve(value);
      }, err => {
        subscription.dispose();
        source.dispose();
        reject(err);
      });
    });
    return new class {
      cancel() {
        source.cancel();
      }
      then(resolve, reject) {
        return promise.then(resolve, reject);
      }
      catch(reject) {
        return this.then(void 0, reject);
      }
      finally(onfinally) {
        return promise.finally(onfinally);
      }
    }();
  }
  function raceCancellation(promise, token, defaultValue) {
    return new Promise((resolve, reject) => {
      const ref = token.onCancellationRequested(() => {
        ref.dispose();
        resolve(defaultValue);
      });
      promise.then(resolve, reject).finally(() => ref.dispose());
    });
  }
  function timeout(millis, token) {
    return token ? new Promise((resolve, reject) => {
      const handle = setTimeout(() => {
        disposable.dispose();
        resolve();
      }, millis), disposable = token.onCancellationRequested(() => {
        clearTimeout(handle);
        disposable.dispose();
        reject(new require$_DOT__SLASH_errors_DOT_js.CancellationError());
      });
    }) : createCancelablePromise(token => timeout(millis, token));
  }
  function disposableTimeout(handler, timeout = 0, store) {
    const timer = setTimeout(() => {
      handler();
      store && disposable.dispose();
    }, timeout), disposable = (0,require$_DOT__SLASH_lifecycle_DOT_js.toDisposable)(() => {
      clearTimeout(timer);
      store === null || store === void 0 || store.deleteAndLeak(disposable);
    });
    store === null || store === void 0 || store.add(disposable);
    return disposable;
  }
  function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {
    let index = 0;
    const len = promiseFactories.length, loop = () => {
      if (index >= len) {
        return Promise.resolve(defaultValue);
      }
      const factory = promiseFactories[index++];
      return Promise.resolve(factory()).then(result => shouldStop(result) ? Promise.resolve(result) : loop());
    };
    return loop();
  }
  function createCancelableAsyncIterable(callback) {
    const source = new require$_DOT__SLASH_cancellation_DOT_js.CancellationTokenSource(), innerIterable = callback(source.token);
    return new CancelableAsyncIterableObject(source, async emitter => {
      const subscription = source.token.onCancellationRequested(() => {
        subscription.dispose();
        source.dispose();
        emitter.reject(new require$_DOT__SLASH_errors_DOT_js.CancellationError());
      });
      try {
        for await (const item of innerIterable) {
          if (source.token.isCancellationRequested) {
            return;
          }
          emitter.emitOne(item);
        }
        subscription.dispose();
        source.dispose();
      } catch (err) {
        subscription.dispose(), source.dispose(), emitter.reject(err);
      }
    });
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AbstractIdleValue:{enumerable:!0, get:function() {
    return AbstractIdleValue;
  }}, AsyncIterableObject:{enumerable:!0, get:function() {
    return AsyncIterableObject;
  }}, CancelableAsyncIterableObject:{enumerable:!0, get:function() {
    return CancelableAsyncIterableObject;
  }}, DeferredPromise:{enumerable:!0, get:function() {
    return DeferredPromise;
  }}, Delayer:{enumerable:!0, get:function() {
    return Delayer;
  }}, GlobalIdleValue:{enumerable:!0, get:function() {
    return GlobalIdleValue;
  }}, IntervalTimer:{enumerable:!0, get:function() {
    return IntervalTimer;
  }}, Promises:{enumerable:!0, get:function() {
    return Promises;
  }}, RunOnceScheduler:{enumerable:!0, get:function() {
    return RunOnceScheduler;
  }}, ThrottledDelayer:{enumerable:!0, get:function() {
    return ThrottledDelayer;
  }}, Throttler:{enumerable:!0, get:function() {
    return Throttler;
  }}, TimeoutTimer:{enumerable:!0, get:function() {
    return TimeoutTimer;
  }}, _runWhenIdle:{enumerable:!0, get:function() {
    return _runWhenIdle;
  }}, createCancelableAsyncIterable:{enumerable:!0, get:function() {
    return createCancelableAsyncIterable;
  }}, createCancelablePromise:{enumerable:!0, get:function() {
    return createCancelablePromise;
  }}, disposableTimeout:{enumerable:!0, get:function() {
    return disposableTimeout;
  }}, first:{enumerable:!0, get:function() {
    return first;
  }}, isThenable:{enumerable:!0, get:function() {
    return isThenable;
  }}, raceCancellation:{enumerable:!0, get:function() {
    return raceCancellation;
  }}, runWhenGlobalIdle:{enumerable:!0, get:function() {
    return runWhenGlobalIdle;
  }}, timeout:{enumerable:!0, get:function() {
    return timeout;
  }}});
  var require$_DOT__SLASH_cancellation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$cancellation"), require$_DOT__SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__SLASH_platform_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), 
  require$_DOT__SLASH_symbols_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$symbols");
  class Throttler {
    constructor() {
      this.isDisposed = !1;
      this.queuedPromiseFactory = this.queuedPromise = this.activePromise = null;
    }
    queue(promiseFactory) {
      if (this.isDisposed) {
        return Promise.reject(Error("Throttler is disposed"));
      }
      if (this.activePromise) {
        this.queuedPromiseFactory = promiseFactory;
        if (!this.queuedPromise) {
          const onComplete = () => {
            this.queuedPromise = null;
            if (!this.isDisposed) {
              var result = this.queue(this.queuedPromiseFactory);
              this.queuedPromiseFactory = null;
              return result;
            }
          };
          this.queuedPromise = new Promise(resolve => {
            this.activePromise.then(onComplete, onComplete).then(resolve);
          });
        }
        return new Promise((resolve, reject) => {
          this.queuedPromise.then(resolve, reject);
        });
      }
      this.activePromise = promiseFactory();
      return new Promise((resolve, reject) => {
        this.activePromise.then(result => {
          this.activePromise = null;
          resolve(result);
        }, err => {
          this.activePromise = null;
          reject(err);
        });
      });
    }
    dispose() {
      this.isDisposed = !0;
    }
  }
  const timeoutDeferred = (timeout, fn) => {
    let scheduled = !0;
    const handle = setTimeout(() => {
      scheduled = !1;
      fn();
    }, timeout);
    return {isTriggered:() => scheduled, dispose:() => {
      clearTimeout(handle);
      scheduled = !1;
    }};
  }, microtaskDeferred = fn => {
    let scheduled = !0;
    queueMicrotask(() => {
      scheduled && (scheduled = !1, fn());
    });
    return {isTriggered:() => scheduled, dispose:() => {
      scheduled = !1;
    }};
  };
  class Delayer {
    constructor(defaultDelay) {
      this.defaultDelay = defaultDelay;
      this.task = this.doReject = this.doResolve = this.completionPromise = this.deferred = null;
    }
    trigger(task, delay = this.defaultDelay) {
      this.task = task;
      this.cancelTimeout();
      this.completionPromise || (this.completionPromise = (new Promise((resolve, reject) => {
        this.doResolve = resolve;
        this.doReject = reject;
      })).then(() => {
        this.doResolve = this.completionPromise = null;
        if (this.task) {
          const task = this.task;
          this.task = null;
          return task();
        }
      }));
      task = () => {
        var _a;
        this.deferred = null;
        (_a = this.doResolve) === null || _a === void 0 || _a.call(this, null);
      };
      this.deferred = delay === require$_DOT__SLASH_symbols_DOT_js.MicrotaskDelay ? microtaskDeferred(task) : timeoutDeferred(delay, task);
      return this.completionPromise;
    }
    isTriggered() {
      var _a;
      return !((_a = this.deferred) === null || _a === void 0 || !_a.isTriggered());
    }
    cancel() {
      var _a;
      this.cancelTimeout();
      this.completionPromise && ((_a = this.doReject) === null || _a === void 0 || _a.call(this, new require$_DOT__SLASH_errors_DOT_js.CancellationError()), this.completionPromise = null);
    }
    cancelTimeout() {
      var _a;
      (_a = this.deferred) === null || _a === void 0 || _a.dispose();
      this.deferred = null;
    }
    dispose() {
      this.cancel();
    }
  }
  class ThrottledDelayer {
    constructor(defaultDelay) {
      this.delayer = new Delayer(defaultDelay);
      this.throttler = new Throttler();
    }
    trigger(promiseFactory, delay) {
      return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
    }
    cancel() {
      this.delayer.cancel();
    }
    dispose() {
      this.delayer.dispose();
      this.throttler.dispose();
    }
  }
  class TimeoutTimer {
    constructor(runner, timeout) {
      this._token = -1;
      typeof runner === "function" && typeof timeout === "number" && this.setIfNotSet(runner, timeout);
    }
    dispose() {
      this.cancel();
    }
    cancel() {
      this._token !== -1 && (clearTimeout(this._token), this._token = -1);
    }
    cancelAndSet(runner, timeout) {
      this.cancel();
      this._token = setTimeout(() => {
        this._token = -1;
        runner();
      }, timeout);
    }
    setIfNotSet(runner, timeout) {
      this._token === -1 && (this._token = setTimeout(() => {
        this._token = -1;
        runner();
      }, timeout));
    }
  }
  class IntervalTimer {
    constructor() {
      this.disposable = void 0;
    }
    cancel() {
      var _a;
      (_a = this.disposable) === null || _a === void 0 || _a.dispose();
      this.disposable = void 0;
    }
    cancelAndSet(runner, interval, context = globalThis) {
      this.cancel();
      const handle = context.setInterval(() => {
        runner();
      }, interval);
      this.disposable = (0,require$_DOT__SLASH_lifecycle_DOT_js.toDisposable)(() => {
        context.clearInterval(handle);
        this.disposable = void 0;
      });
    }
    dispose() {
      this.cancel();
    }
  }
  class RunOnceScheduler {
    constructor(runner, delay) {
      this.timeoutToken = -1;
      this.runner = runner;
      this.timeout = delay;
      this.timeoutHandler = this.onTimeout.bind(this);
    }
    dispose() {
      this.cancel();
      this.runner = null;
    }
    cancel() {
      this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
    }
    schedule(delay = this.timeout) {
      this.cancel();
      this.timeoutToken = setTimeout(this.timeoutHandler, delay);
    }
    get delay() {
      return this.timeout;
    }
    set delay(value) {
      this.timeout = value;
    }
    isScheduled() {
      return this.timeoutToken !== -1;
    }
    onTimeout() {
      this.timeoutToken = -1;
      this.runner && this.doRun();
    }
    doRun() {
      var _a;
      (_a = this.runner) === null || _a === void 0 || _a.call(this);
    }
  }
  let runWhenGlobalIdle, _runWhenIdle;
  (function() {
    _runWhenIdle = typeof globalThis.requestIdleCallback !== "function" || typeof globalThis.cancelIdleCallback !== "function" ? (_targetWindow, runner) => {
      (0,require$_DOT__SLASH_platform_DOT_js.setTimeout0)(() => {
        if (!disposed) {
          var end = Date.now() + 15;
          runner(Object.freeze({didTimeout:!0, timeRemaining() {
            return Math.max(0, end - Date.now());
          }}));
        }
      });
      let disposed = !1;
      return {dispose() {
        disposed ||= !0;
      }};
    } : (targetWindow, runner, timeout) => {
      const handle = targetWindow.requestIdleCallback(runner, typeof timeout === "number" ? {timeout} : void 0);
      let disposed = !1;
      return {dispose() {
        disposed || (disposed = !0, targetWindow.cancelIdleCallback(handle));
      }};
    };
    runWhenGlobalIdle = runner => _runWhenIdle(globalThis, runner);
  })();
  class AbstractIdleValue {
    constructor(targetWindow, executor) {
      this._didRun = !1;
      this._executor = () => {
        try {
          this._value = executor();
        } catch (err) {
          this._error = err;
        } finally {
          this._didRun = !0;
        }
      };
      this._handle = _runWhenIdle(targetWindow, () => this._executor());
    }
    dispose() {
      this._handle.dispose();
    }
    get value() {
      this._didRun || (this._handle.dispose(), this._executor());
      if (this._error) {
        throw this._error;
      }
      return this._value;
    }
    get isInitialized() {
      return this._didRun;
    }
  }
  class GlobalIdleValue extends AbstractIdleValue {
    constructor(executor) {
      super(globalThis, executor);
    }
  }
  class DeferredPromise {
    get isRejected() {
      var _a;
      return ((_a = this.outcome) === null || _a === void 0 ? void 0 : _a.outcome) === 1;
    }
    get isSettled() {
      return !!this.outcome;
    }
    constructor() {
      this.p = new Promise((c, e) => {
        this.completeCallback = c;
        this.errorCallback = e;
      });
    }
    complete(value) {
      return new Promise(resolve => {
        this.completeCallback(value);
        this.outcome = {outcome:0, value};
        resolve();
      });
    }
    error(err) {
      return new Promise(resolve => {
        this.errorCallback(err);
        this.outcome = {outcome:1, value:err};
        resolve();
      });
    }
    cancel() {
      return this.error(new require$_DOT__SLASH_errors_DOT_js.CancellationError());
    }
  }
  var Promises;
  (function(Promises) {
    Promises.settled = async function(promises) {
      let firstError = void 0;
      promises = await Promise.all(promises.map(promise => promise.then(value => value, error => {
        firstError ||= error;
      })));
      if (typeof firstError !== "undefined") {
        throw firstError;
      }
      return promises;
    };
    Promises.withAsyncBody = function(bodyFn) {
      return new Promise(async(resolve, reject) => {
        try {
          await bodyFn(resolve, reject);
        } catch (error) {
          reject(error);
        }
      });
    };
  })(Promises ||= {});
  class AsyncIterableObject {
    static fromArray(items) {
      return new AsyncIterableObject(writer => {
        writer.emitMany(items);
      });
    }
    static fromPromise(promise) {
      return new AsyncIterableObject(async emitter => {
        emitter.emitMany(await promise);
      });
    }
    static fromPromises(promises) {
      return new AsyncIterableObject(async emitter => {
        await Promise.all(promises.map(async p => emitter.emitOne(await p)));
      });
    }
    static merge(iterables) {
      return new AsyncIterableObject(async emitter => {
        await Promise.all(iterables.map(async iterable => {
          for await (const item of iterable) {
            emitter.emitOne(item);
          }
        }));
      });
    }
    constructor(executor) {
      this._state = 0;
      this._results = [];
      this._error = null;
      this._onStateChanged = new require$_DOT__SLASH_event_DOT_js.Emitter();
      queueMicrotask(async() => {
        const writer = {emitOne:item => this.emitOne(item), emitMany:items => this.emitMany(items), reject:error => this.reject(error)};
        try {
          await Promise.resolve(executor(writer)), this.resolve();
        } catch (err) {
          this.reject(err);
        } finally {
          writer.emitOne = void 0, writer.emitMany = void 0, writer.reject = void 0;
        }
      });
    }
    [Symbol.asyncIterator]() {
      let i = 0;
      return {next:async() => {
        do {
          if (this._state === 2) {
            throw this._error;
          }
          if (i < this._results.length) {
            return {done:!1, value:this._results[i++]};
          }
          if (this._state === 1) {
            return {done:!0, value:void 0};
          }
          await require$_DOT__SLASH_event_DOT_js.Event.toPromise(this._onStateChanged.event);
        } while (1);
      }};
    }
    static map(iterable, mapFn) {
      return new AsyncIterableObject(async emitter => {
        for await (const item of iterable) {
          emitter.emitOne(mapFn(item));
        }
      });
    }
    map(mapFn) {
      return AsyncIterableObject.map(this, mapFn);
    }
    static filter(iterable, filterFn) {
      return new AsyncIterableObject(async emitter => {
        for await (const item of iterable) {
          filterFn(item) && emitter.emitOne(item);
        }
      });
    }
    filter(filterFn) {
      return AsyncIterableObject.filter(this, filterFn);
    }
    static coalesce(iterable) {
      return AsyncIterableObject.filter(iterable, item => !!item);
    }
    coalesce() {
      return AsyncIterableObject.coalesce(this);
    }
    static async toPromise(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return result;
    }
    toPromise() {
      return AsyncIterableObject.toPromise(this);
    }
    emitOne(value) {
      this._state === 0 && (this._results.push(value), this._onStateChanged.fire());
    }
    emitMany(values) {
      this._state === 0 && (this._results = this._results.concat(values), this._onStateChanged.fire());
    }
    resolve() {
      this._state === 0 && (this._state = 1, this._onStateChanged.fire());
    }
    reject(error) {
      this._state === 0 && (this._state = 2, this._error = error, this._onStateChanged.fire());
    }
  }
  AsyncIterableObject.EMPTY = AsyncIterableObject.fromArray([]);
  class CancelableAsyncIterableObject extends AsyncIterableObject {
    constructor(_source, executor) {
      super(executor);
      this._source = _source;
    }
    cancel() {
      this._source.cancel();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$async.js.map
