shadow$provide.module$node_modules$vega_time$build$vega_time = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega_util$build$vega_util")) : typeof define === "function" && define.amd ? define(["exports", "vega-util"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.vega = {}, global.vega));
  })(this, function(exports, vegaUtil) {
    function timeUnits(units) {
      const u = vegaUtil.array(units).slice(), m = {};
      u.length || vegaUtil.error("Missing time unit.");
      u.forEach(unit => {
        vegaUtil.hasOwnProperty(UNITS, unit) ? m[unit] = 1 : vegaUtil.error(`Invalid time unit: ${unit}.`);
      });
      (m.week || m.day ? 1 : 0) + (m.quarter || m.month || m.date ? 1 : 0) + (m.dayofyear ? 1 : 0) > 1 && vegaUtil.error(`Incompatible time units: ${units}`);
      u.sort((a, b) => UNITS[a] - UNITS[b]);
      return u;
    }
    function timeInterval$1(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
      }
      interval.floor = date => (floori(date = new Date(+date)), date);
      interval.ceil = date => (floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date);
      interval.round = date => {
        const d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };
      interval.offset = (date, step) => (offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date);
      interval.range = (start, stop, step) => {
        const range = [];
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop && step > 0)) {
          return range;
        }
        let previous;
        do {
          range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        } while (previous < start && start < stop);
        return range;
      };
      interval.filter = test => timeInterval$1(date => {
        if (date >= date) {
          for (; floori(date), !test(date);) {
            date.setTime(date - 1);
          }
        }
      }, (date, step) => {
        if (date >= date) {
          if (step < 0) {
            for (; ++step <= 0;) {
              for (; offseti(date, -1), !test(date);) {
              }
            }
          } else {
            for (; --step >= 0;) {
              for (; offseti(date, 1), !test(date);) {
              }
            }
          }
        }
      });
      count && (interval.count = (start, end) => {
        t0$1.setTime(+start);
        t1.setTime(+end);
        floori(t0$1);
        floori(t1);
        return Math.floor(count(t0$1, t1));
      }, interval.every = step => {
        step = Math.floor(step);
        return isFinite(step) && step > 0 ? step > 1 ? interval.filter(field ? d => field(d) % step === 0 : d => interval.count(0, d) % step === 0) : interval : null;
      });
      return interval;
    }
    function timeWeekday(i) {
      return timeInterval$1(date => {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setDate(date.getDate() + step * 7);
      }, (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6E4) / 6048E5);
    }
    function utcWeekday(i) {
      return timeInterval$1(date => {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, (start, end) => (end - start) / 6048E5);
    }
    function ascending(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    function descending(a, b) {
      return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
    function bisector(f) {
      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) {
            return hi;
          }
          do {
            const mid = lo + hi >>> 1;
            compare2(a[mid], x) < 0 ? lo = mid + 1 : hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      let compare1, compare2, delta;
      f.length !== 2 ? (compare1 = ascending, compare2 = (d, x) => ascending(f(d), x), delta = (d, x) => f(d) - x) : (compare1 = f === ascending || f === descending ? f : zero, delta = compare2 = f);
      return {left, center:function(a, x, lo = 0, hi = a.length) {
        hi = left(a, x, lo, hi - 1);
        return hi > lo && delta(a[hi - 1], x) > -delta(a[hi], x) ? hi - 1 : hi;
      }, right:function(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) {
            return hi;
          }
          do {
            const mid = lo + hi >>> 1;
            compare2(a[mid], x) <= 0 ? lo = mid + 1 : hi = mid;
          } while (lo < hi);
        }
        return lo;
      }};
    }
    function zero() {
      return 0;
    }
    function tickSpec(start, stop, count) {
      var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step));
      step /= Math.pow(10, power);
      step = step >= e10 ? 10 : step >= e5 ? 5 : step >= e2 ? 2 : 1;
      let inc;
      power < 0 ? (inc = Math.pow(10, -power) / step, power = Math.round(start * inc), step = Math.round(stop * inc), power / inc < start && ++power, step / inc > stop && --step, inc = -inc) : (inc = Math.pow(10, power) * step, power = Math.round(start / inc), step = Math.round(stop / inc), power * inc < start && ++power, step * inc > stop && --step);
      return step < power && 0.5 <= count && count < 2 ? tickSpec(start, stop, count * 2) : [power, step, inc];
    }
    function tickIncrement(start, stop, count) {
      return tickSpec(+start, +stop, +count)[2];
    }
    function tickStep(start, stop, count) {
      stop = +stop;
      start = +start;
      count = +count;
      const reverse = stop < start;
      start = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
      return (reverse ? -1 : 1) * (start < 0 ? 1 / -start : start);
    }
    function localYear(y) {
      t0.setFullYear(y);
      t0.setMonth(0);
      t0.setDate(1);
      t0.setHours(0, 0, 0, 0);
      return t0;
    }
    function localDayOfYear(d) {
      return timeDay.count(localYear(d.getFullYear()) - 1, d);
    }
    function localWeekNum(d) {
      return timeSunday.count(localYear(d.getFullYear()) - 1, d);
    }
    function localDate(y, m, d, H, M, S, L) {
      return 0 <= y && y < 100 ? (m = new Date(-1, m, d, H, M, S, L), m.setFullYear(y), m) : new Date(y, m, d, H, M, S, L);
    }
    function utcDayOfYear(d) {
      const y = Date.UTC(d.getUTCFullYear(), 0, 1);
      return utcDay.count(y - 1, d);
    }
    function utcWeekNum(d) {
      const y = Date.UTC(d.getUTCFullYear(), 0, 1);
      return utcSunday.count(y - 1, d);
    }
    function utcFirst(y) {
      t0.setTime(Date.UTC(y, 0, 1));
      return t0.getUTCDay();
    }
    function utcDate(y, m, d, H, M, S, L) {
      return 0 <= y && y < 100 ? (y = new Date(Date.UTC(-1, m, d, H, M, S, L)), y.setUTCFullYear(d.y), y) : new Date(Date.UTC(y, m, d, H, M, S, L));
    }
    function floor(units, step, get, inv, newDate) {
      const s = step || 1, b = vegaUtil.peek(units);
      step = (unit, p, key) => {
        key = key || unit;
        return getUnit(get[key], inv[key], unit === b && s, p);
      };
      const t = new Date();
      units = vegaUtil.toSet(units);
      const y = units.year ? step("year") : vegaUtil.constant(2012), m = units.month ? step("month") : units.quarter ? step("quarter") : vegaUtil.zero, d = units.week && units.day ? step("day", 1, "weekday") : units.week ? step("week", 1) : units.day ? step("day", 1) : units.date ? step("date", 1) : units.dayofyear ? step("dayofyear", 1) : vegaUtil.one, H = units.hours ? step("hours") : vegaUtil.zero, M = units.minutes ? step("minutes") : vegaUtil.zero, S = units.seconds ? step("seconds") : vegaUtil.zero, 
      L = units.milliseconds ? step("milliseconds") : vegaUtil.zero;
      return function(v) {
        t.setTime(+v);
        v = y(t);
        return newDate(v, m(t), d(t, v), H(t), M(t), S(t), L(t));
      };
    }
    function getUnit(f, inv, step, phase) {
      const u = step <= 1 ? f : phase ? (d, y) => phase + step * Math.floor((f(d, y) - phase) / step) : (d, y) => step * Math.floor(f(d, y) / step);
      return inv ? (d, y) => inv(u(d, y), y) : u;
    }
    function weekday(week, day, firstDay) {
      return day + week * 7 - (firstDay + 6) % 7;
    }
    const TIME_UNITS = "year quarter month week date day dayofyear hours minutes seconds milliseconds".split(" "), UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {}), defaultSpecifiers = {year:"%Y ", quarter:"Q%q ", month:"%b ", date:"%d ", week:"W%U ", day:"%a ", dayofyear:"%j ", hours:"%H:00", minutes:"00:%M", seconds:":%S", milliseconds:".%L", ["year-month"]:"%Y-%m ", ["year-month-date"]:"%Y-%m-%d ", ["hours-minutes"]:"%H:%M"}, t0$1 = new Date(), t1 = new Date(), millisecond = timeInterval$1(() => 
    {
    }, (date, step) => {
      date.setTime(+date + step);
    }, (start, end) => end - start);
    millisecond.every = k => {
      k = Math.floor(k);
      return isFinite(k) && k > 0 ? k > 1 ? timeInterval$1(date => {
        date.setTime(Math.floor(date / k) * k);
      }, (date, step) => {
        date.setTime(+date + step * k);
      }, (start, end) => (end - start) / k) : millisecond : null;
    };
    millisecond.range;
    var second = timeInterval$1(date => {
      date.setTime(date - date.getMilliseconds());
    }, (date, step) => {
      date.setTime(+date + step * 1000);
    }, (start, end) => (end - start) / 1000, date => date.getUTCSeconds());
    second.range;
    var timeMinute = timeInterval$1(date => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * 1000);
    }, (date, step) => {
      date.setTime(+date + step * 6E4);
    }, (start, end) => (end - start) / 6E4, date => date.getMinutes());
    timeMinute.range;
    var utcMinute = timeInterval$1(date => {
      date.setUTCSeconds(0, 0);
    }, (date, step) => {
      date.setTime(+date + step * 6E4);
    }, (start, end) => (end - start) / 6E4, date => date.getUTCMinutes());
    utcMinute.range;
    var timeHour = timeInterval$1(date => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * 1000 - date.getMinutes() * 6E4);
    }, (date, step) => {
      date.setTime(+date + step * 36E5);
    }, (start, end) => (end - start) / 36E5, date => date.getHours());
    timeHour.range;
    var utcHour = timeInterval$1(date => {
      date.setUTCMinutes(0, 0, 0);
    }, (date, step) => {
      date.setTime(+date + step * 36E5);
    }, (start, end) => (end - start) / 36E5, date => date.getUTCHours());
    utcHour.range;
    const timeDay = timeInterval$1(date => date.setHours(0, 0, 0, 0), (date, step) => date.setDate(date.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6E4) / 864E5, date => date.getDate() - 1);
    timeDay.range;
    const utcDay = timeInterval$1(date => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => (end - start) / 864E5, date => date.getUTCDate() - 1);
    utcDay.range;
    var unixDay = timeInterval$1(date => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => (end - start) / 864E5, date => Math.floor(date / 864E5));
    unixDay.range;
    const timeSunday = timeWeekday(0);
    unixDay = timeWeekday(1);
    var timeTuesday = timeWeekday(2), timeWednesday = timeWeekday(3), timeThursday = timeWeekday(4), timeFriday = timeWeekday(5), timeSaturday = timeWeekday(6);
    timeSunday.range;
    unixDay.range;
    timeTuesday.range;
    timeWednesday.range;
    timeThursday.range;
    timeFriday.range;
    timeSaturday.range;
    const utcSunday = utcWeekday(0);
    unixDay = utcWeekday(1);
    timeTuesday = utcWeekday(2);
    timeWednesday = utcWeekday(3);
    timeThursday = utcWeekday(4);
    timeFriday = utcWeekday(5);
    timeSaturday = utcWeekday(6);
    utcSunday.range;
    unixDay.range;
    timeTuesday.range;
    timeWednesday.range;
    timeThursday.range;
    timeFriday.range;
    timeSaturday.range;
    unixDay = timeInterval$1(date => {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setMonth(date.getMonth() + step);
    }, (start, end) => end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12, date => date.getMonth());
    unixDay.range;
    timeTuesday = timeInterval$1(date => {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, (start, end) => end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12, date => date.getUTCMonth());
    timeTuesday.range;
    timeWednesday = timeInterval$1(date => {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setFullYear(date.getFullYear() + step);
    }, (start, end) => end.getFullYear() - start.getFullYear(), date => date.getFullYear());
    timeWednesday.every = k => isFinite(k = Math.floor(k)) && k > 0 ? timeInterval$1(date => {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setFullYear(date.getFullYear() + step * k);
    }) : null;
    timeWednesday.range;
    timeThursday = timeInterval$1(date => {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, (start, end) => end.getUTCFullYear() - start.getUTCFullYear(), date => date.getUTCFullYear());
    timeThursday.every = k => isFinite(k = Math.floor(k)) && k > 0 ? timeInterval$1(date => {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    }) : null;
    timeThursday.range;
    const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2), t0 = new Date(), localGet = {year:d => d.getFullYear(), quarter:d => Math.floor(d.getMonth() / 3), month:d => d.getMonth(), date:d => d.getDate(), hours:d => d.getHours(), minutes:d => d.getMinutes(), seconds:d => d.getSeconds(), milliseconds:d => d.getMilliseconds(), dayofyear:d => localDayOfYear(d), week:d => localWeekNum(d), weekday:(d, y) => weekday(localWeekNum(d), d.getDay(), localYear(y).getDay()), day:(d, y) => weekday(1, 
    d.getDay(), localYear(y).getDay())}, localInv = {quarter:q => 3 * q, week:(w, y) => weekday(w, 0, localYear(y).getDay())}, utcGet = {year:d => d.getUTCFullYear(), quarter:d => Math.floor(d.getUTCMonth() / 3), month:d => d.getUTCMonth(), date:d => d.getUTCDate(), hours:d => d.getUTCHours(), minutes:d => d.getUTCMinutes(), seconds:d => d.getUTCSeconds(), milliseconds:d => d.getUTCMilliseconds(), dayofyear:d => utcDayOfYear(d), week:d => utcWeekNum(d), day:(d, y) => weekday(1, d.getUTCDay(), utcFirst(y)), 
    weekday:(d, y) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y))}, utcInv = {quarter:q => 3 * q, week:(w, y) => weekday(w, 0, utcFirst(y))}, timeIntervals = {year:timeWednesday, quarter:unixDay.every(3), month:unixDay, week:timeSunday, date:timeDay, day:timeDay, dayofyear:timeDay, hours:timeHour, minutes:timeMinute, seconds:second, milliseconds:millisecond}, utcIntervals = {year:timeThursday, quarter:timeTuesday.every(3), month:timeTuesday, week:utcSunday, date:utcDay, day:utcDay, dayofyear:utcDay, 
    hours:utcHour, minutes:utcMinute, seconds:second, milliseconds:millisecond}, Milli = "year month date hours minutes seconds milliseconds".split(" ");
    second = Milli.slice(0, -1);
    timeMinute = second.slice(0, -1);
    utcMinute = timeMinute.slice(0, -1);
    timeHour = utcMinute.slice(0, -1);
    utcHour = ["year", "month"];
    const Year = ["year"], intervals = [[second, 1, 1000], [second, 5, 5E3], [second, 15, 15E3], [second, 30, 3E4], [timeMinute, 1, 6E4], [timeMinute, 5, 3E5], [timeMinute, 15, 9E5], [timeMinute, 30, 18E5], [utcMinute, 1, 36E5], [utcMinute, 3, 108E5], [utcMinute, 6, 216E5], [utcMinute, 12, 432E5], [timeHour, 1, 864E5], [["year", "week"], 1, 6048E5], [utcHour, 1, 2592E6], [utcHour, 3, 7776E6], [Year, 1, 31536E6]];
    exports.DATE = "date";
    exports.DAY = "day";
    exports.DAYOFYEAR = "dayofyear";
    exports.HOURS = "hours";
    exports.MILLISECONDS = "milliseconds";
    exports.MINUTES = "minutes";
    exports.MONTH = "month";
    exports.QUARTER = "quarter";
    exports.SECONDS = "seconds";
    exports.TIME_UNITS = TIME_UNITS;
    exports.WEEK = "week";
    exports.YEAR = "year";
    exports.dayofyear = function(d) {
      return localDayOfYear(new Date(d));
    };
    exports.timeBin = function(opt) {
      var ext = opt.extent;
      opt = opt.maxbins || 40;
      var target = Math.abs(vegaUtil.span(ext)) / opt;
      let i = bisector(i => i[2]).right(intervals, target);
      i === intervals.length ? (target = Year, ext = tickStep(ext[0] / 31536E6, ext[1] / 31536E6, opt)) : i ? (i = intervals[target / intervals[i - 1][2] < intervals[i][2] / target ? i - 1 : i], target = i[0], ext = i[1]) : (target = Milli, ext = Math.max(tickStep(ext[0], ext[1], opt), 1));
      return {units:target, step:ext};
    };
    exports.timeFloor = function(units, step) {
      return floor(units, step || 1, localGet, localInv, localDate);
    };
    exports.timeInterval = function(unit) {
      return timeIntervals[unit];
    };
    exports.timeOffset = function(unit, date, step) {
      return (unit = timeIntervals[unit]) ? unit.offset(date, step) : void 0;
    };
    exports.timeSequence = function(unit, start, stop, step) {
      return (unit = timeIntervals[unit]) ? unit.range(start, stop, step) : void 0;
    };
    exports.timeUnitSpecifier = function(units, specifiers) {
      specifiers = vegaUtil.extend({}, defaultSpecifiers, specifiers);
      units = timeUnits(units);
      const n = units.length;
      let fmt = "", start, end, key;
      for (start = 0; start < n;) {
        for (end = units.length; end > start; --end) {
          if (key = units.slice(start, end).join("-"), specifiers[key] != null) {
            fmt += specifiers[key];
            start = end;
            break;
          }
        }
      }
      return fmt.trim();
    };
    exports.timeUnits = timeUnits;
    exports.utcFloor = function(units, step) {
      return floor(units, step || 1, utcGet, utcInv, utcDate);
    };
    exports.utcInterval = function(unit) {
      return utcIntervals[unit];
    };
    exports.utcOffset = function(unit, date, step) {
      return (unit = utcIntervals[unit]) ? unit.offset(date, step) : void 0;
    };
    exports.utcSequence = function(unit, start, stop, step) {
      return (unit = utcIntervals[unit]) ? unit.range(start, stop, step) : void 0;
    };
    exports.utcdayofyear = function(d) {
      return utcDayOfYear(new Date(d));
    };
    exports.utcweek = function(d) {
      return utcWeekNum(new Date(d));
    };
    exports.week = function(d) {
      return localWeekNum(new Date(d));
    };
  });
};

//# sourceMappingURL=module$node_modules$vega_time$build$vega_time.js.map
