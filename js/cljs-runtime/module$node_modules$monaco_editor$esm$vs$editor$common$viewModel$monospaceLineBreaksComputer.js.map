{
"version":3,
"file":"module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$monospaceLineBreaksComputer.js",
"lineCount":230,
"mappings":"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",
"sources":["node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$monospaceLineBreaksComputer\"] = function(require,module,exports) {\nObject.defineProperties(exports, {__esModule:{enumerable:true, value:true}, MonospaceLineBreaksComputerFactory:{enumerable:true, get:function() {\n  return MonospaceLineBreaksComputerFactory;\n}}});\nvar strings = require(\"../../../base/common/strings.js\");\nvar require$_DOT__DOT__SLASH_core_SLASH_characterClassifier_DOT_js = require(\"../core/characterClassifier.js\");\nvar require$_DOT__DOT__SLASH_textModelEvents_DOT_js = require(\"../textModelEvents.js\");\nvar require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js = require(\"../modelLineProjectionData.js\");\nclass MonospaceLineBreaksComputerFactory {\n  static create(options) {\n    return new MonospaceLineBreaksComputerFactory(options.get(132), options.get(131));\n  }\n  constructor(breakBeforeChars, breakAfterChars) {\n    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n  }\n  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n    const requests = [];\n    const injectedTexts = [];\n    const previousBreakingData = [];\n    return {addRequest:(lineText, injectedText, previousLineBreakData) => {\n      requests.push(lineText);\n      injectedTexts.push(injectedText);\n      previousBreakingData.push(previousLineBreakData);\n    }, finalize:() => {\n      const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n      const result = [];\n      for (let i = 0, len = requests.length; i < len; i++) {\n        const injectedText = injectedTexts[i];\n        const previousLineBreakData = previousBreakingData[i];\n        if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n          result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n        } else {\n          result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n        }\n      }\n      arrPool1.length = 0;\n      arrPool2.length = 0;\n      return result;\n    }};\n  }\n}\nclass WrappingCharacterClassifier extends require$_DOT__DOT__SLASH_core_SLASH_characterClassifier_DOT_js.CharacterClassifier {\n  constructor(BREAK_BEFORE, BREAK_AFTER) {\n    super(0);\n    for (let i = 0; i < BREAK_BEFORE.length; i++) {\n      this.set(BREAK_BEFORE.charCodeAt(i), 1);\n    }\n    for (let i = 0; i < BREAK_AFTER.length; i++) {\n      this.set(BREAK_AFTER.charCodeAt(i), 2);\n    }\n  }\n  get(charCode) {\n    if (charCode >= 0 && charCode < 256) {\n      return this._asciiMap[charCode];\n    } else {\n      if (charCode >= 12352 && charCode <= 12543 || charCode >= 13312 && charCode <= 19903 || charCode >= 19968 && charCode <= 40959) {\n        return 3;\n      }\n      return this._map.get(charCode) || this._defaultValue;\n    }\n  }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n  const len = lineText.length;\n  if (len <= 1) {\n    return null;\n  }\n  const isKeepAll = wordBreak === \"keepAll\";\n  const prevBreakingOffsets = previousBreakingData.breakOffsets;\n  const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n  const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  const breakingOffsets = arrPool1;\n  const breakingOffsetsVisibleColumn = arrPool2;\n  let breakingOffsetsCount = 0;\n  let lastBreakingOffset = 0;\n  let lastBreakingOffsetVisibleColumn = 0;\n  let breakingColumn = firstLineBreakColumn;\n  const prevLen = prevBreakingOffsets.length;\n  let prevIndex = 0;\n  if (prevIndex >= 0) {\n    let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n    while (prevIndex + 1 < prevLen) {\n      const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n      if (distance >= bestDistance) {\n        break;\n      }\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n  while (prevIndex < prevLen) {\n    let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n    let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n    if (lastBreakingOffset > prevBreakOffset) {\n      prevBreakOffset = lastBreakingOffset;\n      prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n    }\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let forcedBreakOffset = 0;\n    let forcedBreakOffsetVisibleColumn = 0;\n    if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n      let visibleColumn = prevBreakOffsetVisibleColumn;\n      let prevCharCode = prevBreakOffset === 0 ? 0 : lineText.charCodeAt(prevBreakOffset - 1);\n      let prevCharCodeClass = prevBreakOffset === 0 ? 0 : classifier.get(prevCharCode);\n      let entireLineFits = true;\n      for (let i = prevBreakOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n          i++;\n          charCodeClass = 0;\n          charWidth = 2;\n        } else {\n          charCodeClass = classifier.get(charCode);\n          charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n          breakOffset = charStartOffset;\n          breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        if (visibleColumn > breakingColumn) {\n          if (charStartOffset > lastBreakingOffset) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n          } else {\n            forcedBreakOffset = i + 1;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n          if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n            breakOffset = 0;\n          }\n          entireLineFits = false;\n          break;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n      }\n      if (entireLineFits) {\n        if (breakingOffsetsCount > 0) {\n          breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n          breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n          breakingOffsetsCount++;\n        }\n        break;\n      }\n    }\n    if (breakOffset === 0) {\n      let visibleColumn = prevBreakOffsetVisibleColumn;\n      let charCode = lineText.charCodeAt(prevBreakOffset);\n      let charCodeClass = classifier.get(charCode);\n      let hitATabCharacter = false;\n      for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n        const charStartOffset = i + 1;\n        const prevCharCode = lineText.charCodeAt(i);\n        if (prevCharCode === 9) {\n          hitATabCharacter = true;\n          break;\n        }\n        let prevCharCodeClass;\n        let prevCharWidth;\n        if (strings.isLowSurrogate(prevCharCode)) {\n          i--;\n          prevCharCodeClass = 0;\n          prevCharWidth = 2;\n        } else {\n          prevCharCodeClass = classifier.get(prevCharCode);\n          prevCharWidth = strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1;\n        }\n        if (visibleColumn <= breakingColumn) {\n          if (forcedBreakOffset === 0) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n          if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n            break;\n          }\n          if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n            break;\n          }\n        }\n        visibleColumn -= prevCharWidth;\n        charCode = prevCharCode;\n        charCodeClass = prevCharCodeClass;\n      }\n      if (breakOffset !== 0) {\n        const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n        if (remainingWidthOfNextLine <= tabSize) {\n          const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n          let charWidth;\n          if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n            charWidth = 2;\n          } else {\n            charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n          }\n          if (remainingWidthOfNextLine - charWidth < 0) {\n            breakOffset = 0;\n          }\n        }\n      }\n      if (hitATabCharacter) {\n        prevIndex--;\n        continue;\n      }\n    }\n    if (breakOffset === 0) {\n      breakOffset = forcedBreakOffset;\n      breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n    }\n    if (breakOffset <= lastBreakingOffset) {\n      const charCode = lineText.charCodeAt(lastBreakingOffset);\n      if (strings.isHighSurrogate(charCode)) {\n        breakOffset = lastBreakingOffset + 2;\n        breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n      } else {\n        breakOffset = lastBreakingOffset + 1;\n        breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n      }\n    }\n    lastBreakingOffset = breakOffset;\n    breakingOffsets[breakingOffsetsCount] = breakOffset;\n    lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n    breakingOffsetsCount++;\n    breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n    while (prevIndex < 0 || prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn) {\n      prevIndex++;\n    }\n    let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n    while (prevIndex + 1 < prevLen) {\n      const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n      if (distance >= bestDistance) {\n        break;\n      }\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n  if (breakingOffsetsCount === 0) {\n    return null;\n  }\n  breakingOffsets.length = breakingOffsetsCount;\n  breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n  arrPool1 = previousBreakingData.breakOffsets;\n  arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n  previousBreakingData.breakOffsets = breakingOffsets;\n  previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n  previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n  return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n  const lineText = require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n  let injectionOptions;\n  let injectionOffsets;\n  if (injectedTexts && injectedTexts.length > 0) {\n    injectionOptions = injectedTexts.map(t => t.options);\n    injectionOffsets = injectedTexts.map(text => text.column - 1);\n  } else {\n    injectionOptions = null;\n    injectionOffsets = null;\n  }\n  if (firstLineBreakColumn === -1) {\n    if (!injectionOptions) {\n      return null;\n    }\n    return new require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n  }\n  const len = lineText.length;\n  if (len <= 1) {\n    if (!injectionOptions) {\n      return null;\n    }\n    return new require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n  }\n  const isKeepAll = wordBreak === \"keepAll\";\n  const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  const breakingOffsets = [];\n  const breakingOffsetsVisibleColumn = [];\n  let breakingOffsetsCount = 0;\n  let breakOffset = 0;\n  let breakOffsetVisibleColumn = 0;\n  let breakingColumn = firstLineBreakColumn;\n  let prevCharCode = lineText.charCodeAt(0);\n  let prevCharCodeClass = classifier.get(prevCharCode);\n  let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n  let startOffset = 1;\n  if (strings.isHighSurrogate(prevCharCode)) {\n    visibleColumn += 1;\n    prevCharCode = lineText.charCodeAt(1);\n    prevCharCodeClass = classifier.get(prevCharCode);\n    startOffset++;\n  }\n  for (let i = startOffset; i < len; i++) {\n    const charStartOffset = i;\n    const charCode = lineText.charCodeAt(i);\n    let charCodeClass;\n    let charWidth;\n    if (strings.isHighSurrogate(charCode)) {\n      i++;\n      charCodeClass = 0;\n      charWidth = 2;\n    } else {\n      charCodeClass = classifier.get(charCode);\n      charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n    }\n    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n      breakOffset = charStartOffset;\n      breakOffsetVisibleColumn = visibleColumn;\n    }\n    visibleColumn += charWidth;\n    if (visibleColumn > breakingColumn) {\n      if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n        breakOffset = charStartOffset;\n        breakOffsetVisibleColumn = visibleColumn - charWidth;\n      }\n      breakingOffsets[breakingOffsetsCount] = breakOffset;\n      breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n      breakingOffsetsCount++;\n      breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n      breakOffset = 0;\n    }\n    prevCharCode = charCode;\n    prevCharCodeClass = charCodeClass;\n  }\n  if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n    return null;\n  }\n  breakingOffsets[breakingOffsetsCount] = len;\n  breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n  return new require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n  if (charCode === 9) {\n    return tabSize - visibleColumn % tabSize;\n  }\n  if (strings.isFullWidthCharacter(charCode)) {\n    return columnsForFullWidthChar;\n  }\n  if (charCode < 32) {\n    return columnsForFullWidthChar;\n  }\n  return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n  return tabSize - visibleColumn % tabSize;\n}\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n  return charCode !== 32 && (prevCharCodeClass === 2 && charCodeClass !== 2 || prevCharCodeClass !== 1 && charCodeClass === 1 || !isKeepAll && prevCharCodeClass === 3 && charCodeClass !== 2 || !isKeepAll && charCodeClass === 3 && prevCharCodeClass !== 1);\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  let wrappedTextIndentLength = 0;\n  if (wrappingIndent !== 0) {\n    const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n    if (firstNonWhitespaceIndex !== -1) {\n      for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n        const charWidth = lineText.charCodeAt(i) === 9 ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1;\n        wrappedTextIndentLength += charWidth;\n      }\n      const numberOfAdditionalTabs = wrappingIndent === 3 ? 2 : wrappingIndent === 2 ? 1 : 0;\n      for (let i = 0; i < numberOfAdditionalTabs; i++) {\n        const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n        wrappedTextIndentLength += charWidth;\n      }\n      if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n        wrappedTextIndentLength = 0;\n      }\n    }\n  }\n  return wrappedTextIndentLength;\n}\n\n};"],
"names":["shadow$provide","require","module","exports","createLineBreaks","classifier","_lineText","injectedTexts","tabSize","firstLineBreakColumn","columnsForFullWidthChar","wrappingIndent","wordBreak","lineText","require$_DOT__DOT__SLASH_textModelEvents_DOT_js","LineInjectedText","applyInjectedText","injectionOptions","injectionOffsets","length","map","t","options","text","column","require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js","ModelLineProjectionData","len","isKeepAll","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","breakOffset","breakOffsetVisibleColumn","prevCharCode","charCodeAt","prevCharCodeClass","get","visibleColumn","computeCharWidth","startOffset","strings","isHighSurrogate","i","charStartOffset","charCode","charCodeClass","charWidth","canBreak","breakingColumn","isFullWidthCharacter","firstNonWhitespaceIndex","numberOfAdditionalTabs","Object","defineProperties","__esModule","enumerable","value","MonospaceLineBreaksComputerFactory","require$_DOT__DOT__SLASH_core_SLASH_characterClassifier_DOT_js","create","constructor","breakBeforeChars","breakAfterChars","WrappingCharacterClassifier","createLineBreaksComputer","fontInfo","wrappingColumn","requests","previousBreakingData","addRequest","injectedText","previousLineBreakData","push","finalize","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","result","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","arrPool1","arrPool2","lastBreakingOffset","lastBreakingOffsetVisibleColumn","prevLen","prevIndex","bestDistance","Math","abs","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","entireLineFits","hitATabCharacter","isLowSurrogate","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","CharacterClassifier","BREAK_BEFORE","BREAK_AFTER","set","_asciiMap","_map","_defaultValue"]
}
