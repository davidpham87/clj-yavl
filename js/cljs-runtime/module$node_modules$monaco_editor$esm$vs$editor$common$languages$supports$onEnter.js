shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$onEnter = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, OnEnterSupport:{enumerable:!0, get:function() {
    return OnEnterSupport;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_languageConfiguration_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfiguration");
  class OnEnterSupport {
    constructor(opts) {
      opts = opts || {};
      opts.brackets = opts.brackets || [["(", ")"], ["{", "}"], ["[", "]"]];
      this._brackets = [];
      opts.brackets.forEach(bracket => {
        const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]), closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);
        openRegExp && closeRegExp && this._brackets.push({open:bracket[0], openRegExp, close:bracket[1], closeRegExp});
      });
      this._regExpRules = opts.onEnterRules || [];
    }
    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
      if (autoIndent >= 3) {
        for (let i = 0, len = this._regExpRules.length; i < len; i++) {
          const rule = this._regExpRules[i];
          if ([{reg:rule.beforeText, text:beforeEnterText}, {reg:rule.afterText, text:afterEnterText}, {reg:rule.previousLineText, text:previousLineText}].every(obj => {
            if (!obj.reg) {
              return !0;
            }
            obj.reg.lastIndex = 0;
            return obj.reg.test(obj.text);
          })) {
            return rule.action;
          }
        }
      }
      if (autoIndent >= 2 && beforeEnterText.length > 0 && afterEnterText.length > 0) {
        for (let i = 0, len = this._brackets.length; i < len; i++) {
          if (previousLineText = this._brackets[i], previousLineText.openRegExp.test(beforeEnterText) && previousLineText.closeRegExp.test(afterEnterText)) {
            return {indentAction:require$_DOT__DOT__SLASH_languageConfiguration_DOT_js.IndentAction.IndentOutdent};
          }
        }
      }
      if (autoIndent >= 2 && beforeEnterText.length > 0) {
        for (let i = 0, len = this._brackets.length; i < len; i++) {
          if (this._brackets[i].openRegExp.test(beforeEnterText)) {
            return {indentAction:require$_DOT__DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent};
          }
        }
      }
      return null;
    }
    static _createOpenBracketRegExp(bracket) {
      bracket = strings.escapeRegExpCharacters(bracket);
      /\B/.test(bracket.charAt(0)) || (bracket = "\\b" + bracket);
      return OnEnterSupport._safeRegExp(bracket + "\\s*$");
    }
    static _createCloseBracketRegExp(bracket) {
      bracket = strings.escapeRegExpCharacters(bracket);
      /\B/.test(bracket.charAt(bracket.length - 1)) || (bracket += "\\b");
      return OnEnterSupport._safeRegExp("^\\s*" + bracket);
    }
    static _safeRegExp(def) {
      try {
        return new RegExp(def);
      } catch (err) {
        return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(err), null;
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$onEnter.js.map
