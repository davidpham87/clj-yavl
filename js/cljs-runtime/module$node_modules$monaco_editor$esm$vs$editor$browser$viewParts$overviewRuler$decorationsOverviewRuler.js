shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$overviewRuler$decorationsOverviewRuler = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DecorationsOverviewRuler:{enumerable:!0, get:function() {
    return DecorationsOverviewRuler;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$color");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$editorColorRegistry"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays");
  class Settings {
    constructor(config, theme) {
      config = config.options;
      this.lineHeight = config.get(66);
      this.pixelRatio = config.get(141);
      this.overviewRulerLanes = config.get(82);
      this.renderBorder = config.get(81);
      var borderColor = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js.editorOverviewRulerBorder);
      this.borderColor = borderColor ? borderColor.toString() : null;
      this.hideCursor = config.get(59);
      this.cursorColor = (borderColor = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js.editorCursorForeground)) ? borderColor.transparent(0.7).toString() : null;
      this.themeType = theme.type;
      var minimapOpts = config.get(72);
      borderColor = minimapOpts.enabled;
      minimapOpts = minimapOpts.side;
      theme = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js.editorOverviewRulerBackground);
      const defaultBackground = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js.TokenizationRegistry.getDefaultBackground();
      this.backgroundColor = theme ? theme : borderColor && minimapOpts === "right" ? defaultBackground : null;
      config = config.get(143).overviewRuler;
      this.top = config.top;
      this.right = config.right;
      this.domWidth = config.width;
      this.domHeight = config.height;
      this.overviewRulerLanes === 0 ? this.canvasHeight = this.canvasWidth = 0 : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
      const [x, w] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
      this.x = x;
      this.w = w;
    }
    _initLanes(canvasLeftOffset, canvasWidth, laneCount) {
      canvasWidth -= canvasLeftOffset;
      if (laneCount >= 3) {
        laneCount = Math.floor(canvasWidth / 3);
        const rightWidth = Math.floor(canvasWidth / 3);
        canvasWidth = canvasWidth - laneCount - rightWidth;
        const centerOffset = canvasLeftOffset + laneCount;
        return [[0, canvasLeftOffset, centerOffset, canvasLeftOffset, canvasLeftOffset + laneCount + canvasWidth, canvasLeftOffset, centerOffset, canvasLeftOffset], [0, laneCount, canvasWidth, laneCount + canvasWidth, rightWidth, laneCount + canvasWidth + rightWidth, canvasWidth + rightWidth, laneCount + canvasWidth + rightWidth]];
      }
      return laneCount === 2 ? (laneCount = Math.floor(canvasWidth / 2), canvasWidth -= laneCount, [[0, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset + laneCount, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset], [0, laneCount, laneCount, laneCount, canvasWidth, laneCount + canvasWidth, laneCount + canvasWidth, laneCount + canvasWidth]]) : [[0, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset, canvasLeftOffset], 
      [0, canvasWidth, canvasWidth, canvasWidth, canvasWidth, canvasWidth, canvasWidth, canvasWidth]];
    }
    equals(other) {
      return this.lineHeight === other.lineHeight && this.pixelRatio === other.pixelRatio && this.overviewRulerLanes === other.overviewRulerLanes && this.renderBorder === other.renderBorder && this.borderColor === other.borderColor && this.hideCursor === other.hideCursor && this.cursorColor === other.cursorColor && this.themeType === other.themeType && require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.equals(this.backgroundColor, 
      other.backgroundColor) && this.top === other.top && this.right === other.right && this.domWidth === other.domWidth && this.domHeight === other.domHeight && this.canvasWidth === other.canvasWidth && this.canvasHeight === other.canvasHeight;
    }
  }
  class DecorationsOverviewRuler extends module.ViewPart {
    constructor(context) {
      super(context);
      this._actualShouldRender = 0;
      this._renderedDecorations = [];
      this._renderedCursorPositions = [];
      this._domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("canvas"));
      this._domNode.setClassName("decorationsOverviewRuler");
      this._domNode.setPosition("absolute");
      this._domNode.setLayerHinting(!0);
      this._domNode.setContain("strict");
      this._domNode.setAttribute("aria-hidden", "true");
      this._updateSettings(!1);
      this._tokensColorTrackerListener = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js.TokenizationRegistry.onDidChange(e => {
        e.changedColorMap && this._updateSettings(!0);
      });
      this._cursorPositions = [];
    }
    dispose() {
      super.dispose();
      this._tokensColorTrackerListener.dispose();
    }
    _updateSettings(renderNow) {
      const newSettings = new Settings(this._context.configuration, this._context.theme);
      if (this._settings && this._settings.equals(newSettings)) {
        return !1;
      }
      this._settings = newSettings;
      this._domNode.setTop(this._settings.top);
      this._domNode.setRight(this._settings.right);
      this._domNode.setWidth(this._settings.domWidth);
      this._domNode.setHeight(this._settings.domHeight);
      this._domNode.domNode.width = this._settings.canvasWidth;
      this._domNode.domNode.height = this._settings.canvasHeight;
      renderNow && this._render();
      return !0;
    }
    _markRenderingIsNeeded() {
      this._actualShouldRender = 2;
      return !0;
    }
    _markRenderingIsMaybeNeeded() {
      this._actualShouldRender = 1;
      return !0;
    }
    onConfigurationChanged(e) {
      return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
    }
    onCursorStateChanged(e) {
      this._cursorPositions = [];
      for (let i = 0, len = e.selections.length; i < len; i++) {
        this._cursorPositions[i] = e.selections[i].getPosition();
      }
      this._cursorPositions.sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position.compare);
      return this._markRenderingIsMaybeNeeded();
    }
    onDecorationsChanged(e) {
      return e.affectsOverviewRuler ? this._markRenderingIsMaybeNeeded() : !1;
    }
    onFlushed(e) {
      return this._markRenderingIsNeeded();
    }
    onScrollChanged(e) {
      return e.scrollHeightChanged ? this._markRenderingIsNeeded() : !1;
    }
    onZonesChanged(e) {
      return this._markRenderingIsNeeded();
    }
    onThemeChanged(e) {
      return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
    }
    getDomNode() {
      return this._domNode.domNode;
    }
    prepareRender(ctx) {
    }
    render(editorCtx) {
      this._render();
      this._actualShouldRender = 0;
    }
    _render() {
      var backgroundColor = this._settings.backgroundColor;
      if (this._settings.overviewRulerLanes === 0) {
        this._domNode.setBackgroundColor(backgroundColor ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.Format.CSS.formatHexA(backgroundColor) : ""), this._domNode.setDisplay("none");
      } else {
        var decorations = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme);
        decorations.sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.OverviewRulerDecorationsGroup.compareByRenderingProps);
        this._actualShouldRender !== 1 || require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.OverviewRulerDecorationsGroup.equalsArr(this._renderedDecorations, decorations) || (this._actualShouldRender = 2);
        this._actualShouldRender !== 1 || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.equals)(this._renderedCursorPositions, this._cursorPositions, (a, b) => a.lineNumber === b.lineNumber) || (this._actualShouldRender = 2);
        if (this._actualShouldRender !== 1) {
          this._renderedDecorations = decorations;
          this._renderedCursorPositions = this._cursorPositions;
          this._domNode.setDisplay("block");
          var canvasWidth = this._settings.canvasWidth, canvasHeight = this._settings.canvasHeight, lineHeight = this._settings.lineHeight, viewLayout = this._context.viewLayout, outerHeight = this._context.viewLayout.getScrollHeight();
          outerHeight = canvasHeight / outerHeight;
          var minDecorationHeight = 6 * this._settings.pixelRatio | 0, halfMinDecorationHeight = minDecorationHeight / 2 | 0, canvasCtx = this._domNode.domNode.getContext("2d");
          backgroundColor ? (backgroundColor.isOpaque() || canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight), canvasCtx.fillStyle = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.Format.CSS.formatHexA(backgroundColor), canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight)) : canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
          backgroundColor = this._settings.x;
          var w = this._settings.w;
          for (var decorationGroup of decorations) {
            decorations = decorationGroup.data;
            canvasCtx.fillStyle = decorationGroup.color;
            var prevLane = 0;
            let prevY1 = 0, prevY2 = 0;
            for (let i = 0, len = decorations.length / 3; i < len; i++) {
              const lane = decorations[3 * i];
              var endLineNumber = decorations[3 * i + 2];
              let y1 = viewLayout.getVerticalOffsetForLineNumber(decorations[3 * i + 1]) * outerHeight | 0;
              endLineNumber = (viewLayout.getVerticalOffsetForLineNumber(endLineNumber) + lineHeight) * outerHeight | 0;
              endLineNumber - y1 < minDecorationHeight && (endLineNumber = (y1 + endLineNumber) / 2 | 0, endLineNumber < halfMinDecorationHeight ? endLineNumber = halfMinDecorationHeight : endLineNumber + halfMinDecorationHeight > canvasHeight && (endLineNumber = canvasHeight - halfMinDecorationHeight), y1 = endLineNumber - halfMinDecorationHeight, endLineNumber += halfMinDecorationHeight);
              y1 > prevY2 + 1 || lane !== prevLane ? (i !== 0 && canvasCtx.fillRect(backgroundColor[prevLane], prevY1, w[prevLane], prevY2 - prevY1), prevLane = lane, prevY1 = y1, prevY2 = endLineNumber) : endLineNumber > prevY2 && (prevY2 = endLineNumber);
            }
            canvasCtx.fillRect(backgroundColor[prevLane], prevY1, w[prevLane], prevY2 - prevY1);
          }
          if (!this._settings.hideCursor && this._settings.cursorColor) {
            lineHeight = 2 * this._settings.pixelRatio | 0;
            decorationGroup = lineHeight / 2 | 0;
            minDecorationHeight = this._settings.x[7];
            halfMinDecorationHeight = this._settings.w[7];
            canvasCtx.fillStyle = this._settings.cursorColor;
            w = backgroundColor = -100;
            for (let i = 0, len = this._cursorPositions.length; i < len; i++) {
              decorations = viewLayout.getVerticalOffsetForLineNumber(this._cursorPositions[i].lineNumber) * outerHeight | 0, decorations < decorationGroup ? decorations = decorationGroup : decorations + decorationGroup > canvasHeight && (decorations = canvasHeight - decorationGroup), decorations -= decorationGroup, prevLane = decorations + lineHeight, decorations > w + 1 ? (i !== 0 && canvasCtx.fillRect(minDecorationHeight, backgroundColor, halfMinDecorationHeight, w - backgroundColor), backgroundColor = 
              decorations, w = prevLane) : prevLane > w && (w = prevLane);
            }
            canvasCtx.fillRect(minDecorationHeight, backgroundColor, halfMinDecorationHeight, w - backgroundColor);
          }
          this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (canvasCtx.beginPath(), canvasCtx.lineWidth = 1, canvasCtx.strokeStyle = this._settings.borderColor, canvasCtx.moveTo(0, 0), canvasCtx.lineTo(0, canvasHeight), canvasCtx.stroke(), canvasCtx.moveTo(0, 0), canvasCtx.lineTo(canvasWidth, 0), canvasCtx.stroke());
        }
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$overviewRuler$decorationsOverviewRuler.js.map
