shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$core$wordHelper = function(require, module, exports) {
  function ensureValidWordDefinition(wordDefinition) {
    var result = DEFAULT_WORD_REGEXP;
    wordDefinition && wordDefinition instanceof RegExp && (wordDefinition.global ? result = wordDefinition : (result = "g", wordDefinition.ignoreCase && (result += "i"), wordDefinition.multiline && (result += "m"), wordDefinition.unicode && (result += "u"), result = new RegExp(wordDefinition.source, result)));
    result.lastIndex = 0;
    return result;
  }
  function getWordAtText(column, wordDefinition, text$jscomp$0, textOffset, config) {
    wordDefinition = ensureValidWordDefinition(wordDefinition);
    config ||= require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js.Iterable.first(_defaultConfig);
    if (text$jscomp$0.length > config.maxLen) {
      var start = column - config.maxLen / 2;
      start < 0 ? start = 0 : textOffset += start;
      text$jscomp$0 = text$jscomp$0.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text$jscomp$0, textOffset, config);
    }
    start = Date.now();
    column = column - 1 - textOffset;
    var prevRegexIndex = -1;
    let match = null;
    for (let i = 1; !(Date.now() - start >= config.timeBudget); i++) {
      const regexIndex = column - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      a: {
        let match;
        var JSCompiler_inline_result = wordDefinition;
        for (var text = text$jscomp$0, pos = column; match = JSCompiler_inline_result.exec(text);) {
          const matchIndex = match.index || 0;
          if (matchIndex <= pos && JSCompiler_inline_result.lastIndex >= pos) {
            JSCompiler_inline_result = match;
            break a;
          } else if (prevRegexIndex > 0 && matchIndex > prevRegexIndex) {
            JSCompiler_inline_result = null;
            break a;
          }
        }
        JSCompiler_inline_result = null;
      }
      if (!JSCompiler_inline_result && match) {
        break;
      }
      match = JSCompiler_inline_result;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    return match ? (text$jscomp$0 = {word:match[0], startColumn:textOffset + 1 + match.index, endColumn:textOffset + 1 + match.index + match[0].length}, wordDefinition.lastIndex = 0, text$jscomp$0) : null;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DEFAULT_WORD_REGEXP:{enumerable:!0, get:function() {
    return DEFAULT_WORD_REGEXP;
  }}, USUAL_WORD_SEPARATORS:{enumerable:!0, get:function() {
    return "`~!@#$%^\x26*()-\x3d+[{]}\\|;:'\",.\x3c\x3e/?";
  }}, ensureValidWordDefinition:{enumerable:!0, get:function() {
    return ensureValidWordDefinition;
  }}, getWordAtText:{enumerable:!0, get:function() {
    return getWordAtText;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator");
  require = require("module$node_modules$monaco_editor$esm$vs$base$common$linkedList");
  const DEFAULT_WORD_REGEXP = function(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep of "`~!@#$%^\x26*()-\x3d+[{]}\\|;:'\",.\x3c\x3e/?") {
      allowInWords.indexOf(sep) >= 0 || (source += "\\" + sep);
    }
    return new RegExp(source + "\\s]+)", "g");
  }(), _defaultConfig = new require.LinkedList();
  _defaultConfig.unshift({maxLen:1000, windowSize:15, timeBudget:150});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$core$wordHelper.js.map
