{"version":3,"sources":["clj_yavl/io.cljc"],"mappings":";AAGA,AAAA;;;;;;;4BAAA,oCAAAA,hEAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAMD,qEAMFM;AANJ,AAMO,iEAAA,1DAACC,wDAAcD;;;AANtB,CAAA,0DAAA,aAAAJ,vEAAMF,qEAOFM;AAPJ,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;YAAAA,RAO0BM;aAP1B,AAAAJ,4CAAAF,eAAA,pEAOcK;AAPd,AASY,IAAME,SAAO,AAACC,WAAcL;AAA5B,AACE,0HAAA,nHAACM,0DAAQF,oIAAwB,AAACG,6CAAEL,OAAOM;;;AAVzD,CAAA,oDAAA,pDAAMd;;AAAN,AAYA,AAAA;;;;;;;6BAAA,qCAAAF,lEAAMkB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,yDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,yDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAf,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,2DAAA,3DAAMe,sEAMFG;AANJ,AAMU,qEAAA,9DAACC,yDAAeD;;;AAN1B,CAAA,2DAAA,gBAAAF,3EAAMD,sEAOFG;AAPJ,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAAd,4BAAAc;YAAAA,RAO6BT;aAP7B,AAAAJ,4CAAAa,eAAA,pEAOiBG;AAPjB,AASY,oBAAIA;AACF,iDAAA,1CAACC,eAAkB,AAACC,qBAAQJ,WAAU,qCAAA,nCAAI,OAASE,qBAAQA;;AAC3D,OAACC,eAAkB,AAACC,qBAAQJ;;;;AAX1C,CAAA,qDAAA,rDAAMH;;AAAN","names":["var_args","G__25546","clj-yavl.io/read-json-str","js/Error","p__25547","map__25548","cljs.core/--destructure-map","cljs.core.get","s","clj_yavl.io.read_json_str","key-fn","_opts","js-obj","js/JSON.parse","cljs.core.js__GT_clj","cljs.core._EQ_","cljs.core/keyword","G__25550","clj-yavl.io/write-json-str","p__25551","map__25552","data","clj_yavl.io.write_json_str","indent","js/JSON.stringify","cljs.core/clj->js"],"sourcesContent":["(ns clj-yavl.io\n  (:require #?(:clj [babashka.json :as json])))\n\n(defn read-json-str\n  \"Reads a JSON string and returns a Clojure data structure.\n   Options:\n   :key-fn - a function to apply to keys (e.g. keyword)\n   CLJ: uses babashka.json\n   CLJS: uses js/JSON.parse and js->clj\"\n  ([s] (read-json-str s nil))\n  ([s {:keys [key-fn] :as _opts}]\n   #?(:clj (json/read-str s _opts)\n      :cljs (let [js-obj (js/JSON.parse s)]\n              (js->clj js-obj :keywordize-keys (= key-fn keyword))))))\n\n(defn write-json-str\n  \"Writes a Clojure data structure to a JSON string.\n   Options:\n   :indent - true or a number of spaces for indentation (not fully supported in CLJS default JSON)\n   CLJ: uses babashka.json\n   CLJS: uses js/JSON.stringify\"\n  ([data] (write-json-str data nil))\n  ([data {:keys [indent] :as _opts}]\n   #?(:clj (json/write-str data _opts)\n      :cljs (if indent\n              (js/JSON.stringify (clj->js data) nil (if (number? indent) indent 2))\n              (js/JSON.stringify (clj->js data))))))\n"]}