shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$objectTreeModel = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ObjectTreeModel:{enumerable:!0, get:function() {
    return ObjectTreeModel;
  }}});
  var require$_DOT__SLASH_indexTreeModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$indexTreeModel"), require$_DOT__SLASH_tree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$tree"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator");
  class ObjectTreeModel {
    constructor(user, list, options = {}) {
      this.user = user;
      this.rootRef = null;
      this.nodes = new Map();
      this.nodesByIdentity = new Map();
      this.model = new require$_DOT__SLASH_indexTreeModel_DOT_js.IndexTreeModel(user, list, null, options);
      this.onDidSplice = this.model.onDidSplice;
      this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;
      this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;
      options.sorter && (this.sorter = {compare(a, b) {
        return options.sorter.compare(a.element, b.element);
      }});
      this.identityProvider = options.identityProvider;
    }
    setChildren(element, children = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), options = {}) {
      element = this.getElementLocation(element);
      this._setChildren(element, this.preserveCollapseState(children), options);
    }
    _setChildren(location, children = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty(), options) {
      const insertedElements = new Set(), insertedElementIds = new Set();
      this.model.splice([...location, 0], Number.MAX_VALUE, children, {...options, onDidCreateNode:node => {
        var _a;
        if (node.element !== null) {
          insertedElements.add(node.element);
          this.nodes.set(node.element, node);
          if (this.identityProvider) {
            const id = this.identityProvider.getId(node.element).toString();
            insertedElementIds.add(id);
            this.nodesByIdentity.set(id, node);
          }
          (_a = options.onDidCreateNode) === null || _a === void 0 || _a.call(options, node);
        }
      }, onDidDeleteNode:node => {
        var _a;
        if (node.element !== null) {
          insertedElements.has(node.element) || this.nodes.delete(node.element);
          if (this.identityProvider) {
            const id = this.identityProvider.getId(node.element).toString();
            insertedElementIds.has(id) || this.nodesByIdentity.delete(id);
          }
          (_a = options.onDidDeleteNode) === null || _a === void 0 || _a.call(options, node);
        }
      }});
    }
    preserveCollapseState(elements = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty()) {
      this.sorter && (elements = [...elements].sort(this.sorter.compare.bind(this.sorter)));
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(elements, treeElement => {
        var node = this.nodes.get(treeElement.element);
        !node && this.identityProvider && (node = this.identityProvider.getId(treeElement.element).toString(), node = this.nodesByIdentity.get(node));
        return node ? {...treeElement, collapsible:typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : node.collapsible, collapsed:typeof treeElement.collapsed === "undefined" || treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrCollapsed || treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrExpanded ? node.collapsed : treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.Collapsed ? 
        !0 : treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.Expanded ? !1 : !!treeElement.collapsed, children:this.preserveCollapseState(treeElement.children)} : (node = typeof treeElement.collapsed === "undefined" ? void 0 : treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.Collapsed || treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrCollapsed ? !0 : treeElement.collapsed === 
        require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.Expanded || treeElement.collapsed === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrExpanded ? !1 : !!treeElement.collapsed, {...treeElement, children:this.preserveCollapseState(treeElement.children), collapsed:node});
      });
    }
    rerender(element) {
      element = this.getElementLocation(element);
      this.model.rerender(element);
    }
    getFirstElementChild(ref = null) {
      ref = this.getElementLocation(ref);
      return this.model.getFirstElementChild(ref);
    }
    has(element) {
      return this.nodes.has(element);
    }
    getListIndex(element) {
      element = this.getElementLocation(element);
      return this.model.getListIndex(element);
    }
    getListRenderCount(element) {
      element = this.getElementLocation(element);
      return this.model.getListRenderCount(element);
    }
    isCollapsible(element) {
      element = this.getElementLocation(element);
      return this.model.isCollapsible(element);
    }
    setCollapsible(element, collapsible) {
      element = this.getElementLocation(element);
      return this.model.setCollapsible(element, collapsible);
    }
    isCollapsed(element) {
      element = this.getElementLocation(element);
      return this.model.isCollapsed(element);
    }
    setCollapsed(element, collapsed, recursive) {
      element = this.getElementLocation(element);
      return this.model.setCollapsed(element, collapsed, recursive);
    }
    expandTo(element) {
      element = this.getElementLocation(element);
      this.model.expandTo(element);
    }
    refilter() {
      this.model.refilter();
    }
    getNode(element = null) {
      if (element === null) {
        return this.model.getNode(this.model.rootRef);
      }
      const node = this.nodes.get(element);
      if (!node) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, `Tree element not found: ${element}`);
      }
      return node;
    }
    getNodeLocation(node) {
      return node.element;
    }
    getParentNodeLocation(element) {
      if (element === null) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Invalid getParentNodeLocation call");
      }
      const node = this.nodes.get(element);
      if (!node) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, `Tree element not found: ${element}`);
      }
      element = this.model.getNodeLocation(node);
      element = this.model.getParentNodeLocation(element);
      return this.model.getNode(element).element;
    }
    getElementLocation(element) {
      if (element === null) {
        return [];
      }
      const node = this.nodes.get(element);
      if (!node) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, `Tree element not found: ${element}`);
      }
      return this.model.getNodeLocation(node);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$objectTreeModel.js.map
