shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$filters = function(require, module, exports) {
  function or(...filter) {
    return function(word, wordToMatchAgainst) {
      for (let i = 0, len = filter.length; i < len; i++) {
        const match = filter[i](word, wordToMatchAgainst);
        if (match) {
          return match;
        }
      }
      return null;
    };
  }
  function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
    return !wordToMatchAgainst || wordToMatchAgainst.length < word.length ? null : (ignoreCase ? strings.startsWithIgnoreCase(wordToMatchAgainst, word) : wordToMatchAgainst.indexOf(word) === 0) ? word.length > 0 ? [{start:0, end:word.length}] : [] : null;
  }
  function matchesContiguousSubString(word, wordToMatchAgainst) {
    wordToMatchAgainst = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
    return wordToMatchAgainst === -1 ? null : [{start:wordToMatchAgainst, end:wordToMatchAgainst + word.length}];
  }
  function matchesSubString(word, wordToMatchAgainst) {
    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
  }
  function _matchesSubString(word, wordToMatchAgainst, i, j) {
    if (i === word.length) {
      return [];
    }
    if (j === wordToMatchAgainst.length) {
      return null;
    }
    if (word[i] === wordToMatchAgainst[j]) {
      let result;
      return (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) ? join({start:j, end:j + 1}, result) : null;
    }
    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
  }
  function isUpper(code) {
    return 65 <= code && code <= 90;
  }
  function isWordSeparator(code) {
    return code === 32 || code === 9 || code === 10 || code === 13 || wordSeparators.has(code);
  }
  function charactersMatch(codeA, codeB) {
    return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);
  }
  function getAlternateCodes(code) {
    if (alternateCharsCache.has(code)) {
      return alternateCharsCache.get(code);
    }
    let result;
    const codes = (0,require$_DOT__SLASH_naturalLanguage_SLASH_korean_DOT_js.getKoreanAltChars)(code);
    codes && (result = codes);
    alternateCharsCache.set(code, result);
    return result;
  }
  function isAlphanumeric(code) {
    return 97 <= code && code <= 122 || isUpper(code) || 48 <= code && code <= 57;
  }
  function join(head, tail) {
    tail.length === 0 ? tail = [head] : head.end === tail[0].start ? tail[0].start = head.start : tail.unshift(head);
    return tail;
  }
  function nextAnchor(camelCaseWord, start) {
    for (; start < camelCaseWord.length; start++) {
      const c = camelCaseWord.charCodeAt(start);
      if (isUpper(c) || 48 <= c && c <= 57 || start > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(start - 1))) {
        return start;
      }
    }
    return camelCaseWord.length;
  }
  function _matchesCamelCase(word, camelCaseWord, i, j) {
    if (i === word.length) {
      return [];
    }
    if (j === camelCaseWord.length || word[i] !== camelCaseWord[j].toLowerCase()) {
      return null;
    }
    let result, nextUpperIndex = j + 1;
    for (result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1); !result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length;) {
      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex), nextUpperIndex++;
    }
    return result === null ? null : join({start:j, end:j + 1}, result);
  }
  function matchesCamelCase(word, camelCaseWord) {
    if (!camelCaseWord) {
      return null;
    }
    camelCaseWord = camelCaseWord.trim();
    if (camelCaseWord.length === 0) {
      return null;
    }
    var JSCompiler_inline_result = word;
    var upper = 0, lower = 0, whitespace = 0;
    for (var i$jscomp$0 = 0; i$jscomp$0 < JSCompiler_inline_result.length; i$jscomp$0++) {
      var code = JSCompiler_inline_result.charCodeAt(i$jscomp$0);
      isUpper(code) && upper++;
      97 <= code && code <= 122 && lower++;
      code !== 32 && code !== 9 && code !== 10 && code !== 13 || whitespace++;
    }
    JSCompiler_inline_result = upper !== 0 && lower !== 0 || whitespace !== 0 ? upper <= 5 : JSCompiler_inline_result.length <= 30;
    if (!JSCompiler_inline_result || camelCaseWord.length > 60) {
      return null;
    }
    JSCompiler_inline_result = camelCaseWord;
    whitespace = code = lower = upper = 0;
    for (let i = 0; i < JSCompiler_inline_result.length; i++) {
      i$jscomp$0 = JSCompiler_inline_result.charCodeAt(i), isUpper(i$jscomp$0) && upper++, 97 <= i$jscomp$0 && i$jscomp$0 <= 122 && lower++, isAlphanumeric(i$jscomp$0) && code++, 48 <= i$jscomp$0 && i$jscomp$0 <= 57 && whitespace++;
    }
    JSCompiler_inline_result = {upperPercent:upper / JSCompiler_inline_result.length, lowerPercent:lower / JSCompiler_inline_result.length, alphaPercent:code / JSCompiler_inline_result.length, numericPercent:whitespace / JSCompiler_inline_result.length};
    const {upperPercent, lowerPercent, alphaPercent, numericPercent} = JSCompiler_inline_result;
    if (!(lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2)) {
      const {upperPercent, lowerPercent} = JSCompiler_inline_result;
      if (!(lowerPercent === 0 && upperPercent > 0.6)) {
        return null;
      }
      camelCaseWord = camelCaseWord.toLowerCase();
    }
    JSCompiler_inline_result = null;
    upper = 0;
    for (word = word.toLowerCase(); upper < camelCaseWord.length && (JSCompiler_inline_result = _matchesCamelCase(word, camelCaseWord, 0, upper)) === null;) {
      upper = nextAnchor(camelCaseWord, upper + 1);
    }
    return JSCompiler_inline_result;
  }
  function matchesWords(word, target, contiguous = !1) {
    if (!target || target.length === 0) {
      return null;
    }
    let result = null, targetIndex = 0;
    word = word.toLowerCase();
    for (target = target.toLowerCase(); targetIndex < target.length;) {
      result = _matchesWords(word, target, 0, targetIndex, contiguous);
      if (result !== null) {
        break;
      }
      targetIndex = nextWord(target, targetIndex + 1);
    }
    return result;
  }
  function _matchesWords(word, target, wordIndex, targetIndex, contiguous) {
    let targetIndexOffset = 0;
    if (wordIndex === word.length) {
      return [];
    }
    if (targetIndex === target.length) {
      return null;
    }
    if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {
      var altChars = getAlternateCodes(word.charCodeAt(wordIndex));
      if (!altChars) {
        return null;
      }
      for (var k = 0; k < altChars.length; k++) {
        if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {
          return null;
        }
      }
      targetIndexOffset += altChars.length - 1;
    }
    k = targetIndex + targetIndexOffset + 1;
    altChars = _matchesWords(word, target, wordIndex + 1, k, contiguous);
    if (!contiguous) {
      for (; !altChars && (k = nextWord(target, k)) < target.length;) {
        altChars = _matchesWords(word, target, wordIndex + 1, k, contiguous), k++;
      }
    }
    if (!altChars) {
      return null;
    }
    if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {
      word = getAlternateCodes(word.charCodeAt(wordIndex));
      if (!word) {
        return altChars;
      }
      for (wordIndex = 0; wordIndex < word.length; wordIndex++) {
        if (word[wordIndex] !== target.charCodeAt(targetIndex + wordIndex)) {
          return altChars;
        }
      }
    }
    return join({start:targetIndex, end:targetIndex + targetIndexOffset + 1}, altChars);
  }
  function nextWord(word, start) {
    for (; start < word.length; start++) {
      if (isWordSeparator(word.charCodeAt(start)) || start > 0 && isWordSeparator(word.charCodeAt(start - 1))) {
        return start;
      }
    }
    return word.length;
  }
  function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = !1) {
    if (typeof word !== "string" || typeof wordToMatchAgainst !== "string") {
      return null;
    }
    var regexp = fuzzyRegExpCache.get(word);
    regexp || (regexp = new RegExp(strings.convertSimple2RegExpPattern(word), "i"), fuzzyRegExpCache.set(word, regexp));
    return (regexp = regexp.exec(wordToMatchAgainst)) ? [{start:regexp.index, end:regexp.index + regexp[0].length}] : enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
  }
  function matchesFuzzy2(pattern, word) {
    return (pattern = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, {firstMatchCanBeWeak:!0, boostFullMatch:!0})) ? createMatches(pattern) : null;
  }
  function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {
    const max = Math.min(13, pattern.length);
    for (; patternPos < max; patternPos++) {
      const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, {firstMatchCanBeWeak:!0, boostFullMatch:!0});
      if (result) {
        return result;
      }
    }
    return [0, wordPos];
  }
  function createMatches(score) {
    if (typeof score === "undefined") {
      return [];
    }
    const res = [], wordPos = score[1];
    for (let i = score.length - 1; i > 1; i--) {
      const pos = score[i] + wordPos, last = res[res.length - 1];
      last && last.end === pos ? last.end = pos + 1 : res.push({start:pos, end:pos + 1});
    }
    return res;
  }
  function initTable() {
    const table = [], row = [];
    for (var i = 0; i <= 128; i++) {
      row[i] = 0;
    }
    for (i = 0; i <= 128; i++) {
      table.push(row.slice(0));
    }
    return table;
  }
  function initArr(maxLen) {
    const row = [];
    for (let i = 0; i <= maxLen; i++) {
      row[i] = 0;
    }
    return row;
  }
  function isSeparatorAtPos(value, index) {
    if (index < 0 || index >= value.length) {
      return !1;
    }
    value = value.codePointAt(index);
    switch(value) {
      case 95:
      case 45:
      case 46:
      case 32:
      case 47:
      case 92:
      case 39:
      case 34:
      case 58:
      case 36:
      case 60:
      case 62:
      case 40:
      case 41:
      case 91:
      case 93:
      case 123:
      case 125:
        return !0;
      case void 0:
        return !1;
      default:
        return strings.isEmojiImprecise(value) ? !0 : !1;
    }
  }
  function isWhitespaceAtPos(value, index) {
    if (index < 0 || index >= value.length) {
      return !1;
    }
    switch(value.charCodeAt(index)) {
      case 32:
      case 9:
        return !0;
      default:
        return !1;
    }
  }
  function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = !1) {
    for (; patternPos < patternLen && wordPos < wordLen;) {
      patternLow[patternPos] === wordLow[wordPos] && (fillMinWordPosArr && (_minWordMatchPos[patternPos] = wordPos), patternPos += 1), wordPos += 1;
    }
    return patternPos === patternLen;
  }
  function fuzzyScore(pattern$jscomp$0, patternLow, patternStart$jscomp$0, word$jscomp$0, wordLow$jscomp$0, wordStart$jscomp$0, options = FuzzyScoreOptions.default) {
    const patternLen = pattern$jscomp$0.length > 128 ? 128 : pattern$jscomp$0.length, wordLen = word$jscomp$0.length > 128 ? 128 : word$jscomp$0.length;
    if (!(patternStart$jscomp$0 >= patternLen || wordStart$jscomp$0 >= wordLen || patternLen - patternStart$jscomp$0 > wordLen - wordStart$jscomp$0) && isPatternInWord(patternLow, patternStart$jscomp$0, patternLen, wordLow$jscomp$0, wordStart$jscomp$0, wordLen, !0)) {
      for (var patternPos = patternLen - 1, wordPos = wordLen - 1; patternPos >= patternStart$jscomp$0 && wordPos >= wordStart$jscomp$0;) {
        patternLow[patternPos] === wordLow$jscomp$0[wordPos] && (_maxWordMatchPos[patternPos] = wordPos, patternPos--), wordPos--;
      }
      wordPos = 1;
      var patternPos$jscomp$0, wordPos$jscomp$0, hasStrongFirstMatch = [!1];
      patternPos = 1;
      for (patternPos$jscomp$0 = patternStart$jscomp$0; patternPos$jscomp$0 < patternLen; patternPos++, patternPos$jscomp$0++) {
        var minWordMatchPos = _minWordMatchPos[patternPos$jscomp$0];
        const maxWordMatchPos = _maxWordMatchPos[patternPos$jscomp$0], nextMaxWordMatchPos = patternPos$jscomp$0 + 1 < patternLen ? _maxWordMatchPos[patternPos$jscomp$0 + 1] : wordLen;
        wordPos = minWordMatchPos - wordStart$jscomp$0 + 1;
        for (wordPos$jscomp$0 = minWordMatchPos; wordPos$jscomp$0 < nextMaxWordMatchPos; wordPos++, wordPos$jscomp$0++) {
          var score$jscomp$0 = Number.MIN_SAFE_INTEGER;
          let canComeDiag = !1;
          if (wordPos$jscomp$0 <= maxWordMatchPos) {
            a: {
              var pattern = pattern$jscomp$0;
              score$jscomp$0 = patternPos$jscomp$0;
              var patternStart = patternStart$jscomp$0, word = word$jscomp$0, wordLow = wordLow$jscomp$0, wordPos$jscomp$1 = wordPos$jscomp$0, wordLen$jscomp$0 = wordLen, wordStart = wordStart$jscomp$0, newMatchStart = _diag[patternPos - 1][wordPos - 1] === 0;
              if (patternLow[score$jscomp$0] !== wordLow[wordPos$jscomp$1]) {
                score$jscomp$0 = Number.MIN_SAFE_INTEGER;
                break a;
              }
              let score = 1, isGapLocation = !1;
              if (wordPos$jscomp$1 === score$jscomp$0 - patternStart) {
                score = pattern[score$jscomp$0] === word[wordPos$jscomp$1] ? 7 : 5;
              } else {
                var JSCompiler_temp;
                (JSCompiler_temp = word[wordPos$jscomp$1] !== wordLow[wordPos$jscomp$1]) && !(JSCompiler_temp = wordPos$jscomp$1 === 0) && (JSCompiler_temp = wordPos$jscomp$1 - 1, JSCompiler_temp = word[JSCompiler_temp] === wordLow[JSCompiler_temp]);
                if (JSCompiler_temp) {
                  score = pattern[score$jscomp$0] === word[wordPos$jscomp$1] ? 7 : 5, isGapLocation = !0;
                } else if (isSeparatorAtPos(wordLow, wordPos$jscomp$1) && (wordPos$jscomp$1 === 0 || !isSeparatorAtPos(wordLow, wordPos$jscomp$1 - 1))) {
                  score = 5;
                } else if (isSeparatorAtPos(wordLow, wordPos$jscomp$1 - 1) || isWhitespaceAtPos(wordLow, wordPos$jscomp$1 - 1)) {
                  score = 5, isGapLocation = !0;
                }
              }
              score > 1 && score$jscomp$0 === patternStart && (hasStrongFirstMatch[0] = !0);
              isGapLocation ||= word[wordPos$jscomp$1] !== wordLow[wordPos$jscomp$1] || isSeparatorAtPos(wordLow, wordPos$jscomp$1 - 1) || isWhitespaceAtPos(wordLow, wordPos$jscomp$1 - 1);
              score$jscomp$0 === patternStart ? wordPos$jscomp$1 > wordStart && (score -= isGapLocation ? 3 : 5) : score = newMatchStart ? score + (isGapLocation ? 2 : 0) : score + (isGapLocation ? 0 : 1);
              wordPos$jscomp$1 + 1 === wordLen$jscomp$0 && (score -= isGapLocation ? 3 : 5);
              score$jscomp$0 = score;
            }
          }
          pattern = 0;
          score$jscomp$0 !== Number.MAX_SAFE_INTEGER && (canComeDiag = !0, pattern = score$jscomp$0 + _table[patternPos - 1][wordPos - 1]);
          patternStart = (score$jscomp$0 = wordPos$jscomp$0 > minWordMatchPos) ? _table[patternPos][wordPos - 1] + (_diag[patternPos][wordPos - 1] > 0 ? -5 : 0) : 0;
          wordLow = (word = wordPos$jscomp$0 > minWordMatchPos + 1 && _diag[patternPos][wordPos - 1] > 0) ? _table[patternPos][wordPos - 2] + (_diag[patternPos][wordPos - 2] > 0 ? -5 : 0) : 0;
          if (word && (!score$jscomp$0 || wordLow >= patternStart) && (!canComeDiag || wordLow >= pattern)) {
            _table[patternPos][wordPos] = wordLow, _arrows[patternPos][wordPos] = 3, _diag[patternPos][wordPos] = 0;
          } else if (score$jscomp$0 && (!canComeDiag || patternStart >= pattern)) {
            _table[patternPos][wordPos] = patternStart, _arrows[patternPos][wordPos] = 2, _diag[patternPos][wordPos] = 0;
          } else if (canComeDiag) {
            _table[patternPos][wordPos] = pattern, _arrows[patternPos][wordPos] = 1, _diag[patternPos][wordPos] = _diag[patternPos - 1][wordPos - 1] + 1;
          } else {
            throw Error("not possible");
          }
        }
      }
      if (hasStrongFirstMatch[0] || options.firstMatchCanBeWeak) {
        patternPos--;
        wordPos--;
        pattern$jscomp$0 = [_table[patternPos][wordPos], wordStart$jscomp$0];
        for (wordPos$jscomp$0 = patternPos$jscomp$0 = 0; patternPos >= 1;) {
          hasStrongFirstMatch = wordPos;
          do {
            if (minWordMatchPos = _arrows[patternPos][hasStrongFirstMatch], minWordMatchPos === 3) {
              hasStrongFirstMatch -= 2;
            } else if (minWordMatchPos === 2) {
              --hasStrongFirstMatch;
            } else {
              break;
            }
          } while (hasStrongFirstMatch >= 1);
          if (minWordMatchPos = patternPos$jscomp$0 > 1 && patternLow[patternStart$jscomp$0 + patternPos - 1] === wordLow$jscomp$0[wordStart$jscomp$0 + wordPos - 1]) {
            minWordMatchPos = hasStrongFirstMatch + wordStart$jscomp$0 - 1, minWordMatchPos = word$jscomp$0[minWordMatchPos] === wordLow$jscomp$0[minWordMatchPos];
          }
          minWordMatchPos && patternPos$jscomp$0 + 1 > _diag[patternPos][hasStrongFirstMatch] && (hasStrongFirstMatch = wordPos);
          hasStrongFirstMatch === wordPos ? patternPos$jscomp$0++ : patternPos$jscomp$0 = 1;
          wordPos$jscomp$0 ||= hasStrongFirstMatch;
          patternPos--;
          wordPos = hasStrongFirstMatch - 1;
          pattern$jscomp$0.push(wordPos);
        }
        wordLen === patternLen && options.boostFullMatch && (pattern$jscomp$0[0] += 2);
        pattern$jscomp$0[0] -= wordPos$jscomp$0 - patternLen;
        return pattern$jscomp$0;
      }
    }
  }
  function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos$jscomp$0, word, lowWord, wordPos, options) {
    lowPattern = fuzzyScore(pattern, lowPattern, patternPos$jscomp$0, word, lowWord, wordPos, options);
    if (pattern.length >= 3) {
      const tries = Math.min(7, pattern.length - 1);
      for (let movingPatternPos = patternPos$jscomp$0 + 1; movingPatternPos < tries; movingPatternPos++) {
        b: {
          var JSCompiler_inline_result = pattern;
          var patternPos = movingPatternPos;
          if (!(patternPos + 1 >= JSCompiler_inline_result.length)) {
            var swap1 = JSCompiler_inline_result[patternPos], swap2 = JSCompiler_inline_result[patternPos + 1];
            if (swap1 !== swap2) {
              JSCompiler_inline_result = JSCompiler_inline_result.slice(0, patternPos) + swap2 + swap1 + JSCompiler_inline_result.slice(patternPos + 2);
              break b;
            }
          }
          JSCompiler_inline_result = void 0;
        }
        JSCompiler_inline_result && (JSCompiler_inline_result = fuzzyScore(JSCompiler_inline_result, JSCompiler_inline_result.toLowerCase(), patternPos$jscomp$0, word, lowWord, wordPos, options)) && (JSCompiler_inline_result[0] -= 3, !lowPattern || JSCompiler_inline_result[0] > lowPattern[0]) && (lowPattern = JSCompiler_inline_result);
      }
    }
    pattern = lowPattern;
    return pattern;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, FuzzyScore:{enumerable:!0, get:function() {
    return FuzzyScore;
  }}, FuzzyScoreOptions:{enumerable:!0, get:function() {
    return FuzzyScoreOptions;
  }}, anyScore:{enumerable:!0, get:function() {
    return anyScore;
  }}, createMatches:{enumerable:!0, get:function() {
    return createMatches;
  }}, fuzzyScore:{enumerable:!0, get:function() {
    return fuzzyScore;
  }}, fuzzyScoreGracefulAggressive:{enumerable:!0, get:function() {
    return fuzzyScoreGracefulAggressive;
  }}, isPatternInWord:{enumerable:!0, get:function() {
    return isPatternInWord;
  }}, isUpper:{enumerable:!0, get:function() {
    return isUpper;
  }}, matchesCamelCase:{enumerable:!0, get:function() {
    return matchesCamelCase;
  }}, matchesContiguousSubString:{enumerable:!0, get:function() {
    return matchesContiguousSubString;
  }}, matchesFuzzy:{enumerable:!0, get:function() {
    return matchesFuzzy;
  }}, matchesFuzzy2:{enumerable:!0, get:function() {
    return matchesFuzzy2;
  }}, matchesPrefix:{enumerable:!0, get:function() {
    return matchesPrefix;
  }}, matchesStrictPrefix:{enumerable:!0, get:function() {
    return matchesStrictPrefix;
  }}, matchesSubString:{enumerable:!0, get:function() {
    return matchesSubString;
  }}, matchesWords:{enumerable:!0, get:function() {
    return matchesWords;
  }}, or:{enumerable:!0, get:function() {
    return or;
  }}});
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$map");
  var require$_DOT__SLASH_naturalLanguage_SLASH_korean_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$naturalLanguage$korean"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  const matchesStrictPrefix = _matchesPrefix.bind(void 0, !1), matchesPrefix = _matchesPrefix.bind(void 0, !0), wordSeparators = new Set();
  "()[]{}\x3c\x3e`'\"-/;:,.?!".split("").forEach(s => wordSeparators.add(s.charCodeAt(0)));
  const alternateCharsCache = new Map(), fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString), fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString), fuzzyRegExpCache = new module.LRUCache(10000), _minWordMatchPos = initArr(256), _maxWordMatchPos = initArr(256), _diag = initTable(), _table = initTable(), _arrows = initTable();
  var FuzzyScore;
  (function(FuzzyScore) {
    FuzzyScore.Default = [-100, 0];
    FuzzyScore.isDefault = function(score) {
      return !score || score.length === 2 && score[0] === -100 && score[1] === 0;
    };
  })(FuzzyScore ||= {});
  class FuzzyScoreOptions {
    constructor(firstMatchCanBeWeak, boostFullMatch) {
      this.firstMatchCanBeWeak = firstMatchCanBeWeak;
      this.boostFullMatch = boostFullMatch;
    }
  }
  FuzzyScoreOptions.default = {boostFullMatch:!0, firstMatchCanBeWeak:!1};
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$filters.js.map
