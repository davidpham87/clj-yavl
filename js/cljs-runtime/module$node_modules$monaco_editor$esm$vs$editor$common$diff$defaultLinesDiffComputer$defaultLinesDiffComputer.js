shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$defaultLinesDiffComputer = function(require, module, exports) {
  function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = !1) {
    const changes = [];
    for (const g of (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.groupAdjacentBy)(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
      alignments = g[0];
      const last = g[g.length - 1];
      changes.push(new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.DetailedLineRangeMapping(alignments.original.join(last.original), alignments.modified.join(last.modified), g.map(a => a.innerChanges[0])));
    }
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.assertFn)(() => !dontAssertStartLine && changes.length > 0 && changes[0].original.startLineNumber !== changes[0].modified.startLineNumber ? !1 : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.checkAdjacentItems)(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - 
    m1.modified.endLineNumberExclusive && m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber));
    return changes;
  }
  function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    var lineStartDelta = 0;
    let lineEndDelta = 0;
    rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber && (lineEndDelta = -1);
    rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta && (lineStartDelta = 1);
    originalLines = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    lineStartDelta = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.DetailedLineRangeMapping(originalLines, lineStartDelta, [rangeMapping]);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DefaultLinesDiffComputer:{enumerable:!0, get:function() {
    return DefaultLinesDiffComputer;
  }}, getLineRangeMapping:{enumerable:!0, get:function() {
    return getLineRangeMapping;
  }}, lineRangeMappingFromRangeMappings:{enumerable:!0, get:function() {
    return lineRangeMappingFromRangeMappings;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$assert"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$diffAlgorithm"), require$_DOT__SLASH_algorithms_SLASH_dynamicProgrammingDiffing_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$dynamicProgrammingDiffing"), require$_DOT__SLASH_algorithms_SLASH_myersDiffAlgorithm_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$myersDiffAlgorithm"), require$_DOT__SLASH_computeMovedLines_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$computeMovedLines"), require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$heuristicSequenceOptimizations"), require$_DOT__DOT__SLASH_linesDiffComputer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$linesDiffComputer"), require$_DOT__DOT__SLASH_rangeMapping_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$rangeMapping"), require$_DOT__SLASH_linesSliceCharSequence_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$linesSliceCharSequence"), 
  require$_DOT__SLASH_lineSequence_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$lineSequence");
  class DefaultLinesDiffComputer {
    constructor() {
      this.dynamicProgrammingDiffing = new require$_DOT__SLASH_algorithms_SLASH_dynamicProgrammingDiffing_DOT_js.DynamicProgrammingDiffing();
      this.myersDiffingAlgorithm = new require$_DOT__SLASH_algorithms_SLASH_myersDiffAlgorithm_DOT_js.MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
      function getOrCreateHash(text) {
        let hash = perfectHashes.get(text);
        hash === void 0 && (hash = perfectHashes.size, perfectHashes.set(text, hash));
        return hash;
      }
      if (originalLines.length <= 1 && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.equals)(originalLines, modifiedLines, (a, b) => a === b)) {
        return new require$_DOT__DOT__SLASH_linesDiffComputer_DOT_js.LinesDiff([], [], !1);
      }
      if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
        return new require$_DOT__DOT__SLASH_linesDiffComputer_DOT_js.LinesDiff([new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.DetailedLineRangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(1, originalLines.length + 1), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(1, modifiedLines.length + 1), [new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.RangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 
        1, originalLines.length, originalLines[0].length + 1), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))])], [], !1);
      }
      const timeout = options.maxComputationTimeMs === 0 ? require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js.InfiniteTimeout.instance : new require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js.DateTimeout(options.maxComputationTimeMs), considerWhitespaceChanges = !options.ignoreTrimWhitespace, perfectHashes = new Map(), originalLinesHashes = originalLines.map(l => getOrCreateHash(l.trim())), modifiedLinesHashes = modifiedLines.map(l => getOrCreateHash(l.trim())), sequence1 = new require$_DOT__SLASH_lineSequence_DOT_js.LineSequence(originalLinesHashes, 
      originalLines), sequence2 = new require$_DOT__SLASH_lineSequence_DOT_js.LineSequence(modifiedLinesHashes, modifiedLines);
      var lineAlignmentResult = (() => sequence1.length + sequence2.length < 1700 ? this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99) : this.myersDiffingAlgorithm.compute(sequence1, sequence2))(), lineAlignments = lineAlignmentResult.diffs;
      let hitTimeout = lineAlignmentResult.hitTimeout;
      lineAlignments = (0,require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js.optimizeSequenceDiffs)(sequence1, sequence2, lineAlignments);
      lineAlignments = (0,require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js.removeVeryShortMatchingLinesBetweenDiffs)(sequence1, sequence2, lineAlignments);
      const alignments = [];
      lineAlignmentResult = equalLinesCount => {
        if (considerWhitespaceChanges) {
          for (let i = 0; i < equalLinesCount; i++) {
            var seq1Offset = seq1LastStart + i;
            const seq2Offset = seq2LastStart + i;
            if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
              seq1Offset = this.refineDiff(originalLines, modifiedLines, new require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js.SequenceDiff(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(seq1Offset, seq1Offset + 1), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
              for (const a of seq1Offset.mappings) {
                alignments.push(a);
              }
              seq1Offset.hitTimeout && (hitTimeout = !0);
            }
          }
        }
      };
      let seq1LastStart = 0, seq2LastStart = 0;
      for (const diff of lineAlignments) {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.assertFn)(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
        lineAlignmentResult(diff.seq1Range.start - seq1LastStart);
        seq1LastStart = diff.seq1Range.endExclusive;
        seq2LastStart = diff.seq2Range.endExclusive;
        lineAlignments = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
        lineAlignments.hitTimeout && (hitTimeout = !0);
        for (var a of lineAlignments.mappings) {
          alignments.push(a);
        }
      }
      lineAlignmentResult(originalLines.length - seq1LastStart);
      const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
      a = [];
      options.computeMoves && (a = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges));
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.assertFn)(() => {
        function validatePosition(pos, lines) {
          if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
            return !1;
          }
          lines = lines[pos.lineNumber - 1];
          return pos.column < 1 || pos.column > lines.length + 1 ? !1 : !0;
        }
        function validateRange(range, lines) {
          return range.startLineNumber < 1 || range.startLineNumber > lines.length + 1 || range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1 ? !1 : !0;
        }
        for (const c of changes) {
          if (!c.innerChanges) {
            return !1;
          }
          for (const ic of c.innerChanges) {
            if (!(validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines))) {
              return !1;
            }
          }
          if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
            return !1;
          }
        }
        return !0;
      });
      return new require$_DOT__DOT__SLASH_linesDiffComputer_DOT_js.LinesDiff(changes, a, hitTimeout);
    }
    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
      return (0,require$_DOT__SLASH_computeMovedLines_DOT_js.computeMovedLines)(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout).map(m => {
        var moveChanges = this.refineDiff(originalLines, modifiedLines, new require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js.SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
        moveChanges = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, !0);
        return new require$_DOT__DOT__SLASH_linesDiffComputer_DOT_js.MovedText(m, moveChanges);
      });
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
      const slice1 = new require$_DOT__SLASH_linesSliceCharSequence_DOT_js.LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges), slice2 = new require$_DOT__SLASH_linesSliceCharSequence_DOT_js.LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
      originalLines = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
      modifiedLines = originalLines.diffs;
      modifiedLines = (0,require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js.optimizeSequenceDiffs)(slice1, slice2, modifiedLines);
      modifiedLines = (0,require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js.extendDiffsToEntireWordIfAppropriate)(slice1, slice2, modifiedLines);
      modifiedLines = (0,require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js.removeShortMatches)(slice1, slice2, modifiedLines);
      modifiedLines = (0,require$_DOT__SLASH_heuristicSequenceOptimizations_DOT_js.removeVeryShortMatchingTextBetweenLongDiffs)(slice1, slice2, modifiedLines);
      return {mappings:modifiedLines.map(d => new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range))), hitTimeout:originalLines.hitTimeout};
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$defaultLinesDiffComputer.js.map
