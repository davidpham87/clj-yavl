shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$services$editorSimpleWorker = function(require, module, exports) {
  function create(host) {
    return new EditorSimpleWorker(host, null);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, EditorSimpleWorker:{enumerable:!0, get:function() {
    return EditorSimpleWorker;
  }}, create:{enumerable:!0, get:function() {
    return create;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_diff_SLASH_diff_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$diff$diff"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$uri"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$mirrorTextModel");
  var require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordHelper"), require$_DOT__DOT__SLASH_languages_SLASH_linkComputer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$linkComputer"), require$_DOT__DOT__SLASH_languages_SLASH_supports_SLASH_inplaceReplaceSupport_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$inplaceReplaceSupport");
  exports = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$editorBaseApi");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_stopwatch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$stopwatch"), require$_DOT__SLASH_unicodeTextModelHighlighter_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$services$unicodeTextModelHighlighter"), require$_DOT__DOT__SLASH_diff_SLASH_linesDiffComputers_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$linesDiffComputers"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_objects_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$objects"), require$_DOT__DOT__SLASH_languages_SLASH_defaultDocumentColorsComputer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$defaultDocumentColorsComputer");
  class MirrorModel extends module.MirrorTextModel {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    findMatches(regex) {
      const matches = [];
      for (let i = 0; i < this._lines.length; i++) {
        var line = this._lines[i];
        const offsetToAdd = this.offsetAt(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(i + 1, 1));
        line = line.matchAll(regex);
        for (const match of line) {
          if (match.index || match.index === 0) {
            match.index += offsetToAdd;
          }
          matches.push(match);
        }
      }
      return matches;
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(lineNumber) {
      return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position, wordDefinition) {
      return (wordDefinition = (0,require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js.getWordAtText)(position.column, (0,require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js.ensureValidWordDefinition)(wordDefinition), this._lines[position.lineNumber - 1], 0)) ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, wordDefinition.startColumn, position.lineNumber, wordDefinition.endColumn) : null;
    }
    words(wordDefinition) {
      const lines = this._lines, wordenize = this._wordenize.bind(this);
      let lineNumber = 0, lineText = "", wordRangesIdx = 0, wordRanges = [];
      return {*[Symbol.iterator]() {
        for (;;) {
          if (wordRangesIdx < wordRanges.length) {
            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
            wordRangesIdx += 1;
            yield value;
          } else {
            if (lineNumber < lines.length) {
              lineText = lines[lineNumber], wordRanges = wordenize(lineText, wordDefinition), wordRangesIdx = 0, lineNumber += 1;
            } else {
              break;
            }
          }
        }
      }};
    }
    getLineWords(lineNumber, wordDefinition) {
      lineNumber = this._lines[lineNumber - 1];
      wordDefinition = this._wordenize(lineNumber, wordDefinition);
      const words = [];
      for (const range of wordDefinition) {
        words.push({word:lineNumber.substring(range.start, range.end), startColumn:range.start + 1, endColumn:range.end + 1});
      }
      return words;
    }
    _wordenize(content, wordDefinition) {
      const result = [];
      let match;
      for (wordDefinition.lastIndex = 0; (match = wordDefinition.exec(content)) && match[0].length !== 0;) {
        result.push({start:match.index, end:match.index + match[0].length});
      }
      return result;
    }
    getValueInRange(range) {
      range = this._validateRange(range);
      if (range.startLineNumber === range.endLineNumber) {
        return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
      }
      const lineEnding = this._eol;
      var startLineIndex = range.startLineNumber - 1;
      const endLineIndex = range.endLineNumber - 1, resultLines = [];
      resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
      for (startLineIndex += 1; startLineIndex < endLineIndex; startLineIndex++) {
        resultLines.push(this._lines[startLineIndex]);
      }
      resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
      return resultLines.join(lineEnding);
    }
    offsetAt(position) {
      position = this._validatePosition(position);
      this._ensureLineStarts();
      return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
    }
    positionAt(offset) {
      offset = Math.floor(offset);
      offset = Math.max(0, offset);
      this._ensureLineStarts();
      offset = this._lineStarts.getIndexOf(offset);
      return {lineNumber:1 + offset.index, column:1 + Math.min(offset.remainder, this._lines[offset.index].length)};
    }
    _validateRange(range) {
      const start = this._validatePosition({lineNumber:range.startLineNumber, column:range.startColumn}), end = this._validatePosition({lineNumber:range.endLineNumber, column:range.endColumn});
      return start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn ? {startLineNumber:start.lineNumber, startColumn:start.column, endLineNumber:end.lineNumber, endColumn:end.column} : range;
    }
    _validatePosition(position) {
      if (!require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position.isIPosition(position)) {
        throw Error("bad position");
      }
      let {lineNumber, column} = position, hasChanged = !1;
      if (lineNumber < 1) {
        column = lineNumber = 1, hasChanged = !0;
      } else if (lineNumber > this._lines.length) {
        lineNumber = this._lines.length, column = this._lines[lineNumber - 1].length + 1, hasChanged = !0;
      } else {
        const maxCharacter = this._lines[lineNumber - 1].length + 1;
        column < 1 ? (column = 1, hasChanged = !0) : column > maxCharacter && (column = maxCharacter, hasChanged = !0);
      }
      return hasChanged ? {lineNumber, column} : position;
    }
  }
  class EditorSimpleWorker {
    constructor(host, foreignModuleFactory) {
      this._host = host;
      this._models = Object.create(null);
      this._foreignModuleFactory = foreignModuleFactory;
      this._foreignModule = null;
    }
    dispose() {
      this._models = Object.create(null);
    }
    _getModel(uri) {
      return this._models[uri];
    }
    _getModels() {
      const all = [];
      Object.keys(this._models).forEach(key => all.push(this._models[key]));
      return all;
    }
    acceptNewModel(data) {
      this._models[data.url] = new MirrorModel(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    acceptModelChanged(strURL, e) {
      if (this._models[strURL]) {
        this._models[strURL].onEvents(e);
      }
    }
    acceptRemovedModel(strURL) {
      this._models[strURL] && delete this._models[strURL];
    }
    async computeUnicodeHighlights(url, options, range) {
      return (url = this._getModel(url)) ? require$_DOT__SLASH_unicodeTextModelHighlighter_DOT_js.UnicodeTextModelHighlighter.computeUnicodeHighlights(url, options, range) : {ranges:[], hasMore:!1, ambiguousCharacterCount:0, invisibleCharacterCount:0, nonBasicAsciiCharacterCount:0};
    }
    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
      originalUrl = this._getModel(originalUrl);
      modifiedUrl = this._getModel(modifiedUrl);
      return originalUrl && modifiedUrl ? EditorSimpleWorker.computeDiff(originalUrl, modifiedUrl, options, algorithm) : null;
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
      function getLineChanges(changes) {
        return changes.map(m => {
          var _a;
          return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [m.originalRange.startLineNumber, m.originalRange.startColumn, m.originalRange.endLineNumber, m.originalRange.endColumn, m.modifiedRange.startLineNumber, m.modifiedRange.startColumn, m.modifiedRange.endLineNumber, m.modifiedRange.endColumn])];
        });
      }
      algorithm = algorithm === "advanced" ? require$_DOT__DOT__SLASH_diff_SLASH_linesDiffComputers_DOT_js.linesDiffComputers.getDefault() : require$_DOT__DOT__SLASH_diff_SLASH_linesDiffComputers_DOT_js.linesDiffComputers.getLegacy();
      const originalLines = originalTextModel.getLinesContent(), modifiedLines = modifiedTextModel.getLinesContent();
      options = algorithm.computeDiff(originalLines, modifiedLines, options);
      return {identical:options.changes.length > 0 ? !1 : this._modelsAreIdentical(originalTextModel, modifiedTextModel), quitEarly:options.hitTimeout, changes:getLineChanges(options.changes), moves:options.moves.map(m => [m.lineRangeMapping.original.startLineNumber, m.lineRangeMapping.original.endLineNumberExclusive, m.lineRangeMapping.modified.startLineNumber, m.lineRangeMapping.modified.endLineNumberExclusive, getLineChanges(m.changes)])};
    }
    static _modelsAreIdentical(original, modified) {
      const originalLineCount = original.getLineCount();
      var modifiedLineCount = modified.getLineCount();
      if (originalLineCount !== modifiedLineCount) {
        return !1;
      }
      for (modifiedLineCount = 1; modifiedLineCount <= originalLineCount; modifiedLineCount++) {
        const originalLine = original.getLineContent(modifiedLineCount), modifiedLine = modified.getLineContent(modifiedLineCount);
        if (originalLine !== modifiedLine) {
          return !1;
        }
      }
      return !0;
    }
    async computeMoreMinimalEdits(modelUrl, edits, pretty) {
      modelUrl = this._getModel(modelUrl);
      if (!modelUrl) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = edits.slice(0).sort((a, b) => a.range && b.range ? require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts(a.range, b.range) : (a.range ? 0 : 1) - (b.range ? 0 : 1));
      var writeIndex = 0;
      for (var readIndex = 1; readIndex < edits.length; readIndex++) {
        require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.getEndPosition(edits[writeIndex].range).equals(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.getStartPosition(edits[readIndex].range)) ? (edits[writeIndex].range = require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.getStartPosition(edits[writeIndex].range), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.getEndPosition(edits[readIndex].range)), edits[writeIndex].text += 
        edits[readIndex].text) : (writeIndex++, edits[writeIndex] = edits[readIndex]);
      }
      edits.length = writeIndex + 1;
      for (let {range, text, eol} of edits) {
        if (typeof eol === "number" && (lastEol = eol), !require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.isEmpty(range) || text) {
          if (edits = modelUrl.getValueInRange(range), text = text.replace(/\r\n|\n|\r/g, modelUrl.eol), edits !== text) {
            if (Math.max(text.length, edits.length) > EditorSimpleWorker._diffLimit) {
              result.push({range, text});
            } else {
              writeIndex = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_diff_SLASH_diff_DOT_js.stringDiff)(edits, text, pretty);
              edits = modelUrl.offsetAt(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.lift(range).getStartPosition());
              for (const change of writeIndex) {
                writeIndex = modelUrl.positionAt(edits + change.originalStart), readIndex = modelUrl.positionAt(edits + change.originalStart + change.originalLength), writeIndex = {text:text.substr(change.modifiedStart, change.modifiedLength), range:{startLineNumber:writeIndex.lineNumber, startColumn:writeIndex.column, endLineNumber:readIndex.lineNumber, endColumn:readIndex.column}}, modelUrl.getValueInRange(writeIndex.range) !== writeIndex.text && result.push(writeIndex);
              }
            }
          }
        }
      }
      typeof lastEol === "number" && result.push({eol:lastEol, text:"", range:{startLineNumber:0, startColumn:0, endLineNumber:0, endColumn:0}});
      return result;
    }
    async computeLinks(modelUrl) {
      return (modelUrl = this._getModel(modelUrl)) ? (0,require$_DOT__DOT__SLASH_languages_SLASH_linkComputer_DOT_js.computeLinks)(modelUrl) : null;
    }
    async computeDefaultDocumentColors(modelUrl) {
      return (modelUrl = this._getModel(modelUrl)) ? (0,require$_DOT__DOT__SLASH_languages_SLASH_defaultDocumentColorsComputer_DOT_js.computeDefaultDocumentColors)(modelUrl) : null;
    }
    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
      const sw = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_stopwatch_DOT_js.StopWatch();
      wordDef = new RegExp(wordDef, wordDefFlags);
      wordDefFlags = new Set();
      a: for (const url of modelUrls) {
        if (modelUrls = this._getModel(url)) {
          for (const word of modelUrls.words(wordDef)) {
            if (word !== leadingWord && isNaN(Number(word)) && (wordDefFlags.add(word), wordDefFlags.size > EditorSimpleWorker._suggestionsLimit)) {
              break a;
            }
          }
        }
      }
      return {words:Array.from(wordDefFlags), duration:sw.elapsed()};
    }
    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
      modelUrl = this._getModel(modelUrl);
      if (!modelUrl) {
        return Object.create(null);
      }
      wordDef = new RegExp(wordDef, wordDefFlags);
      wordDefFlags = Object.create(null);
      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
        var words = modelUrl.getLineWords(line, wordDef);
        for (const word of words) {
          isNaN(Number(word.word)) && (words = wordDefFlags[word.word], words || (words = [], wordDefFlags[word.word] = words), words.push({startLineNumber:line, startColumn:word.startColumn, endLineNumber:line, endColumn:word.endColumn}));
        }
      }
      return wordDefFlags;
    }
    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
      modelUrl = this._getModel(modelUrl);
      if (!modelUrl) {
        return null;
      }
      wordDefFlags = new RegExp(wordDef, wordDefFlags);
      range.startColumn === range.endColumn && (range = {startLineNumber:range.startLineNumber, startColumn:range.startColumn, endLineNumber:range.endLineNumber, endColumn:range.endColumn + 1});
      wordDef = modelUrl.getValueInRange(range);
      wordDefFlags = modelUrl.getWordAtPosition({lineNumber:range.startLineNumber, column:range.startColumn}, wordDefFlags);
      if (!wordDefFlags) {
        return null;
      }
      modelUrl = modelUrl.getValueInRange(wordDefFlags);
      return require$_DOT__DOT__SLASH_languages_SLASH_supports_SLASH_inplaceReplaceSupport_DOT_js.BasicInplaceReplace.INSTANCE.navigateValueSet(range, wordDef, wordDefFlags, modelUrl, up);
    }
    loadForeignModule(moduleId, createData, foreignHostMethods) {
      moduleId = {host:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_objects_DOT_js.createProxyObject)(foreignHostMethods, (method, args) => this._host.fhr(method, args)), getMirrorModels:() => this._getModels()};
      return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(moduleId, createData), Promise.resolve((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_objects_DOT_js.getAllMethodNames)(this._foreignModule))) : Promise.reject(Error("Unexpected usage"));
    }
    fmr(method, args) {
      if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
        return Promise.reject(Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }
  EditorSimpleWorker._diffLimit = 100000;
  EditorSimpleWorker._suggestionsLimit = 10000;
  typeof importScripts === "function" && (globalThis.monaco = (0,exports.createMonacoBaseAPI)());
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$services$editorSimpleWorker.js.map
