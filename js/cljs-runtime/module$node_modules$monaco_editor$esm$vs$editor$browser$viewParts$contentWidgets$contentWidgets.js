shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$contentWidgets$contentWidgets = function(require, module, exports) {
  function safeInvoke(fn, thisArg, ...args) {
    try {
      return fn.call(thisArg, ...args);
    } catch (_a) {
      return null;
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ViewContentWidgets:{enumerable:!0, get:function() {
    return ViewContentWidgets;
  }}});
  var dom = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart");
  class ViewContentWidgets extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.ViewPart {
    constructor(context, viewDomNode) {
      super(context);
      this._viewDomNode = viewDomNode;
      this._widgets = {};
      this.domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.write(this.domNode, 1);
      this.domNode.setClassName("contentWidgets");
      this.domNode.setPosition("absolute");
      this.domNode.setTop(0);
      this.overflowingContentWidgetsDomNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2);
      this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
    }
    dispose() {
      super.dispose();
      this._widgets = {};
    }
    onConfigurationChanged(e) {
      const keys = Object.keys(this._widgets);
      for (const widgetId of keys) {
        this._widgets[widgetId].onConfigurationChanged(e);
      }
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLineMappingChanged(e) {
      this._updateAnchorsViewPositions();
      return !0;
    }
    onLinesChanged(e) {
      this._updateAnchorsViewPositions();
      return !0;
    }
    onLinesDeleted(e) {
      this._updateAnchorsViewPositions();
      return !0;
    }
    onLinesInserted(e) {
      this._updateAnchorsViewPositions();
      return !0;
    }
    onScrollChanged(e) {
      return !0;
    }
    onZonesChanged(e) {
      return !0;
    }
    _updateAnchorsViewPositions() {
      const keys = Object.keys(this._widgets);
      for (const widgetId of keys) {
        this._widgets[widgetId].updateAnchorViewPosition();
      }
    }
    addWidget(_widget) {
      _widget = new Widget(this._context, this._viewDomNode, _widget);
      this._widgets[_widget.id] = _widget;
      _widget.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(_widget.domNode) : this.domNode.appendChild(_widget.domNode);
      this.setShouldRender();
    }
    setWidgetPosition(widget, primaryAnchor, secondaryAnchor, preference, affinity) {
      this._widgets[widget.getId()].setPosition(primaryAnchor, secondaryAnchor, preference, affinity);
      this.setShouldRender();
    }
    removeWidget(widget) {
      widget = widget.getId();
      if (this._widgets.hasOwnProperty(widget)) {
        const myWidget = this._widgets[widget];
        delete this._widgets[widget];
        widget = myWidget.domNode.domNode;
        widget.parentNode.removeChild(widget);
        widget.removeAttribute("monaco-visible-content-widget");
        this.setShouldRender();
      }
    }
    shouldSuppressMouseDownOnWidget(widgetId) {
      return this._widgets.hasOwnProperty(widgetId) ? this._widgets[widgetId].suppressMouseDown : !1;
    }
    onBeforeRender(viewportData) {
      const keys = Object.keys(this._widgets);
      for (const widgetId of keys) {
        this._widgets[widgetId].onBeforeRender(viewportData);
      }
    }
    prepareRender(ctx) {
      const keys = Object.keys(this._widgets);
      for (const widgetId of keys) {
        this._widgets[widgetId].prepareRender(ctx);
      }
    }
    render(ctx) {
      const keys = Object.keys(this._widgets);
      for (const widgetId of keys) {
        this._widgets[widgetId].render(ctx);
      }
    }
  }
  class Widget {
    constructor(context, viewDomNode, actual) {
      this._primaryAnchor = new PositionPair(null, null);
      this._secondaryAnchor = new PositionPair(null, null);
      this._context = context;
      this._viewDomNode = viewDomNode;
      this._actual = actual;
      this.domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(this._actual.getDomNode());
      this.id = this._actual.getId();
      this.allowEditorOverflow = this._actual.allowEditorOverflow || !1;
      this.suppressMouseDown = this._actual.suppressMouseDown || !1;
      context = this._context.configuration.options;
      viewDomNode = context.get(143);
      this._fixedOverflowWidgets = context.get(42);
      this._contentWidth = viewDomNode.contentWidth;
      this._contentLeft = viewDomNode.contentLeft;
      this._lineHeight = context.get(66);
      this._affinity = null;
      this._preference = [];
      this._cachedDomNodeOffsetHeight = this._cachedDomNodeOffsetWidth = -1;
      this._maxWidth = this._getMaxWidth();
      this._isVisible = !1;
      this._renderData = null;
      this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute");
      this.domNode.setDisplay("none");
      this.domNode.setVisibility("hidden");
      this.domNode.setAttribute("widgetId", this.id);
      this.domNode.setMaxWidth(this._maxWidth);
    }
    onConfigurationChanged(e) {
      const options = this._context.configuration.options;
      this._lineHeight = options.get(66);
      e.hasChanged(143) && (e = options.get(143), this._contentLeft = e.contentLeft, this._contentWidth = e.contentWidth, this._maxWidth = this._getMaxWidth());
    }
    updateAnchorViewPosition() {
      this._setPosition(this._affinity, this._primaryAnchor.modelPosition, this._secondaryAnchor.modelPosition);
    }
    _setPosition(affinity, primaryAnchor, secondaryAnchor) {
      function getValidPositionPair(position, viewModel, affinity) {
        if (!position) {
          return new PositionPair(null, null);
        }
        const validModelPosition = viewModel.model.validatePosition(position);
        return viewModel.coordinatesConverter.modelPositionIsVisible(validModelPosition) ? (viewModel = viewModel.coordinatesConverter.convertModelPositionToViewPosition(validModelPosition, affinity !== null && affinity !== void 0 ? affinity : void 0), new PositionPair(position, viewModel)) : new PositionPair(position, null);
      }
      this._affinity = affinity;
      this._primaryAnchor = getValidPositionPair(primaryAnchor, this._context.viewModel, this._affinity);
      this._secondaryAnchor = getValidPositionPair(secondaryAnchor, this._context.viewModel, this._affinity);
    }
    _getMaxWidth() {
      const elDocument = this.domNode.domNode.ownerDocument, elWindow = elDocument.defaultView;
      return this.allowEditorOverflow ? (elWindow === null || elWindow === void 0 ? void 0 : elWindow.innerWidth) || elDocument.documentElement.offsetWidth || elDocument.body.offsetWidth : this._contentWidth;
    }
    setPosition(primaryAnchor, secondaryAnchor, preference, affinity) {
      this._setPosition(affinity, primaryAnchor, secondaryAnchor);
      this._preference = preference;
      this._primaryAnchor.viewPosition && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none");
      this._cachedDomNodeOffsetHeight = this._cachedDomNodeOffsetWidth = -1;
    }
    _layoutBoxInViewport(anchor, width, height, ctx) {
      const aboveLineTop = anchor.top, underLineTop = anchor.top + anchor.height, heightAvailableUnderLine = ctx.viewportHeight - underLineTop;
      anchor = anchor.left;
      anchor + width > ctx.scrollLeft + ctx.viewportWidth && (anchor = ctx.scrollLeft + ctx.viewportWidth - width);
      anchor < ctx.scrollLeft && (anchor = ctx.scrollLeft);
      return {fitsAbove:aboveLineTop >= height, aboveTop:aboveLineTop - height, fitsBelow:heightAvailableUnderLine >= height, belowTop:underLineTop, left:anchor};
    }
    _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {
      var _a, MIN_LIMIT = Math.max(15, domNodePosition.left - width);
      windowSize = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width - 15);
      const elWindow = this._viewDomNode.domNode.ownerDocument.defaultView;
      domNodePosition = domNodePosition.left + left - ((_a = elWindow === null || elWindow === void 0 ? void 0 : elWindow.scrollX) !== null && _a !== void 0 ? _a : 0);
      domNodePosition + width > windowSize && (width = domNodePosition - (windowSize - width), domNodePosition -= width, left -= width);
      domNodePosition < MIN_LIMIT && (MIN_LIMIT = domNodePosition - MIN_LIMIT, domNodePosition -= MIN_LIMIT, left -= MIN_LIMIT);
      return [left, domNodePosition];
    }
    _layoutBoxInPage(anchor, width, height, ctx) {
      var _a, _b;
      const aboveTop = anchor.top - height, belowTop = anchor.top + anchor.height, domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode), elDocument = this._viewDomNode.domNode.ownerDocument, elWindow = elDocument.defaultView, absoluteAboveTop = domNodePosition.top + aboveTop - ((_a = elWindow === null || elWindow === void 0 ? void 0 : elWindow.scrollY) !== null && _a !== void 0 ? _a : 0);
      _a = domNodePosition.top + belowTop - ((_b = elWindow === null || elWindow === void 0 ? void 0 : elWindow.scrollY) !== null && _b !== void 0 ? _b : 0);
      _b = dom.getClientArea(elDocument.body);
      const [left, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(_b, domNodePosition, anchor.left - ctx.scrollLeft + this._contentLeft, width);
      anchor = absoluteAboveTop >= 22;
      height = _a + height <= _b.height - 22;
      return this._fixedOverflowWidgets ? {fitsAbove:anchor, aboveTop:Math.max(absoluteAboveTop, 22), fitsBelow:height, belowTop:_a, left:absoluteAboveLeft} : {fitsAbove:anchor, aboveTop, fitsBelow:height, belowTop, left};
    }
    _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {
      return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);
    }
    _getAnchorsCoordinates(ctx) {
      function getCoordinates(position, affinity, lineHeight) {
        if (!position) {
          return null;
        }
        const horizontalPosition = ctx.visibleRangeForPosition(position);
        if (!horizontalPosition) {
          return null;
        }
        affinity = position.column === 1 && affinity === 3 ? 0 : horizontalPosition.left;
        position = ctx.getVerticalOffsetForLineNumber(position.lineNumber) - ctx.scrollTop;
        return new AnchorCoordinate(position, affinity, lineHeight);
      }
      var _a, _b;
      const primary = getCoordinates(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight), secondaryViewPosition = ((_a = this._secondaryAnchor.viewPosition) === null || _a === void 0 ? void 0 : _a.lineNumber) === ((_b = this._primaryAnchor.viewPosition) === null || _b === void 0 ? void 0 : _b.lineNumber) ? this._secondaryAnchor.viewPosition : null;
      _a = getCoordinates(secondaryViewPosition, this._affinity, this._lineHeight);
      return {primary, secondary:_a};
    }
    _reduceAnchorCoordinates(primary, secondary, width) {
      if (!secondary) {
        return primary;
      }
      const fontInfo = this._context.configuration.options.get(50);
      secondary = secondary.left;
      secondary = secondary < primary.left ? Math.max(secondary, primary.left - width + fontInfo.typicalFullwidthCharacterWidth) : Math.min(secondary, primary.left + width - fontInfo.typicalFullwidthCharacterWidth);
      return new AnchorCoordinate(primary.top, secondary, primary.height);
    }
    _prepareRenderWidget(ctx) {
      if (!this._preference || this._preference.length === 0) {
        return null;
      }
      const {primary, secondary} = this._getAnchorsCoordinates(ctx);
      if (!primary) {
        return null;
      }
      if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
        var preferredDimensions = null;
        typeof this._actual.beforeRender === "function" && (preferredDimensions = safeInvoke(this._actual.beforeRender, this._actual));
        preferredDimensions ? (this._cachedDomNodeOffsetWidth = preferredDimensions.width, this._cachedDomNodeOffsetHeight = preferredDimensions.height) : (preferredDimensions = this.domNode.domNode.getBoundingClientRect(), this._cachedDomNodeOffsetWidth = Math.round(preferredDimensions.width), this._cachedDomNodeOffsetHeight = Math.round(preferredDimensions.height));
      }
      preferredDimensions = this._reduceAnchorCoordinates(primary, secondary, this._cachedDomNodeOffsetWidth);
      ctx = this.allowEditorOverflow ? this._layoutBoxInPage(preferredDimensions, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx) : this._layoutBoxInViewport(preferredDimensions, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);
      for (let pass = 1; pass <= 2; pass++) {
        for (const pref of this._preference) {
          if (pref === 1) {
            if (!ctx) {
              return null;
            }
            if (pass === 2 || ctx.fitsAbove) {
              return {coordinate:new Coordinate(ctx.aboveTop, ctx.left), position:1};
            }
          } else if (pref === 2) {
            if (!ctx) {
              return null;
            }
            if (pass === 2 || ctx.fitsBelow) {
              return {coordinate:new Coordinate(ctx.belowTop, ctx.left), position:2};
            }
          } else {
            return this.allowEditorOverflow ? {coordinate:this._prepareRenderWidgetAtExactPositionOverflowing(new Coordinate(preferredDimensions.top, preferredDimensions.left)), position:0} : {coordinate:new Coordinate(preferredDimensions.top, preferredDimensions.left), position:0};
          }
        }
      }
      return null;
    }
    onBeforeRender(viewportData) {
      this._primaryAnchor.viewPosition && this._preference && (this._primaryAnchor.viewPosition.lineNumber < viewportData.startLineNumber || this._primaryAnchor.viewPosition.lineNumber > viewportData.endLineNumber || this.domNode.setMaxWidth(this._maxWidth));
    }
    prepareRender(ctx) {
      this._renderData = this._prepareRenderWidget(ctx);
    }
    render(ctx) {
      this._renderData ? (this.allowEditorOverflow ? this.domNode.setTop(this._renderData.coordinate.top) : this.domNode.setTop(this._renderData.coordinate.top + ctx.scrollTop - ctx.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender === "function" && safeInvoke(this._actual.afterRender, this._actual, 
      this._renderData.position)) : (this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, this.domNode.setVisibility("hidden")), typeof this._actual.afterRender === "function" && safeInvoke(this._actual.afterRender, this._actual, null));
    }
  }
  class PositionPair {
    constructor(modelPosition, viewPosition) {
      this.modelPosition = modelPosition;
      this.viewPosition = viewPosition;
    }
  }
  class Coordinate {
    constructor(top, left) {
      this.top = top;
      this.left = left;
      this._coordinateBrand = void 0;
    }
  }
  class AnchorCoordinate {
    constructor(top, left, height) {
      this.top = top;
      this.left = left;
      this.height = height;
      this._anchorCoordinateBrand = void 0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$contentWidgets$contentWidgets.js.map
