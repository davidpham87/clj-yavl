shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$blockDecorations$blockDecorations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BlockDecorations:{enumerable:!0, get:function() {
    return BlockDecorations;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode");
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$blockDecorations$blockDecorations_css");
  require = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart");
  class BlockDecorations extends require.ViewPart {
    constructor(context) {
      super(context);
      this.blocks = [];
      this.contentWidth = -1;
      this.contentLeft = 0;
      this.domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      this.domNode.setAttribute("role", "presentation");
      this.domNode.setAttribute("aria-hidden", "true");
      this.domNode.setClassName("blockDecorations-container");
      this.update();
    }
    update() {
      let didChange = !1;
      var layoutInfo = this._context.configuration.options.get(143);
      const newContentWidth = layoutInfo.contentWidth - layoutInfo.verticalScrollbarWidth;
      this.contentWidth !== newContentWidth && (this.contentWidth = newContentWidth, didChange = !0);
      layoutInfo = layoutInfo.contentLeft;
      this.contentLeft !== layoutInfo && (this.contentLeft = layoutInfo, didChange = !0);
      return didChange;
    }
    dispose() {
      super.dispose();
    }
    onConfigurationChanged(e) {
      return this.update();
    }
    onScrollChanged(e) {
      return e.scrollTopChanged || e.scrollLeftChanged;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onZonesChanged(e) {
      return !0;
    }
    prepareRender(ctx) {
    }
    render(ctx) {
      var _a;
      let count = 0;
      var decorations = ctx.getDecorationsInViewport();
      for (const decoration of decorations) {
        if (!decoration.options.blockClassName) {
          continue;
        }
        decorations = this.blocks[count];
        decorations || (decorations = this.blocks[count] = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div")), this.domNode.appendChild(decorations));
        let top, bottom;
        decoration.options.blockIsAfterEnd ? (top = ctx.getVerticalOffsetAfterLineNumber(decoration.range.endLineNumber, !1), bottom = ctx.getVerticalOffsetAfterLineNumber(decoration.range.endLineNumber, !0)) : (top = ctx.getVerticalOffsetForLineNumber(decoration.range.startLineNumber, !0), bottom = decoration.range.isEmpty() && !decoration.options.blockDoesNotCollapse ? ctx.getVerticalOffsetForLineNumber(decoration.range.startLineNumber, !1) : ctx.getVerticalOffsetAfterLineNumber(decoration.range.endLineNumber, 
        !0));
        const [paddingTop, paddingRight, paddingBottom, paddingLeft] = (_a = decoration.options.blockPadding) !== null && _a !== void 0 ? _a : [0, 0, 0, 0];
        decorations.setClassName("blockDecorations-block " + decoration.options.blockClassName);
        decorations.setLeft(this.contentLeft - paddingLeft);
        decorations.setWidth(this.contentWidth + paddingLeft + paddingRight);
        decorations.setTop(top - ctx.scrollTop - paddingTop);
        decorations.setHeight(bottom - top + paddingTop + paddingBottom);
        count++;
      }
      for (ctx = count; ctx < this.blocks.length; ctx++) {
        this.blocks[ctx].domNode.remove();
      }
      this.blocks.length = count;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$blockDecorations$blockDecorations.js.map
