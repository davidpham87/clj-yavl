shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$diff$legacyLinesDiffComputer = function(require, module, exports) {
  function getFirstNonBlankColumn(txt, defaultValue) {
    txt = strings.firstNonWhitespaceIndex(txt);
    return txt === -1 ? defaultValue : txt + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    txt = strings.lastNonWhitespaceIndex(txt);
    return txt === -1 ? defaultValue : txt + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => !0;
    }
    const startTime = Date.now();
    return () => Date.now() - startTime < maximumRuntime;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DiffComputer:{enumerable:!0, get:function() {
    return DiffComputer;
  }}, LegacyLinesDiffComputer:{enumerable:!0, get:function() {
    return LegacyLinesDiffComputer;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_diff_SLASH_diff_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$diff$diff"), require$_DOT__SLASH_linesDiffComputer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$linesDiffComputer"), require$_DOT__SLASH_rangeMapping_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$rangeMapping"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), 
  require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$assert"), require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange");
  class LegacyLinesDiffComputer {
    computeDiff(originalLines, modifiedLines, options) {
      var _a;
      originalLines = (new DiffComputer(originalLines, modifiedLines, {maxComputationTime:options.maxComputationTimeMs, shouldIgnoreTrimWhitespace:options.ignoreTrimWhitespace, shouldComputeCharChanges:!0, shouldMakePrettyDiff:!0, shouldPostProcessCharChanges:!0})).computeDiff();
      const changes = [];
      modifiedLines = null;
      for (const c of originalLines.changes) {
        options = c.originalEndLineNumber === 0 ? new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1) : new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
        let modifiedRange;
        modifiedRange = c.modifiedEndLineNumber === 0 ? new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1) : new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
        options = new require$_DOT__SLASH_rangeMapping_DOT_js.DetailedLineRangeMapping(options, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new require$_DOT__SLASH_rangeMapping_DOT_js.RangeMapping(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(c.modifiedStartLineNumber, c.modifiedStartColumn, 
        c.modifiedEndLineNumber, c.modifiedEndColumn))));
        !modifiedLines || modifiedLines.modified.endLineNumberExclusive !== options.modified.startLineNumber && modifiedLines.original.endLineNumberExclusive !== options.original.startLineNumber || (options = new require$_DOT__SLASH_rangeMapping_DOT_js.DetailedLineRangeMapping(modifiedLines.original.join(options.original), modifiedLines.modified.join(options.modified), modifiedLines.innerChanges && options.innerChanges ? modifiedLines.innerChanges.concat(options.innerChanges) : void 0), changes.pop());
        changes.push(options);
        modifiedLines = options;
      }
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.assertFn)(() => (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.checkAdjacentItems)(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < 
      m2.modified.startLineNumber));
      return new require$_DOT__SLASH_linesDiffComputer_DOT_js.LinesDiff(changes, [], originalLines.quitEarly);
    }
  }
  class LineSequence {
    constructor(lines) {
      const startColumns = [], endColumns = [];
      for (let i = 0, length = lines.length; i < length; i++) {
        startColumns[i] = getFirstNonBlankColumn(lines[i], 1), endColumns[i] = getLastNonBlankColumn(lines[i], 1);
      }
      this.lines = lines;
      this._startColumns = startColumns;
      this._endColumns = endColumns;
    }
    getElements() {
      const elements = [];
      for (let i = 0, len = this.lines.length; i < len; i++) {
        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
      }
      return elements;
    }
    getStrictElement(index) {
      return this.lines[index];
    }
    getStartLineNumber(i) {
      return i + 1;
    }
    getEndLineNumber(i) {
      return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
      const charCodes = [], lineNumbers = [], columns = [];
      let len = 0;
      for (; startIndex <= endIndex; startIndex++) {
        const lineContent = this.lines[startIndex];
        var startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[startIndex] : 1;
        const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[startIndex] : lineContent.length + 1;
        for (; startColumn < endColumn; startColumn++) {
          charCodes[len] = lineContent.charCodeAt(startColumn - 1), lineNumbers[len] = startIndex + 1, columns[len] = startColumn, len++;
        }
        !shouldIgnoreTrimWhitespace && startIndex < endIndex && (charCodes[len] = 10, lineNumbers[len] = startIndex + 1, columns[len] = lineContent.length + 1, len++);
      }
      return new CharSequence(charCodes, lineNumbers, columns);
    }
  }
  class CharSequence {
    constructor(charCodes, lineNumbers, columns) {
      this._charCodes = charCodes;
      this._lineNumbers = lineNumbers;
      this._columns = columns;
    }
    toString() {
      return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
    }
    _assertIndex(index, arr) {
      if (index < 0 || index >= arr.length) {
        throw Error("Illegal index");
      }
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(i) {
      if (i > 0 && i === this._lineNumbers.length) {
        return this.getEndLineNumber(i - 1);
      }
      this._assertIndex(i, this._lineNumbers);
      return this._lineNumbers[i];
    }
    getEndLineNumber(i) {
      if (i === -1) {
        return this.getStartLineNumber(i + 1);
      }
      this._assertIndex(i, this._lineNumbers);
      return this._charCodes[i] === 10 ? this._lineNumbers[i] + 1 : this._lineNumbers[i];
    }
    getStartColumn(i) {
      if (i > 0 && i === this._columns.length) {
        return this.getEndColumn(i - 1);
      }
      this._assertIndex(i, this._columns);
      return this._columns[i];
    }
    getEndColumn(i) {
      if (i === -1) {
        return this.getStartColumn(i + 1);
      }
      this._assertIndex(i, this._columns);
      return this._charCodes[i] === 10 ? 1 : this._columns[i] + 1;
    }
  }
  class CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalStartColumn = originalStartColumn;
      this.originalEndLineNumber = originalEndLineNumber;
      this.originalEndColumn = originalEndColumn;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedStartColumn = modifiedStartColumn;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
      const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart), originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart), originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      originalCharSequence = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart), modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart), modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      diffChange = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalCharSequence, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, diffChange);
    }
  }
  class LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalEndLineNumber = originalEndLineNumber;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
      let originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber;
      var charChanges = void 0;
      diffChange.originalLength === 0 ? (originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1, originalEndLineNumber = 0) : (originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart), originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1));
      diffChange.modifiedLength === 0 ? (modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1, modifiedEndLineNumber = 0) : (modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart), modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1));
      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff() && (originalLineSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1), shouldIgnoreTrimWhitespace = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + 
      diffChange.modifiedLength - 1), originalLineSequence.getElements().length > 0 && shouldIgnoreTrimWhitespace.getElements().length > 0)) {
        continueCharDiff = (new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_diff_SLASH_diff_DOT_js.LcsDiff(originalLineSequence, shouldIgnoreTrimWhitespace, continueCharDiff)).ComputeDiff(!0).changes;
        if (shouldPostProcessCharChanges) {
          if (shouldPostProcessCharChanges = continueCharDiff, shouldPostProcessCharChanges.length <= 1) {
            continueCharDiff = shouldPostProcessCharChanges;
          } else {
            charChanges = [shouldPostProcessCharChanges[0]];
            continueCharDiff = charChanges[0];
            for (let i = 1, len = shouldPostProcessCharChanges.length; i < len; i++) {
              diffChange = shouldPostProcessCharChanges[i], Math.min(diffChange.originalStart - (continueCharDiff.originalStart + continueCharDiff.originalLength), diffChange.modifiedStart - (continueCharDiff.modifiedStart + continueCharDiff.modifiedLength)) < 3 ? (continueCharDiff.originalLength = diffChange.originalStart + diffChange.originalLength - continueCharDiff.originalStart, continueCharDiff.modifiedLength = diffChange.modifiedStart + diffChange.modifiedLength - continueCharDiff.modifiedStart) : 
              (charChanges.push(diffChange), continueCharDiff = diffChange);
            }
            continueCharDiff = charChanges;
          }
        }
        charChanges = [];
        for (let i = 0, length = continueCharDiff.length; i < length; i++) {
          charChanges.push(CharChange.createFromDiffChange(continueCharDiff[i], originalLineSequence, shouldIgnoreTrimWhitespace));
        }
      }
      return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
  }
  class DiffComputer {
    constructor(originalLines, modifiedLines, opts) {
      this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
      this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
      this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
      this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
      this.originalLines = originalLines;
      this.modifiedLines = modifiedLines;
      this.original = new LineSequence(originalLines);
      this.modified = new LineSequence(modifiedLines);
      this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
      this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
        return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {quitEarly:!1, changes:[]} : {quitEarly:!1, changes:[{originalStartLineNumber:1, originalEndLineNumber:1, modifiedStartLineNumber:1, modifiedEndLineNumber:this.modified.lines.length, charChanges:void 0}]};
      }
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {quitEarly:!1, changes:[{originalStartLineNumber:1, originalEndLineNumber:this.original.lines.length, modifiedStartLineNumber:1, modifiedEndLineNumber:1, charChanges:void 0}]};
      }
      var pretty = this.shouldMakePrettyDiff;
      var JSCompiler_inline_result = (new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_diff_SLASH_diff_DOT_js.LcsDiff(this.original, this.modified, this.continueLineDiff)).ComputeDiff(pretty);
      pretty = JSCompiler_inline_result.changes;
      JSCompiler_inline_result = JSCompiler_inline_result.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        var lineChanges = [];
        for (let i = 0, length = pretty.length; i < length; i++) {
          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, pretty[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        }
        return {quitEarly:JSCompiler_inline_result, changes:lineChanges};
      }
      lineChanges = [];
      let originalLineIndex = 0, modifiedLineIndex = 0;
      for (let i = -1, len = pretty.length; i < len; i++) {
        const nextChange = i + 1 < len ? pretty[i + 1] : null, originalStop = nextChange ? nextChange.originalStart : this.originalLines.length, modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
        for (; originalLineIndex < originalStop && modifiedLineIndex < modifiedStop;) {
          const originalLine = this.originalLines[originalLineIndex];
          var modifiedLine = this.modifiedLines[modifiedLineIndex];
          if (originalLine !== modifiedLine) {
            for (var originalStartColumn = getFirstNonBlankColumn(originalLine, 1), modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1); originalStartColumn > 1 && modifiedStartColumn > 1;) {
              var originalChar = originalLine.charCodeAt(originalStartColumn - 2), modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalStartColumn--;
              modifiedStartColumn--;
            }
            (originalStartColumn > 1 || modifiedStartColumn > 1) && this._pushTrimWhitespaceCharChange(lineChanges, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
            originalStartColumn = getLastNonBlankColumn(originalLine, 1);
            modifiedStartColumn = getLastNonBlankColumn(modifiedLine, 1);
            originalChar = originalLine.length + 1;
            for (modifiedLine = modifiedLine.length + 1; originalStartColumn < originalChar && modifiedStartColumn < modifiedLine;) {
              modifiedChar = originalLine.charCodeAt(originalStartColumn - 1);
              const modifiedChar$jscomp$0 = originalLine.charCodeAt(modifiedStartColumn - 1);
              if (modifiedChar !== modifiedChar$jscomp$0) {
                break;
              }
              originalStartColumn++;
              modifiedStartColumn++;
            }
            (originalStartColumn < originalChar || modifiedStartColumn < modifiedLine) && this._pushTrimWhitespaceCharChange(lineChanges, originalLineIndex + 1, originalStartColumn, originalChar, modifiedLineIndex + 1, modifiedStartColumn, modifiedLine);
          }
          originalLineIndex++;
          modifiedLineIndex++;
        }
        nextChange && (lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), originalLineIndex += nextChange.originalLength, modifiedLineIndex += nextChange.modifiedLength);
      }
      return {quitEarly:JSCompiler_inline_result, changes:lineChanges};
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      if (!this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
        var charChanges = void 0;
        this.shouldComputeCharChanges && (charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)]);
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
      }
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      const len = result.length;
      if (len === 0) {
        return !1;
      }
      result = result[len - 1];
      return result.originalEndLineNumber === 0 || result.modifiedEndLineNumber === 0 ? !1 : result.originalEndLineNumber === originalLineNumber && result.modifiedEndLineNumber === modifiedLineNumber ? (this.shouldComputeCharChanges && result.charChanges && result.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)), !0) : result.originalEndLineNumber + 1 === 
      originalLineNumber && result.modifiedEndLineNumber + 1 === modifiedLineNumber ? (result.originalEndLineNumber = originalLineNumber, result.modifiedEndLineNumber = modifiedLineNumber, this.shouldComputeCharChanges && result.charChanges && result.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)), !0) : !1;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$diff$legacyLinesDiffComputer.js.map
