shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$color = function(require, module, exports) {
  function roundFloat(number, decimalPoints) {
    decimalPoints = Math.pow(10, decimalPoints);
    return Math.round(number * decimalPoints) / decimalPoints;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Color:{enumerable:!0, get:function() {
    return Color;
  }}, HSLA:{enumerable:!0, get:function() {
    return HSLA;
  }}, HSVA:{enumerable:!0, get:function() {
    return HSVA;
  }}, RGBA:{enumerable:!0, get:function() {
    return RGBA;
  }}});
  class RGBA {
    constructor(r, g, b, a = 1) {
      this._rgbaBrand = void 0;
      this.r = Math.min(255, Math.max(0, r)) | 0;
      this.g = Math.min(255, Math.max(0, g)) | 0;
      this.b = Math.min(255, Math.max(0, b)) | 0;
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
    }
  }
  class HSLA {
    constructor(h, s, l, a) {
      this._hslaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
    }
    static fromRGBA(rgba) {
      const r = rgba.r / 255, g = rgba.g / 255, b = rgba.b / 255;
      rgba = rgba.a;
      const max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      let h = 0, s = 0;
      const l = (min + max) / 2;
      min = max - min;
      if (min > 0) {
        s = Math.min(l <= 0.5 ? min / (2 * l) : min / (2 - 2 * l), 1);
        switch(max) {
          case r:
            h = (g - b) / min + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / min + 2;
            break;
          case b:
            h = (r - g) / min + 4;
        }
        h = Math.round(h * 60);
      }
      return new HSLA(h, s, l, rgba);
    }
    static _hue2rgb(p, q, t) {
      t < 0 && (t += 1);
      t > 1 && --t;
      return t < 1 / 6 ? p + (q - p) * 6 * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
    }
    static toRGBA(hsla) {
      var h = hsla.h / 360;
      const {s, l, a} = hsla;
      let g;
      if (s === 0) {
        hsla = g = h = l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
        hsla = HSLA._hue2rgb(p, q, h + 1 / 3);
        g = HSLA._hue2rgb(p, q, h);
        h = HSLA._hue2rgb(p, q, h - 1 / 3);
      }
      return new RGBA(Math.round(hsla * 255), Math.round(g * 255), Math.round(h * 255), a);
    }
  }
  class HSVA {
    constructor(h, s, v, a) {
      this._hsvaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
    }
    static fromRGBA(rgba) {
      const r = rgba.r / 255, g = rgba.g / 255, b = rgba.b / 255, cmax = Math.max(r, g, b), delta = cmax - Math.min(r, g, b);
      return new HSVA(Math.round((delta === 0 ? 0 : cmax === r ? ((g - b) / delta % 6 + 6) % 6 : cmax === g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60), cmax === 0 ? 0 : delta / cmax, cmax, rgba.a);
    }
    static toRGBA(hsva) {
      const {h, s, v, a} = hsva;
      hsva = v * s;
      const x = hsva * (1 - Math.abs(h / 60 % 2 - 1)), m = v - hsva;
      let [r, g, b] = [0, 0, 0];
      h < 60 ? (r = hsva, g = x) : h < 120 ? (r = x, g = hsva) : h < 180 ? (g = hsva, b = x) : h < 240 ? (g = x, b = hsva) : h < 300 ? (r = x, b = hsva) : h <= 360 && (r = hsva, b = x);
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return new RGBA(r, g, b, a);
    }
  }
  class Color {
    static fromHex(hex) {
      return Color.Format.CSS.parseHex(hex) || Color.red;
    }
    static equals(a, b) {
      return a || b ? a && b ? a.equals(b) : !1 : !0;
    }
    get hsla() {
      return this._hsla ? this._hsla : HSLA.fromRGBA(this.rgba);
    }
    get hsva() {
      return this._hsva ? this._hsva : HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
      if (arg) {
        if (arg instanceof RGBA) {
          this.rgba = arg;
        } else if (arg instanceof HSLA) {
          this._hsla = arg, this.rgba = HSLA.toRGBA(arg);
        } else if (arg instanceof HSVA) {
          this._hsva = arg, this.rgba = HSVA.toRGBA(arg);
        } else {
          throw Error("Invalid color ctor argument");
        }
      } else {
        throw Error("Color needs a value");
      }
    }
    equals(other) {
      return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    getRelativeLuminance() {
      const R = Color._relativeLuminanceForComponent(this.rgba.r), G = Color._relativeLuminanceForComponent(this.rgba.g), B = Color._relativeLuminanceForComponent(this.rgba.b);
      return roundFloat(0.2126 * R + 0.7152 * G + 0.0722 * B, 4);
    }
    static _relativeLuminanceForComponent(color) {
      color /= 255;
      return color <= 0.03928 ? color / 12.92 : Math.pow((color + 0.055) / 1.055, 2.4);
    }
    isLighter() {
      return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000 >= 128;
    }
    isLighterThan(another) {
      const lum1 = this.getRelativeLuminance();
      another = another.getRelativeLuminance();
      return lum1 > another;
    }
    isDarkerThan(another) {
      const lum1 = this.getRelativeLuminance();
      another = another.getRelativeLuminance();
      return lum1 < another;
    }
    lighten(factor) {
      return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
    }
    darken(factor) {
      return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
    }
    transparent(factor) {
      const {r, g, b, a} = this.rgba;
      return new Color(new RGBA(r, g, b, a * factor));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
      if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
        return this;
      }
      const {r, g, b, a} = this.rgba;
      return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
    }
    toString() {
      this._toString || (this._toString = Color.Format.CSS.format(this));
      return this._toString;
    }
    static getLighterColor(of, relative, factor) {
      if (of.isLighterThan(relative)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      relative = relative.getRelativeLuminance();
      factor = factor * (relative - lum1) / relative;
      return of.lighten(factor);
    }
    static getDarkerColor(of, relative, factor) {
      if (of.isDarkerThan(relative)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      relative = relative.getRelativeLuminance();
      factor = factor * (lum1 - relative) / lum1;
      return of.darken(factor);
    }
  }
  Color.white = new Color(new RGBA(255, 255, 255, 1));
  Color.black = new Color(new RGBA(0, 0, 0, 1));
  Color.red = new Color(new RGBA(255, 0, 0, 1));
  Color.blue = new Color(new RGBA(0, 0, 255, 1));
  Color.green = new Color(new RGBA(0, 255, 0, 1));
  Color.cyan = new Color(new RGBA(0, 255, 255, 1));
  Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
  Color.transparent = new Color(new RGBA(0, 0, 0, 0));
  (function(Color) {
    (function(Format) {
      (function(CSS) {
        function _toTwoDigitHex(n) {
          n = n.toString(16);
          return n.length !== 2 ? "0" + n : n;
        }
        function _parseHexDigit(charCode) {
          switch(charCode) {
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
        CSS.formatRGB = function(color) {
          return color.rgba.a === 1 ? `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})` : Color.Format.CSS.formatRGBA(color);
        };
        CSS.formatRGBA = function(color) {
          return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
        };
        CSS.formatHSL = function(color) {
          return color.hsla.a === 1 ? `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)` : Color.Format.CSS.formatHSLA(color);
        };
        CSS.formatHSLA = function(color) {
          return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
        };
        CSS.formatHex = function(color) {
          return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
        };
        CSS.formatHexA = function(color, compact = !1) {
          return compact && color.rgba.a === 1 ? Color.Format.CSS.formatHex(color) : `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
        };
        CSS.format = function(color) {
          return color.isOpaque() ? Color.Format.CSS.formatHex(color) : Color.Format.CSS.formatRGBA(color);
        };
        CSS.parseHex = function(hex) {
          var length = hex.length;
          if (length === 0 || hex.charCodeAt(0) !== 35) {
            return null;
          }
          if (length === 7) {
            length = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            var g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            hex = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            return new Color(new RGBA(length, g, hex, 1));
          }
          if (length === 9) {
            length = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            var b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            hex = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
            return new Color(new RGBA(length, g, b, hex / 255));
          }
          return length === 4 ? (length = _parseHexDigit(hex.charCodeAt(1)), g = _parseHexDigit(hex.charCodeAt(2)), hex = _parseHexDigit(hex.charCodeAt(3)), new Color(new RGBA(16 * length + length, 16 * g + g, 16 * hex + hex))) : length === 5 ? (length = _parseHexDigit(hex.charCodeAt(1)), g = _parseHexDigit(hex.charCodeAt(2)), b = _parseHexDigit(hex.charCodeAt(3)), hex = _parseHexDigit(hex.charCodeAt(4)), new Color(new RGBA(16 * length + length, 16 * g + g, 16 * b + b, (16 * hex + hex) / 255))) : 
          null;
        };
      })(Format.CSS || (Format.CSS = {}));
    })(Color.Format || (Color.Format = {}));
  })(Color ||= {});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$color.js.map
