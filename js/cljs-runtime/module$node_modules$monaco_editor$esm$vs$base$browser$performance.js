shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$performance = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, inputLatency:{enumerable:!0, get:function() {
    return inputLatency;
  }}});
  var inputLatency;
  (function(inputLatency) {
    function markKeyDownEnd() {
      state.keydown === 1 && (performance.mark("keydown/end"), state.keydown = 2);
    }
    function onBeforeInput() {
      performance.mark("input/start");
      state.input = 1;
      setTimeout(recordIfFinished);
    }
    function markInputEnd() {
      state.input === 1 && (performance.mark("input/end"), state.input = 2);
    }
    function markRenderEnd() {
      state.render === 1 && (performance.mark("render/end"), state.render = 2);
    }
    function recordIfFinished() {
      state.keydown === 2 && state.input === 2 && state.render === 2 && (performance.mark("inputlatency/end"), performance.measure("keydown", "keydown/start", "keydown/end"), performance.measure("input", "input/start", "input/end"), performance.measure("render", "render/start", "render/end"), performance.measure("inputlatency", "inputlatency/start", "inputlatency/end"), addMeasure("keydown", totalKeydownTime), addMeasure("input", totalInputTime), addMeasure("render", totalRenderTime), addMeasure("inputlatency", 
      totalInputLatencyTime), measurementsCount++, performance.clearMarks("keydown/start"), performance.clearMarks("keydown/end"), performance.clearMarks("input/start"), performance.clearMarks("input/end"), performance.clearMarks("render/start"), performance.clearMarks("render/end"), performance.clearMarks("inputlatency/start"), performance.clearMarks("inputlatency/end"), performance.clearMeasures("keydown"), performance.clearMeasures("input"), performance.clearMeasures("render"), performance.clearMeasures("inputlatency"), 
      state.keydown = 0, state.input = 0, state.render = 0);
    }
    function addMeasure(entryName, cumulativeMeasurement) {
      entryName = performance.getEntriesByName(entryName)[0].duration;
      cumulativeMeasurement.total += entryName;
      cumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, entryName);
      cumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, entryName);
    }
    function cumulativeToFinalMeasurement(cumulative) {
      return {average:cumulative.total / measurementsCount, max:cumulative.max, min:cumulative.min};
    }
    function clearCumulativeMeasurement(cumulative) {
      cumulative.total = 0;
      cumulative.min = Number.MAX_VALUE;
      cumulative.max = 0;
    }
    const totalKeydownTime = {total:0, min:Number.MAX_VALUE, max:0}, totalInputTime = {...totalKeydownTime}, totalRenderTime = {...totalKeydownTime}, totalInputLatencyTime = {...totalKeydownTime};
    let measurementsCount = 0;
    const state = {keydown:0, input:0, render:0};
    inputLatency.onKeyDown = function() {
      recordIfFinished();
      performance.mark("inputlatency/start");
      performance.mark("keydown/start");
      state.keydown = 1;
      queueMicrotask(markKeyDownEnd);
    };
    inputLatency.onBeforeInput = onBeforeInput;
    inputLatency.onInput = function() {
      state.input === 0 && onBeforeInput();
      queueMicrotask(markInputEnd);
    };
    inputLatency.onKeyUp = function() {
      recordIfFinished();
    };
    inputLatency.onSelectionChange = function() {
      recordIfFinished();
    };
    inputLatency.onRenderStart = function() {
      state.keydown === 2 && state.input === 2 && state.render === 0 && (performance.mark("render/start"), state.render = 1, queueMicrotask(markRenderEnd), setTimeout(recordIfFinished));
    };
    inputLatency.getAndClearMeasurements = function() {
      if (measurementsCount !== 0) {
        var result = {keydown:cumulativeToFinalMeasurement(totalKeydownTime), input:cumulativeToFinalMeasurement(totalInputTime), render:cumulativeToFinalMeasurement(totalRenderTime), total:cumulativeToFinalMeasurement(totalInputLatencyTime), sampleCount:measurementsCount};
        clearCumulativeMeasurement(totalKeydownTime);
        clearCumulativeMeasurement(totalInputTime);
        clearCumulativeMeasurement(totalRenderTime);
        clearCumulativeMeasurement(totalInputLatencyTime);
        measurementsCount = 0;
        return result;
      }
    };
  })(inputLatency ||= {});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$performance.js.map
