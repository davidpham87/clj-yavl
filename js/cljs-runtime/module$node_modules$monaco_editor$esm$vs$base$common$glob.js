shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$glob = function(require, module, exports) {
  function starsToRegExp(starCount, isLastPattern) {
    switch(starCount) {
      case 0:
        return "";
      case 1:
        return "[^/\\\\]*?";
      default:
        return `(?:${"[/\\\\]"}|${"[^/\\\\]"}+${"[/\\\\]"}${isLastPattern ? "|[/\\\\][^/\\\\]+" : ""})*?`;
    }
  }
  function splitGlobAware(pattern, splitChar) {
    if (!pattern) {
      return [];
    }
    const segments = [];
    let inBraces = !1, inBrackets = !1, curVal = "";
    for (const char of pattern) {
      switch(char) {
        case splitChar:
          if (!inBraces && !inBrackets) {
            segments.push(curVal);
            curVal = "";
            continue;
          }
          break;
        case "{":
          inBraces = !0;
          break;
        case "}":
          inBraces = !1;
          break;
        case "[":
          inBrackets = !0;
          break;
        case "]":
          inBrackets = !1;
      }
      curVal += char;
    }
    curVal && segments.push(curVal);
    return segments;
  }
  function parseRegExp(pattern) {
    if (!pattern) {
      return "";
    }
    let regEx = "";
    const segments = splitGlobAware(pattern, "/");
    if (segments.every(segment => segment === "**")) {
      regEx = ".*";
    } else {
      let previousSegmentWasGlobStar = !1;
      segments.forEach((segment, index) => {
        if (segment === "**") {
          if (previousSegmentWasGlobStar) {
            return;
          }
          regEx += starsToRegExp(2, index === segments.length - 1);
        } else {
          var inBraces = !1;
          let braceVal = "", inBrackets = !1, bracketVal = "";
          for (const char of segment) {
            if (char !== "}" && inBraces) {
              braceVal += char;
            } else {
              if (!inBrackets || char === "]" && bracketVal) {
                switch(char) {
                  case "{":
                    inBraces = !0;
                    continue;
                  case "[":
                    inBrackets = !0;
                    continue;
                  case "}":
                    inBraces = `(?:${splitGlobAware(braceVal, ",").map(choice => parseRegExp(choice)).join("|")})`;
                    regEx += inBraces;
                    inBraces = !1;
                    braceVal = "";
                    break;
                  case "]":
                    regEx += "[" + bracketVal + "]";
                    inBrackets = !1;
                    bracketVal = "";
                    break;
                  case "?":
                    regEx += "[^/\\\\]";
                    continue;
                  case "*":
                    regEx += starsToRegExp(1);
                    continue;
                  default:
                    regEx += (0,require$_DOT__SLASH_strings_DOT_js.escapeRegExpCharacters)(char);
                }
              } else {
                let res;
                res = char === "-" ? char : char !== "^" && char !== "!" || bracketVal ? char === "/" ? "" : (0,require$_DOT__SLASH_strings_DOT_js.escapeRegExpCharacters)(char) : "^";
                bracketVal += res;
              }
            }
          }
          index < segments.length - 1 && (segments[index + 1] !== "**" || index + 2 < segments.length) && (regEx += "[/\\\\]");
        }
        previousSegmentWasGlobStar = segment === "**";
      });
    }
    return regEx;
  }
  function parsePattern(arg1, options) {
    if (!arg1) {
      return NULL;
    }
    let pattern;
    pattern = typeof arg1 !== "string" ? arg1.pattern : arg1;
    pattern = pattern.trim();
    const patternKey = `${pattern}_${!!options.trimForExclusions}`;
    let parsedPattern = CACHE.get(patternKey);
    if (parsedPattern) {
      return wrapRelativePattern(parsedPattern, arg1);
    }
    let match;
    parsedPattern = T1.test(pattern) ? trivia1(pattern.substr(4), pattern) : (match = T2.exec(trimForExclusions(pattern, options))) ? trivia2(match[1], pattern) : (options.trimForExclusions ? T3_2 : T3).test(pattern) ? trivia3(pattern, options) : (match = T4.exec(trimForExclusions(pattern, options))) ? trivia4and5(match[1].substr(1), pattern, !0) : (match = T5.exec(trimForExclusions(pattern, options))) ? trivia4and5(match[1], pattern, !1) : toRegExp(pattern);
    CACHE.set(patternKey, parsedPattern);
    return wrapRelativePattern(parsedPattern, arg1);
  }
  function wrapRelativePattern(parsedPattern, arg2) {
    if (typeof arg2 === "string") {
      return parsedPattern;
    }
    const wrappedPattern = function(path, basename) {
      return (0,require$_DOT__SLASH_extpath_DOT_js.isEqualOrParent)(path, arg2.base, !require$_DOT__SLASH_platform_DOT_js.isLinux) ? parsedPattern((0,require$_DOT__SLASH_strings_DOT_js.ltrim)(path.substr(arg2.base.length), require$_DOT__SLASH_path_DOT_js.sep), basename) : null;
    };
    wrappedPattern.allBasenames = parsedPattern.allBasenames;
    wrappedPattern.allPaths = parsedPattern.allPaths;
    wrappedPattern.basenames = parsedPattern.basenames;
    wrappedPattern.patterns = parsedPattern.patterns;
    return wrappedPattern;
  }
  function trimForExclusions(pattern, options) {
    return options.trimForExclusions && pattern.endsWith("/**") ? pattern.substr(0, pattern.length - 2) : pattern;
  }
  function trivia1(base, pattern) {
    return function(path, basename) {
      return typeof path === "string" && path.endsWith(base) ? pattern : null;
    };
  }
  function trivia2(base, pattern) {
    const slashBase = `/${base}`, backslashBase = `\\${base}`, parsedPattern = function(path, basename) {
      return typeof path !== "string" ? null : basename ? basename === base ? pattern : null : path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;
    }, basenames = [base];
    parsedPattern.basenames = basenames;
    parsedPattern.patterns = [pattern];
    parsedPattern.allBasenames = basenames;
    return parsedPattern;
  }
  function trivia3(pattern, options) {
    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(",").map(pattern => parsePattern(pattern, options)).filter(pattern => pattern !== NULL), pattern);
    var patternsLength = parsedPatterns.length;
    if (!patternsLength) {
      return NULL;
    }
    if (patternsLength === 1) {
      return parsedPatterns[0];
    }
    patternsLength = function(path, basename) {
      for (let i = 0, n = parsedPatterns.length; i < n; i++) {
        if (parsedPatterns[i](path, basename)) {
          return pattern;
        }
      }
      return null;
    };
    var withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
    withBasenames && (patternsLength.allBasenames = withBasenames.allBasenames);
    withBasenames = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    withBasenames.length && (patternsLength.allPaths = withBasenames);
    return patternsLength;
  }
  function trivia4and5(targetPath, pattern, matchPathEnds) {
    const usingPosixSep = require$_DOT__SLASH_path_DOT_js.sep === require$_DOT__SLASH_path_DOT_js.posix.sep, nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, require$_DOT__SLASH_path_DOT_js.sep), nativePathEnd = require$_DOT__SLASH_path_DOT_js.sep + nativePath, targetPathEnd = require$_DOT__SLASH_path_DOT_js.posix.sep + targetPath;
    let parsedPattern;
    parsedPattern = matchPathEnds ? function(path, basename) {
      return typeof path !== "string" || path !== nativePath && !path.endsWith(nativePathEnd) && (usingPosixSep || path !== targetPath && !path.endsWith(targetPathEnd)) ? null : pattern;
    } : function(path, basename) {
      return typeof path !== "string" || path !== nativePath && (usingPosixSep || path !== targetPath) ? null : pattern;
    };
    parsedPattern.allPaths = [(matchPathEnds ? "*/" : "./") + targetPath];
    return parsedPattern;
  }
  function toRegExp(pattern) {
    try {
      const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
      return function(path) {
        regExp.lastIndex = 0;
        return typeof path === "string" && regExp.test(path) ? pattern : null;
      };
    } catch (error) {
      return NULL;
    }
  }
  function match(arg1, path, hasSibling) {
    return arg1 && typeof path === "string" ? parse(arg1)(path, void 0, hasSibling) : !1;
  }
  function parse(arg1, options = {}) {
    if (!arg1) {
      return FALSE;
    }
    if (typeof arg1 === "string" || isRelativePattern(arg1)) {
      const parsedPattern = parsePattern(arg1, options);
      if (parsedPattern === NULL) {
        return FALSE;
      }
      arg1 = function(path, basename) {
        return !!parsedPattern(path, basename);
      };
      parsedPattern.allBasenames && (arg1.allBasenames = parsedPattern.allBasenames);
      parsedPattern.allPaths && (arg1.allPaths = parsedPattern.allPaths);
      return arg1;
    }
    return parsedExpression(arg1, options);
  }
  function isRelativePattern(obj) {
    return obj ? typeof obj.base === "string" && typeof obj.pattern === "string" : !1;
  }
  function parsedExpression(expression, options) {
    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(pattern => parseExpressionPattern(pattern, expression[pattern], options)).filter(pattern => pattern !== NULL));
    var patternsLength = parsedPatterns.length;
    if (!patternsLength) {
      return NULL;
    }
    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {
      if (patternsLength === 1) {
        return parsedPatterns[0];
      }
      patternsLength = function(path, basename) {
        let resultPromises = void 0;
        for (let i = 0, n = parsedPatterns.length; i < n; i++) {
          const result = parsedPatterns[i](path, basename);
          if (typeof result === "string") {
            return result;
          }
          (0,require$_DOT__SLASH_async_DOT_js.isThenable)(result) && (resultPromises ||= [], resultPromises.push(result));
        }
        return resultPromises ? (async() => {
          for (const resultPromise of resultPromises) {
            const result = await resultPromise;
            if (typeof result === "string") {
              return result;
            }
          }
          return null;
        })() : null;
      };
      var withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
      withBasenames && (patternsLength.allBasenames = withBasenames.allBasenames);
      withBasenames = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
      withBasenames.length && (patternsLength.allPaths = withBasenames);
      return patternsLength;
    }
    patternsLength = function(path, base, hasSibling) {
      let name = void 0, resultPromises = void 0;
      for (let i = 0, n = parsedPatterns.length; i < n; i++) {
        var parsedPattern = parsedPatterns[i];
        parsedPattern.requiresSiblings && hasSibling && (base ||= (0,require$_DOT__SLASH_path_DOT_js.basename)(path), name ||= base.substr(0, base.length - (0,require$_DOT__SLASH_path_DOT_js.extname)(path).length));
        parsedPattern = parsedPattern(path, base, name, hasSibling);
        if (typeof parsedPattern === "string") {
          return parsedPattern;
        }
        (0,require$_DOT__SLASH_async_DOT_js.isThenable)(parsedPattern) && (resultPromises ||= [], resultPromises.push(parsedPattern));
      }
      return resultPromises ? (async() => {
        for (const resultPromise of resultPromises) {
          const result = await resultPromise;
          if (typeof result === "string") {
            return result;
          }
        }
        return null;
      })() : null;
    };
    if (withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames)) {
      patternsLength.allBasenames = withBasenames.allBasenames;
    }
    withBasenames = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    withBasenames.length && (patternsLength.allPaths = withBasenames);
    return patternsLength;
  }
  function parseExpressionPattern(pattern, value, options) {
    if (value === !1) {
      return NULL;
    }
    const parsedPattern = parsePattern(pattern, options);
    if (parsedPattern === NULL) {
      return NULL;
    }
    if (typeof value === "boolean") {
      return parsedPattern;
    }
    if (value) {
      const when = value.when;
      if (typeof when === "string") {
        return value = (path, basename, name, hasSibling) => {
          if (!hasSibling || !parsedPattern(path, basename)) {
            return null;
          }
          path = when.replace("$(basename)", () => name);
          hasSibling = hasSibling(path);
          return (0,require$_DOT__SLASH_async_DOT_js.isThenable)(hasSibling) ? hasSibling.then(match => match ? pattern : null) : hasSibling ? pattern : null;
        }, value.requiresSiblings = !0, value;
      }
    }
    return parsedPattern;
  }
  function aggregateBasenameMatches(parsedPatterns, result) {
    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);
    if (basenamePatterns.length < 2) {
      return parsedPatterns;
    }
    const basenames = basenamePatterns.reduce((all, current) => (current = current.basenames) ? all.concat(current) : all, []);
    let patterns;
    if (result) {
      patterns = [];
      for (let i = 0, n = basenames.length; i < n; i++) {
        patterns.push(result);
      }
    } else {
      patterns = basenamePatterns.reduce((all, current) => (current = current.patterns) ? all.concat(current) : all, []);
    }
    result = function(path, basename) {
      if (typeof path !== "string") {
        return null;
      }
      if (!basename) {
        for (basename = path.length; basename > 0; basename--) {
          const ch = path.charCodeAt(basename - 1);
          if (ch === 47 || ch === 92) {
            break;
          }
        }
        basename = path.substr(basename);
      }
      path = basenames.indexOf(basename);
      return path !== -1 ? patterns[path] : null;
    };
    result.basenames = basenames;
    result.patterns = patterns;
    result.allBasenames = basenames;
    parsedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);
    parsedPatterns.push(result);
    return parsedPatterns;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, GLOBSTAR:{enumerable:!0, get:function() {
    return "**";
  }}, GLOB_SPLIT:{enumerable:!0, get:function() {
    return "/";
  }}, isRelativePattern:{enumerable:!0, get:function() {
    return isRelativePattern;
  }}, match:{enumerable:!0, get:function() {
    return match;
  }}, parse:{enumerable:!0, get:function() {
    return parse;
  }}, splitGlobAware:{enumerable:!0, get:function() {
    return splitGlobAware;
  }}});
  var require$_DOT__SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__SLASH_extpath_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$extpath");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$map");
  var require$_DOT__SLASH_path_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$path"), require$_DOT__SLASH_platform_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), require$_DOT__SLASH_strings_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  const ALL_FORWARD_SLASHES = /\//g, T1 = /^\*\*\/\*\.[\w\.-]+$/, T2 = /^\*\*\/([\w\.-]+)\/?$/, T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, T4 = /^\*\*((\/[\w\.-]+)+)\/?$/, T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, CACHE = new module.LRUCache(10000), FALSE = function() {
    return !1;
  }, NULL = function() {
    return null;
  };
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$glob.js.map
