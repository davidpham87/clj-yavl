shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$contextkey$common$contextkey = function(require, module, exports) {
  function expressionsAreEqualWithConstantSubstitution(a, b) {
    a = a ? a.substituteConstants() : void 0;
    b = b ? b.substituteConstants() : void 0;
    return a || b ? a && b ? a.equals(b) : !1 : !0;
  }
  function cmp(a, b) {
    return a.cmp(b);
  }
  function withFloatOrStr(value, callback) {
    if (typeof value === "string") {
      const n = parseFloat(value);
      isNaN(n) || (value = n);
    }
    return typeof value === "string" || typeof value === "number" ? callback(value) : ContextKeyFalseExpr.INSTANCE;
  }
  function eliminateConstantsInArray(arr) {
    let newArr = null;
    for (let i = 0, len = arr.length; i < len; i++) {
      const newExpr = arr[i].substituteConstants();
      if (arr[i] !== newExpr && newArr === null) {
        newArr = [];
        for (let j = 0; j < i; j++) {
          newArr[j] = arr[j];
        }
      }
      newArr !== null && (newArr[i] = newExpr);
    }
    return newArr === null ? arr : newArr;
  }
  function cmp2(key1, value1, key2, value2) {
    return key1 < key2 ? -1 : key1 > key2 ? 1 : value1 < value2 ? -1 : value1 > value2 ? 1 : 0;
  }
  function implies(p, q) {
    if (p.type === 0 || q.type === 1) {
      return !0;
    }
    if (p.type === 9) {
      return q.type === 9 ? allElementsIncluded(p.expr, q.expr) : !1;
    }
    if (q.type === 9) {
      for (const element of q.expr) {
        if (implies(p, element)) {
          return !0;
        }
      }
      return !1;
    }
    if (p.type === 6) {
      if (q.type === 6) {
        return allElementsIncluded(q.expr, p.expr);
      }
      for (const element of p.expr) {
        if (implies(element, q)) {
          return !0;
        }
      }
      return !1;
    }
    return p.equals(q);
  }
  function allElementsIncluded(p, q) {
    let pIndex = 0, qIndex = 0;
    for (; pIndex < p.length && qIndex < q.length;) {
      const cmp = p[pIndex].cmp(q[qIndex]);
      if (cmp < 0) {
        return !1;
      }
      cmp === 0 && pIndex++;
      qIndex++;
    }
    return pIndex === p.length;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ContextKeyAndExpr:{enumerable:!0, get:function() {
    return ContextKeyAndExpr;
  }}, ContextKeyDefinedExpr:{enumerable:!0, get:function() {
    return ContextKeyDefinedExpr;
  }}, ContextKeyEqualsExpr:{enumerable:!0, get:function() {
    return ContextKeyEqualsExpr;
  }}, ContextKeyExpr:{enumerable:!0, get:function() {
    return ContextKeyExpr;
  }}, ContextKeyFalseExpr:{enumerable:!0, get:function() {
    return ContextKeyFalseExpr;
  }}, ContextKeyGreaterEqualsExpr:{enumerable:!0, get:function() {
    return ContextKeyGreaterEqualsExpr;
  }}, ContextKeyGreaterExpr:{enumerable:!0, get:function() {
    return ContextKeyGreaterExpr;
  }}, ContextKeyInExpr:{enumerable:!0, get:function() {
    return ContextKeyInExpr;
  }}, ContextKeyNotEqualsExpr:{enumerable:!0, get:function() {
    return ContextKeyNotEqualsExpr;
  }}, ContextKeyNotExpr:{enumerable:!0, get:function() {
    return ContextKeyNotExpr;
  }}, ContextKeyNotInExpr:{enumerable:!0, get:function() {
    return ContextKeyNotInExpr;
  }}, ContextKeyNotRegexExpr:{enumerable:!0, get:function() {
    return ContextKeyNotRegexExpr;
  }}, ContextKeyOrExpr:{enumerable:!0, get:function() {
    return ContextKeyOrExpr;
  }}, ContextKeyRegexExpr:{enumerable:!0, get:function() {
    return ContextKeyRegexExpr;
  }}, ContextKeySmallerEqualsExpr:{enumerable:!0, get:function() {
    return ContextKeySmallerEqualsExpr;
  }}, ContextKeySmallerExpr:{enumerable:!0, get:function() {
    return ContextKeySmallerExpr;
  }}, ContextKeyTrueExpr:{enumerable:!0, get:function() {
    return ContextKeyTrueExpr;
  }}, IContextKeyService:{enumerable:!0, get:function() {
    return IContextKeyService;
  }}, Parser:{enumerable:!0, get:function() {
    return Parser;
  }}, RawContextKey:{enumerable:!0, get:function() {
    return RawContextKey;
  }}, expressionsAreEqualWithConstantSubstitution:{enumerable:!0, get:function() {
    return expressionsAreEqualWithConstantSubstitution;
  }}, implies:{enumerable:!0, get:function() {
    return implies;
  }}});
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$platform");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_strings_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__SLASH_scanner_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$contextkey$common$scanner");
  exports = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$instantiation");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js = require("module$node_modules$monaco_editor$esm$vs$nls");
  const CONSTANT_VALUES = new Map();
  CONSTANT_VALUES.set("false", !1);
  CONSTANT_VALUES.set("true", !0);
  CONSTANT_VALUES.set("isMac", module.isMacintosh);
  CONSTANT_VALUES.set("isLinux", module.isLinux);
  CONSTANT_VALUES.set("isWindows", module.isWindows);
  CONSTANT_VALUES.set("isWeb", module.isWeb);
  CONSTANT_VALUES.set("isMacNative", module.isMacintosh && !module.isWeb);
  CONSTANT_VALUES.set("isEdge", module.isEdge);
  CONSTANT_VALUES.set("isFirefox", module.isFirefox);
  CONSTANT_VALUES.set("isChrome", module.isChrome);
  CONSTANT_VALUES.set("isSafari", module.isSafari);
  const hasOwnProperty = Object.prototype.hasOwnProperty, defaultConfig = {regexParsingWithErrorRecovery:!0}, errorEmptyString = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.emptyString", "Empty context key expression"), hintEmptyString = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."), 
  errorNoInAfterNot = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.noInAfterNot", "'in' after 'not'."), errorClosingParenthesis = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"), errorUnexpectedToken = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.unexpectedToken", "Unexpected token"), 
  hintUnexpectedToken = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put \x26\x26 or || before the token?"), errorUnexpectedEOF = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"), hintUnexpectedEOF = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.unexpectedEOF.hint", 
  "Did you forget to put a context key?");
  class Parser {
    constructor(_config = defaultConfig) {
      this._config = _config;
      this._scanner = new require$_DOT__SLASH_scanner_DOT_js.Scanner();
      this._tokens = [];
      this._current = 0;
      this._parsingErrors = [];
      this._flagsGYRe = /g|y/g;
    }
    parse(input) {
      if (input === "") {
        this._parsingErrors.push({message:errorEmptyString, offset:0, lexeme:"", additionalInfo:hintEmptyString});
      } else {
        this._tokens = this._scanner.reset(input).scan();
        this._current = 0;
        this._parsingErrors = [];
        try {
          const expr = this._expr();
          if (!this._isAtEnd()) {
            const peek = this._peek(), additionalInfo = peek.type === 17 ? hintUnexpectedToken : void 0;
            this._parsingErrors.push({message:errorUnexpectedToken, offset:peek.offset, lexeme:require$_DOT__SLASH_scanner_DOT_js.Scanner.getLexeme(peek), additionalInfo});
            throw Parser._parseError;
          }
          return expr;
        } catch (e) {
          if (e !== Parser._parseError) {
            throw e;
          }
        }
      }
    }
    _expr() {
      return this._or();
    }
    _or() {
      const expr = [this._and()];
      for (; this._matchOne(16);) {
        const right = this._and();
        expr.push(right);
      }
      return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);
    }
    _and() {
      const expr = [this._term()];
      for (; this._matchOne(15);) {
        const right = this._term();
        expr.push(right);
      }
      return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);
    }
    _term() {
      if (this._matchOne(2)) {
        var peek = this._peek();
        switch(peek.type) {
          case 11:
            return this._advance(), ContextKeyFalseExpr.INSTANCE;
          case 12:
            return this._advance(), ContextKeyTrueExpr.INSTANCE;
          case 0:
            return this._advance(), peek = this._expr(), this._consume(1, errorClosingParenthesis), peek === null || peek === void 0 ? void 0 : peek.negate();
          case 17:
            return this._advance(), ContextKeyNotExpr.create(peek.lexeme);
          default:
            throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", peek);
        }
      }
      return this._primary();
    }
    _primary() {
      var peek = this._peek();
      switch(peek.type) {
        case 11:
          return this._advance(), ContextKeyExpr.true();
        case 12:
          return this._advance(), ContextKeyExpr.false();
        case 0:
          return this._advance(), peek = this._expr(), this._consume(1, errorClosingParenthesis), peek;
        case 17:
          peek = peek.lexeme;
          this._advance();
          if (this._matchOne(9)) {
            var expr = this._peek();
            if (!this._config.regexParsingWithErrorRecovery) {
              this._advance();
              if (expr.type !== 10) {
                throw this._errExpectedButGot("REGEX", expr);
              }
              var regexLexeme = expr.lexeme, closingSlashIndex = regexLexeme.lastIndexOf("/"), flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
              try {
                var regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
              } catch (e) {
                throw this._errExpectedButGot("REGEX", expr);
              }
              return ContextKeyRegexExpr.create(peek, regexp);
            }
            switch(expr.type) {
              case 10:
              case 19:
                regexp = [expr.lexeme];
                this._advance();
                closingSlashIndex = this._peek();
                flags = 0;
                for (var i = 0; i < expr.lexeme.length; i++) {
                  expr.lexeme.charCodeAt(i) === 40 ? flags++ : expr.lexeme.charCodeAt(i) === 41 && flags--;
                }
                for (; !this._isAtEnd() && closingSlashIndex.type !== 15 && closingSlashIndex.type !== 16;) {
                  switch(closingSlashIndex.type) {
                    case 0:
                      flags++;
                      break;
                    case 1:
                      flags--;
                      break;
                    case 10:
                    case 18:
                      for (i = 0; i < closingSlashIndex.lexeme.length; i++) {
                        closingSlashIndex.lexeme.charCodeAt(i) === 40 ? flags++ : expr.lexeme.charCodeAt(i) === 41 && flags--;
                      }
                  }
                  if (flags < 0) {
                    break;
                  }
                  regexp.push(require$_DOT__SLASH_scanner_DOT_js.Scanner.getLexeme(closingSlashIndex));
                  this._advance();
                  closingSlashIndex = this._peek();
                }
                regexp = regexp.join("");
                closingSlashIndex = regexp.lastIndexOf("/");
                flags = closingSlashIndex === regexp.length - 1 ? void 0 : this._removeFlagsGY(regexp.substring(closingSlashIndex + 1));
                try {
                  regexLexeme = new RegExp(regexp.substring(1, closingSlashIndex), flags);
                } catch (e) {
                  throw this._errExpectedButGot("REGEX", expr);
                }
                return ContextKeyExpr.regex(peek, regexLexeme);
              case 18:
                regexp = expr.lexeme;
                this._advance();
                regexLexeme = null;
                if (!(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_strings_DOT_js.isFalsyOrWhitespace)(regexp) && (flags = regexp.indexOf("/"), closingSlashIndex = regexp.lastIndexOf("/"), flags !== closingSlashIndex && flags >= 0)) {
                  flags = regexp.slice(flags + 1, closingSlashIndex);
                  regexp = regexp[closingSlashIndex + 1] === "i" ? "i" : "";
                  try {
                    regexLexeme = new RegExp(flags, regexp);
                  } catch (_e) {
                    throw this._errExpectedButGot("REGEX", expr);
                  }
                }
                if (regexLexeme === null) {
                  throw this._errExpectedButGot("REGEX", expr);
                }
                return ContextKeyRegexExpr.create(peek, regexLexeme);
              default:
                throw this._errExpectedButGot("REGEX", this._peek());
            }
          }
          if (this._matchOne(14)) {
            return this._consume(13, errorNoInAfterNot), expr = this._value(), ContextKeyExpr.notIn(peek, expr);
          }
          switch(this._peek().type) {
            case 3:
              this._advance();
              expr = this._value();
              if (this._previous().type === 18) {
                return ContextKeyExpr.equals(peek, expr);
              }
              switch(expr) {
                case "true":
                  return ContextKeyExpr.has(peek);
                case "false":
                  return ContextKeyExpr.not(peek);
                default:
                  return ContextKeyExpr.equals(peek, expr);
              }case 4:
              this._advance();
              expr = this._value();
              if (this._previous().type === 18) {
                return ContextKeyExpr.notEquals(peek, expr);
              }
              switch(expr) {
                case "true":
                  return ContextKeyExpr.not(peek);
                case "false":
                  return ContextKeyExpr.has(peek);
                default:
                  return ContextKeyExpr.notEquals(peek, expr);
              }case 5:
              return this._advance(), ContextKeySmallerExpr.create(peek, this._value());
            case 6:
              return this._advance(), ContextKeySmallerEqualsExpr.create(peek, this._value());
            case 7:
              return this._advance(), ContextKeyGreaterExpr.create(peek, this._value());
            case 8:
              return this._advance(), ContextKeyGreaterEqualsExpr.create(peek, this._value());
            case 13:
              return this._advance(), ContextKeyExpr.in(peek, this._value());
            default:
              return ContextKeyExpr.has(peek);
          }case 20:
          throw this._parsingErrors.push({message:errorUnexpectedEOF, offset:peek.offset, lexeme:"", additionalInfo:hintUnexpectedEOF}), Parser._parseError;
        default:
          throw this._errExpectedButGot("true | false | KEY \n\t| KEY '\x3d~' REGEX \n\t| KEY ('\x3d\x3d' | '!\x3d' | '\x3c' | '\x3c\x3d' | '\x3e' | '\x3e\x3d' | 'in' | 'not' 'in') value", this._peek());
      }
    }
    _value() {
      const token = this._peek();
      switch(token.type) {
        case 17:
        case 18:
          return this._advance(), token.lexeme;
        case 11:
          return this._advance(), "true";
        case 12:
          return this._advance(), "false";
        case 13:
          return this._advance(), "in";
        default:
          return "";
      }
    }
    _removeFlagsGY(flags) {
      return flags.replaceAll(this._flagsGYRe, "");
    }
    _previous() {
      return this._tokens[this._current - 1];
    }
    _matchOne(token) {
      return this._check(token) ? (this._advance(), !0) : !1;
    }
    _advance() {
      this._isAtEnd() || this._current++;
      return this._previous();
    }
    _consume(type, message) {
      if (this._check(type)) {
        return this._advance();
      }
      throw this._errExpectedButGot(message, this._peek());
    }
    _errExpectedButGot(expected, got, additionalInfo) {
      expected = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("contextkey.parser.error.expectedButGot", "Expected: {0}\nReceived: '{1}'.", expected, require$_DOT__SLASH_scanner_DOT_js.Scanner.getLexeme(got));
      const offset = got.offset;
      got = require$_DOT__SLASH_scanner_DOT_js.Scanner.getLexeme(got);
      this._parsingErrors.push({message:expected, offset, lexeme:got, additionalInfo});
      return Parser._parseError;
    }
    _check(type) {
      return this._peek().type === type;
    }
    _peek() {
      return this._tokens[this._current];
    }
    _isAtEnd() {
      return this._peek().type === 20;
    }
  }
  Parser._parseError = Error();
  class ContextKeyExpr {
    static false() {
      return ContextKeyFalseExpr.INSTANCE;
    }
    static true() {
      return ContextKeyTrueExpr.INSTANCE;
    }
    static has(key) {
      return ContextKeyDefinedExpr.create(key);
    }
    static equals(key, value) {
      return ContextKeyEqualsExpr.create(key, value);
    }
    static notEquals(key, value) {
      return ContextKeyNotEqualsExpr.create(key, value);
    }
    static regex(key, value) {
      return ContextKeyRegexExpr.create(key, value);
    }
    static in(key, value) {
      return ContextKeyInExpr.create(key, value);
    }
    static notIn(key, value) {
      return ContextKeyNotInExpr.create(key, value);
    }
    static not(key) {
      return ContextKeyNotExpr.create(key);
    }
    static and(...expr) {
      return ContextKeyAndExpr.create(expr, null, !0);
    }
    static or(...expr) {
      return ContextKeyOrExpr.create(expr, null, !0);
    }
    static deserialize(serialized) {
      if (serialized !== void 0 && serialized !== null) {
        return this._parser.parse(serialized);
      }
    }
  }
  ContextKeyExpr._parser = new Parser({regexParsingWithErrorRecovery:!1});
  class ContextKeyFalseExpr {
    constructor() {
      this.type = 0;
    }
    cmp(other) {
      return this.type - other.type;
    }
    equals(other) {
      return other.type === this.type;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return !1;
    }
    serialize() {
      return "false";
    }
    keys() {
      return [];
    }
    negate() {
      return ContextKeyTrueExpr.INSTANCE;
    }
  }
  ContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();
  class ContextKeyTrueExpr {
    constructor() {
      this.type = 1;
    }
    cmp(other) {
      return this.type - other.type;
    }
    equals(other) {
      return other.type === this.type;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return !0;
    }
    serialize() {
      return "true";
    }
    keys() {
      return [];
    }
    negate() {
      return ContextKeyFalseExpr.INSTANCE;
    }
  }
  ContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();
  class ContextKeyDefinedExpr {
    static create(key, negated = null) {
      const constantValue = CONSTANT_VALUES.get(key);
      return typeof constantValue === "boolean" ? constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE : new ContextKeyDefinedExpr(key, negated);
    }
    constructor(key, negated) {
      this.key = key;
      this.negated = negated;
      this.type = 2;
    }
    cmp(other) {
      if (other.type !== this.type) {
        var JSCompiler_temp = this.type - other.type;
      } else {
        JSCompiler_temp = this.key, other = other.key, JSCompiler_temp = JSCompiler_temp < other ? -1 : JSCompiler_temp > other ? 1 : 0;
      }
      return JSCompiler_temp;
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key : !1;
    }
    substituteConstants() {
      const constantValue = CONSTANT_VALUES.get(this.key);
      return typeof constantValue === "boolean" ? constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE : this;
    }
    evaluate(context) {
      return !!context.getValue(this.key);
    }
    serialize() {
      return this.key;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyNotExpr.create(this.key, this));
      return this.negated;
    }
  }
  class ContextKeyEqualsExpr {
    static create(key, value, negated = null) {
      if (typeof value === "boolean") {
        return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);
      }
      const constantValue = CONSTANT_VALUES.get(key);
      return typeof constantValue === "boolean" ? value === (constantValue ? "true" : "false") ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE : new ContextKeyEqualsExpr(key, value, negated);
    }
    constructor(key, value, negated) {
      this.key = key;
      this.value = value;
      this.negated = negated;
      this.type = 4;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.value === other.value : !1;
    }
    substituteConstants() {
      const constantValue = CONSTANT_VALUES.get(this.key);
      return typeof constantValue === "boolean" ? this.value === (constantValue ? "true" : "false") ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE : this;
    }
    evaluate(context) {
      return context.getValue(this.key) == this.value;
    }
    serialize() {
      return `${this.key} == '${this.value}'`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this));
      return this.negated;
    }
  }
  class ContextKeyInExpr {
    static create(key, valueKey) {
      return new ContextKeyInExpr(key, valueKey);
    }
    constructor(key, valueKey) {
      this.key = key;
      this.valueKey = valueKey;
      this.type = 10;
      this.negated = null;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.valueKey, other.key, other.valueKey);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.valueKey === other.valueKey : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      const source = context.getValue(this.valueKey);
      context = context.getValue(this.key);
      return Array.isArray(source) ? source.includes(context) : typeof context === "string" && typeof source === "object" && source !== null ? hasOwnProperty.call(source, context) : !1;
    }
    serialize() {
      return `${this.key} in '${this.valueKey}'`;
    }
    keys() {
      return [this.key, this.valueKey];
    }
    negate() {
      this.negated || (this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey));
      return this.negated;
    }
  }
  class ContextKeyNotInExpr {
    static create(key, valueKey) {
      return new ContextKeyNotInExpr(key, valueKey);
    }
    constructor(key, valueKey) {
      this.key = key;
      this.valueKey = valueKey;
      this.type = 11;
      this._negated = ContextKeyInExpr.create(key, valueKey);
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : this._negated.cmp(other._negated);
    }
    equals(other) {
      return other.type === this.type ? this._negated.equals(other._negated) : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return !this._negated.evaluate(context);
    }
    serialize() {
      return `${this.key} not in '${this.valueKey}'`;
    }
    keys() {
      return this._negated.keys();
    }
    negate() {
      return this._negated;
    }
  }
  class ContextKeyNotEqualsExpr {
    static create(key, value, negated = null) {
      if (typeof value === "boolean") {
        return value ? ContextKeyNotExpr.create(key, negated) : ContextKeyDefinedExpr.create(key, negated);
      }
      const constantValue = CONSTANT_VALUES.get(key);
      return typeof constantValue === "boolean" ? value === (constantValue ? "true" : "false") ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE : new ContextKeyNotEqualsExpr(key, value, negated);
    }
    constructor(key, value, negated) {
      this.key = key;
      this.value = value;
      this.negated = negated;
      this.type = 5;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.value === other.value : !1;
    }
    substituteConstants() {
      const constantValue = CONSTANT_VALUES.get(this.key);
      return typeof constantValue === "boolean" ? this.value === (constantValue ? "true" : "false") ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE : this;
    }
    evaluate(context) {
      return context.getValue(this.key) != this.value;
    }
    serialize() {
      return `${this.key} != '${this.value}'`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this));
      return this.negated;
    }
  }
  class ContextKeyNotExpr {
    static create(key, negated = null) {
      const constantValue = CONSTANT_VALUES.get(key);
      return typeof constantValue === "boolean" ? constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE : new ContextKeyNotExpr(key, negated);
    }
    constructor(key, negated) {
      this.key = key;
      this.negated = negated;
      this.type = 3;
    }
    cmp(other) {
      if (other.type !== this.type) {
        var JSCompiler_temp = this.type - other.type;
      } else {
        JSCompiler_temp = this.key, other = other.key, JSCompiler_temp = JSCompiler_temp < other ? -1 : JSCompiler_temp > other ? 1 : 0;
      }
      return JSCompiler_temp;
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key : !1;
    }
    substituteConstants() {
      const constantValue = CONSTANT_VALUES.get(this.key);
      return typeof constantValue === "boolean" ? constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE : this;
    }
    evaluate(context) {
      return !context.getValue(this.key);
    }
    serialize() {
      return `!${this.key}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyDefinedExpr.create(this.key, this));
      return this.negated;
    }
  }
  class ContextKeyGreaterExpr {
    static create(key, _value, negated = null) {
      return withFloatOrStr(_value, value => new ContextKeyGreaterExpr(key, value, negated));
    }
    constructor(key, value, negated) {
      this.key = key;
      this.value = value;
      this.negated = negated;
      this.type = 12;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.value === other.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return typeof this.value === "string" ? !1 : parseFloat(context.getValue(this.key)) > this.value;
    }
    serialize() {
      return `${this.key} > ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this));
      return this.negated;
    }
  }
  class ContextKeyGreaterEqualsExpr {
    static create(key, _value, negated = null) {
      return withFloatOrStr(_value, value => new ContextKeyGreaterEqualsExpr(key, value, negated));
    }
    constructor(key, value, negated) {
      this.key = key;
      this.value = value;
      this.negated = negated;
      this.type = 13;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.value === other.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return typeof this.value === "string" ? !1 : parseFloat(context.getValue(this.key)) >= this.value;
    }
    serialize() {
      return `${this.key} >= ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeySmallerExpr.create(this.key, this.value, this));
      return this.negated;
    }
  }
  class ContextKeySmallerExpr {
    static create(key, _value, negated = null) {
      return withFloatOrStr(_value, value => new ContextKeySmallerExpr(key, value, negated));
    }
    constructor(key, value, negated) {
      this.key = key;
      this.value = value;
      this.negated = negated;
      this.type = 14;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.value === other.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return typeof this.value === "string" ? !1 : parseFloat(context.getValue(this.key)) < this.value;
    }
    serialize() {
      return `${this.key} < ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this));
      return this.negated;
    }
  }
  class ContextKeySmallerEqualsExpr {
    static create(key, _value, negated = null) {
      return withFloatOrStr(_value, value => new ContextKeySmallerEqualsExpr(key, value, negated));
    }
    constructor(key, value, negated) {
      this.key = key;
      this.value = value;
      this.negated = negated;
      this.type = 15;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
      return other.type === this.type ? this.key === other.key && this.value === other.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return typeof this.value === "string" ? !1 : parseFloat(context.getValue(this.key)) <= this.value;
    }
    serialize() {
      return `${this.key} <= ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this));
      return this.negated;
    }
  }
  class ContextKeyRegexExpr {
    static create(key, regexp) {
      return new ContextKeyRegexExpr(key, regexp);
    }
    constructor(key, regexp) {
      this.key = key;
      this.regexp = regexp;
      this.type = 7;
      this.negated = null;
    }
    cmp(other) {
      if (other.type !== this.type) {
        return this.type - other.type;
      }
      if (this.key < other.key) {
        return -1;
      }
      if (this.key > other.key) {
        return 1;
      }
      const thisSource = this.regexp ? this.regexp.source : "";
      other = other.regexp ? other.regexp.source : "";
      return thisSource < other ? -1 : thisSource > other ? 1 : 0;
    }
    equals(other) {
      if (other.type === this.type) {
        const thisSource = this.regexp ? this.regexp.source : "", otherSource = other.regexp ? other.regexp.source : "";
        return this.key === other.key && thisSource === otherSource;
      }
      return !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      context = context.getValue(this.key);
      return this.regexp ? this.regexp.test(context) : !1;
    }
    serialize() {
      return `${this.key} =~ ${this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/"}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      this.negated || (this.negated = ContextKeyNotRegexExpr.create(this));
      return this.negated;
    }
  }
  class ContextKeyNotRegexExpr {
    static create(actual) {
      return new ContextKeyNotRegexExpr(actual);
    }
    constructor(_actual) {
      this._actual = _actual;
      this.type = 8;
    }
    cmp(other) {
      return other.type !== this.type ? this.type - other.type : this._actual.cmp(other._actual);
    }
    equals(other) {
      return other.type === this.type ? this._actual.equals(other._actual) : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(context) {
      return !this._actual.evaluate(context);
    }
    serialize() {
      return `!(${this._actual.serialize()})`;
    }
    keys() {
      return this._actual.keys();
    }
    negate() {
      return this._actual;
    }
  }
  class ContextKeyAndExpr {
    static create(_expr, negated, extraRedundantCheck) {
      return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
    }
    constructor(expr, negated) {
      this.expr = expr;
      this.negated = negated;
      this.type = 6;
    }
    cmp(other) {
      if (other.type !== this.type) {
        return this.type - other.type;
      }
      if (this.expr.length < other.expr.length) {
        return -1;
      }
      if (this.expr.length > other.expr.length) {
        return 1;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        const r = this.expr[i].cmp(other.expr[i]);
        if (r !== 0) {
          return r;
        }
      }
      return 0;
    }
    equals(other) {
      if (other.type === this.type) {
        if (this.expr.length !== other.expr.length) {
          return !1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
          if (!this.expr[i].equals(other.expr[i])) {
            return !1;
          }
        }
        return !0;
      }
      return !1;
    }
    substituteConstants() {
      const exprArr = eliminateConstantsInArray(this.expr);
      return exprArr === this.expr ? this : ContextKeyAndExpr.create(exprArr, this.negated, !1);
    }
    evaluate(context) {
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].evaluate(context)) {
          return !1;
        }
      }
      return !0;
    }
    static _normalizeArr(arr, negated, extraRedundantCheck) {
      const expr = [];
      var hasTrue = !1;
      for (const e of arr) {
        if (e) {
          if (e.type === 1) {
            hasTrue = !0;
          } else {
            if (e.type === 0) {
              return ContextKeyFalseExpr.INSTANCE;
            }
            e.type === 6 ? expr.push(...e.expr) : expr.push(e);
          }
        }
      }
      if (expr.length === 0 && hasTrue) {
        return ContextKeyTrueExpr.INSTANCE;
      }
      if (expr.length !== 0) {
        if (expr.length === 1) {
          return expr[0];
        }
        expr.sort(cmp);
        for (arr = 1; arr < expr.length; arr++) {
          expr[arr - 1].equals(expr[arr]) && (expr.splice(arr, 1), arr--);
        }
        if (expr.length === 1) {
          return expr[0];
        }
        for (; expr.length > 1;) {
          arr = expr[expr.length - 1];
          if (arr.type !== 9) {
            break;
          }
          expr.pop();
          const secondToLastElement = expr.pop();
          hasTrue = expr.length === 0;
          if (arr = ContextKeyOrExpr.create(arr.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, hasTrue)) {
            expr.push(arr), expr.sort(cmp);
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        if (extraRedundantCheck) {
          for (arr = 0; arr < expr.length; arr++) {
            for (hasTrue = arr + 1; hasTrue < expr.length; hasTrue++) {
              if (expr[arr].negate().equals(expr[hasTrue])) {
                return ContextKeyFalseExpr.INSTANCE;
              }
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
        }
        return new ContextKeyAndExpr(expr, negated);
      }
    }
    serialize() {
      return this.expr.map(e => e.serialize()).join(" \x26\x26 ");
    }
    keys() {
      const result = [];
      for (const expr of this.expr) {
        result.push(...expr.keys());
      }
      return result;
    }
    negate() {
      if (!this.negated) {
        const result = [];
        for (const expr of this.expr) {
          result.push(expr.negate());
        }
        this.negated = ContextKeyOrExpr.create(result, this, !0);
      }
      return this.negated;
    }
  }
  class ContextKeyOrExpr {
    static create(_expr, negated, extraRedundantCheck) {
      return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
    }
    constructor(expr, negated) {
      this.expr = expr;
      this.negated = negated;
      this.type = 9;
    }
    cmp(other) {
      if (other.type !== this.type) {
        return this.type - other.type;
      }
      if (this.expr.length < other.expr.length) {
        return -1;
      }
      if (this.expr.length > other.expr.length) {
        return 1;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        const r = this.expr[i].cmp(other.expr[i]);
        if (r !== 0) {
          return r;
        }
      }
      return 0;
    }
    equals(other) {
      if (other.type === this.type) {
        if (this.expr.length !== other.expr.length) {
          return !1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
          if (!this.expr[i].equals(other.expr[i])) {
            return !1;
          }
        }
        return !0;
      }
      return !1;
    }
    substituteConstants() {
      const exprArr = eliminateConstantsInArray(this.expr);
      return exprArr === this.expr ? this : ContextKeyOrExpr.create(exprArr, this.negated, !1);
    }
    evaluate(context) {
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (this.expr[i].evaluate(context)) {
          return !0;
        }
      }
      return !1;
    }
    static _normalizeArr(arr, negated, extraRedundantCheck) {
      let expr = [], hasFalse = !1;
      if (arr) {
        for (let i = 0, len = arr.length; i < len; i++) {
          const e = arr[i];
          if (e) {
            if (e.type === 0) {
              hasFalse = !0;
            } else {
              if (e.type === 1) {
                return ContextKeyTrueExpr.INSTANCE;
              }
              e.type === 9 ? expr = expr.concat(e.expr) : expr.push(e);
            }
          }
        }
        if (expr.length === 0 && hasFalse) {
          return ContextKeyFalseExpr.INSTANCE;
        }
        expr.sort(cmp);
      }
      if (expr.length !== 0) {
        if (expr.length === 1) {
          return expr[0];
        }
        for (arr = 1; arr < expr.length; arr++) {
          expr[arr - 1].equals(expr[arr]) && (expr.splice(arr, 1), arr--);
        }
        if (expr.length === 1) {
          return expr[0];
        }
        if (extraRedundantCheck) {
          for (extraRedundantCheck = 0; extraRedundantCheck < expr.length; extraRedundantCheck++) {
            for (arr = extraRedundantCheck + 1; arr < expr.length; arr++) {
              if (expr[extraRedundantCheck].negate().equals(expr[arr])) {
                return ContextKeyTrueExpr.INSTANCE;
              }
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
        }
        return new ContextKeyOrExpr(expr, negated);
      }
    }
    serialize() {
      return this.expr.map(e => e.serialize()).join(" || ");
    }
    keys() {
      const result = [];
      for (const expr of this.expr) {
        result.push(...expr.keys());
      }
      return result;
    }
    negate() {
      if (!this.negated) {
        const result = [];
        for (var expr of this.expr) {
          result.push(expr.negate());
        }
        for (; result.length > 1;) {
          expr = result.shift();
          const RIGHT = result.shift(), all = [];
          for (const left of expr.type === 9 ? expr.expr : [expr]) {
            for (const right of RIGHT.type === 9 ? RIGHT.expr : [RIGHT]) {
              all.push(ContextKeyAndExpr.create([left, right], null, !1));
            }
          }
          result.unshift(ContextKeyOrExpr.create(all, null, !1));
        }
        this.negated = ContextKeyOrExpr.create(result, this, !0);
      }
      return this.negated;
    }
  }
  class RawContextKey extends ContextKeyDefinedExpr {
    static all() {
      return RawContextKey._info.values();
    }
    constructor(key, defaultValue, metaOrHide) {
      super(key, null);
      this._defaultValue = defaultValue;
      typeof metaOrHide === "object" ? RawContextKey._info.push({...metaOrHide, key}) : metaOrHide !== !0 && RawContextKey._info.push({key, description:metaOrHide, type:defaultValue !== null && defaultValue !== void 0 ? typeof defaultValue : void 0});
    }
    bindTo(target) {
      return target.createKey(this.key, this._defaultValue);
    }
    getValue(target) {
      return target.getContextKeyValue(this.key);
    }
    toNegated() {
      return this.negate();
    }
    isEqualTo(value) {
      return ContextKeyEqualsExpr.create(this.key, value);
    }
  }
  RawContextKey._info = [];
  const IContextKeyService = (0,exports.createDecorator)("contextKeyService");
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$contextkey$common$contextkey.js.map
