shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$tokenization = function(require, module, exports) {
  function parseTokenTheme(source) {
    if (!source || !Array.isArray(source)) {
      return [];
    }
    const result = [];
    let resultLen = 0;
    for (let i = 0, len = source.length; i < len; i++) {
      const entry = source[i];
      let fontStyle = -1;
      if (typeof entry.fontStyle === "string") {
        fontStyle = 0;
        var segments = entry.fontStyle.split(" ");
        for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
          switch(segments[j]) {
            case "italic":
              fontStyle |= 1;
              break;
            case "bold":
              fontStyle |= 2;
              break;
            case "underline":
              fontStyle |= 4;
              break;
            case "strikethrough":
              fontStyle |= 8;
          }
        }
      }
      segments = null;
      typeof entry.foreground === "string" && (segments = entry.foreground);
      let background = null;
      typeof entry.background === "string" && (background = entry.background);
      result[resultLen++] = new ParsedTokenThemeRule(entry.token || "", i, fontStyle, segments, background);
    }
    return result;
  }
  function resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {
    parsedThemeRules.sort((a, b) => {
      const r = strcmp(a.token, b.token);
      return r !== 0 ? r : a.index - b.index;
    });
    var defaultFontStyle = 0;
    let defaultForeground = "000000";
    for (var defaultBackground = "ffffff"; parsedThemeRules.length >= 1 && parsedThemeRules[0].token === "";) {
      var incomingDefaults = parsedThemeRules.shift();
      incomingDefaults.fontStyle !== -1 && (defaultFontStyle = incomingDefaults.fontStyle);
      incomingDefaults.foreground !== null && (defaultForeground = incomingDefaults.foreground);
      incomingDefaults.background !== null && (defaultBackground = incomingDefaults.background);
    }
    incomingDefaults = new ColorMap();
    for (const color of customTokenColors) {
      incomingDefaults.getId(color);
    }
    customTokenColors = incomingDefaults.getId(defaultForeground);
    defaultBackground = incomingDefaults.getId(defaultBackground);
    defaultFontStyle = new ThemeTrieElementRule(defaultFontStyle, customTokenColors, defaultBackground);
    defaultFontStyle = new ThemeTrieElement(defaultFontStyle);
    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
      defaultBackground = parsedThemeRules[i], defaultFontStyle.insert(defaultBackground.token, defaultBackground.fontStyle, incomingDefaults.getId(defaultBackground.foreground), incomingDefaults.getId(defaultBackground.background));
    }
    return new TokenTheme(incomingDefaults, defaultFontStyle);
  }
  function toStandardTokenType(tokenType) {
    tokenType = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
    if (!tokenType) {
      return 0;
    }
    switch(tokenType[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "regexp":
        return 3;
    }
    throw Error("Unexpected match for standard token type!");
  }
  function strcmp(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function generateTokensCSSForColorMap(colorMap) {
    const rules = [];
    for (let i = 1, len = colorMap.length; i < len; i++) {
      rules[i] = `.mtk${i} { color: ${colorMap[i]}; }`;
    }
    rules.push(".mtki { font-style: italic; }");
    rules.push(".mtkb { font-weight: bold; }");
    rules.push(".mtku { text-decoration: underline; text-underline-position: under; }");
    rules.push(".mtks { text-decoration: line-through; }");
    rules.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }");
    return rules.join("\n");
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ColorMap:{enumerable:!0, get:function() {
    return ColorMap;
  }}, ParsedTokenThemeRule:{enumerable:!0, get:function() {
    return ParsedTokenThemeRule;
  }}, ThemeTrieElement:{enumerable:!0, get:function() {
    return ThemeTrieElement;
  }}, ThemeTrieElementRule:{enumerable:!0, get:function() {
    return ThemeTrieElementRule;
  }}, TokenTheme:{enumerable:!0, get:function() {
    return TokenTheme;
  }}, generateTokensCSSForColorMap:{enumerable:!0, get:function() {
    return generateTokensCSSForColorMap;
  }}, parseTokenTheme:{enumerable:!0, get:function() {
    return parseTokenTheme;
  }}, strcmp:{enumerable:!0, get:function() {
    return strcmp;
  }}, toStandardTokenType:{enumerable:!0, get:function() {
    return toStandardTokenType;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$color");
  class ParsedTokenThemeRule {
    constructor(token, index, fontStyle, foreground, background) {
      this._parsedThemeRuleBrand = void 0;
      this.token = token;
      this.index = index;
      this.fontStyle = fontStyle;
      this.foreground = foreground;
      this.background = background;
    }
  }
  const colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
  class ColorMap {
    constructor() {
      this._lastColorId = 0;
      this._id2color = [];
      this._color2id = new Map();
    }
    getId(color) {
      if (color === null) {
        return 0;
      }
      var match = color.match(colorRegExp);
      if (!match) {
        throw Error("Illegal value for token color: " + color);
      }
      color = match[1].toUpperCase();
      if (match = this._color2id.get(color)) {
        return match;
      }
      match = ++this._lastColorId;
      this._color2id.set(color, match);
      this._id2color[match] = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.fromHex("#" + color);
      return match;
    }
    getColorMap() {
      return this._id2color.slice(0);
    }
  }
  class TokenTheme {
    static createFromRawTokenTheme(source, customTokenColors) {
      return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);
    }
    static createFromParsedTokenTheme(source, customTokenColors) {
      return resolveParsedTokenThemeRules(source, customTokenColors);
    }
    constructor(colorMap, root) {
      this._colorMap = colorMap;
      this._root = root;
      this._cache = new Map();
    }
    getColorMap() {
      return this._colorMap.getColorMap();
    }
    _match(token) {
      return this._root.match(token);
    }
    match(languageId, token) {
      var result = this._cache.get(token);
      if (typeof result === "undefined") {
        result = this._match(token);
        const standardToken = toStandardTokenType(token);
        result = (result.metadata | standardToken << 8) >>> 0;
        this._cache.set(token, result);
      }
      return (result | languageId << 0) >>> 0;
    }
  }
  const STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|regexp)\b/;
  class ThemeTrieElementRule {
    constructor(fontStyle, foreground, background) {
      this._themeTrieElementRuleBrand = void 0;
      this._fontStyle = fontStyle;
      this._foreground = foreground;
      this._background = background;
      this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
    }
    clone() {
      return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
    }
    acceptOverwrite(fontStyle, foreground, background) {
      fontStyle !== -1 && (this._fontStyle = fontStyle);
      foreground !== 0 && (this._foreground = foreground);
      background !== 0 && (this._background = background);
      this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
    }
  }
  class ThemeTrieElement {
    constructor(mainRule) {
      this._themeTrieElementBrand = void 0;
      this._mainRule = mainRule;
      this._children = new Map();
    }
    match(token) {
      if (token === "") {
        return this._mainRule;
      }
      const dotIndex = token.indexOf(".");
      if (dotIndex === -1) {
        var head = token;
        token = "";
      } else {
        head = token.substring(0, dotIndex), token = token.substring(dotIndex + 1);
      }
      head = this._children.get(head);
      return typeof head !== "undefined" ? head.match(token) : this._mainRule;
    }
    insert(token, fontStyle, foreground, background) {
      if (token === "") {
        this._mainRule.acceptOverwrite(fontStyle, foreground, background);
      } else {
        var dotIndex = token.indexOf(".");
        if (dotIndex === -1) {
          var head = token;
          token = "";
        } else {
          head = token.substring(0, dotIndex), token = token.substring(dotIndex + 1);
        }
        dotIndex = this._children.get(head);
        typeof dotIndex === "undefined" && (dotIndex = new ThemeTrieElement(this._mainRule.clone()), this._children.set(head, dotIndex));
        dotIndex.insert(token, fontStyle, foreground, background);
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$tokenization.js.map
