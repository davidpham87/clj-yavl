shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$computeMovedLines = function(require, module, exports) {
  function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
    let {moves, excludedChanges} = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
    if (!timeout.isValid()) {
      return [];
    }
    const filteredChanges = changes.filter(c => !excludedChanges.has(c));
    modifiedLines = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.pushMany)(moves, modifiedLines);
    moves = joinCloseConsecutiveMoves(moves);
    moves = moves.filter(current => {
      current = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());
      return current.join("\n").length >= 15 && countWhere(current, l => l.length >= 2) >= 2;
    });
    return moves = removeMovesInSameDiff(changes, moves);
  }
  function countWhere(arr, predicate) {
    let count = 0;
    for (const t of arr) {
      predicate(t) && count++;
    }
    return count;
  }
  function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
    const moves = [];
    var deletions = changes.filter(c => c.modified.isEmpty && c.original.length >= 3).map(d => new require$_DOT__SLASH_utils_DOT_js.LineRangeFragment(d.original, originalLines, d));
    changes = new Set(changes.filter(c => c.original.isEmpty && c.modified.length >= 3).map(d => new require$_DOT__SLASH_utils_DOT_js.LineRangeFragment(d.modified, modifiedLines, d)));
    const excludedChanges = new Set();
    for (const deletion of deletions) {
      deletions = -1;
      let best;
      for (const insertion of changes) {
        const similarity = deletion.computeSimilarity(insertion);
        similarity > deletions && (deletions = similarity, best = insertion);
      }
      deletions > 0.90 && best && (changes.delete(best), moves.push(new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.LineRangeMapping(deletion.range, best.range)), excludedChanges.add(deletion.source), excludedChanges.add(best.source));
      if (!timeout.isValid()) {
        break;
      }
    }
    return {moves, excludedChanges};
  }
  function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
    const moves = [];
    var original3LineHashes = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js.SetMap();
    for (var change of changes) {
      for (var i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
        original3LineHashes.add(`${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`, {range:new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(i, i + 3)});
      }
    }
    const possibleMappings = [];
    changes.sort((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(c => c.modified.startLineNumber, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.numberComparator));
    for (var change$jscomp$0 of changes) {
      let lastMappings = [];
      for (hashedOriginalLines = change$jscomp$0.modified.startLineNumber; hashedOriginalLines < change$jscomp$0.modified.endLineNumberExclusive - 2; hashedOriginalLines++) {
        change = `${hashedModifiedLines[hashedOriginalLines - 1]}:${hashedModifiedLines[hashedOriginalLines + 1 - 1]}:${hashedModifiedLines[hashedOriginalLines + 2 - 1]}`;
        const currentModifiedRange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(hashedOriginalLines, hashedOriginalLines + 3), nextMappings = [];
        original3LineHashes.forEach(change, ({range}) => {
          for (const lastMapping of lastMappings) {
            if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
              lastMapping.originalLineRange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
              lastMapping.modifiedLineRange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
              nextMappings.push(lastMapping);
              return;
            }
          }
          range = {modifiedLineRange:currentModifiedRange, originalLineRange:range};
          possibleMappings.push(range);
          nextMappings.push(range);
        });
        lastMappings = nextMappings;
      }
      if (!timeout.isValid()) {
        return [];
      }
    }
    possibleMappings.sort((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.reverseOrder)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(m => m.modifiedLineRange.length, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.numberComparator)));
    hashedModifiedLines = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRangeSet();
    original3LineHashes = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRangeSet();
    for (var mapping of possibleMappings) {
      change$jscomp$0 = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
      hashedOriginalLines = hashedModifiedLines.subtractFrom(mapping.modifiedLineRange);
      change = original3LineHashes.subtractFrom(mapping.originalLineRange).getWithDelta(change$jscomp$0);
      hashedOriginalLines = hashedOriginalLines.getIntersection(change);
      for (var s of hashedOriginalLines.ranges) {
        s.length < 3 || (hashedOriginalLines = s, change = s.delta(-change$jscomp$0), moves.push(new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.LineRangeMapping(change, hashedOriginalLines)), hashedModifiedLines.addRange(hashedOriginalLines), original3LineHashes.addRange(change));
      }
    }
    moves.sort((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(m => m.original.startLineNumber, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.numberComparator));
    mapping = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.MonotonousArray(changes);
    for (s = 0; s < moves.length; s++) {
      const move = moves[s];
      change$jscomp$0 = mapping.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);
      hashedOriginalLines = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMonotonous)(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);
      change = Math.max(move.original.startLineNumber - change$jscomp$0.original.startLineNumber, move.modified.startLineNumber - hashedOriginalLines.modified.startLineNumber);
      change$jscomp$0 = mapping.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);
      hashedOriginalLines = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMonotonous)(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
      change$jscomp$0 = Math.max(change$jscomp$0.original.endLineNumberExclusive - move.original.endLineNumberExclusive, hashedOriginalLines.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
      for (hashedOriginalLines = 0; hashedOriginalLines < change; hashedOriginalLines++) {
        i = move.original.startLineNumber - hashedOriginalLines - 1;
        var modLine = move.modified.startLineNumber - hashedOriginalLines - 1;
        if (i > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (hashedModifiedLines.contains(modLine) || original3LineHashes.contains(i)) {
          break;
        }
        if (!areLinesSimilar(originalLines[i - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      hashedOriginalLines > 0 && (original3LineHashes.addRange(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(move.original.startLineNumber - hashedOriginalLines, move.original.startLineNumber)), hashedModifiedLines.addRange(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(move.modified.startLineNumber - hashedOriginalLines, move.modified.startLineNumber)));
      for (change = 0; change < change$jscomp$0; change++) {
        i = move.original.endLineNumberExclusive + change;
        modLine = move.modified.endLineNumberExclusive + change;
        if (i > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (hashedModifiedLines.contains(modLine) || original3LineHashes.contains(i)) {
          break;
        }
        if (!areLinesSimilar(originalLines[i - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      change > 0 && (original3LineHashes.addRange(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + change)), hashedModifiedLines.addRange(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + change)));
      if (hashedOriginalLines > 0 || change > 0) {
        moves[s] = new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.LineRangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(move.original.startLineNumber - hashedOriginalLines, move.original.endLineNumberExclusive + change), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(move.modified.startLineNumber - hashedOriginalLines, move.modified.endLineNumberExclusive + change));
      }
    }
    return moves;
  }
  function areLinesSimilar(line1, line2, timeout) {
    if (line1.trim() === line2.trim()) {
      return !0;
    }
    if (line1.length > 300 && line2.length > 300) {
      return !1;
    }
    timeout = (new require$_DOT__SLASH_algorithms_SLASH_myersDiffAlgorithm_DOT_js.MyersDiffAlgorithm()).compute(new require$_DOT__SLASH_linesSliceCharSequence_DOT_js.LinesSliceCharSequence([line1], new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(0, 1), !1), new require$_DOT__SLASH_linesSliceCharSequence_DOT_js.LinesSliceCharSequence([line2], new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(0, 1), !1), timeout);
    let commonNonSpaceCharCount = 0;
    timeout = require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js.SequenceDiff.invert(timeout.diffs, line1.length);
    for (const seq of timeout) {
      seq.seq1Range.forEach(idx => {
        (0,require$_DOT__SLASH_utils_DOT_js.isSpace)(line1.charCodeAt(idx)) || commonNonSpaceCharCount++;
      });
    }
    line2 = function(str) {
      let count = 0;
      for (let i = 0; i < line1.length; i++) {
        (0,require$_DOT__SLASH_utils_DOT_js.isSpace)(str.charCodeAt(i)) || count++;
      }
      return count;
    }(line1.length > line2.length ? line1 : line2);
    return commonNonSpaceCharCount / line2 > 0.6 && line2 > 10;
  }
  function joinCloseConsecutiveMoves(moves) {
    if (moves.length === 0) {
      return moves;
    }
    moves.sort((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(m => m.original.startLineNumber, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.numberComparator));
    const result = [moves[0]];
    for (let i = 1; i < moves.length; i++) {
      const last = result[result.length - 1], current = moves[i], originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive, modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
      originalDist >= 0 && modifiedDist >= 0 && originalDist + modifiedDist <= 2 ? result[result.length - 1] = last.join(current) : result.push(current);
    }
    return result;
  }
  function removeMovesInSameDiff(changes, moves) {
    const changesMonotonous = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.MonotonousArray(changes);
    return moves = moves.filter(m => {
      const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive) || new require$_DOT__DOT__SLASH_rangeMapping_DOT_js.LineRangeMapping(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(1, 1), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(1, 1)), diffBeforeEndOfMoveModified = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMonotonous)(changes, 
      c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
      return diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
    });
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, computeMovedLines:{enumerable:!0, get:function() {
    return computeMovedLines;
  }}});
  var require$_DOT__SLASH_algorithms_SLASH_diffAlgorithm_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$diffAlgorithm"), require$_DOT__DOT__SLASH_rangeMapping_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$rangeMapping"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arraysFind"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_map_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$map"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange"), require$_DOT__SLASH_linesSliceCharSequence_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$linesSliceCharSequence"), require$_DOT__SLASH_utils_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$utils"), require$_DOT__SLASH_algorithms_SLASH_myersDiffAlgorithm_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$myersDiffAlgorithm");
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$computeMovedLines.js.map
