shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$arrays = function(require, module, exports) {
  function tail(array, n = 0) {
    return array[array.length - (1 + n)];
  }
  function tail2(arr) {
    if (arr.length === 0) {
      throw Error("Invalid tail call");
    }
    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
  }
  function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
      return !0;
    }
    if (!one || !other || one.length !== other.length) {
      return !1;
    }
    for (let i = 0, len = one.length; i < len; i++) {
      if (!itemEquals(one[i], other[i])) {
        return !1;
      }
    }
    return !0;
  }
  function removeFastWithoutKeepingOrder(array, index) {
    const last = array.length - 1;
    index < last && (array[index] = array[last]);
    array.pop();
  }
  function binarySearch(array, key, comparator) {
    return binarySearch2(array.length, i => comparator(array[i], key));
  }
  function binarySearch2(length, compareToKey) {
    let low = 0;
    for (--length; low <= length;) {
      const mid = (low + length) / 2 | 0, comp = compareToKey(mid);
      if (comp < 0) {
        low = mid + 1;
      } else if (comp > 0) {
        length = mid - 1;
      } else {
        return mid;
      }
    }
    return -(low + 1);
  }
  function quickSelect(nth, data, compare) {
    nth |= 0;
    if (nth >= data.length) {
      throw new TypeError("invalid index");
    }
    const pivotValue = data[Math.floor(data.length * Math.random())], lower = [], higher = [], pivots = [];
    for (const value of data) {
      data = compare(value, pivotValue), data < 0 ? lower.push(value) : data > 0 ? higher.push(value) : pivots.push(value);
    }
    return nth < lower.length ? quickSelect(nth, lower, compare) : nth < lower.length + pivots.length ? pivots[0] : quickSelect(nth - (lower.length + pivots.length), higher, compare);
  }
  function groupBy(data, compare) {
    const result = [];
    let currentGroup = void 0;
    for (const element of data.slice(0).sort(compare)) {
      currentGroup && compare(currentGroup[0], element) === 0 ? currentGroup.push(element) : (currentGroup = [element], result.push(currentGroup));
    }
    return result;
  }
  function* groupAdjacentBy(items, shouldBeGrouped) {
    let currentGroup, last;
    for (const item of items) {
      last !== void 0 && shouldBeGrouped(last, item) ? currentGroup.push(item) : (currentGroup && (yield currentGroup), currentGroup = [item]), last = item;
    }
    currentGroup && (yield currentGroup);
  }
  function forEachAdjacent(arr, f) {
    for (let i = 0; i <= arr.length; i++) {
      f(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
    }
  }
  function forEachWithNeighbors(arr, f) {
    for (let i = 0; i < arr.length; i++) {
      f(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
    }
  }
  function coalesce(array) {
    return array.filter(e => !!e);
  }
  function coalesceInPlace(array) {
    let to = 0;
    for (let i = 0; i < array.length; i++) {
      array[i] && (array[to] = array[i], to += 1);
    }
    array.length = to;
  }
  function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
  }
  function isNonEmptyArray(obj) {
    return Array.isArray(obj) && obj.length > 0;
  }
  function distinct(array, keyFn = value => value) {
    const seen = new Set();
    return array.filter(element => {
      element = keyFn(element);
      if (seen.has(element)) {
        return !1;
      }
      seen.add(element);
      return !0;
    });
  }
  function firstOrDefault(array, notFoundValue) {
    return array.length > 0 ? array[0] : notFoundValue;
  }
  function range(arg, to) {
    if (typeof to === "number") {
      var from = arg;
    } else {
      from = 0, to = arg;
    }
    arg = [];
    if (from <= to) {
      for (; from < to; from++) {
        arg.push(from);
      }
    } else {
      for (; from > to; from--) {
        arg.push(from);
      }
    }
    return arg;
  }
  function arrayInsert(target, insertIndex, insertArr) {
    const before = target.slice(0, insertIndex);
    target = target.slice(insertIndex);
    return before.concat(insertArr, target);
  }
  function pushToStart(arr, value) {
    const index = arr.indexOf(value);
    index > -1 && (arr.splice(index, 1), arr.unshift(value));
  }
  function pushToEnd(arr, value) {
    const index = arr.indexOf(value);
    index > -1 && (arr.splice(index, 1), arr.push(value));
  }
  function pushMany(arr, items) {
    for (const item of items) {
      arr.push(item);
    }
  }
  function asArray(x) {
    return Array.isArray(x) ? x : [x];
  }
  function insertInto(array, start, newItems) {
    start = start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
    var originalLength = array.length;
    const newItemsLength = newItems.length;
    array.length = originalLength + newItemsLength;
    for (--originalLength; originalLength >= start; originalLength--) {
      array[originalLength + newItemsLength] = array[originalLength];
    }
    for (originalLength = 0; originalLength < newItemsLength; originalLength++) {
      array[originalLength + start] = newItems[originalLength];
    }
  }
  function splice(array, start, deleteCount, newItems) {
    start = start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
    deleteCount = array.splice(start, deleteCount);
    deleteCount === void 0 && (deleteCount = []);
    insertInto(array, start, newItems);
    return deleteCount;
  }
  function compareBy(selector, comparator) {
    return (a, b) => comparator(selector(a), selector(b));
  }
  function tieBreakComparators(...comparators) {
    return (item1, item2) => {
      for (const comparator of comparators) {
        const result = comparator(item1, item2);
        if (!CompareResult.isNeitherLessOrGreaterThan(result)) {
          return result;
        }
      }
      return CompareResult.neitherLessOrGreaterThan;
    };
  }
  function reverseOrder(comparator) {
    return (a, b) => -comparator(a, b);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ArrayQueue:{enumerable:!0, get:function() {
    return ArrayQueue;
  }}, CallbackIterable:{enumerable:!0, get:function() {
    return CallbackIterable;
  }}, CompareResult:{enumerable:!0, get:function() {
    return CompareResult;
  }}, arrayInsert:{enumerable:!0, get:function() {
    return arrayInsert;
  }}, asArray:{enumerable:!0, get:function() {
    return asArray;
  }}, binarySearch:{enumerable:!0, get:function() {
    return binarySearch;
  }}, binarySearch2:{enumerable:!0, get:function() {
    return binarySearch2;
  }}, booleanComparator:{enumerable:!0, get:function() {
    return booleanComparator;
  }}, coalesce:{enumerable:!0, get:function() {
    return coalesce;
  }}, coalesceInPlace:{enumerable:!0, get:function() {
    return coalesceInPlace;
  }}, compareBy:{enumerable:!0, get:function() {
    return compareBy;
  }}, distinct:{enumerable:!0, get:function() {
    return distinct;
  }}, equals:{enumerable:!0, get:function() {
    return equals;
  }}, firstOrDefault:{enumerable:!0, get:function() {
    return firstOrDefault;
  }}, forEachAdjacent:{enumerable:!0, get:function() {
    return forEachAdjacent;
  }}, forEachWithNeighbors:{enumerable:!0, get:function() {
    return forEachWithNeighbors;
  }}, groupAdjacentBy:{enumerable:!0, get:function() {
    return groupAdjacentBy;
  }}, groupBy:{enumerable:!0, get:function() {
    return groupBy;
  }}, insertInto:{enumerable:!0, get:function() {
    return insertInto;
  }}, isFalsyOrEmpty:{enumerable:!0, get:function() {
    return isFalsyOrEmpty;
  }}, isNonEmptyArray:{enumerable:!0, get:function() {
    return isNonEmptyArray;
  }}, numberComparator:{enumerable:!0, get:function() {
    return numberComparator;
  }}, pushMany:{enumerable:!0, get:function() {
    return pushMany;
  }}, pushToEnd:{enumerable:!0, get:function() {
    return pushToEnd;
  }}, pushToStart:{enumerable:!0, get:function() {
    return pushToStart;
  }}, quickSelect:{enumerable:!0, get:function() {
    return quickSelect;
  }}, range:{enumerable:!0, get:function() {
    return range;
  }}, removeFastWithoutKeepingOrder:{enumerable:!0, get:function() {
    return removeFastWithoutKeepingOrder;
  }}, reverseOrder:{enumerable:!0, get:function() {
    return reverseOrder;
  }}, splice:{enumerable:!0, get:function() {
    return splice;
  }}, tail:{enumerable:!0, get:function() {
    return tail;
  }}, tail2:{enumerable:!0, get:function() {
    return tail2;
  }}, tieBreakComparators:{enumerable:!0, get:function() {
    return tieBreakComparators;
  }}});
  var CompareResult;
  (function(CompareResult) {
    CompareResult.isLessThan = function(result) {
      return result < 0;
    };
    CompareResult.isLessThanOrEqual = function(result) {
      return result <= 0;
    };
    CompareResult.isGreaterThan = function(result) {
      return result > 0;
    };
    CompareResult.isNeitherLessOrGreaterThan = function(result) {
      return result === 0;
    };
    CompareResult.greaterThan = 1;
    CompareResult.lessThan = -1;
    CompareResult.neitherLessOrGreaterThan = 0;
  })(CompareResult ||= {});
  const numberComparator = (a, b) => a - b, booleanComparator = (a, b) => (a ? 1 : 0) - (b ? 1 : 0);
  class ArrayQueue {
    constructor(items) {
      this.items = items;
      this.firstIdx = 0;
      this.lastIdx = this.items.length - 1;
    }
    get length() {
      return this.lastIdx - this.firstIdx + 1;
    }
    takeWhile(predicate) {
      let startIdx = this.firstIdx;
      for (; startIdx < this.items.length && predicate(this.items[startIdx]);) {
        startIdx++;
      }
      predicate = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
      this.firstIdx = startIdx;
      return predicate;
    }
    takeFromEndWhile(predicate) {
      let endIdx = this.lastIdx;
      for (; endIdx >= 0 && predicate(this.items[endIdx]);) {
        endIdx--;
      }
      predicate = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
      this.lastIdx = endIdx;
      return predicate;
    }
    peek() {
      if (this.length !== 0) {
        return this.items[this.firstIdx];
      }
    }
    dequeue() {
      const result = this.items[this.firstIdx];
      this.firstIdx++;
      return result;
    }
    takeCount(count) {
      const result = this.items.slice(this.firstIdx, this.firstIdx + count);
      this.firstIdx += count;
      return result;
    }
  }
  class CallbackIterable {
    constructor(iterate) {
      this.iterate = iterate;
    }
    toArray() {
      const result = [];
      this.iterate(item => {
        result.push(item);
        return !0;
      });
      return result;
    }
    filter(predicate) {
      return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : !0));
    }
    map(mapFn) {
      return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));
    }
    findLast(predicate) {
      let result;
      this.iterate(item => {
        predicate(item) && (result = item);
        return !0;
      });
      return result;
    }
    findLastMaxBy(comparator) {
      let result, first = !0;
      this.iterate(item => {
        if (first || CompareResult.isGreaterThan(comparator(item, result))) {
          first = !1, result = item;
        }
        return !0;
      });
      return result;
    }
  }
  CallbackIterable.empty = new CallbackIterable(_callback => {
  });
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$arrays.js.map
