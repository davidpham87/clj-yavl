shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorWordOperations = function(require, module, exports) {
  function enforceDefined(arr) {
    return arr.filter(el => !!el);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, WordOperations:{enumerable:!0, get:function() {
    return WordOperations;
  }}, WordPartOperations:{enumerable:!0, get:function() {
    return WordPartOperations;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), require$_DOT__SLASH_cursorDeleteOperations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorDeleteOperations"), require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordCharacterClassifier"), 
  require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class WordOperations {
    static _createWord(lineContent, wordType, nextCharClass, start, end) {
      return {start, end, wordType, nextCharClass};
    }
    static _findPreviousWordOnLine(wordSeparators, model, position) {
      model = model.getLineContent(position.lineNumber);
      return this._doFindPreviousWordOnLine(model, wordSeparators, position);
    }
    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {
      let wordType = 0;
      for (position = position.column - 2; position >= 0; position--) {
        var chCode = lineContent.charCodeAt(position);
        chCode = wordSeparators.get(chCode);
        if (chCode === 0) {
          if (wordType === 2) {
            return this._createWord(lineContent, wordType, chCode, position + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, position + 1));
          }
          wordType = 1;
        } else if (chCode === 2) {
          if (wordType === 1) {
            return this._createWord(lineContent, wordType, chCode, position + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, position + 1));
          }
          wordType = 2;
        } else if (chCode === 1 && wordType !== 0) {
          return this._createWord(lineContent, wordType, chCode, position + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, position + 1));
        }
      }
      return wordType !== 0 ? this._createWord(lineContent, wordType, 1, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0)) : null;
    }
    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {
      const len = lineContent.length;
      for (; startIndex < len; startIndex++) {
        var chCode = lineContent.charCodeAt(startIndex);
        chCode = wordSeparators.get(chCode);
        if (chCode === 1 || wordType === 1 && chCode === 2 || wordType === 2 && chCode === 0) {
          return startIndex;
        }
      }
      return len;
    }
    static _findNextWordOnLine(wordSeparators, model, position) {
      model = model.getLineContent(position.lineNumber);
      return this._doFindNextWordOnLine(model, wordSeparators, position);
    }
    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {
      let wordType = 0;
      const len = lineContent.length;
      for (position = position.column - 1; position < len; position++) {
        var chCode = lineContent.charCodeAt(position);
        chCode = wordSeparators.get(chCode);
        if (chCode === 0) {
          if (wordType === 2) {
            return this._createWord(lineContent, wordType, chCode, this._findStartOfWord(lineContent, wordSeparators, wordType, position - 1), position);
          }
          wordType = 1;
        } else if (chCode === 2) {
          if (wordType === 1) {
            return this._createWord(lineContent, wordType, chCode, this._findStartOfWord(lineContent, wordSeparators, wordType, position - 1), position);
          }
          wordType = 2;
        } else if (chCode === 1 && wordType !== 0) {
          return this._createWord(lineContent, wordType, chCode, this._findStartOfWord(lineContent, wordSeparators, wordType, position - 1), position);
        }
      }
      return wordType !== 0 ? this._createWord(lineContent, wordType, 1, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len) : null;
    }
    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {
      for (; startIndex >= 0; startIndex--) {
        var chCode = lineContent.charCodeAt(startIndex);
        chCode = wordSeparators.get(chCode);
        if (chCode === 1 || wordType === 1 && chCode === 2 || wordType === 2 && chCode === 0) {
          return startIndex + 1;
        }
      }
      return 0;
    }
    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {
      let lineNumber = position.lineNumber;
      position = position.column;
      position === 1 && lineNumber > 1 && (--lineNumber, position = model.getLineMaxColumn(lineNumber));
      let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, position));
      if (wordNavigationType === 0) {
        return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);
      }
      if (wordNavigationType === 1) {
        return prevWordOnLine && prevWordOnLine.wordType === 2 && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0 && (prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine.start + 1))), new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);
      }
      if (wordNavigationType === 3) {
        for (; prevWordOnLine && prevWordOnLine.wordType === 2;) {
          prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine.start + 1));
        }
        return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);
      }
      prevWordOnLine && position <= prevWordOnLine.end + 1 && (prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine.start + 1)));
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);
    }
    static _moveWordPartLeft(model, position) {
      const lineNumber = position.lineNumber, maxColumn = model.getLineMaxColumn(lineNumber);
      if (position.column === 1) {
        return lineNumber > 1 ? new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;
      }
      model = model.getLineContent(lineNumber);
      for (position = position.column - 1; position > 1; position--) {
        var left = model.charCodeAt(position - 2);
        const right = model.charCodeAt(position - 1);
        if (left === 95 && right !== 95 || left === 45 && right !== 45 || (strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right) || strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right) && position + 1 < maxColumn && (left = model.charCodeAt(position), strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left))) {
          return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, position);
        }
      }
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, 1);
    }
    static moveWordRight(wordSeparators, model, position, wordNavigationType) {
      let lineNumber = position.lineNumber;
      position = position.column;
      let movedDown = !1;
      position === model.getLineMaxColumn(lineNumber) && lineNumber < model.getLineCount() && (movedDown = !0, lineNumber += 1, position = 1);
      let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, position));
      if (wordNavigationType === 2) {
        nextWordOnLine && nextWordOnLine.wordType === 2 && nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 && (nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, nextWordOnLine.end + 1))), position = nextWordOnLine ? nextWordOnLine.end + 1 : model.getLineMaxColumn(lineNumber);
      } else {
        if (wordNavigationType === 3) {
          for (movedDown && (position = 0); nextWordOnLine && (nextWordOnLine.wordType === 2 || nextWordOnLine.start + 1 <= position);) {
            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, nextWordOnLine.end + 1));
          }
        } else {
          nextWordOnLine && !movedDown && position >= nextWordOnLine.start + 1 && (nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, nextWordOnLine.end + 1)));
        }
        position = nextWordOnLine ? nextWordOnLine.start + 1 : model.getLineMaxColumn(lineNumber);
      }
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, position);
    }
    static _moveWordPartRight(model, position) {
      const lineNumber = position.lineNumber, maxColumn = model.getLineMaxColumn(lineNumber);
      if (position.column === maxColumn) {
        return lineNumber < model.getLineCount() ? new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber + 1, 1) : position;
      }
      model = model.getLineContent(lineNumber);
      for (position = position.column + 1; position < maxColumn; position++) {
        var left = model.charCodeAt(position - 2);
        const right = model.charCodeAt(position - 1);
        if (left !== 95 && right === 95 || left !== 45 && right === 45 || (strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right) || strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right) && position + 1 < maxColumn && (left = model.charCodeAt(position), strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left))) {
          return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, position);
        }
      }
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, maxColumn);
    }
    static _deleteWordLeftWhitespace(model, position) {
      var lineContent = model.getLineContent(position.lineNumber);
      model = position.column - 2;
      lineContent = strings.lastNonWhitespaceIndex(lineContent, model);
      return lineContent + 1 < model ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, lineContent + 2, position.lineNumber, position.column) : null;
    }
    static deleteWordLeft(ctx, wordNavigationType) {
      const wordSeparators = ctx.wordSeparators, model = ctx.model;
      var selection = ctx.selection, whitespaceHeuristics = ctx.whitespaceHeuristics;
      if (!selection.isEmpty()) {
        return selection;
      }
      if (require$_DOT__SLASH_cursorDeleteOperations_DOT_js.DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {
        return wordNavigationType = ctx.selection.getPosition(), new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(wordNavigationType.lineNumber, wordNavigationType.column - 1, wordNavigationType.lineNumber, wordNavigationType.column + 1);
      }
      ctx = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(selection.positionLineNumber, selection.positionColumn);
      selection = ctx.lineNumber;
      let column = ctx.column;
      if (selection === 1 && column === 1) {
        return null;
      }
      if (whitespaceHeuristics && (whitespaceHeuristics = this._deleteWordLeftWhitespace(model, ctx))) {
        return whitespaceHeuristics;
      }
      whitespaceHeuristics = WordOperations._findPreviousWordOnLine(wordSeparators, model, ctx);
      wordNavigationType === 0 ? whitespaceHeuristics ? column = whitespaceHeuristics.start + 1 : column > 1 ? column = 1 : (selection--, column = model.getLineMaxColumn(selection)) : (whitespaceHeuristics && column <= whitespaceHeuristics.end + 1 && (whitespaceHeuristics = WordOperations._findPreviousWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(selection, whitespaceHeuristics.start + 1))), whitespaceHeuristics ? column = whitespaceHeuristics.end + 
      1 : column > 1 ? column = 1 : (selection--, column = model.getLineMaxColumn(selection)));
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection, column, ctx.lineNumber, ctx.column);
    }
    static deleteInsideWord(wordSeparators, model, selection) {
      if (!selection.isEmpty()) {
        return selection;
      }
      selection = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(selection.positionLineNumber, selection.positionColumn);
      const r = this._deleteInsideWordWhitespace(model, selection);
      return r ? r : this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, selection);
    }
    static _charAtIsWhitespace(str, index) {
      str = str.charCodeAt(index);
      return str === 32 || str === 9;
    }
    static _deleteInsideWordWhitespace(model, position) {
      model = model.getLineContent(position.lineNumber);
      const lineContentLength = model.length;
      if (lineContentLength === 0) {
        return null;
      }
      let leftIndex = Math.max(position.column - 2, 0);
      if (!this._charAtIsWhitespace(model, leftIndex)) {
        return null;
      }
      let rightIndex = Math.min(position.column - 1, lineContentLength - 1);
      if (!this._charAtIsWhitespace(model, rightIndex)) {
        return null;
      }
      for (; leftIndex > 0 && this._charAtIsWhitespace(model, leftIndex - 1);) {
        leftIndex--;
      }
      for (; rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(model, rightIndex + 1);) {
        rightIndex++;
      }
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);
    }
    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {
      const lineContent = model.getLineContent(position.lineNumber), lineLength = lineContent.length;
      if (lineLength === 0) {
        return position.lineNumber > 1 ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1) : position.lineNumber < model.getLineCount() ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, 1, position.lineNumber + 1, 1) : new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, 1, position.lineNumber, 1);
      }
      const createRangeWithPosition = (startColumn, endColumn) => {
        startColumn = Math.min(startColumn, position.column);
        endColumn = Math.max(endColumn, position.column);
        return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, startColumn, position.lineNumber, endColumn);
      }, deleteWordAndAdjacentWhitespace = word => {
        let startColumn = word.start + 1;
        word = word.end + 1;
        let expandedToTheRight = !1;
        for (; word - 1 < lineLength && this._charAtIsWhitespace(lineContent, word - 1);) {
          expandedToTheRight = !0, word++;
        }
        if (!expandedToTheRight) {
          for (; startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2);) {
            startColumn--;
          }
        }
        return createRangeWithPosition(startColumn, word);
      }, prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);
      return prevWordOnLine && prevWordOnLine.start + 1 <= position.column && position.column <= prevWordOnLine.end + 1 ? deleteWordAndAdjacentWhitespace(prevWordOnLine) : (wordSeparators = WordOperations._findNextWordOnLine(wordSeparators, model, position)) && wordSeparators.start + 1 <= position.column && position.column <= wordSeparators.end + 1 ? deleteWordAndAdjacentWhitespace(wordSeparators) : prevWordOnLine && wordSeparators ? createRangeWithPosition(prevWordOnLine.end + 1, wordSeparators.start + 
      1) : prevWordOnLine ? createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1) : wordSeparators ? createRangeWithPosition(wordSeparators.start + 1, wordSeparators.end + 1) : createRangeWithPosition(1, lineLength + 1);
    }
    static _deleteWordPartLeft(model, selection) {
      if (!selection.isEmpty()) {
        return selection;
      }
      selection = selection.getPosition();
      model = WordOperations._moveWordPartLeft(model, selection);
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection.lineNumber, selection.column, model.lineNumber, model.column);
    }
    static _findFirstNonWhitespaceChar(str, startIndex) {
      const len = str.length;
      for (; startIndex < len; startIndex++) {
        const ch = str.charAt(startIndex);
        if (ch !== " " && ch !== "\t") {
          return startIndex;
        }
      }
      return len;
    }
    static _deleteWordRightWhitespace(model, position) {
      var lineContent = model.getLineContent(position.lineNumber);
      model = position.column - 1;
      lineContent = this._findFirstNonWhitespaceChar(lineContent, model);
      return model + 1 < lineContent ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, position.column, position.lineNumber, lineContent + 1) : null;
    }
    static deleteWordRight(ctx, wordNavigationType) {
      const wordSeparators = ctx.wordSeparators, model = ctx.model;
      var selection = ctx.selection, whitespaceHeuristics = ctx.whitespaceHeuristics;
      if (!selection.isEmpty()) {
        return selection;
      }
      selection = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(selection.positionLineNumber, selection.positionColumn);
      ctx = selection.lineNumber;
      let column = selection.column;
      const lineCount = model.getLineCount(), maxColumn = model.getLineMaxColumn(ctx);
      if (ctx === lineCount && column === maxColumn) {
        return null;
      }
      if (whitespaceHeuristics && (whitespaceHeuristics = this._deleteWordRightWhitespace(model, selection))) {
        return whitespaceHeuristics;
      }
      whitespaceHeuristics = WordOperations._findNextWordOnLine(wordSeparators, model, selection);
      wordNavigationType === 2 ? whitespaceHeuristics ? column = whitespaceHeuristics.end + 1 : column < maxColumn || ctx === lineCount ? column = maxColumn : (ctx++, column = (whitespaceHeuristics = WordOperations._findNextWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(ctx, 1))) ? whitespaceHeuristics.start + 1 : model.getLineMaxColumn(ctx)) : (whitespaceHeuristics && column >= whitespaceHeuristics.start + 1 && (whitespaceHeuristics = WordOperations._findNextWordOnLine(wordSeparators, 
      model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(ctx, whitespaceHeuristics.end + 1))), whitespaceHeuristics ? column = whitespaceHeuristics.start + 1 : column < maxColumn || ctx === lineCount ? column = maxColumn : (ctx++, column = (whitespaceHeuristics = WordOperations._findNextWordOnLine(wordSeparators, model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(ctx, 1))) ? whitespaceHeuristics.start + 1 : model.getLineMaxColumn(ctx)));
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(ctx, column, selection.lineNumber, selection.column);
    }
    static _deleteWordPartRight(model, selection) {
      if (!selection.isEmpty()) {
        return selection;
      }
      selection = selection.getPosition();
      model = WordOperations._moveWordPartRight(model, selection);
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection.lineNumber, selection.column, model.lineNumber, model.column);
    }
    static _createWordAtPosition(model, lineNumber, word) {
      lineNumber = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, word.start + 1, lineNumber, word.end + 1);
      return {word:model.getValueInRange(lineNumber), startColumn:lineNumber.startColumn, endColumn:lineNumber.endColumn};
    }
    static getWordAtPosition(model, _wordSeparators, position) {
      _wordSeparators = (0,require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js.getMapForWordSeparators)(_wordSeparators);
      const prevWord = WordOperations._findPreviousWordOnLine(_wordSeparators, model, position);
      return prevWord && prevWord.wordType === 1 && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end ? WordOperations._createWordAtPosition(model, position.lineNumber, prevWord) : (_wordSeparators = WordOperations._findNextWordOnLine(_wordSeparators, model, position)) && _wordSeparators.wordType === 1 && _wordSeparators.start <= position.column - 1 && position.column - 1 <= _wordSeparators.end ? WordOperations._createWordAtPosition(model, position.lineNumber, _wordSeparators) : 
      null;
    }
    static word(config, model, cursor, inSelectionMode, position) {
      var wordSeparators = (0,require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js.getMapForWordSeparators)(config.wordSeparators);
      config = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);
      wordSeparators = WordOperations._findNextWordOnLine(wordSeparators, model, position);
      if (!inSelectionMode) {
        return config && config.wordType === 1 && config.start <= position.column - 1 && position.column - 1 <= config.end ? (cursor = config.start + 1, model = config.end + 1) : wordSeparators && wordSeparators.wordType === 1 && wordSeparators.start <= position.column - 1 && position.column - 1 <= wordSeparators.end ? (cursor = wordSeparators.start + 1, model = wordSeparators.end + 1) : (cursor = config ? config.end + 1 : 1, model = wordSeparators ? wordSeparators.start + 1 : model.getLineMaxColumn(position.lineNumber)), 
        new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, cursor, position.lineNumber, model), 1, 0, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(position.lineNumber, model), 0);
      }
      config && config.wordType === 1 && config.start < position.column - 1 && position.column - 1 < config.end ? (inSelectionMode = config.start + 1, config = config.end + 1) : wordSeparators && wordSeparators.wordType === 1 && wordSeparators.start < position.column - 1 && position.column - 1 < wordSeparators.end ? (inSelectionMode = wordSeparators.start + 1, config = wordSeparators.end + 1) : config = inSelectionMode = position.column;
      model = position.lineNumber;
      cursor.selectionStart.containsPosition(position) ? position = cursor.selectionStart.endColumn : position.isBeforeOrEqual(cursor.selectionStart.getStartPosition()) ? (position = inSelectionMode, config = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(model, position), cursor.selectionStart.containsPosition(config) && (position = cursor.selectionStart.endColumn)) : (position = config, config = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(model, position), 
      cursor.selectionStart.containsPosition(config) && (position = cursor.selectionStart.startColumn));
      return cursor.move(!0, model, position, 0);
    }
  }
  class WordPartOperations extends WordOperations {
    static deleteWordPartLeft(ctx) {
      ctx = enforceDefined([WordOperations.deleteWordLeft(ctx, 0), WordOperations.deleteWordLeft(ctx, 2), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);
      ctx.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingEnds);
      return ctx[2];
    }
    static deleteWordPartRight(ctx) {
      ctx = enforceDefined([WordOperations.deleteWordRight(ctx, 0), WordOperations.deleteWordRight(ctx, 2), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);
      ctx.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
      return ctx[0];
    }
    static moveWordPartLeft(wordSeparators, model, position) {
      wordSeparators = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0), WordOperations.moveWordLeft(wordSeparators, model, position, 2), WordOperations._moveWordPartLeft(model, position)]);
      wordSeparators.sort(require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position.compare);
      return wordSeparators[2];
    }
    static moveWordPartRight(wordSeparators, model, position) {
      wordSeparators = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0), WordOperations.moveWordRight(wordSeparators, model, position, 2), WordOperations._moveWordPartRight(model, position)]);
      wordSeparators.sort(require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position.compare);
      return wordSeparators[0];
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorWordOperations.js.map
