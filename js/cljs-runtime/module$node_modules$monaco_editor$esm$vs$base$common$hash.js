shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$hash = function(require, module, exports) {
  function hash(obj) {
    return doHash(obj, 0);
  }
  function doHash(obj, hashVal) {
    switch(typeof obj) {
      case "object":
        return obj === null ? numberHash(349, hashVal) : Array.isArray(obj) ? arrayHash(obj, hashVal) : objectHash(obj, hashVal);
      case "string":
        return stringHash(obj, hashVal);
      case "boolean":
        return numberHash(obj ? 433 : 863, hashVal);
      case "number":
        return numberHash(obj, hashVal);
      case "undefined":
        return numberHash(937, hashVal);
      default:
        return numberHash(617, hashVal);
    }
  }
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function arrayHash(arr, initialHashVal) {
    initialHashVal = numberHash(104579, initialHashVal);
    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
  }
  function objectHash(obj, initialHashVal) {
    initialHashVal = numberHash(181387, initialHashVal);
    return Object.keys(obj).sort().reduce((hashVal, key) => {
      hashVal = stringHash(key, hashVal);
      return doHash(obj[key], hashVal);
    }, initialHashVal);
  }
  function leftRotate(value, bits, totalBits = 32) {
    totalBits -= bits;
    return (value << bits | (~((1 << totalBits) - 1) & value) >>> totalBits) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    for (; value.length < length;) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    return bufferOrValue instanceof ArrayBuffer ? Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, "0")).join("") : leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, StringSHA1:{enumerable:!0, get:function() {
    return StringSHA1;
  }}, doHash:{enumerable:!0, get:function() {
    return doHash;
  }}, hash:{enumerable:!0, get:function() {
    return hash;
  }}, numberHash:{enumerable:!0, get:function() {
    return numberHash;
  }}, stringHash:{enumerable:!0, get:function() {
    return stringHash;
  }}, toHexString:{enumerable:!0, get:function() {
    return toHexString;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  class StringSHA1 {
    constructor() {
      this._h0 = 1732584193;
      this._h1 = 4023233417;
      this._h2 = 2562383102;
      this._h3 = 271733878;
      this._h4 = 3285377520;
      this._buff = new Uint8Array(67);
      this._buffDV = new DataView(this._buff.buffer);
      this._leftoverHighSurrogate = this._totalLen = this._buffLen = 0;
      this._finished = !1;
    }
    update(str) {
      const strLen = str.length;
      if (strLen !== 0) {
        var buff = this._buff, buffLen = this._buffLen, leftoverHighSurrogate = this._leftoverHighSurrogate;
        if (leftoverHighSurrogate !== 0) {
          var charCode = leftoverHighSurrogate;
          var offset = -1;
          leftoverHighSurrogate = 0;
        } else {
          charCode = str.charCodeAt(0), offset = 0;
        }
        for (;;) {
          var codePoint = charCode;
          if (strings.isHighSurrogate(charCode)) {
            if (offset + 1 < strLen) {
              codePoint = str.charCodeAt(offset + 1), strings.isLowSurrogate(codePoint) ? (offset++, codePoint = strings.computeCodePoint(charCode, codePoint)) : codePoint = 65533;
            } else {
              leftoverHighSurrogate = charCode;
              break;
            }
          } else {
            strings.isLowSurrogate(charCode) && (codePoint = 65533);
          }
          buffLen = this._push(buff, buffLen, codePoint);
          offset++;
          if (offset < strLen) {
            charCode = str.charCodeAt(offset);
          } else {
            break;
          }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
      }
    }
    _push(buff, buffLen, codePoint) {
      codePoint < 128 ? buff[buffLen++] = codePoint : (codePoint < 2048 ? buff[buffLen++] = 192 | (codePoint & 1984) >>> 6 : (codePoint < 65536 ? buff[buffLen++] = 224 | (codePoint & 61440) >>> 12 : (buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18, buff[buffLen++] = 128 | (codePoint & 258048) >>> 12), buff[buffLen++] = 128 | (codePoint & 4032) >>> 6), buff[buffLen++] = 128 | (codePoint & 63) >>> 0);
      buffLen >= 64 && (this._step(), buffLen -= 64, this._totalLen += 64, buff[0] = buff[64], buff[1] = buff[65], buff[2] = buff[66]);
      return buffLen;
    }
    digest() {
      this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(this._buff, this._buffLen, 65533)), this._totalLen += this._buffLen, this._wrapUp());
      return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128;
      fill(this._buff, this._buffLen);
      this._buffLen > 56 && (this._step(), fill(this._buff));
      const ml = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(ml / 4294967296), !1);
      this._buffDV.setUint32(60, ml % 4294967296, !1);
      this._step();
    }
    _step() {
      const bigBlock32 = StringSHA1._bigBlock32;
      var data = this._buffDV;
      for (var j$jscomp$0 = 0; j$jscomp$0 < 64; j$jscomp$0 += 4) {
        bigBlock32.setUint32(j$jscomp$0, data.getUint32(j$jscomp$0, !1), !1);
      }
      for (data = 64; data < 320; data += 4) {
        bigBlock32.setUint32(data, leftRotate(bigBlock32.getUint32(data - 12, !1) ^ bigBlock32.getUint32(data - 32, !1) ^ bigBlock32.getUint32(data - 56, !1) ^ bigBlock32.getUint32(data - 64, !1), 1), !1);
      }
      data = this._h0;
      j$jscomp$0 = this._h1;
      let c = this._h2, d = this._h3, e = this._h4;
      let k;
      for (let j = 0; j < 80; j++) {
        if (j < 20) {
          var f = j$jscomp$0 & c | ~j$jscomp$0 & d;
          k = 1518500249;
        } else {
          j < 40 ? (f = j$jscomp$0 ^ c ^ d, k = 1859775393) : j < 60 ? (f = j$jscomp$0 & c | j$jscomp$0 & d | c & d, k = 2400959708) : (f = j$jscomp$0 ^ c ^ d, k = 3395469782);
        }
        f = leftRotate(data, 5) + f + e + k + bigBlock32.getUint32(j * 4, !1) & 4294967295;
        e = d;
        d = c;
        c = leftRotate(j$jscomp$0, 30);
        j$jscomp$0 = data;
        data = f;
      }
      this._h0 = this._h0 + data & 4294967295;
      this._h1 = this._h1 + j$jscomp$0 & 4294967295;
      this._h2 = this._h2 + c & 4294967295;
      this._h3 = this._h3 + d & 4294967295;
      this._h4 = this._h4 + e & 4294967295;
    }
  }
  StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$hash.js.map
