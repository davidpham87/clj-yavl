shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorMoveCommands = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CursorMove:{enumerable:!0, get:function() {
    return CursorMove;
  }}, CursorMoveCommands:{enumerable:!0, get:function() {
    return CursorMoveCommands;
  }}});
  var types = require("module$node_modules$monaco_editor$esm$vs$base$common$types"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), require$_DOT__SLASH_cursorMoveOperations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorMoveOperations"), require$_DOT__SLASH_cursorWordOperations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorWordOperations"), 
  require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class CursorMoveCommands {
    static addCursorDown(viewModel, cursors, useLogicalLine) {
      const result = [];
      let resultLen = 0;
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i];
        result[resultLen++] = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState(cursor.modelState, cursor.viewState);
        useLogicalLine ? result[resultLen++] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState)) : result[resultLen++] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));
      }
      return result;
    }
    static addCursorUp(viewModel, cursors, useLogicalLine) {
      const result = [];
      let resultLen = 0;
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i];
        result[resultLen++] = new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState(cursor.modelState, cursor.viewState);
        useLogicalLine ? result[resultLen++] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState)) : result[resultLen++] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));
      }
      return result;
    }
    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = this._moveToLineStart(viewModel, cursors[i], inSelectionMode);
      }
      return result;
    }
    static _moveToLineStart(viewModel, cursor, inSelectionMode) {
      const currentViewStateColumn = cursor.viewState.position.column, isFirstLineOfWrappedLine = currentViewStateColumn === cursor.modelState.position.column, firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(cursor.viewState.position.lineNumber);
      return isFirstLineOfWrappedLine || currentViewStateColumn === firstNonBlankColumn ? this._moveToLineStartByModel(viewModel, cursor, inSelectionMode) : this._moveToLineStartByView(viewModel, cursor, inSelectionMode);
    }
    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));
    }
    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));
    }
    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = this._moveToLineEnd(viewModel, cursors[i], inSelectionMode, sticky);
      }
      return result;
    }
    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {
      var viewStatePosition = cursor.viewState.position;
      const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber), isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn, modelStatePosition = cursor.modelState.position, modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);
      viewStatePosition = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;
      return isEndOfViewLine || viewStatePosition ? this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) : this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);
    }
    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));
    }
    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));
    }
    static expandLineSelection(viewModel, cursors) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        var cursor = cursors[i];
        const startLineNumber = cursor.modelState.selection.startLineNumber;
        var lineCount = viewModel.model.getLineCount();
        cursor = cursor.modelState.selection.endLineNumber;
        cursor === lineCount ? lineCount = viewModel.model.getLineMaxColumn(lineCount) : (cursor++, lineCount = 1);
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, 1, startLineNumber, 1), 0, 0, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(cursor, lineCount), 0));
      }
      return result;
    }
    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursors[i].modelState, inSelectionMode));
      }
      return result;
    }
    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursors[i].modelState, inSelectionMode));
      }
      return result;
    }
    static selectAll(viewModel, cursor) {
      cursor = viewModel.model.getLineCount();
      viewModel = viewModel.model.getLineMaxColumn(cursor);
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, 1, 1), 0, 0, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(cursor, viewModel), 0));
    }
    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {
      _position = viewModel.model.validatePosition(_position);
      _viewPosition = _viewPosition ? viewModel.coordinatesConverter.validateViewPosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_viewPosition.lineNumber, _viewPosition.column), _position) : viewModel.coordinatesConverter.convertModelPositionToViewPosition(_position);
      if (!inSelectionMode) {
        return cursor = viewModel.model.getLineCount(), inSelectionMode = _position.lineNumber + 1, _viewPosition = 1, inSelectionMode > cursor && (inSelectionMode = cursor, _viewPosition = viewModel.model.getLineMaxColumn(inSelectionMode)), require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_position.lineNumber, 1, inSelectionMode, _viewPosition), 2, 
        0, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(inSelectionMode, _viewPosition), 0));
      }
      inSelectionMode = cursor.modelState.selectionStart.getStartPosition().lineNumber;
      if (_position.lineNumber < inSelectionMode) {
        return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(cursor.viewState.move(!0, _viewPosition.lineNumber, 1, 0));
      }
      if (_position.lineNumber > inSelectionMode) {
        return _position = viewModel.getLineCount(), inSelectionMode = _viewPosition.lineNumber + 1, _viewPosition = 1, inSelectionMode > _position && (inSelectionMode = _position, _viewPosition = viewModel.getLineMaxColumn(inSelectionMode)), require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(cursor.viewState.move(!0, inSelectionMode, _viewPosition, 0));
      }
      viewModel = cursor.modelState.selectionStart.getEndPosition();
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(cursor.modelState.move(!0, viewModel.lineNumber, viewModel.column, 0));
    }
    static word(viewModel, cursor, inSelectionMode, _position) {
      _position = viewModel.model.validatePosition(_position);
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorWordOperations_DOT_js.WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, _position));
    }
    static cancelSelection(viewModel, cursor) {
      if (!cursor.modelState.hasSelection()) {
        return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState(cursor.modelState, cursor.viewState);
      }
      viewModel = cursor.viewState.position.lineNumber;
      cursor = cursor.viewState.position.column;
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.SingleCursorState(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(viewModel, cursor, viewModel, cursor), 0, 0, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(viewModel, cursor), 0));
    }
    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {
      if (inSelectionMode) {
        if (cursor.modelState.selectionStartKind === 1) {
          return this.word(viewModel, cursor, inSelectionMode, _position);
        }
        if (cursor.modelState.selectionStartKind === 2) {
          return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);
        }
      }
      _position = viewModel.model.validatePosition(_position);
      viewModel = _viewPosition ? viewModel.coordinatesConverter.validateViewPosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_viewPosition.lineNumber, _viewPosition.column), _position) : viewModel.coordinatesConverter.convertModelPositionToViewPosition(_position);
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewModel.lineNumber, viewModel.column, 0));
    }
    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {
      switch(direction) {
        case 0:
          return unit === 4 ? this._moveHalfLineLeft(viewModel, cursors, inSelectionMode) : this._moveLeft(viewModel, cursors, inSelectionMode, value);
        case 1:
          return unit === 4 ? this._moveHalfLineRight(viewModel, cursors, inSelectionMode) : this._moveRight(viewModel, cursors, inSelectionMode, value);
        case 2:
          return unit === 2 ? this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value) : this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);
        case 3:
          return unit === 2 ? this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value) : this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);
        case 4:
          return unit === 2 ? cursors.map(cursor => require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode))) : cursors.map(cursor => require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, 
          inSelectionMode)));
        case 5:
          return unit === 2 ? cursors.map(cursor => require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode))) : cursors.map(cursor => require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, 
          inSelectionMode)));
        case 6:
          return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);
        case 7:
          return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);
        case 8:
          return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);
        case 9:
          return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);
        case 10:
          return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);
        default:
          return null;
      }
    }
    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {
      var visibleViewRange = viewModel.getCompletelyVisibleViewRange();
      const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);
      switch(direction) {
        case 11:
          return visibleViewRange = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value), direction = viewModel.model.getLineFirstNonWhitespaceColumn(visibleViewRange), [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, visibleViewRange, direction)];
        case 13:
          return visibleViewRange = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value), direction = viewModel.model.getLineFirstNonWhitespaceColumn(visibleViewRange), [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, visibleViewRange, direction)];
        case 12:
          return visibleViewRange = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2), direction = viewModel.model.getLineFirstNonWhitespaceColumn(visibleViewRange), [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, visibleViewRange, direction)];
        case 14:
          direction = [];
          for (let i = 0, len = cursors.length; i < len; i++) {
            direction[i] = this.findPositionInViewportIfOutside(viewModel, cursors[i], visibleViewRange, inSelectionMode);
          }
          return direction;
        default:
          return null;
      }
    }
    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {
      const viewLineNumber = cursor.viewState.position.lineNumber;
      if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {
        return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState(cursor.modelState, cursor.viewState);
      }
      viewModel = require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, viewLineNumber > visibleViewRange.endLineNumber - 1 ? visibleViewRange.endLineNumber - 1 : viewLineNumber < visibleViewRange.startLineNumber ? visibleViewRange.startLineNumber : viewLineNumber, !1);
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewModel.lineNumber, viewModel.column, viewModel.leftoverVisibleColumns));
    }
    static _firstLineNumberInRange(model, range, count) {
      let startLineNumber = range.startLineNumber;
      range.startColumn !== model.getLineMinColumn(startLineNumber) && startLineNumber++;
      return Math.min(range.endLineNumber, startLineNumber + count - 1);
    }
    static _lastLineNumberInRange(model, range, count) {
      let startLineNumber = range.startLineNumber;
      range.startColumn !== model.getLineMinColumn(startLineNumber) && startLineNumber++;
      return Math.max(startLineNumber, range.endLineNumber - count + 1);
    }
    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {
      return cursors.map(cursor => require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));
    }
    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], halfLine = Math.round(viewModel.getLineLength(cursor.viewState.position.lineNumber) / 2);
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));
      }
      return result;
    }
    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {
      return cursors.map(cursor => require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));
    }
    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], halfLine = Math.round(viewModel.getLineLength(cursor.viewState.position.lineNumber) / 2);
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));
      }
      return result;
    }
    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursors[i].viewState, inSelectionMode, linesCount));
      }
      return result;
    }
    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursors[i].modelState, inSelectionMode, linesCount));
      }
      return result;
    }
    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursors[i].viewState, inSelectionMode, linesCount));
      }
      return result;
    }
    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        result[i] = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursors[i].modelState, inSelectionMode, linesCount));
      }
      return result;
    }
    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));
    }
    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {
      return require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));
    }
    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], viewLineNumber = cursor.viewState.position.lineNumber, viewColumn = viewModel.getLineMinColumn(viewLineNumber);
        result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
      }
      return result;
    }
    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], viewLineNumber = cursor.viewState.position.lineNumber, viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
        result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
      }
      return result;
    }
    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], viewLineNumber = cursor.viewState.position.lineNumber, viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);
        result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
      }
      return result;
    }
    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], viewLineNumber = cursor.viewState.position.lineNumber, viewColumn = viewModel.getLineMaxColumn(viewLineNumber);
        result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
      }
      return result;
    }
    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {
      const result = [];
      for (let i = 0, len = cursors.length; i < len; i++) {
        const cursor = cursors[i], viewLineNumber = cursor.viewState.position.lineNumber, viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);
        result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);
      }
      return result;
    }
  }
  var CursorMove;
  (function(CursorMove) {
    CursorMove.metadata = {description:"Move cursor to a logical position in the view", args:[{name:"Cursor move argument object", description:"Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t", 
    constraint:function(arg) {
      return types.isObject(arg) && types.isString(arg.to) && (types.isUndefined(arg.select) || types.isBoolean(arg.select)) && (types.isUndefined(arg.by) || types.isString(arg.by)) && (types.isUndefined(arg.value) || types.isNumber(arg.value)) ? !0 : !1;
    }, schema:{type:"object", required:["to"], properties:{to:{type:"string", "enum":"left right up down prevBlankLine nextBlankLine wrappedLineStart wrappedLineEnd wrappedLineColumnCenter wrappedLineFirstNonWhitespaceCharacter wrappedLineLastNonWhitespaceCharacter viewPortTop viewPortCenter viewPortBottom viewPortIfOutside".split(" ")}, by:{type:"string", "enum":["line", "wrappedLine", "character", "halfLine"]}, value:{type:"number", "default":1}, select:{type:"boolean", "default":!1}}}}]};
    CursorMove.RawDirection = {Left:"left", Right:"right", Up:"up", Down:"down", PrevBlankLine:"prevBlankLine", NextBlankLine:"nextBlankLine", WrappedLineStart:"wrappedLineStart", WrappedLineFirstNonWhitespaceCharacter:"wrappedLineFirstNonWhitespaceCharacter", WrappedLineColumnCenter:"wrappedLineColumnCenter", WrappedLineEnd:"wrappedLineEnd", WrappedLineLastNonWhitespaceCharacter:"wrappedLineLastNonWhitespaceCharacter", ViewPortTop:"viewPortTop", ViewPortCenter:"viewPortCenter", ViewPortBottom:"viewPortBottom", 
    ViewPortIfOutside:"viewPortIfOutside"};
    CursorMove.RawUnit = {Line:"line", WrappedLine:"wrappedLine", Character:"character", HalfLine:"halfLine"};
    CursorMove.parse = function(args) {
      if (!args.to) {
        return null;
      }
      let direction;
      switch(args.to) {
        case CursorMove.RawDirection.Left:
          direction = 0;
          break;
        case CursorMove.RawDirection.Right:
          direction = 1;
          break;
        case CursorMove.RawDirection.Up:
          direction = 2;
          break;
        case CursorMove.RawDirection.Down:
          direction = 3;
          break;
        case CursorMove.RawDirection.PrevBlankLine:
          direction = 4;
          break;
        case CursorMove.RawDirection.NextBlankLine:
          direction = 5;
          break;
        case CursorMove.RawDirection.WrappedLineStart:
          direction = 6;
          break;
        case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
          direction = 7;
          break;
        case CursorMove.RawDirection.WrappedLineColumnCenter:
          direction = 8;
          break;
        case CursorMove.RawDirection.WrappedLineEnd:
          direction = 9;
          break;
        case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:
          direction = 10;
          break;
        case CursorMove.RawDirection.ViewPortTop:
          direction = 11;
          break;
        case CursorMove.RawDirection.ViewPortBottom:
          direction = 13;
          break;
        case CursorMove.RawDirection.ViewPortCenter:
          direction = 12;
          break;
        case CursorMove.RawDirection.ViewPortIfOutside:
          direction = 14;
          break;
        default:
          return null;
      }
      let unit = 0;
      switch(args.by) {
        case CursorMove.RawUnit.Line:
          unit = 1;
          break;
        case CursorMove.RawUnit.WrappedLine:
          unit = 2;
          break;
        case CursorMove.RawUnit.Character:
          unit = 3;
          break;
        case CursorMove.RawUnit.HalfLine:
          unit = 4;
      }
      return {direction, unit, select:!!args.select, value:args.value || 1};
    };
  })(CursorMove ||= {});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorMoveCommands.js.map
