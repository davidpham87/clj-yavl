shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, InternalModelContentChangeEvent:{enumerable:!0, get:function() {
    return InternalModelContentChangeEvent;
  }}, LineInjectedText:{enumerable:!0, get:function() {
    return LineInjectedText;
  }}, ModelInjectedTextChangedEvent:{enumerable:!0, get:function() {
    return ModelInjectedTextChangedEvent;
  }}, ModelRawContentChangedEvent:{enumerable:!0, get:function() {
    return ModelRawContentChangedEvent;
  }}, ModelRawEOLChanged:{enumerable:!0, get:function() {
    return ModelRawEOLChanged;
  }}, ModelRawFlush:{enumerable:!0, get:function() {
    return ModelRawFlush;
  }}, ModelRawLineChanged:{enumerable:!0, get:function() {
    return ModelRawLineChanged;
  }}, ModelRawLinesDeleted:{enumerable:!0, get:function() {
    return ModelRawLinesDeleted;
  }}, ModelRawLinesInserted:{enumerable:!0, get:function() {
    return ModelRawLinesInserted;
  }}});
  class ModelRawFlush {
    constructor() {
      this.changeType = 1;
    }
  }
  class LineInjectedText {
    static applyInjectedText(lineText, injectedTexts) {
      if (!injectedTexts || injectedTexts.length === 0) {
        return lineText;
      }
      let result = "", lastOriginalOffset = 0;
      for (const injectedText of injectedTexts) {
        result += lineText.substring(lastOriginalOffset, injectedText.column - 1), lastOriginalOffset = injectedText.column - 1, result += injectedText.options.content;
      }
      return result += lineText.substring(lastOriginalOffset);
    }
    static fromDecorations(decorations) {
      const result = [];
      for (const decoration of decorations) {
        decoration.options.before && decoration.options.before.content.length > 0 && result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0)), decoration.options.after && decoration.options.after.content.length > 0 && result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));
      }
      result.sort((a, b) => a.lineNumber === b.lineNumber ? a.column === b.column ? a.order - b.order : a.column - b.column : a.lineNumber - b.lineNumber);
      return result;
    }
    constructor(ownerId, lineNumber, column, options, order) {
      this.ownerId = ownerId;
      this.lineNumber = lineNumber;
      this.column = column;
      this.options = options;
      this.order = order;
    }
  }
  class ModelRawLineChanged {
    constructor(lineNumber, detail, injectedText) {
      this.changeType = 2;
      this.lineNumber = lineNumber;
      this.detail = detail;
      this.injectedText = injectedText;
    }
  }
  class ModelRawLinesDeleted {
    constructor(fromLineNumber, toLineNumber) {
      this.changeType = 3;
      this.fromLineNumber = fromLineNumber;
      this.toLineNumber = toLineNumber;
    }
  }
  class ModelRawLinesInserted {
    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {
      this.changeType = 4;
      this.injectedTexts = injectedTexts;
      this.fromLineNumber = fromLineNumber;
      this.toLineNumber = toLineNumber;
      this.detail = detail;
    }
  }
  class ModelRawEOLChanged {
    constructor() {
      this.changeType = 5;
    }
  }
  class ModelRawContentChangedEvent {
    constructor(changes, versionId, isUndoing, isRedoing) {
      this.changes = changes;
      this.versionId = versionId;
      this.isUndoing = isUndoing;
      this.isRedoing = isRedoing;
      this.resultingSelection = null;
    }
    containsEvent(type) {
      for (let i = 0, len = this.changes.length; i < len; i++) {
        if (this.changes[i].changeType === type) {
          return !0;
        }
      }
      return !1;
    }
    static merge(a, b) {
      const changes = [].concat(a.changes).concat(b.changes);
      return new ModelRawContentChangedEvent(changes, b.versionId, a.isUndoing || b.isUndoing, a.isRedoing || b.isRedoing);
    }
  }
  class ModelInjectedTextChangedEvent {
    constructor(changes) {
      this.changes = changes;
    }
  }
  class InternalModelContentChangeEvent {
    constructor(rawContentChangedEvent, contentChangedEvent) {
      this.rawContentChangedEvent = rawContentChangedEvent;
      this.contentChangedEvent = contentChangedEvent;
    }
    merge(other) {
      const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
      other = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
      return new InternalModelContentChangeEvent(rawContentChangedEvent, other);
    }
    static _mergeChangeEvents(a, b) {
      return {changes:[].concat(a.changes).concat(b.changes), eol:b.eol, isEolChange:a.isEolChange && b.isEolChange, versionId:b.versionId, isUndoing:a.isUndoing || b.isUndoing, isRedoing:a.isRedoing || b.isRedoing, isFlush:a.isFlush || b.isFlush};
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents.js.map
