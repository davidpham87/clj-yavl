{
"version":3,
"file":"module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseMultilineTokens.js",
"lineCount":282,
"mappings":"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",
"sources":["node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseMultilineTokens\"] = function(require,module,exports) {\nObject.defineProperties(exports, {__esModule:{enumerable:true, value:true}, SparseLineTokens:{enumerable:true, get:function() {\n  return SparseLineTokens;\n}}, SparseMultilineTokens:{enumerable:true, get:function() {\n  return SparseMultilineTokens;\n}}});\nvar require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require(\"../core/position.js\");\nvar require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require(\"../core/range.js\");\nvar require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js = require(\"../core/eolCounter.js\");\nclass SparseMultilineTokens {\n  static create(startLineNumber, tokens) {\n    return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n  }\n  get startLineNumber() {\n    return this._startLineNumber;\n  }\n  get endLineNumber() {\n    return this._endLineNumber;\n  }\n  constructor(startLineNumber, tokens) {\n    this._startLineNumber = startLineNumber;\n    this._tokens = tokens;\n    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n  }\n  toString() {\n    return this._tokens.toString(this._startLineNumber);\n  }\n  _updateEndLineNumber() {\n    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n  }\n  isEmpty() {\n    return this._tokens.isEmpty();\n  }\n  getLineTokens(lineNumber) {\n    if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n      return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n    }\n    return null;\n  }\n  getRange() {\n    const deltaRange = this._tokens.getRange();\n    if (!deltaRange) {\n      return deltaRange;\n    }\n    return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n  }\n  removeTokens(range) {\n    const startLineIndex = range.startLineNumber - this._startLineNumber;\n    const endLineIndex = range.endLineNumber - this._startLineNumber;\n    this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n    this._updateEndLineNumber();\n  }\n  split(range) {\n    const startLineIndex = range.startLineNumber - this._startLineNumber;\n    const endLineIndex = range.endLineNumber - this._startLineNumber;\n    const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n    return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n  }\n  applyEdit(range, text) {\n    const [eolCount, firstLineLength, lastLineLength] = (0,require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(text);\n    this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0);\n  }\n  acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n    this._updateEndLineNumber();\n  }\n  _acceptDeleteRange(range) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      return;\n    }\n    const firstLineIndex = range.startLineNumber - this._startLineNumber;\n    const lastLineIndex = range.endLineNumber - this._startLineNumber;\n    if (lastLineIndex < 0) {\n      const deletedLinesCount = lastLineIndex - firstLineIndex;\n      this._startLineNumber -= deletedLinesCount;\n      return;\n    }\n    const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n    if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n      return;\n    }\n    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n      this._startLineNumber = 0;\n      this._tokens.clear();\n      return;\n    }\n    if (firstLineIndex < 0) {\n      const deletedBefore = -firstLineIndex;\n      this._startLineNumber -= deletedBefore;\n      this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n    } else {\n      this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n    }\n  }\n  _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      return;\n    }\n    const lineIndex = position.lineNumber - this._startLineNumber;\n    if (lineIndex < 0) {\n      this._startLineNumber += eolCount;\n      return;\n    }\n    const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n    if (lineIndex >= tokenMaxDeltaLine + 1) {\n      return;\n    }\n    this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n  }\n}\nclass SparseMultilineTokensStorage {\n  constructor(tokens) {\n    this._tokens = tokens;\n    this._tokenCount = tokens.length / 4;\n  }\n  toString(startLineNumber) {\n    const pieces = [];\n    for (let i = 0; i < this._tokenCount; i++) {\n      pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n    }\n    return `[${pieces.join(\",\")}]`;\n  }\n  getMaxDeltaLine() {\n    const tokenCount = this._getTokenCount();\n    if (tokenCount === 0) {\n      return -1;\n    }\n    return this._getDeltaLine(tokenCount - 1);\n  }\n  getRange() {\n    const tokenCount = this._getTokenCount();\n    if (tokenCount === 0) {\n      return null;\n    }\n    const startChar = this._getStartCharacter(0);\n    const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n    const endChar = this._getEndCharacter(tokenCount - 1);\n    return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n  }\n  _getTokenCount() {\n    return this._tokenCount;\n  }\n  _getDeltaLine(tokenIndex) {\n    return this._tokens[4 * tokenIndex];\n  }\n  _getStartCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  }\n  _getEndCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  }\n  isEmpty() {\n    return this._getTokenCount() === 0;\n  }\n  getLineTokens(deltaLine) {\n    let low = 0;\n    let high = this._getTokenCount() - 1;\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2);\n      const midDeltaLine = this._getDeltaLine(mid);\n      if (midDeltaLine < deltaLine) {\n        low = mid + 1;\n      } else if (midDeltaLine > deltaLine) {\n        high = mid - 1;\n      } else {\n        let min = mid;\n        while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n          min--;\n        }\n        let max = mid;\n        while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n          max++;\n        }\n        return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n      }\n    }\n    if (this._getDeltaLine(low) === deltaLine) {\n      return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n    }\n    return null;\n  }\n  clear() {\n    this._tokenCount = 0;\n  }\n  removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    let newTokenCount = 0;\n    let hasDeletedTokens = false;\n    let firstDeltaLine = 0;\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      const tokenDeltaLine = tokens[srcOffset];\n      const tokenStartCharacter = tokens[srcOffset + 1];\n      const tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n      if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {\n        hasDeletedTokens = true;\n      } else {\n        if (newTokenCount === 0) {\n          firstDeltaLine = tokenDeltaLine;\n        }\n        if (hasDeletedTokens) {\n          const destOffset = 4 * newTokenCount;\n          tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n          tokens[destOffset + 1] = tokenStartCharacter;\n          tokens[destOffset + 2] = tokenEndCharacter;\n          tokens[destOffset + 3] = tokenMetadata;\n        }\n        newTokenCount++;\n      }\n    }\n    this._tokenCount = newTokenCount;\n    return firstDeltaLine;\n  }\n  split(startDeltaLine, startChar, endDeltaLine, endChar) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    const aTokens = [];\n    const bTokens = [];\n    let destTokens = aTokens;\n    let destOffset = 0;\n    let destFirstDeltaLine = 0;\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      const tokenDeltaLine = tokens[srcOffset];\n      const tokenStartCharacter = tokens[srcOffset + 1];\n      const tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n      if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {\n        if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {\n          continue;\n        } else {\n          if (destTokens !== bTokens) {\n            destTokens = bTokens;\n            destOffset = 0;\n            destFirstDeltaLine = tokenDeltaLine;\n          }\n        }\n      }\n      destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n      destTokens[destOffset++] = tokenStartCharacter;\n      destTokens[destOffset++] = tokenEndCharacter;\n      destTokens[destOffset++] = tokenMetadata;\n    }\n    return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n  }\n  acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    const deletedLineCount = endDeltaLine - startDeltaLine;\n    let newTokenCount = 0;\n    let hasDeletedTokens = false;\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      let tokenDeltaLine = tokens[srcOffset];\n      let tokenStartCharacter = tokens[srcOffset + 1];\n      let tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {\n        newTokenCount++;\n        continue;\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          tokenEndCharacter = startCharacter;\n        }\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          tokenDeltaLine = startDeltaLine;\n          tokenStartCharacter = startCharacter;\n          tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n        } else {\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine > endDeltaLine) {\n        if (deletedLineCount === 0 && !hasDeletedTokens) {\n          newTokenCount = tokenCount;\n          break;\n        }\n        tokenDeltaLine -= deletedLineCount;\n      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n          tokenStartCharacter += horizontalShiftForFirstLineTokens;\n          tokenEndCharacter += horizontalShiftForFirstLineTokens;\n        }\n        tokenDeltaLine -= deletedLineCount;\n        tokenStartCharacter -= endCharacter - startCharacter;\n        tokenEndCharacter -= endCharacter - startCharacter;\n      } else {\n        throw new Error(`Not possible!`);\n      }\n      const destOffset = 4 * newTokenCount;\n      tokens[destOffset] = tokenDeltaLine;\n      tokens[destOffset + 1] = tokenStartCharacter;\n      tokens[destOffset + 2] = tokenEndCharacter;\n      tokens[destOffset + 3] = tokenMetadata;\n      newTokenCount++;\n    }\n    this._tokenCount = newTokenCount;\n  }\n  acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    const isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48 && firstCharCode <= 57 || firstCharCode >= 65 && firstCharCode <= 90 || firstCharCode >= 97 && firstCharCode <= 122);\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    for (let i = 0; i < tokenCount; i++) {\n      const offset = 4 * i;\n      let tokenDeltaLine = tokens[offset];\n      let tokenStartCharacter = tokens[offset + 1];\n      let tokenEndCharacter = tokens[offset + 2];\n      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {\n        continue;\n      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n        if (isInsertingPreciselyOneWordCharacter) {\n          tokenEndCharacter += 1;\n        } else {\n          continue;\n        }\n      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n        if (eolCount === 0) {\n          tokenEndCharacter += firstLineLength;\n        } else {\n          tokenEndCharacter = character;\n        }\n      } else {\n        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n          if (isInsertingPreciselyOneWordCharacter) {\n            continue;\n          }\n        }\n        if (tokenDeltaLine === deltaLine) {\n          tokenDeltaLine += eolCount;\n          if (eolCount === 0) {\n            tokenStartCharacter += firstLineLength;\n            tokenEndCharacter += firstLineLength;\n          } else {\n            const tokenLength = tokenEndCharacter - tokenStartCharacter;\n            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n            tokenEndCharacter = tokenStartCharacter + tokenLength;\n          }\n        } else {\n          tokenDeltaLine += eolCount;\n        }\n      }\n      tokens[offset] = tokenDeltaLine;\n      tokens[offset + 1] = tokenStartCharacter;\n      tokens[offset + 2] = tokenEndCharacter;\n    }\n  }\n}\nclass SparseLineTokens {\n  constructor(tokens) {\n    this._tokens = tokens;\n  }\n  getCount() {\n    return this._tokens.length / 4;\n  }\n  getStartCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  }\n  getEndCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  }\n  getMetadata(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 3];\n  }\n}\n\n};"],
"names":["shadow$provide","require","module","exports","Object","defineProperties","__esModule","enumerable","value","SparseLineTokens","get","SparseMultilineTokens","require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js","require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js","require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js","create","startLineNumber","tokens","SparseMultilineTokensStorage","_startLineNumber","_endLineNumber","constructor","_tokens","getMaxDeltaLine","toString","_updateEndLineNumber","isEmpty","getLineTokens","lineNumber","getRange","deltaRange","Range","startColumn","endLineNumber","endColumn","removeTokens","range","split","a","b","bDeltaLine","applyEdit","text","eolCount","firstLineLength","lastLineLength","countEOL","acceptEdit","length","charCodeAt","firstCharCode","_acceptDeleteRange","_acceptInsertText","Position","firstLineIndex","lastLineIndex","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","position","lineIndex","acceptInsertText","column","_tokenCount","pieces","i","push","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","tokenIndex","deltaLine","low","high","mid","Math","floor","midDeltaLine","min","max","subarray","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","Uint32Array","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","character","isInsertingPreciselyOneWordCharacter","offset","tokenLength","getCount","getStartCharacter","getEndCharacter","getMetadata"]
}
