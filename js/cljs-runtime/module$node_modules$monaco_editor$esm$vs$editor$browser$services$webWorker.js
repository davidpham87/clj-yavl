shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$services$webWorker = function(require, module, exports) {
  function createWebWorker(modelService, languageConfigurationService, opts) {
    return new MonacoWebWorkerImpl(modelService, languageConfigurationService, opts);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, createWebWorker:{enumerable:!0, get:function() {
    return createWebWorker;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_objects_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$objects");
  require = require("module$node_modules$monaco_editor$esm$vs$editor$browser$services$editorWorkerService");
  class MonacoWebWorkerImpl extends require.EditorWorkerClient {
    constructor(modelService, languageConfigurationService, opts) {
      super(modelService, opts.keepIdleModels || !1, opts.label, languageConfigurationService);
      this._foreignModuleId = opts.moduleId;
      this._foreignModuleCreateData = opts.createData || null;
      this._foreignModuleHost = opts.host || null;
      this._foreignProxy = null;
    }
    fhr(method, args) {
      if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== "function") {
        return Promise.reject(Error("Missing method " + method + " or missing main thread foreign host."));
      }
      try {
        return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _getForeignProxy() {
      this._foreignProxy || (this._foreignProxy = this._getProxy().then(proxy => {
        const foreignHostMethods = this._foreignModuleHost ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_objects_DOT_js.getAllMethodNames)(this._foreignModuleHost) : [];
        return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then(foreignMethods => {
          this._foreignModuleCreateData = null;
          const proxyMethodRequest = (method, args) => proxy.fmr(method, args), createProxyMethod = (method, proxyMethodRequest) => function() {
            const args = Array.prototype.slice.call(arguments, 0);
            return proxyMethodRequest(method, args);
          }, foreignProxy = {};
          for (const foreignMethod of foreignMethods) {
            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);
          }
          return foreignProxy;
        });
      }));
      return this._foreignProxy;
    }
    getProxy() {
      return this._getForeignProxy();
    }
    withSyncedResources(resources) {
      return this._withSyncedResources(resources).then(_ => this.getProxy());
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$services$webWorker.js.map
