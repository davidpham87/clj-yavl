shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursor = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CursorsController:{enumerable:!0, get:function() {
    return CursorsController;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__SLASH_cursorCollection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorCollection"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), 
  require$_DOT__SLASH_cursorContext_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorContext"), require$_DOT__SLASH_cursorDeleteOperations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorDeleteOperations"), require$_DOT__SLASH_cursorTypeOperations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorTypeOperations"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), 
  require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH_textModelEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents"), require$_DOT__DOT__SLASH_viewEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewEvents"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), 
  require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModelEventDispatcher");
  class CursorsController extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(model, viewModel, coordinatesConverter, cursorConfig) {
      super();
      this._model = model;
      this._knownModelVersionId = this._model.getVersionId();
      this._viewModel = viewModel;
      this._coordinatesConverter = coordinatesConverter;
      this.context = new require$_DOT__SLASH_cursorContext_DOT_js.CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);
      this._cursors = new require$_DOT__SLASH_cursorCollection_DOT_js.CursorCollection(this.context);
      this._isHandling = this._hasFocus = !1;
      this._columnSelectData = this._compositionState = null;
      this._autoClosedActions = [];
      this._prevEditOperationType = 0;
    }
    dispose() {
      this._cursors.dispose();
      this._autoClosedActions = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this._autoClosedActions);
      super.dispose();
    }
    updateConfiguration(cursorConfig) {
      this.context = new require$_DOT__SLASH_cursorContext_DOT_js.CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);
      this._cursors.updateContext(this.context);
    }
    onLineMappingChanged(eventsCollector) {
      this._knownModelVersionId === this._model.getVersionId() && this.setStates(eventsCollector, "viewModel", 0, this.getCursorStates());
    }
    setHasFocus(hasFocus) {
      this._hasFocus = hasFocus;
    }
    _validateAutoClosedActions() {
      if (this._autoClosedActions.length > 0) {
        const selections = this._cursors.getSelections();
        for (let i = 0; i < this._autoClosedActions.length; i++) {
          const autoClosedAction = this._autoClosedActions[i];
          autoClosedAction.isValid(selections) || (autoClosedAction.dispose(), this._autoClosedActions.splice(i, 1), i--);
        }
      }
    }
    getPrimaryCursorState() {
      return this._cursors.getPrimaryCursor();
    }
    getLastAddedCursorIndex() {
      return this._cursors.getLastAddedCursorIndex();
    }
    getCursorStates() {
      return this._cursors.getAll();
    }
    setStates(eventsCollector, source, reason, states) {
      let reachedMaxCursorCount = !1;
      var multiCursorLimit = this.context.cursorConfig.multiCursorLimit;
      states !== null && states.length > multiCursorLimit && (states = states.slice(0, multiCursorLimit), reachedMaxCursorCount = !0);
      multiCursorLimit = CursorModelState.from(this._model, this);
      this._cursors.setStates(states);
      this._cursors.normalize();
      this._columnSelectData = null;
      this._validateAutoClosedActions();
      return this._emitStateChangedIfNecessary(eventsCollector, source, reason, multiCursorLimit, reachedMaxCursorCount);
    }
    setCursorColumnSelectData(columnSelectData) {
      this._columnSelectData = columnSelectData;
    }
    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {
      const viewPositions = this._cursors.getViewPositions();
      let revealViewRange = null, revealViewSelections = null;
      viewPositions.length > 1 ? revealViewSelections = this._cursors.getViewSelections() : revealViewRange = require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(viewPositions[0], viewPositions[0]);
      eventsCollector.emitViewEvent(new require$_DOT__DOT__SLASH_viewEvents_DOT_js.ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));
    }
    saveState() {
      const result = [], selections = this._cursors.getSelections();
      for (let i = 0, len = selections.length; i < len; i++) {
        const selection = selections[i];
        result.push({inSelectionMode:!selection.isEmpty(), selectionStart:{lineNumber:selection.selectionStartLineNumber, column:selection.selectionStartColumn}, position:{lineNumber:selection.positionLineNumber, column:selection.positionColumn}});
      }
      return result;
    }
    restoreState(eventsCollector, states) {
      const desiredSelections = [];
      for (let i = 0, len = states.length; i < len; i++) {
        const state = states[i];
        let positionLineNumber = 1, positionColumn = 1;
        state.position && state.position.lineNumber && (positionLineNumber = state.position.lineNumber);
        state.position && state.position.column && (positionColumn = state.position.column);
        let selectionStartLineNumber = positionLineNumber, selectionStartColumn = positionColumn;
        state.selectionStart && state.selectionStart.lineNumber && (selectionStartLineNumber = state.selectionStart.lineNumber);
        state.selectionStart && state.selectionStart.column && (selectionStartColumn = state.selectionStart.column);
        desiredSelections.push({selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn});
      }
      this.setStates(eventsCollector, "restoreState", 0, require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelSelections(desiredSelections));
      this.revealPrimary(eventsCollector, "restoreState", !1, 0, !0, 1);
    }
    onModelContentChanged(eventsCollector, event) {
      if (event instanceof require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelInjectedTextChangedEvent) {
        if (!this._isHandling) {
          this._isHandling = !0;
          try {
            this.setStates(eventsCollector, "modelChange", 0, this.getCursorStates());
          } finally {
            this._isHandling = !1;
          }
        }
      } else {
        if (event = event.rawContentChangedEvent, this._knownModelVersionId = event.versionId, !this._isHandling) {
          var hadFlushEvent = event.containsEvent(1);
          this._prevEditOperationType = 0;
          hadFlushEvent ? (this._cursors.dispose(), this._cursors = new require$_DOT__SLASH_cursorCollection_DOT_js.CursorCollection(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(eventsCollector, "model", 1, null, !1)) : this._hasFocus && event.resultingSelection && event.resultingSelection.length > 0 ? (hadFlushEvent = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelSelections(event.resultingSelection), this.setStates(eventsCollector, "modelChange", 
          event.isUndoing ? 5 : event.isRedoing ? 6 : 2, hadFlushEvent) && this.revealPrimary(eventsCollector, "modelChange", !1, 0, !0, 0)) : (event = this._cursors.readSelectionFromMarkers(), this.setStates(eventsCollector, "modelChange", 2, require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelSelections(event)));
        }
      }
    }
    getSelection() {
      return this._cursors.getPrimaryCursor().modelState.selection;
    }
    getTopMostViewPosition() {
      return this._cursors.getTopMostViewPosition();
    }
    getBottomMostViewPosition() {
      return this._cursors.getBottomMostViewPosition();
    }
    getCursorColumnSelectData() {
      if (this._columnSelectData) {
        return this._columnSelectData;
      }
      var primaryCursor = this._cursors.getPrimaryCursor();
      const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();
      primaryCursor = primaryCursor.viewState.position;
      return {isReal:!1, fromViewLineNumber:viewSelectionStart.lineNumber, fromViewVisualColumn:this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart), toViewLineNumber:primaryCursor.lineNumber, toViewVisualColumn:this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, primaryCursor)};
    }
    getSelections() {
      return this._cursors.getSelections();
    }
    setSelections(eventsCollector, source, selections, reason) {
      this.setStates(eventsCollector, source, reason, require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelSelections(selections));
    }
    getPrevEditOperationType() {
      return this._prevEditOperationType;
    }
    setPrevEditOperationType(type) {
      this._prevEditOperationType = type;
    }
    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {
      const autoClosedCharactersDeltaDecorations = [];
      var autoClosedEnclosingDeltaDecorations = [];
      for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {
        autoClosedCharactersDeltaDecorations.push({range:autoClosedCharactersRanges[i], options:{description:"auto-closed-character", inlineClassName:"auto-closed-character", stickiness:1}}), autoClosedEnclosingDeltaDecorations.push({range:autoClosedEnclosingRanges[i], options:{description:"auto-closed-enclosing", stickiness:1}});
      }
      autoClosedCharactersRanges = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);
      autoClosedEnclosingDeltaDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);
      this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersRanges, autoClosedEnclosingDeltaDecorations));
    }
    _executeEditOperation(opResult) {
      if (opResult) {
        opResult.shouldPushStackElementBefore && this._model.pushStackElement();
        var result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);
        if (result) {
          this._interpretCommandResult(result);
          result = [];
          const autoClosedEnclosingRanges = [];
          for (let i = 0; i < opResult.commands.length; i++) {
            const command = opResult.commands[i];
            command instanceof require$_DOT__SLASH_cursorTypeOperations_DOT_js.TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange && (result.push(command.closeCharacterRange), autoClosedEnclosingRanges.push(command.enclosingRange));
          }
          result.length > 0 && this._pushAutoClosedAction(result, autoClosedEnclosingRanges);
          this._prevEditOperationType = opResult.type;
        }
        opResult.shouldPushStackElementAfter && this._model.pushStackElement();
      }
    }
    _interpretCommandResult(cursorState) {
      cursorState && cursorState.length !== 0 || (cursorState = this._cursors.readSelectionFromMarkers());
      this._columnSelectData = null;
      this._cursors.setSelections(cursorState);
      this._cursors.normalize();
    }
    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {
      const newState = CursorModelState.from(this._model, this);
      if (newState.equals(oldState)) {
        return !1;
      }
      const selections = this._cursors.getSelections();
      var viewSelections = this._cursors.getViewSelections();
      eventsCollector.emitViewEvent(new require$_DOT__DOT__SLASH_viewEvents_DOT_js.ViewCursorStateChangedEvent(viewSelections, selections, reason));
      if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {
        viewSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null, eventsCollector.emitOutgoingEvent(new require$_DOT__DOT__SLASH_viewModelEventDispatcher_DOT_js.CursorStateChangedEvent(viewSelections, selections, oldState ? oldState.modelVersionId : 0, newState.modelVersionId, source || "keyboard", reason, reachedMaxCursorCount));
      }
      return !0;
    }
    _findAutoClosingPairs(edits) {
      if (!edits.length) {
        return null;
      }
      const indices = [];
      for (let i = 0, len = edits.length; i < len; i++) {
        var edit = edits[i];
        if (!edit.text || edit.text.indexOf("\n") >= 0) {
          return null;
        }
        var m = edit.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
        if (!m) {
          return null;
        }
        const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(m[1]);
        if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {
          return null;
        }
        m = edit.text.length - m[2].length - 1;
        edit = edit.text.lastIndexOf(autoClosingPairsCandidates[0].open, m - 1);
        if (edit === -1) {
          return null;
        }
        indices.push([edit, m]);
      }
      return indices;
    }
    executeEdits(eventsCollector, source, edits, cursorStateComputer) {
      let autoClosingIndices = null;
      source === "snippet" && (autoClosingIndices = this._findAutoClosingPairs(edits));
      autoClosingIndices && (edits[0]._isTracked = !0);
      const autoClosedCharactersRanges = [], autoClosedEnclosingRanges = [];
      if (edits = this._model.pushEditOperations(this.getSelections(), edits, undoEdits => {
        if (autoClosingIndices) {
          for (let i = 0, len = autoClosingIndices.length; i < len; i++) {
            const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];
            var undoEdit = undoEdits[i];
            const lineNumber = undoEdit.range.startLineNumber, openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;
            undoEdit = undoEdit.range.startColumn - 1 + closeCharInnerIndex;
            autoClosedCharactersRanges.push(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, undoEdit + 1, lineNumber, undoEdit + 2));
            autoClosedEnclosingRanges.push(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, openCharIndex + 1, lineNumber, undoEdit + 2));
          }
        }
        if (undoEdits = cursorStateComputer(undoEdits)) {
          this._isHandling = !0;
        }
        return undoEdits;
      })) {
        this._isHandling = !1, this.setSelections(eventsCollector, source, edits, 0);
      }
      autoClosedCharactersRanges.length > 0 && this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);
    }
    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0) {
      if (!this.context.cursorConfig.readOnly) {
        var oldState = CursorModelState.from(this._model, this);
        this._cursors.stopTrackingSelections();
        this._isHandling = !0;
        try {
          this._cursors.ensureValidState(), callback();
        } catch (err) {
          (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(err);
        }
        this._isHandling = !1;
        this._cursors.startTrackingSelections();
        this._validateAutoClosedActions();
        this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, !1) && this.revealPrimary(eventsCollector, source, !1, 0, !0, 0);
      }
    }
    getAutoClosedCharacters() {
      return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);
    }
    startComposition(eventsCollector) {
      this._compositionState = new CompositionState(this._model, this.getSelections());
    }
    endComposition(eventsCollector, source) {
      const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
      this._compositionState = null;
      this._executeEdit(() => {
        source === "keyboard" && this._executeEditOperation(require$_DOT__SLASH_cursorTypeOperations_DOT_js.TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));
      }, eventsCollector, source);
    }
    type(eventsCollector, text, source) {
      this._executeEdit(() => {
        if (source === "keyboard") {
          const len = text.length;
          let offset = 0;
          for (; offset < len;) {
            const charLength = strings.nextCharLength(text, offset), chr = text.substr(offset, charLength);
            this._executeEditOperation(require$_DOT__SLASH_cursorTypeOperations_DOT_js.TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));
            offset += charLength;
          }
        } else {
          this._executeEditOperation(require$_DOT__SLASH_cursorTypeOperations_DOT_js.TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));
        }
      }, eventsCollector, source);
    }
    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {
      if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {
        if (positionDelta !== 0) {
          const newSelections = this.getSelections().map(selection => {
            selection = selection.getPosition();
            return new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(selection.lineNumber, selection.column + positionDelta, selection.lineNumber, selection.column + positionDelta);
          });
          this.setSelections(eventsCollector, source, newSelections, 0);
        }
      } else {
        this._executeEdit(() => {
          this._executeEditOperation(require$_DOT__SLASH_cursorTypeOperations_DOT_js.TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));
        }, eventsCollector, source);
      }
    }
    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {
      this._executeEdit(() => {
        this._executeEditOperation(require$_DOT__SLASH_cursorTypeOperations_DOT_js.TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));
      }, eventsCollector, source, 4);
    }
    cut(eventsCollector, source) {
      this._executeEdit(() => {
        this._executeEditOperation(require$_DOT__SLASH_cursorDeleteOperations_DOT_js.DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));
      }, eventsCollector, source);
    }
    executeCommand(eventsCollector, command, source) {
      this._executeEdit(() => {
        this._cursors.killSecondaryCursors();
        this._executeEditOperation(new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(0, [command], {shouldPushStackElementBefore:!1, shouldPushStackElementAfter:!1}));
      }, eventsCollector, source);
    }
    executeCommands(eventsCollector, commands, source) {
      this._executeEdit(() => {
        this._executeEditOperation(new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(0, commands, {shouldPushStackElementBefore:!1, shouldPushStackElementAfter:!1}));
      }, eventsCollector, source);
    }
  }
  class CursorModelState {
    static from(model, cursor) {
      return new CursorModelState(model.getVersionId(), cursor.getCursorStates());
    }
    constructor(modelVersionId, cursorState) {
      this.modelVersionId = modelVersionId;
      this.cursorState = cursorState;
    }
    equals(other) {
      if (!other || this.modelVersionId !== other.modelVersionId || this.cursorState.length !== other.cursorState.length) {
        return !1;
      }
      for (let i = 0, len = this.cursorState.length; i < len; i++) {
        if (!this.cursorState[i].equals(other.cursorState[i])) {
          return !1;
        }
      }
      return !0;
    }
  }
  class AutoClosedAction {
    static getAllAutoClosedCharacters(autoClosedActions) {
      let autoClosedCharacters = [];
      for (const autoClosedAction of autoClosedActions) {
        autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());
      }
      return autoClosedCharacters;
    }
    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {
      this._model = model;
      this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;
      this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;
    }
    dispose() {
      this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);
      this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
    }
    getAutoClosedCharactersRanges() {
      const result = [];
      for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {
        const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);
        decorationRange && result.push(decorationRange);
      }
      return result;
    }
    isValid(selections) {
      const enclosingRanges = [];
      for (var i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
        const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
        if (decorationRange && (enclosingRanges.push(decorationRange), decorationRange.startLineNumber !== decorationRange.endLineNumber)) {
          return !1;
        }
      }
      enclosingRanges.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
      selections.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
      for (i = 0; i < selections.length; i++) {
        if (i >= enclosingRanges.length || !enclosingRanges[i].strictContainsRange(selections[i])) {
          return !1;
        }
      }
      return !0;
    }
  }
  class CommandExecutor {
    static executeCommands(model, selectionsBefore, commands) {
      model = {model, selectionsBefore, trackedRanges:[], trackedRangesDirection:[]};
      commands = this._innerExecuteCommands(model, commands);
      for (let i = 0, len = model.trackedRanges.length; i < len; i++) {
        model.model._setTrackedRange(model.trackedRanges[i], null, 0);
      }
      return commands;
    }
    static _innerExecuteCommands(ctx, commands) {
      if (this._arrayIsEmpty(commands)) {
        return null;
      }
      var commandsData = this._getEditOperations(ctx, commands);
      if (commandsData.operations.length === 0) {
        return null;
      }
      var rawOperations = commandsData.operations;
      const loserCursorsMap = this._getLoserCursorMap(rawOperations);
      if (loserCursorsMap.hasOwnProperty("0")) {
        return console.warn("Ignoring commands"), null;
      }
      const filteredOperations = [];
      for (let i = 0, len = rawOperations.length; i < len; i++) {
        loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString()) || filteredOperations.push(rawOperations[i]);
      }
      commandsData.hadTrackedEditOperation && filteredOperations.length > 0 && (filteredOperations[0]._isTracked = !0);
      commandsData = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, inverseEditOperations => {
        const groupedInverseEditOperations = [];
        for (var i$jscomp$0 = 0; i$jscomp$0 < ctx.selectionsBefore.length; i$jscomp$0++) {
          groupedInverseEditOperations[i$jscomp$0] = [];
        }
        for (const op of inverseEditOperations) {
          op.identifier && groupedInverseEditOperations[op.identifier.major].push(op);
        }
        inverseEditOperations = (a, b) => a.identifier.minor - b.identifier.minor;
        i$jscomp$0 = [];
        for (let i = 0; i < ctx.selectionsBefore.length; i++) {
          groupedInverseEditOperations[i].length > 0 ? (groupedInverseEditOperations[i].sort(inverseEditOperations), i$jscomp$0[i] = commands[i].computeCursorState(ctx.model, {getInverseEditOperations:() => groupedInverseEditOperations[i], getTrackedSelection:id => {
            id = parseInt(id, 10);
            const range = ctx.model._getTrackedRange(ctx.trackedRanges[id]);
            return ctx.trackedRangesDirection[id] === 0 ? new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn) : new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
          }})) : i$jscomp$0[i] = ctx.selectionsBefore[i];
        }
        return i$jscomp$0;
      });
      commandsData || (commandsData = ctx.selectionsBefore);
      rawOperations = [];
      for (const losingCursorIndex in loserCursorsMap) {
        loserCursorsMap.hasOwnProperty(losingCursorIndex) && rawOperations.push(parseInt(losingCursorIndex, 10));
      }
      rawOperations.sort((a, b) => b - a);
      for (const losingCursor of rawOperations) {
        commandsData.splice(losingCursor, 1);
      }
      return commandsData;
    }
    static _arrayIsEmpty(commands) {
      for (let i = 0, len = commands.length; i < len; i++) {
        if (commands[i]) {
          return !1;
        }
      }
      return !0;
    }
    static _getEditOperations(ctx, commands) {
      let operations = [], hadTrackedEditOperation = !1;
      for (let i = 0, len = commands.length; i < len; i++) {
        var command = commands[i];
        command && (command = this._getEditOperationsFromCommand(ctx, i, command), operations = operations.concat(command.operations), hadTrackedEditOperation = hadTrackedEditOperation || command.hadTrackedEditOperation);
      }
      return {operations, hadTrackedEditOperation};
    }
    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {
      const operations = [];
      let operationMinor = 0;
      const addEditOperation = (range, text, forceMoveMarkers = !1) => {
        require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.isEmpty(range) && text === "" || operations.push({identifier:{major:majorIdentifier, minor:operationMinor++}, range, text, forceMoveMarkers, isAutoWhitespaceEdit:command.insertsAutoWhitespace});
      };
      let hadTrackedEditOperation = !1;
      const editOperationBuilder = {addEditOperation, addTrackedEditOperation:(selection, text, forceMoveMarkers) => {
        hadTrackedEditOperation = !0;
        addEditOperation(selection, text, forceMoveMarkers);
      }, trackSelection:(_selection, trackPreviousOnEmpty) => {
        _selection = require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection.liftSelection(_selection);
        if (_selection.isEmpty()) {
          if (typeof trackPreviousOnEmpty === "boolean") {
            var stickiness = trackPreviousOnEmpty ? 2 : 3;
          } else {
            trackPreviousOnEmpty = ctx.model.getLineMaxColumn(_selection.startLineNumber), stickiness = _selection.startColumn === trackPreviousOnEmpty ? 2 : 3;
          }
        } else {
          stickiness = 1;
        }
        trackPreviousOnEmpty = ctx.trackedRanges.length;
        stickiness = ctx.model._setTrackedRange(null, _selection, stickiness);
        ctx.trackedRanges[trackPreviousOnEmpty] = stickiness;
        ctx.trackedRangesDirection[trackPreviousOnEmpty] = _selection.getDirection();
        return trackPreviousOnEmpty.toString();
      }};
      try {
        command.getEditOperations(ctx.model, editOperationBuilder);
      } catch (e) {
        return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e), {operations:[], hadTrackedEditOperation:!1};
      }
      return {operations, hadTrackedEditOperation};
    }
    static _getLoserCursorMap(operations) {
      operations = operations.slice(0);
      operations.sort((a, b) => -require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingEnds(a.range, b.range));
      const loserCursorsMap = {};
      for (let i = 1; i < operations.length; i++) {
        var previousOp = operations[i - 1], currentOp = operations[i];
        if (require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.getStartPosition(previousOp.range).isBefore(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.getEndPosition(currentOp.range))) {
          previousOp = previousOp.identifier.major > currentOp.identifier.major ? previousOp.identifier.major : currentOp.identifier.major;
          loserCursorsMap[previousOp.toString()] = !0;
          for (currentOp = 0; currentOp < operations.length; currentOp++) {
            operations[currentOp].identifier.major === previousOp && (operations.splice(currentOp, 1), currentOp < i && i--, currentOp--);
          }
          i > 0 && i--;
        }
      }
      return loserCursorsMap;
    }
  }
  class CompositionLineState {
    constructor(text, startSelection, endSelection) {
      this.text = text;
      this.startSelection = startSelection;
      this.endSelection = endSelection;
    }
  }
  class CompositionState {
    static _capture(textModel, selections) {
      const result = [];
      for (const selection of selections) {
        if (selection.startLineNumber !== selection.endLineNumber) {
          return null;
        }
        result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));
      }
      return result;
    }
    constructor(textModel, selections) {
      this._original = CompositionState._capture(textModel, selections);
    }
    deduceOutcome(textModel, selections) {
      if (!this._original) {
        return null;
      }
      textModel = CompositionState._capture(textModel, selections);
      if (!textModel || this._original.length !== textModel.length) {
        return null;
      }
      selections = [];
      for (let i = 0, len = this._original.length; i < len; i++) {
        selections.push(CompositionState._deduceOutcome(this._original[i], textModel[i]));
      }
      return selections;
    }
    static _deduceOutcome(original, current) {
      const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));
      var commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));
      const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);
      commonSuffix = current.text.substring(commonPrefix, current.text.length - commonSuffix);
      return new require$_DOT__SLASH_cursorTypeOperations_DOT_js.CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, commonSuffix, current.startSelection - commonPrefix, current.endSelection - commonPrefix);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursor.js.map
