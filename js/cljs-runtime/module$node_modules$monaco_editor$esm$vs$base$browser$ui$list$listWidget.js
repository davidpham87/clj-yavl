shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listWidget = function(require, module, exports) {
  function isInputElement(e) {
    return e.tagName === "INPUT" || e.tagName === "TEXTAREA";
  }
  function isListElementDescendantOfClass(e, className) {
    return e.classList.contains(className) ? !0 : e.classList.contains("monaco-list") || !e.parentElement ? !1 : isListElementDescendantOfClass(e.parentElement, className);
  }
  function isMonacoEditor(e) {
    return isListElementDescendantOfClass(e, "monaco-editor");
  }
  function isMonacoCustomToggle(e) {
    return isListElementDescendantOfClass(e, "monaco-custom-toggle");
  }
  function isActionItem(e) {
    return isListElementDescendantOfClass(e, "action-item");
  }
  function isStickyScrollElement(e) {
    return isListElementDescendantOfClass(e, "monaco-tree-sticky-row");
  }
  function isButton(e) {
    return e.tagName === "A" && e.classList.contains("monaco-button") || e.tagName === "DIV" && e.classList.contains("monaco-button-dropdown") ? !0 : e.classList.contains("monaco-list") || !e.parentElement ? !1 : isButton(e.parentElement);
  }
  function isSelectionSingleChangeEvent(event) {
    return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
  }
  function isSelectionRangeChangeEvent(event) {
    return event.browserEvent.shiftKey;
  }
  function getContiguousRangeContaining(range, value) {
    const index = range.indexOf(value);
    if (index === -1) {
      return [];
    }
    const result = [];
    let i = index - 1;
    for (; i >= 0 && range[i] === value - (index - i);) {
      result.push(range[i--]);
    }
    result.reverse();
    for (i = index; i < range.length && range[i] === value + (i - index);) {
      result.push(range[i++]);
    }
    return result;
  }
  function disjunction(one, other) {
    const result = [];
    let i = 0, j = 0;
    for (; i < one.length || j < other.length;) {
      i >= one.length ? result.push(other[j++]) : j >= other.length ? result.push(one[i++]) : one[i] === other[j] ? (result.push(one[i]), i++, j++) : one[i] < other[j] ? result.push(one[i++]) : result.push(other[j++]);
    }
    return result;
  }
  function relativeComplement(one, other) {
    const result = [];
    let i = 0, j = 0;
    for (; i < one.length || j < other.length;) {
      i >= one.length ? result.push(other[j++]) : j >= other.length ? result.push(one[i++]) : one[i] === other[j] ? (i++, j++) : one[i] < other[j] ? result.push(one[i++]) : j++;
    }
    return result;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DefaultKeyboardNavigationDelegate:{enumerable:!0, get:function() {
    return DefaultKeyboardNavigationDelegate;
  }}, DefaultStyleController:{enumerable:!0, get:function() {
    return DefaultStyleController;
  }}, List:{enumerable:!0, get:function() {
    return List;
  }}, MouseController:{enumerable:!0, get:function() {
    return MouseController;
  }}, TypeNavigationMode:{enumerable:!0, get:function() {
    return TypeNavigationMode;
  }}, isActionItem:{enumerable:!0, get:function() {
    return isActionItem;
  }}, isButton:{enumerable:!0, get:function() {
    return isButton;
  }}, isInputElement:{enumerable:!0, get:function() {
    return isInputElement;
  }}, isMonacoCustomToggle:{enumerable:!0, get:function() {
    return isMonacoCustomToggle;
  }}, isMonacoEditor:{enumerable:!0, get:function() {
    return isMonacoEditor;
  }}, isSelectionRangeChangeEvent:{enumerable:!0, get:function() {
    return isSelectionRangeChangeEvent;
  }}, isSelectionSingleChangeEvent:{enumerable:!0, get:function() {
    return isSelectionSingleChangeEvent;
  }}, isStickyScrollElement:{enumerable:!0, get:function() {
    return isStickyScrollElement;
  }}, unthemedListStyles:{enumerable:!0, get:function() {
    return unthemedListStyles;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$keyboardEvent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$touch"), 
  require$_DOT__DOT__SLASH_aria_SLASH_aria_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$aria$aria"), require$_DOT__SLASH_splice_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$splice"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$color");
  exports = require("module$node_modules$monaco_editor$esm$vs$base$common$decorators");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$filters"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$numbers"), platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$list_css");
  var require$_DOT__SLASH_list_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$list"), require$_DOT__SLASH_listView_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listView"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_mouseEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$mouseEvent");
  require = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  class TraitRenderer {
    constructor(trait) {
      this.trait = trait;
      this.renderedElements = [];
    }
    get templateId() {
      return `template:${this.trait.name}`;
    }
    renderTemplate(container) {
      return container;
    }
    renderElement(element, index, templateData) {
      element = this.renderedElements.findIndex(el => el.templateData === templateData);
      element >= 0 ? (element = this.renderedElements[element], this.trait.unrender(templateData), element.index = index) : this.renderedElements.push({index, templateData});
      this.trait.renderIndex(index, templateData);
    }
    splice(start, deleteCount, insertCount) {
      const rendered = [];
      for (const renderedElement of this.renderedElements) {
        renderedElement.index < start ? rendered.push(renderedElement) : renderedElement.index >= start + deleteCount && rendered.push({index:renderedElement.index + insertCount - deleteCount, templateData:renderedElement.templateData});
      }
      this.renderedElements = rendered;
    }
    renderIndexes(indexes) {
      for (const {index, templateData} of this.renderedElements) {
        indexes.indexOf(index) > -1 && this.trait.renderIndex(index, templateData);
      }
    }
    disposeTemplate(templateData) {
      const index = this.renderedElements.findIndex(el => el.templateData === templateData);
      index < 0 || this.renderedElements.splice(index, 1);
    }
  }
  class Trait {
    get name() {
      return this._trait;
    }
    get renderer() {
      return new TraitRenderer(this);
    }
    constructor(_trait) {
      this._trait = _trait;
      this.length = 0;
      this.indexes = [];
      this.sortedIndexes = [];
      this._onChange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onChange = this._onChange.event;
    }
    splice(start, deleteCount, elements) {
      var _a;
      deleteCount = Math.max(0, Math.min(deleteCount, this.length - start));
      var diff = elements.length - deleteCount, end = start + deleteCount;
      const sortedIndexes = [];
      let i = 0;
      for (; i < this.sortedIndexes.length && this.sortedIndexes[i] < start;) {
        sortedIndexes.push(this.sortedIndexes[i++]);
      }
      for (let j = 0; j < elements.length; j++) {
        elements[j] && sortedIndexes.push(j + start);
      }
      for (; i < this.sortedIndexes.length && this.sortedIndexes[i] >= end;) {
        sortedIndexes.push(this.sortedIndexes[i++] + diff);
      }
      diff = this.length + diff;
      this.sortedIndexes.length > 0 && sortedIndexes.length === 0 && diff > 0 && (end = (_a = this.sortedIndexes.find(index => index >= start)) !== null && _a !== void 0 ? _a : diff - 1, sortedIndexes.push(Math.min(end, diff - 1)));
      this.renderer.splice(start, deleteCount, elements.length);
      this._set(sortedIndexes, sortedIndexes);
      this.length = diff;
    }
    renderIndex(index, container) {
      container.classList.toggle(this._trait, this.contains(index));
    }
    unrender(container) {
      container.classList.remove(this._trait);
    }
    set(indexes, browserEvent) {
      return this._set(indexes, [...indexes].sort(numericSort), browserEvent);
    }
    _set(indexes, sortedIndexes, browserEvent) {
      const result = this.indexes, sortedResult = this.sortedIndexes;
      this.indexes = indexes;
      this.sortedIndexes = sortedIndexes;
      sortedIndexes = disjunction(sortedResult, indexes);
      this.renderer.renderIndexes(sortedIndexes);
      this._onChange.fire({indexes, browserEvent});
      return result;
    }
    get() {
      return this.indexes;
    }
    contains(index) {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.binarySearch)(this.sortedIndexes, index, numericSort) >= 0;
    }
    dispose() {
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this._onChange);
    }
  }
  require([exports.memoize], Trait.prototype, "renderer", null);
  class SelectionTrait extends Trait {
    constructor(setAriaSelected) {
      super("selected");
      this.setAriaSelected = setAriaSelected;
    }
    renderIndex(index, container) {
      super.renderIndex(index, container);
      this.setAriaSelected && (this.contains(index) ? container.setAttribute("aria-selected", "true") : container.setAttribute("aria-selected", "false"));
    }
  }
  class TraitSpliceable {
    constructor(trait, view, identityProvider) {
      this.trait = trait;
      this.view = view;
      this.identityProvider = identityProvider;
    }
    splice(start, deleteCount, elements) {
      if (!this.identityProvider) {
        return this.trait.splice(start, deleteCount, Array(elements.length).fill(!1));
      }
      const pastElementsWithTrait = this.trait.get().map(i => this.identityProvider.getId(this.view.element(i)).toString());
      if (pastElementsWithTrait.length === 0) {
        return this.trait.splice(start, deleteCount, Array(elements.length).fill(!1));
      }
      const pastElementsWithTraitSet = new Set(pastElementsWithTrait);
      elements = elements.map(e => pastElementsWithTraitSet.has(this.identityProvider.getId(e).toString()));
      this.trait.splice(start, deleteCount, elements);
    }
  }
  class KeyboardController {
    get onKeyDown() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.view.domNode, "keydown")).event, $ => $.filter(e => !isInputElement(e.target)).map(e => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e)));
    }
    constructor(list, view, options) {
      this.list = list;
      this.view = view;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.multipleSelectionDisposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.multipleSelectionSupport = options.multipleSelectionSupport;
      this.disposables.add(this.onKeyDown(e => {
        switch(e.keyCode) {
          case 3:
            return this.onEnter(e);
          case 16:
            return this.onUpArrow(e);
          case 18:
            return this.onDownArrow(e);
          case 11:
            return this.onPageUpArrow(e);
          case 12:
            return this.onPageDownArrow(e);
          case 9:
            return this.onEscape(e);
          case 31:
            if (this.multipleSelectionSupport && (platform.isMacintosh ? e.metaKey : e.ctrlKey)) {
              this.onCtrlA(e);
            }
        }
      }));
    }
    updateOptions(optionsUpdate) {
      optionsUpdate.multipleSelectionSupport !== void 0 && (this.multipleSelectionSupport = optionsUpdate.multipleSelectionSupport);
    }
    onEnter(e) {
      e.preventDefault();
      e.stopPropagation();
      this.list.setSelection(this.list.getFocus(), e.browserEvent);
    }
    onUpArrow(e) {
      e.preventDefault();
      e.stopPropagation();
      this.list.focusPrevious(1, !1, e.browserEvent);
      e = this.list.getFocus()[0];
      this.list.setAnchor(e);
      this.list.reveal(e);
      this.view.domNode.focus();
    }
    onDownArrow(e) {
      e.preventDefault();
      e.stopPropagation();
      this.list.focusNext(1, !1, e.browserEvent);
      e = this.list.getFocus()[0];
      this.list.setAnchor(e);
      this.list.reveal(e);
      this.view.domNode.focus();
    }
    onPageUpArrow(e) {
      e.preventDefault();
      e.stopPropagation();
      this.list.focusPreviousPage(e.browserEvent);
      e = this.list.getFocus()[0];
      this.list.setAnchor(e);
      this.list.reveal(e);
      this.view.domNode.focus();
    }
    onPageDownArrow(e) {
      e.preventDefault();
      e.stopPropagation();
      this.list.focusNextPage(e.browserEvent);
      e = this.list.getFocus()[0];
      this.list.setAnchor(e);
      this.list.reveal(e);
      this.view.domNode.focus();
    }
    onCtrlA(e) {
      e.preventDefault();
      e.stopPropagation();
      this.list.setSelection((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(this.list.length), e.browserEvent);
      this.list.setAnchor(void 0);
      this.view.domNode.focus();
    }
    onEscape(e) {
      this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
    }
    dispose() {
      this.disposables.dispose();
      this.multipleSelectionDisposables.dispose();
    }
  }
  require([exports.memoize], KeyboardController.prototype, "onKeyDown", null);
  var TypeNavigationMode;
  (function(TypeNavigationMode) {
    TypeNavigationMode[TypeNavigationMode.Automatic = 0] = "Automatic";
    TypeNavigationMode[TypeNavigationMode.Trigger = 1] = "Trigger";
  })(TypeNavigationMode ||= {});
  var TypeNavigationControllerState;
  (function(TypeNavigationControllerState) {
    TypeNavigationControllerState[TypeNavigationControllerState.Idle = 0] = "Idle";
    TypeNavigationControllerState[TypeNavigationControllerState.Typing = 1] = "Typing";
  })(TypeNavigationControllerState ||= {});
  const DefaultKeyboardNavigationDelegate = new class {
    mightProducePrintableCharacter(event) {
      return event.ctrlKey || event.metaKey || event.altKey ? !1 : event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30 || event.keyCode >= 98 && event.keyCode <= 107 || event.keyCode >= 85 && event.keyCode <= 95;
    }
  }();
  class TypeNavigationController {
    constructor(list, view, keyboardNavigationLabelProvider, keyboardNavigationEventFilter, delegate) {
      this.list = list;
      this.view = view;
      this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
      this.keyboardNavigationEventFilter = keyboardNavigationEventFilter;
      this.delegate = delegate;
      this.enabled = !1;
      this.state = TypeNavigationControllerState.Idle;
      this.mode = TypeNavigationMode.Automatic;
      this.triggered = !1;
      this.previouslyFocused = -1;
      this.enabledDisposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.updateOptions(list.options);
    }
    updateOptions(options) {
      var _a, _b;
      ((_a = options.typeNavigationEnabled) !== null && _a !== void 0 ? _a : 1) ? this.enable() : this.disable();
      this.mode = (_b = options.typeNavigationMode) !== null && _b !== void 0 ? _b : TypeNavigationMode.Automatic;
    }
    enable() {
      if (!this.enabled) {
        var typing = !1, onChar = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.enabledDisposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.view.domNode, "keydown")).event, $ => $.filter(e => !isInputElement(e.target)).filter(() => this.mode === TypeNavigationMode.Automatic || this.triggered).map(event => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(event)).filter(e => 
        typing || this.keyboardNavigationEventFilter(e)).filter(e => this.delegate.mightProducePrintableCharacter(e)).forEach(e => require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.EventHelper.stop(e, !0)).map(event => event.browserEvent.key)), onClear = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.debounce(onChar, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
        require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.reduce(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.any(onChar, onClear), (r, i) => i === null ? null : (r || "") + i, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables);
        onClear(this.onClear, this, this.enabledDisposables);
        onChar(() => typing = !0, void 0, this.enabledDisposables);
        onClear(() => typing = !1, void 0, this.enabledDisposables);
        this.enabled = !0;
        this.triggered = !1;
      }
    }
    disable() {
      this.enabled && (this.enabledDisposables.clear(), this.triggered = this.enabled = !1);
    }
    onClear() {
      var _a;
      const focus = this.list.getFocus();
      if (focus.length > 0 && focus[0] === this.previouslyFocused) {
        const ariaLabel = (_a = this.list.options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getAriaLabel(this.list.element(focus[0]));
        ariaLabel && (0,require$_DOT__DOT__SLASH_aria_SLASH_aria_DOT_js.alert)(ariaLabel);
      }
      this.previouslyFocused = -1;
    }
    onInput(word) {
      if (word) {
        var focus = this.list.getFocus();
        focus = focus.length > 0 ? focus[0] : 0;
        var delta = this.state === TypeNavigationControllerState.Idle ? 1 : 0;
        this.state = TypeNavigationControllerState.Typing;
        for (let i = 0; i < this.list.length; i++) {
          const index = (focus + i + delta) % this.list.length;
          var label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));
          label = label && label.toString();
          if (this.list.options.typeNavigationEnabled) {
            if (typeof label !== "undefined") {
              if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.matchesPrefix)(word, label)) {
                this.previouslyFocused = focus;
                this.list.setFocus([index]);
                this.list.reveal(index);
                break;
              }
              if ((label = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.matchesFuzzy2)(word, label)) && label[0].end - label[0].start > 1 && label.length === 1) {
                this.previouslyFocused = focus;
                this.list.setFocus([index]);
                this.list.reveal(index);
                break;
              }
            }
          } else if (typeof label === "undefined" || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.matchesPrefix)(word, label)) {
            this.previouslyFocused = focus;
            this.list.setFocus([index]);
            this.list.reveal(index);
            break;
          }
        }
      } else {
        this.state = TypeNavigationControllerState.Idle, this.triggered = !1;
      }
    }
    dispose() {
      this.disable();
      this.enabledDisposables.dispose();
      this.disposables.dispose();
    }
  }
  class DOMFocusController {
    constructor(list, view) {
      this.list = list;
      this.view = view;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      list = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(view.domNode, "keydown")).event, $ => $.filter(e => !isInputElement(e.target)).map(e => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e)));
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(list, $ => $.filter(e => e.keyCode === 2 && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey))(this.onTab, this, this.disposables);
    }
    onTab(e) {
      if (e.target === this.view.domNode) {
        var focus = this.list.getFocus();
        if (focus.length !== 0 && (focus = this.view.domElement(focus[0])) && (focus = focus.querySelector("[tabIndex]")) && focus instanceof HTMLElement && focus.tabIndex !== -1) {
          var style = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(focus).getComputedStyle(focus);
          style.visibility !== "hidden" && style.display !== "none" && (e.preventDefault(), e.stopPropagation(), focus.focus());
        }
      }
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  const DefaultMultipleSelectionController = {isSelectionSingleChangeEvent, isSelectionRangeChangeEvent};
  class MouseController {
    constructor(list) {
      this.list = list;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._onPointer = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onPointer = this._onPointer.event;
      list.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController);
      if (this.mouseSupport = typeof list.options.mouseSupport === "undefined" || !!list.options.mouseSupport) {
        list.onMouseDown(this.onMouseDown, this, this.disposables), list.onContextMenu(this.onContextMenu, this, this.disposables), list.onMouseDblClick(this.onDoubleClick, this, this.disposables), list.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_touch_DOT_js.Gesture.addTarget(list.getHTMLElement()));
      }
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);
    }
    updateOptions(optionsUpdate) {
      optionsUpdate.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, optionsUpdate.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController));
    }
    isSelectionSingleChangeEvent(event) {
      return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(event) : !1;
    }
    isSelectionRangeChangeEvent(event) {
      return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(event) : !1;
    }
    isSelectionChangeEvent(event) {
      return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);
    }
    onMouseDown(e) {
      isMonacoEditor(e.browserEvent.target) || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getActiveElement)() !== e.browserEvent.target && this.list.domFocus();
    }
    onContextMenu(e) {
      isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target) || this.list.setFocus(typeof e.index === "undefined" ? [] : [e.index], e.browserEvent);
    }
    onViewPointer(e) {
      if (this.mouseSupport && !isInputElement(e.browserEvent.target) && !isMonacoEditor(e.browserEvent.target) && !e.browserEvent.isHandledByList) {
        e.browserEvent.isHandledByList = !0;
        var focus = e.index;
        if (typeof focus === "undefined") {
          this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
        } else {
          if (this.isSelectionChangeEvent(e)) {
            return this.changeSelection(e);
          }
          this.list.setFocus([focus], e.browserEvent);
          this.list.setAnchor(focus);
          var event = e.browserEvent;
          (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.isMouseEvent)(event) && event.button === 2 || this.list.setSelection([focus], e.browserEvent);
          this._onPointer.fire(e);
        }
      }
    }
    onDoubleClick(e) {
      if (!(isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target) || this.isSelectionChangeEvent(e) || e.browserEvent.isHandledByList)) {
        e.browserEvent.isHandledByList = !0;
        var focus = this.list.getFocus();
        this.list.setSelection(focus, e.browserEvent);
      }
    }
    changeSelection(e) {
      const focus = e.index;
      var anchor = this.list.getAnchor();
      if (this.isSelectionRangeChangeEvent(e)) {
        if (typeof anchor === "undefined") {
          var currentFocus = this.list.getFocus()[0];
          anchor = currentFocus !== null && currentFocus !== void 0 ? currentFocus : focus;
          this.list.setAnchor(anchor);
        }
        currentFocus = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(Math.min(anchor, focus), Math.max(anchor, focus) + 1);
        var selection = this.list.getSelection();
        anchor = getContiguousRangeContaining(disjunction(selection, [anchor]), anchor);
        anchor.length !== 0 && (currentFocus = disjunction(currentFocus, relativeComplement(selection, anchor)), this.list.setSelection(currentFocus, e.browserEvent), this.list.setFocus([focus], e.browserEvent));
      } else {
        this.isSelectionSingleChangeEvent(e) && (currentFocus = this.list.getSelection(), selection = currentFocus.filter(i => i !== focus), this.list.setFocus([focus]), this.list.setAnchor(focus), currentFocus.length === selection.length ? this.list.setSelection([...selection, focus], e.browserEvent) : this.list.setSelection(selection, e.browserEvent));
      }
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  class DefaultStyleController {
    constructor(styleElement, selectorSuffix) {
      this.styleElement = styleElement;
      this.selectorSuffix = selectorSuffix;
    }
    style(styles) {
      var _a, _b;
      const suffix = this.selectorSuffix && `.${this.selectorSuffix}`, content = [];
      styles.listBackground && content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);
      styles.listFocusBackground && (content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`), content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`));
      styles.listFocusForeground && content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);
      styles.listActiveSelectionBackground && (content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`), content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`));
      styles.listActiveSelectionForeground && content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);
      styles.listActiveSelectionIconForeground && content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected .codicon { color: ${styles.listActiveSelectionIconForeground}; }`);
      styles.listFocusAndSelectionBackground && content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }
			`);
      styles.listFocusAndSelectionForeground && content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }
			`);
      styles.listInactiveFocusForeground && (content.push(`.monaco-list${suffix} .monaco-list-row.focused { color:  ${styles.listInactiveFocusForeground}; }`), content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { color:  ${styles.listInactiveFocusForeground}; }`));
      styles.listInactiveSelectionIconForeground && content.push(`.monaco-list${suffix} .monaco-list-row.focused .codicon { color:  ${styles.listInactiveSelectionIconForeground}; }`);
      styles.listInactiveFocusBackground && (content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`), content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`));
      styles.listInactiveSelectionBackground && (content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`), content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`));
      styles.listInactiveSelectionForeground && content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);
      styles.listHoverBackground && content.push(`.monaco-list${suffix}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${styles.listHoverBackground}; }`);
      styles.listHoverForeground && content.push(`.monaco-list${suffix}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);
      const focusAndSelectionOutline = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.asCssValueWithDefault)(styles.listFocusAndSelectionOutline, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.asCssValueWithDefault)(styles.listSelectionOutline, (_a = styles.listFocusOutline) !== null && _a !== void 0 ? _a : ""));
      focusAndSelectionOutline && content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);
      styles.listFocusOutline && content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
			`);
      (_a = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.asCssValueWithDefault)(styles.listSelectionOutline, (_b = styles.listInactiveFocusOutline) !== null && _b !== void 0 ? _b : "")) && content.push(`.monaco-list${suffix} .monaco-list-row.focused.selected { outline: 1px dotted ${_a}; outline-offset: -1px; }`);
      styles.listSelectionOutline && content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);
      styles.listInactiveFocusOutline && content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);
      styles.listHoverOutline && content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);
      styles.listDropBackground && content.push(`
				.monaco-list${suffix}.drop-target,
				.monaco-list${suffix} .monaco-list-rows.drop-target,
				.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropBackground} !important; color: inherit !important; }
			`);
      styles.tableColumnsBorder && content.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${styles.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`);
      styles.tableOddRowsBackgroundColor && content.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${styles.tableOddRowsBackgroundColor};
				}
			`);
      this.styleElement.textContent = content.join("\n");
    }
  }
  const unthemedListStyles = {listFocusBackground:"#7FB0D0", listActiveSelectionBackground:"#0E639C", listActiveSelectionForeground:"#FFFFFF", listActiveSelectionIconForeground:"#FFFFFF", listFocusAndSelectionOutline:"#90C2F9", listFocusAndSelectionBackground:"#094771", listFocusAndSelectionForeground:"#FFFFFF", listInactiveSelectionBackground:"#3F3F46", listInactiveSelectionIconForeground:"#FFFFFF", listHoverBackground:"#2A2D2E", listDropBackground:"#383B3D", treeIndentGuidesStroke:"#a9a9a9", treeInactiveIndentGuidesStroke:module.Color.fromHex("#a9a9a9").transparent(0.4).toString(), 
  tableColumnsBorder:module.Color.fromHex("#cccccc").transparent(0.2).toString(), tableOddRowsBackgroundColor:module.Color.fromHex("#cccccc").transparent(0.04).toString(), listBackground:void 0, listFocusForeground:void 0, listInactiveSelectionForeground:void 0, listInactiveFocusForeground:void 0, listInactiveFocusBackground:void 0, listHoverForeground:void 0, listFocusOutline:void 0, listInactiveFocusOutline:void 0, listSelectionOutline:void 0, listHoverOutline:void 0}, DefaultOptions = {keyboardSupport:!0, 
  mouseSupport:!0, multipleSelectionSupport:!0, dnd:{getDragURI() {
    return null;
  }, onDragStart() {
  }, onDragOver() {
    return !1;
  }, drop() {
  }, dispose() {
  }}}, numericSort = (a, b) => a - b;
  class PipelineRenderer {
    constructor(_templateId, renderers) {
      this._templateId = _templateId;
      this.renderers = renderers;
    }
    get templateId() {
      return this._templateId;
    }
    renderTemplate(container) {
      return this.renderers.map(r => r.renderTemplate(container));
    }
    renderElement(element, index, templateData, height) {
      let i = 0;
      for (const renderer of this.renderers) {
        renderer.renderElement(element, index, templateData[i++], height);
      }
    }
    disposeElement(element, index, templateData, height) {
      var _a;
      let i = 0;
      for (const renderer of this.renderers) {
        (_a = renderer.disposeElement) === null || _a === void 0 || _a.call(renderer, element, index, templateData[i], height), i += 1;
      }
    }
    disposeTemplate(templateData) {
      let i = 0;
      for (const renderer of this.renderers) {
        renderer.disposeTemplate(templateData[i++]);
      }
    }
  }
  class AccessibiltyRenderer {
    constructor(accessibilityProvider) {
      this.accessibilityProvider = accessibilityProvider;
      this.templateId = "a18n";
    }
    renderTemplate(container) {
      return container;
    }
    renderElement(element, index, container) {
      (index = this.accessibilityProvider.getAriaLabel(element)) ? container.setAttribute("aria-label", index) : container.removeAttribute("aria-label");
      element = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);
      typeof element === "number" ? container.setAttribute("aria-level", `${element}`) : container.removeAttribute("aria-level");
    }
    disposeTemplate(templateData) {
    }
  }
  class ListViewDragAndDrop {
    constructor(list, dnd) {
      this.list = list;
      this.dnd = dnd;
    }
    getDragElements(element) {
      const selection = this.list.getSelectedElements();
      return selection.indexOf(element) > -1 ? selection : [element];
    }
    getDragURI(element) {
      return this.dnd.getDragURI(element);
    }
    getDragLabel(elements, originalEvent) {
      if (this.dnd.getDragLabel) {
        return this.dnd.getDragLabel(elements, originalEvent);
      }
    }
    onDragStart(data, originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 || _b.call(_a, data, originalEvent);
    }
    onDragOver(data, targetElement, targetIndex, originalEvent) {
      return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);
    }
    onDragLeave(data, targetElement, targetIndex, originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragLeave) === null || _b === void 0 || _b.call(_a, data, targetElement, targetIndex, originalEvent);
    }
    onDragEnd(originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 || _b.call(_a, originalEvent);
    }
    drop(data, targetElement, targetIndex, originalEvent) {
      this.dnd.drop(data, targetElement, targetIndex, originalEvent);
    }
    dispose() {
      this.dnd.dispose();
    }
  }
  class List {
    get onDidChangeFocus() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), e => this.toListEvent(e), this.disposables);
    }
    get onDidChangeSelection() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), e => this.toListEvent(e), this.disposables);
    }
    get domId() {
      return this.view.domId;
    }
    get onDidScroll() {
      return this.view.onDidScroll;
    }
    get onMouseClick() {
      return this.view.onMouseClick;
    }
    get onMouseDblClick() {
      return this.view.onMouseDblClick;
    }
    get onMouseMiddleClick() {
      return this.view.onMouseMiddleClick;
    }
    get onPointer() {
      return this.mouseController.onPointer;
    }
    get onMouseDown() {
      return this.view.onMouseDown;
    }
    get onMouseOver() {
      return this.view.onMouseOver;
    }
    get onMouseOut() {
      return this.view.onMouseOut;
    }
    get onTouchStart() {
      return this.view.onTouchStart;
    }
    get onTap() {
      return this.view.onTap;
    }
    get onContextMenu() {
      let didJustPressContextMenuKey = !1;
      const fromKeyDown = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.view.domNode, "keydown")).event, $ => $.map(e => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e)).filter(e => didJustPressContextMenuKey = e.keyCode === 58 || e.shiftKey && e.keyCode === 68).map(e => require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.EventHelper.stop(e, 
      !0)).filter(() => !1)), fromKeyUp = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.view.domNode, "keyup")).event, $ => $.forEach(() => didJustPressContextMenuKey = !1).map(e => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e)).filter(e => e.keyCode === 58 || e.shiftKey && e.keyCode === 68).map(e => require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.EventHelper.stop(e, 
      !0)).map(({browserEvent}) => {
        var focus = this.getFocus();
        focus = focus.length ? focus[0] : void 0;
        const element = typeof focus !== "undefined" ? this.view.element(focus) : void 0, anchor = typeof focus !== "undefined" ? this.view.domElement(focus) : this.view.domNode;
        return {index:focus, element, anchor, browserEvent};
      })), fromMouse = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.view.onContextMenu, $ => $.filter(_ => !didJustPressContextMenuKey).map(({element, index, browserEvent}) => ({element, index, anchor:new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_mouseEvent_DOT_js.StandardMouseEvent((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(this.view.domNode), browserEvent), browserEvent})));
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.any(fromKeyDown, fromKeyUp, fromMouse);
    }
    get onKeyDown() {
      return this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.view.domNode, "keydown")).event;
    }
    get onDidFocus() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.signal(this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.view.domNode, "focus", !0)).event);
    }
    constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {
      var _a, _b, _c, _d;
      this.user = user;
      this._options = _options;
      this.focus = new Trait("focused");
      this.anchor = new Trait("anchor");
      this.eventBufferer = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.EventBufferer();
      this._ariaLabel = "";
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._onDidDispose = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidDispose = this._onDidDispose.event;
      user = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a = this._options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.getWidgetRole() : "list";
      this.selection = new SelectionTrait(user !== "listbox");
      const baseRenderers = [this.focus.renderer, this.selection.renderer];
      if (this.accessibilityProvider = _options.accessibilityProvider) {
        baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider)), (_c = (_b = this.accessibilityProvider).onDidChangeActiveDescendant) === null || _c === void 0 || _c.call(_b, this.onDidChangeActiveDescendant, this, this.disposables);
      }
      renderers = renderers.map(r => new PipelineRenderer(r.templateId, [...baseRenderers, r]));
      _a = {..._options, dnd:_options.dnd && new ListViewDragAndDrop(this, _options.dnd)};
      this.view = this.createListView(container, virtualDelegate, renderers, _a);
      this.view.domNode.setAttribute("role", user);
      _options.styleController ? this.styleController = _options.styleController(this.view.domId) : (container = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createStyleSheet)(this.view.domNode), this.styleController = new DefaultStyleController(container, this.view.domId));
      this.spliceable = new require$_DOT__SLASH_splice_DOT_js.CombinedSpliceable([new TraitSpliceable(this.focus, this.view, _options.identityProvider), new TraitSpliceable(this.selection, this.view, _options.identityProvider), new TraitSpliceable(this.anchor, this.view, _options.identityProvider), this.view]);
      this.disposables.add(this.focus);
      this.disposables.add(this.selection);
      this.disposables.add(this.anchor);
      this.disposables.add(this.view);
      this.disposables.add(this._onDidDispose);
      this.disposables.add(new DOMFocusController(this, this.view));
      if (typeof _options.keyboardSupport !== "boolean" || _options.keyboardSupport) {
        this.keyboardController = new KeyboardController(this, this.view, _options), this.disposables.add(this.keyboardController);
      }
      _options.keyboardNavigationLabelProvider && (container = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate, this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, (_d = _options.keyboardNavigationEventFilter) !== null && _d !== void 0 ? _d : () => !0, container), this.disposables.add(this.typeNavigationController));
      this.mouseController = this.createMouseController(_options);
      this.disposables.add(this.mouseController);
      this.onDidChangeFocus(this._onFocusChange, this, this.disposables);
      this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);
      this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel());
      this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
    }
    createListView(container, virtualDelegate, renderers, viewOptions) {
      return new require$_DOT__SLASH_listView_DOT_js.ListView(container, virtualDelegate, renderers, viewOptions);
    }
    createMouseController(options) {
      return new MouseController(this);
    }
    updateOptions(optionsUpdate = {}) {
      var _a, _b;
      this._options = {...this._options, ...optionsUpdate};
      (_a = this.typeNavigationController) === null || _a === void 0 || _a.updateOptions(this._options);
      this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable"));
      this.mouseController.updateOptions(optionsUpdate);
      (_b = this.keyboardController) === null || _b === void 0 || _b.updateOptions(optionsUpdate);
      this.view.updateOptions(optionsUpdate);
    }
    get options() {
      return this._options;
    }
    splice(start, deleteCount, elements = []) {
      if (start < 0 || start > this.view.length) {
        throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid start index: ${start}`);
      }
      if (deleteCount < 0) {
        throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid delete count: ${deleteCount}`);
      }
      deleteCount === 0 && elements.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));
    }
    rerender() {
      this.view.rerender();
    }
    element(index) {
      return this.view.element(index);
    }
    indexOf(element) {
      return this.view.indexOf(element);
    }
    get length() {
      return this.view.length;
    }
    get contentHeight() {
      return this.view.contentHeight;
    }
    get onDidChangeContentHeight() {
      return this.view.onDidChangeContentHeight;
    }
    get scrollTop() {
      return this.view.getScrollTop();
    }
    set scrollTop(scrollTop) {
      this.view.setScrollTop(scrollTop);
    }
    get scrollHeight() {
      return this.view.scrollHeight;
    }
    get renderHeight() {
      return this.view.renderHeight;
    }
    get firstVisibleIndex() {
      return this.view.firstVisibleIndex;
    }
    get ariaLabel() {
      return this._ariaLabel;
    }
    set ariaLabel(value) {
      this._ariaLabel = value;
      this.view.domNode.setAttribute("aria-label", value);
    }
    domFocus() {
      this.view.domNode.focus({preventScroll:!0});
    }
    layout(height, width) {
      this.view.layout(height, width);
    }
    setSelection(indexes, browserEvent) {
      for (const index of indexes) {
        if (index < 0 || index >= this.length) {
          throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid index ${index}`);
        }
      }
      this.selection.set(indexes, browserEvent);
    }
    getSelection() {
      return this.selection.get();
    }
    getSelectedElements() {
      return this.getSelection().map(i => this.view.element(i));
    }
    setAnchor(index) {
      if (typeof index === "undefined") {
        this.anchor.set([]);
      } else {
        if (index < 0 || index >= this.length) {
          throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid index ${index}`);
        }
        this.anchor.set([index]);
      }
    }
    getAnchor() {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.firstOrDefault)(this.anchor.get(), void 0);
    }
    getAnchorElement() {
      const anchor = this.getAnchor();
      return typeof anchor === "undefined" ? void 0 : this.element(anchor);
    }
    setFocus(indexes, browserEvent) {
      for (const index of indexes) {
        if (index < 0 || index >= this.length) {
          throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid index ${index}`);
        }
      }
      this.focus.set(indexes, browserEvent);
    }
    focusNext(n = 1, loop = !1, browserEvent, filter) {
      if (this.length !== 0) {
        var focus = this.focus.get();
        n = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);
        n > -1 && this.setFocus([n], browserEvent);
      }
    }
    focusPrevious(n = 1, loop = !1, browserEvent, filter) {
      if (this.length !== 0) {
        var focus = this.focus.get();
        n = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);
        n > -1 && this.setFocus([n], browserEvent);
      }
    }
    async focusNextPage(browserEvent, filter) {
      let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
      lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
      const currentlyFocusedElementIndex = this.getFocus()[0];
      if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === void 0 || lastPageIndex > currentlyFocusedElementIndex)) {
        filter = this.findPreviousIndex(lastPageIndex, !1, filter), filter > -1 && currentlyFocusedElementIndex !== filter ? this.setFocus([filter], browserEvent) : this.setFocus([lastPageIndex], browserEvent);
      } else {
        const previousScrollTop = this.view.getScrollTop();
        let nextpageScrollTop = previousScrollTop + this.view.renderHeight;
        lastPageIndex > currentlyFocusedElementIndex && (nextpageScrollTop -= this.view.elementHeight(lastPageIndex));
        this.view.setScrollTop(nextpageScrollTop);
        this.view.getScrollTop() !== previousScrollTop && (this.setFocus([]), await (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.timeout)(0), await this.focusNextPage(browserEvent, filter));
      }
    }
    async focusPreviousPage(browserEvent, filter) {
      let firstPageIndex;
      const scrollTop = this.view.getScrollTop();
      firstPageIndex = scrollTop === 0 ? this.view.indexAt(scrollTop) : this.view.indexAfter(scrollTop - 1);
      const currentlyFocusedElementIndex = this.getFocus()[0];
      currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === void 0 || currentlyFocusedElementIndex >= firstPageIndex) ? (filter = this.findNextIndex(firstPageIndex, !1, filter), filter > -1 && currentlyFocusedElementIndex !== filter ? this.setFocus([filter], browserEvent) : this.setFocus([firstPageIndex], browserEvent)) : (this.view.setScrollTop(scrollTop - this.view.renderHeight), this.view.getScrollTop() !== scrollTop && (this.setFocus([]), await (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.timeout)(0), 
      await this.focusPreviousPage(browserEvent, filter)));
    }
    focusLast(browserEvent, filter) {
      this.length !== 0 && (filter = this.findPreviousIndex(this.length - 1, !1, filter), filter > -1 && this.setFocus([filter], browserEvent));
    }
    focusFirst(browserEvent, filter) {
      this.focusNth(0, browserEvent, filter);
    }
    focusNth(n, browserEvent, filter) {
      this.length !== 0 && (n = this.findNextIndex(n, !1, filter), n > -1 && this.setFocus([n], browserEvent));
    }
    findNextIndex(index, loop = !1, filter) {
      for (let i = 0; i < this.length && (!(index >= this.length) || loop); i++) {
        index %= this.length;
        if (!filter || filter(this.element(index))) {
          return index;
        }
        index++;
      }
      return -1;
    }
    findPreviousIndex(index, loop = !1, filter) {
      for (let i = 0; i < this.length && (!(index < 0) || loop); i++) {
        index = (this.length + index % this.length) % this.length;
        if (!filter || filter(this.element(index))) {
          return index;
        }
        index--;
      }
      return -1;
    }
    getFocus() {
      return this.focus.get();
    }
    getFocusedElements() {
      return this.getFocus().map(i => this.view.element(i));
    }
    reveal(index, relativeTop, paddingTop = 0) {
      if (index < 0 || index >= this.length) {
        throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid index ${index}`);
      }
      const scrollTop = this.view.getScrollTop(), elementTop = this.view.elementTop(index);
      index = this.view.elementHeight(index);
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isNumber)(relativeTop)) {
        this.view.setScrollTop((index - this.view.renderHeight + paddingTop) * (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(relativeTop, 0, 1) + elementTop - paddingTop);
      } else {
        relativeTop = elementTop + index;
        const scrollBottom = scrollTop + this.view.renderHeight;
        elementTop < scrollTop + paddingTop && relativeTop >= scrollBottom || (elementTop < scrollTop + paddingTop || relativeTop >= scrollBottom && index >= this.view.renderHeight ? this.view.setScrollTop(elementTop - paddingTop) : relativeTop >= scrollBottom && this.view.setScrollTop(relativeTop - this.view.renderHeight));
      }
    }
    getRelativeTop(index, paddingTop = 0) {
      if (index < 0 || index >= this.length) {
        throw new require$_DOT__SLASH_list_DOT_js.ListError(this.user, `Invalid index ${index}`);
      }
      const scrollTop = this.view.getScrollTop(), elementTop = this.view.elementTop(index);
      index = this.view.elementHeight(index);
      return elementTop < scrollTop + paddingTop || elementTop + index > scrollTop + this.view.renderHeight ? null : Math.abs((scrollTop + paddingTop - elementTop) / (index - this.view.renderHeight + paddingTop));
    }
    getHTMLElement() {
      return this.view.domNode;
    }
    getScrollableElement() {
      return this.view.scrollableElementDomNode;
    }
    getElementID(index) {
      return this.view.getElementDomId(index);
    }
    getElementTop(index) {
      return this.view.elementTop(index);
    }
    style(styles) {
      this.styleController.style(styles);
    }
    toListEvent({indexes, browserEvent}) {
      return {indexes, elements:indexes.map(i => this.view.element(i)), browserEvent};
    }
    _onFocusChange() {
      const focus = this.focus.get();
      this.view.domNode.classList.toggle("element-focused", focus.length > 0);
      this.onDidChangeActiveDescendant();
    }
    onDidChangeActiveDescendant() {
      var _a;
      const focus = this.focus.get();
      if (focus.length > 0) {
        let id;
        if ((_a = this.accessibilityProvider) === null || _a === void 0 ? 0 : _a.getActiveDescendantId) {
          id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));
        }
        this.view.domNode.setAttribute("aria-activedescendant", id || this.view.getElementDomId(focus[0]));
      } else {
        this.view.domNode.removeAttribute("aria-activedescendant");
      }
    }
    _onSelectionChange() {
      const selection = this.selection.get();
      this.view.domNode.classList.toggle("selection-none", selection.length === 0);
      this.view.domNode.classList.toggle("selection-single", selection.length === 1);
      this.view.domNode.classList.toggle("selection-multiple", selection.length > 1);
    }
    dispose() {
      this._onDidDispose.fire();
      this.disposables.dispose();
      this._onDidDispose.dispose();
    }
  }
  require([exports.memoize], List.prototype, "onDidChangeFocus", null);
  require([exports.memoize], List.prototype, "onDidChangeSelection", null);
  require([exports.memoize], List.prototype, "onContextMenu", null);
  require([exports.memoize], List.prototype, "onKeyDown", null);
  require([exports.memoize], List.prototype, "onDidFocus", null);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listWidget.js.map
