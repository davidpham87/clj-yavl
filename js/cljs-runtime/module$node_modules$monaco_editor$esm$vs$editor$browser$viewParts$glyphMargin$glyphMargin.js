shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$glyphMargin$glyphMargin = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DecorationToRender:{enumerable:!0, get:function() {
    return DecorationToRender;
  }}, DedupOverlay:{enumerable:!0, get:function() {
    return DedupOverlay;
  }}, GlyphMarginWidgets:{enumerable:!0, get:function() {
    return GlyphMarginWidgets;
  }}, LineDecorationToRender:{enumerable:!0, get:function() {
    return LineDecorationToRender;
  }}, VisibleLineDecorationsToRender:{enumerable:!0, get:function() {
    return VisibleLineDecorationsToRender;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays");
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$glyphMargin$glyphMargin_css");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$dynamicViewOverlay");
  exports = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class DecorationToRender {
    constructor(startLineNumber, endLineNumber, className, zIndex) {
      this._decorationToRenderBrand = void 0;
      this.startLineNumber = +startLineNumber;
      this.endLineNumber = +endLineNumber;
      this.className = String(className);
      this.zIndex = zIndex !== null && zIndex !== void 0 ? zIndex : 0;
    }
  }
  class LineDecorationToRender {
    constructor(className, zIndex) {
      this.className = className;
      this.zIndex = zIndex;
    }
  }
  class VisibleLineDecorationsToRender {
    constructor() {
      this.decorations = [];
    }
    add(decoration) {
      this.decorations.push(decoration);
    }
    getDecorations() {
      return this.decorations;
    }
  }
  class DedupOverlay extends module.DynamicViewOverlay {
    _render(visibleStartLineNumber, visibleEndLineNumber, decorations) {
      const output = [];
      for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
        output[lineNumber - visibleStartLineNumber] = new VisibleLineDecorationsToRender();
      }
      if (decorations.length === 0) {
        return output;
      }
      decorations.sort((a, b) => a.className === b.className ? a.startLineNumber === b.startLineNumber ? a.endLineNumber - b.endLineNumber : a.startLineNumber - b.startLineNumber : a.className < b.className ? -1 : 1);
      lineNumber = null;
      let prevEndLineIndex = 0;
      for (let i = 0, len = decorations.length; i < len; i++) {
        var d = decorations[i];
        const className = d.className, zIndex = d.zIndex;
        var startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;
        d = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;
        lineNumber === className ? (startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex), prevEndLineIndex = Math.max(prevEndLineIndex, d)) : (lineNumber = className, prevEndLineIndex = d);
        for (; startLineIndex <= prevEndLineIndex; startLineIndex++) {
          output[startLineIndex].add(new LineDecorationToRender(className, zIndex));
        }
      }
      return output;
    }
  }
  class GlyphMarginWidgets extends exports.ViewPart {
    constructor(context) {
      super(context);
      this._widgets = {};
      this._context = context;
      context = this._context.configuration.options;
      const layoutInfo = context.get(143);
      this.domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      this.domNode.setClassName("glyph-margin-widgets");
      this.domNode.setPosition("absolute");
      this.domNode.setTop(0);
      this._lineHeight = context.get(66);
      this._glyphMargin = context.get(57);
      this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
      this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
      this._glyphMarginDecorationLaneCount = layoutInfo.glyphMarginDecorationLaneCount;
      this._managedDomNodes = [];
      this._decorationGlyphsToRender = [];
    }
    dispose() {
      this._managedDomNodes = [];
      this._decorationGlyphsToRender = [];
      this._widgets = {};
      super.dispose();
    }
    getWidgets() {
      return Object.values(this._widgets);
    }
    onConfigurationChanged(e) {
      e = this._context.configuration.options;
      const layoutInfo = e.get(143);
      this._lineHeight = e.get(66);
      this._glyphMargin = e.get(57);
      this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
      this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
      this._glyphMarginDecorationLaneCount = layoutInfo.glyphMarginDecorationLaneCount;
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    addWidget(widget) {
      const domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(widget.getDomNode());
      this._widgets[widget.getId()] = {widget, preference:widget.getPosition(), domNode, renderInfo:null};
      domNode.setPosition("absolute");
      domNode.setDisplay("none");
      domNode.setAttribute("widgetId", widget.getId());
      this.domNode.appendChild(domNode);
      this.setShouldRender();
    }
    setWidgetPosition(widget, preference) {
      widget = this._widgets[widget.getId()];
      if (widget.preference.lane === preference.lane && widget.preference.zIndex === preference.zIndex && require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.equalsRange(widget.preference.range, preference.range)) {
        return !1;
      }
      widget.preference = preference;
      this.setShouldRender();
      return !0;
    }
    removeWidget(widget) {
      var _a;
      widget = widget.getId();
      if (this._widgets[widget]) {
        const domNode = this._widgets[widget].domNode.domNode;
        delete this._widgets[widget];
        (_a = domNode.parentNode) === null || _a === void 0 || _a.removeChild(domNode);
        this.setShouldRender();
      }
    }
    _collectDecorationBasedGlyphRenderRequest(ctx, requests) {
      var _a, _b, _c;
      const visibleStartLineNumber = ctx.visibleRange.startLineNumber, visibleEndLineNumber = ctx.visibleRange.endLineNumber;
      ctx = ctx.getDecorationsInViewport();
      for (const d of ctx) {
        ctx = d.options.glyphMarginClassName;
        if (!ctx) {
          continue;
        }
        var startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
        const endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber), lane = Math.min((_b = (_a = d.options.glyphMargin) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : 1, this._glyphMarginDecorationLaneCount), zIndex = (_c = d.options.zIndex) !== null && _c !== void 0 ? _c : 0;
        for (; startLineNumber <= endLineNumber; startLineNumber++) {
          requests.push(new DecorationBasedGlyphRenderRequest(startLineNumber, lane, zIndex, ctx));
        }
      }
    }
    _collectWidgetBasedGlyphRenderRequest(ctx, requests) {
      const visibleStartLineNumber = ctx.visibleRange.startLineNumber;
      ctx = ctx.visibleRange.endLineNumber;
      for (const widget of Object.values(this._widgets)) {
        const {startLineNumber, endLineNumber} = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.lift(widget.preference.range));
        !startLineNumber || !endLineNumber || endLineNumber < visibleStartLineNumber || startLineNumber > ctx || requests.push(new WidgetBasedGlyphRenderRequest(Math.max(startLineNumber, visibleStartLineNumber), Math.min(widget.preference.lane, this._glyphMarginDecorationLaneCount), widget.preference.zIndex, widget));
      }
    }
    _collectSortedGlyphRenderRequests(ctx) {
      const requests = [];
      this._collectDecorationBasedGlyphRenderRequest(ctx, requests);
      this._collectWidgetBasedGlyphRenderRequest(ctx, requests);
      requests.sort((a, b) => a.lineNumber === b.lineNumber ? a.lane === b.lane ? a.zIndex === b.zIndex ? b.type === a.type ? a.type === 0 && b.type === 0 ? a.className < b.className ? -1 : 1 : 0 : b.type - a.type : b.zIndex - a.zIndex : a.lane - b.lane : a.lineNumber - b.lineNumber);
      return requests;
    }
    prepareRender(ctx) {
      if (this._glyphMargin) {
        for (var widget of Object.values(this._widgets)) {
          widget.renderInfo = null;
        }
        ctx = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.ArrayQueue(this._collectSortedGlyphRenderRequests(ctx));
        for (widget = []; ctx.length > 0;) {
          const first = ctx.peek();
          if (!first) {
            break;
          }
          const requestsAtLocation = ctx.takeWhile(el => el.lineNumber === first.lineNumber && el.lane === first.lane);
          if (!requestsAtLocation || requestsAtLocation.length === 0) {
            break;
          }
          const winner = requestsAtLocation[0];
          if (winner.type === 0) {
            const classNames = [];
            for (const request of requestsAtLocation) {
              if (request.zIndex !== winner.zIndex || request.type !== winner.type) {
                break;
              }
              classNames.length !== 0 && classNames[classNames.length - 1] === request.className || classNames.push(request.className);
            }
            widget.push(winner.accept(classNames.join(" ")));
          } else {
            winner.widget.renderInfo = {lineNumber:winner.lineNumber, lane:winner.lane};
          }
        }
        this._decorationGlyphsToRender = widget;
      } else {
        this._decorationGlyphsToRender = [];
      }
    }
    render(ctx) {
      if (this._glyphMargin) {
        var width = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);
        for (var widget of Object.values(this._widgets)) {
          if (widget.renderInfo) {
            var top = ctx.viewportData.relativeVerticalOffset[widget.renderInfo.lineNumber - ctx.viewportData.startLineNumber], left$jscomp$0 = this._glyphMarginLeft + (widget.renderInfo.lane - 1) * this._lineHeight;
            widget.domNode.setDisplay("block");
            widget.domNode.setTop(top);
            widget.domNode.setLeft(left$jscomp$0);
            widget.domNode.setWidth(width);
            widget.domNode.setHeight(this._lineHeight);
          } else {
            widget.domNode.setDisplay("none");
          }
        }
        for (widget = 0; widget < this._decorationGlyphsToRender.length; widget++) {
          top = this._decorationGlyphsToRender[widget];
          left$jscomp$0 = ctx.viewportData.relativeVerticalOffset[top.lineNumber - ctx.viewportData.startLineNumber];
          const left = this._glyphMarginLeft + (top.lane - 1) * this._lineHeight;
          let domNode;
          widget < this._managedDomNodes.length ? domNode = this._managedDomNodes[widget] : (domNode = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div")), this._managedDomNodes.push(domNode), this.domNode.appendChild(domNode));
          domNode.setClassName("cgmr codicon " + top.combinedClassName);
          domNode.setPosition("absolute");
          domNode.setTop(left$jscomp$0);
          domNode.setLeft(left);
          domNode.setWidth(width);
          domNode.setHeight(this._lineHeight);
        }
        for (; this._managedDomNodes.length > this._decorationGlyphsToRender.length;) {
          ctx = this._managedDomNodes.pop(), ctx === null || ctx === void 0 || ctx.domNode.remove();
        }
      } else {
        for (width of Object.values(this._widgets)) {
          width.domNode.setDisplay("none");
        }
        for (; this._managedDomNodes.length > 0;) {
          ctx = this._managedDomNodes.pop(), ctx === null || ctx === void 0 || ctx.domNode.remove();
        }
      }
    }
  }
  class DecorationBasedGlyphRenderRequest {
    constructor(lineNumber, lane, zIndex, className) {
      this.lineNumber = lineNumber;
      this.lane = lane;
      this.zIndex = zIndex;
      this.className = className;
      this.type = 0;
    }
    accept(combinedClassName) {
      return new DecorationBasedGlyph(this.lineNumber, this.lane, combinedClassName);
    }
  }
  class WidgetBasedGlyphRenderRequest {
    constructor(lineNumber, lane, zIndex, widget) {
      this.lineNumber = lineNumber;
      this.lane = lane;
      this.zIndex = zIndex;
      this.widget = widget;
      this.type = 1;
    }
  }
  class DecorationBasedGlyph {
    constructor(lineNumber, lane, combinedClassName) {
      this.lineNumber = lineNumber;
      this.lane = lane;
      this.combinedClassName = combinedClassName;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$glyphMargin$glyphMargin.js.map
