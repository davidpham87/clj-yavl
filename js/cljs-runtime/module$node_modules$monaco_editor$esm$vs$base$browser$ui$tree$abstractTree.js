shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$abstractTree = function(require, module, exports) {
  function asTreeDragAndDropData(data) {
    return data instanceof require$_DOT__DOT__SLASH_list_SLASH_listView_DOT_js.ElementsDragAndDropData ? new TreeElementsDragAndDropData(data) : data;
  }
  function asListOptions(modelProvider, options) {
    return options && {...options, identityProvider:options.identityProvider && {getId(el) {
      return options.identityProvider.getId(el.element);
    }}, dnd:options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController:options.multipleSelectionController && {isSelectionSingleChangeEvent(e) {
      return options.multipleSelectionController.isSelectionSingleChangeEvent({...e, element:e.element});
    }, isSelectionRangeChangeEvent(e) {
      return options.multipleSelectionController.isSelectionRangeChangeEvent({...e, element:e.element});
    }}, accessibilityProvider:options.accessibilityProvider && {...options.accessibilityProvider, getSetSize(node) {
      const model = modelProvider();
      node = model.getNodeLocation(node);
      node = model.getParentNodeLocation(node);
      return model.getNode(node).visibleChildrenCount;
    }, getPosInSet(node) {
      return node.visibleChildIndex + 1;
    }, isChecked:options.accessibilityProvider && options.accessibilityProvider.isChecked ? node => options.accessibilityProvider.isChecked(node.element) : void 0, getRole:options.accessibilityProvider && options.accessibilityProvider.getRole ? node => options.accessibilityProvider.getRole(node.element) : () => "treeitem", getAriaLabel(e) {
      return options.accessibilityProvider.getAriaLabel(e.element);
    }, getWidgetAriaLabel() {
      return options.accessibilityProvider.getWidgetAriaLabel();
    }, getWidgetRole:options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => "tree", getAriaLevel:options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? node => options.accessibilityProvider.getAriaLevel(node.element) : node => node.depth, getActiveDescendantId:options.accessibilityProvider.getActiveDescendantId && (node => options.accessibilityProvider.getActiveDescendantId(node.element))}, 
    keyboardNavigationLabelProvider:options.keyboardNavigationLabelProvider && {...options.keyboardNavigationLabelProvider, getKeyboardNavigationLabel(node) {
      return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);
    }}};
  }
  function stickyScrollNodeEquals(node1, node2) {
    return node1.position === node2.position && node1.node.element === node2.node.element && node1.startIndex === node2.startIndex && node1.height === node2.height && node1.endIndex === node2.endIndex;
  }
  function asTreeMouseEvent(event) {
    let target = require$_DOT__SLASH_tree_DOT_js.TreeMouseEventTarget.Unknown;
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.hasParentWithClass)(event.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? target = require$_DOT__SLASH_tree_DOT_js.TreeMouseEventTarget.Twistie : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.hasParentWithClass)(event.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? target = require$_DOT__SLASH_tree_DOT_js.TreeMouseEventTarget.Element : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.hasParentWithClass)(event.browserEvent.target, 
    "monaco-tree-type-filter", "monaco-list") && (target = require$_DOT__SLASH_tree_DOT_js.TreeMouseEventTarget.Filter);
    return {browserEvent:event.browserEvent, element:event.element ? event.element.element : null, target};
  }
  function dfs(node, fn) {
    fn(node);
    node.children.forEach(child => dfs(child, fn));
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AbstractTree:{enumerable:!0, get:function() {
    return AbstractTree;
  }}, ComposedTreeDelegate:{enumerable:!0, get:function() {
    return ComposedTreeDelegate;
  }}, FuzzyToggle:{enumerable:!0, get:function() {
    return FuzzyToggle;
  }}, ModeToggle:{enumerable:!0, get:function() {
    return ModeToggle;
  }}, RenderIndentGuides:{enumerable:!0, get:function() {
    return RenderIndentGuides;
  }}, TreeFindMatchType:{enumerable:!0, get:function() {
    return TreeFindMatchType;
  }}, TreeFindMode:{enumerable:!0, get:function() {
    return TreeFindMode;
  }}, TreeRenderer:{enumerable:!0, get:function() {
    return TreeRenderer;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$event");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$keyboardEvent");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$actionbar$actionbar");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$findinput$findInput");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$inputbox$inputBox");
  var require$_DOT__DOT__SLASH_list_SLASH_listView_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listView"), require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listWidget");
  module = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$toggle$toggle");
  var require$_DOT__SLASH_indexTreeModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$indexTreeModel"), require$_DOT__SLASH_tree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$tree");
  require("module$node_modules$monaco_editor$esm$vs$base$common$actions");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$codicons"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$themables"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_map_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$map"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$filters"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$numbers"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$media$tree_css");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js = require("module$node_modules$monaco_editor$esm$vs$nls");
  class TreeElementsDragAndDropData extends require$_DOT__DOT__SLASH_list_SLASH_listView_DOT_js.ElementsDragAndDropData {
    constructor(data) {
      super(data.elements.map(node => node.element));
      this.data = data;
    }
  }
  class TreeNodeListDragAndDrop {
    constructor(modelProvider, dnd) {
      this.modelProvider = modelProvider;
      this.dnd = dnd;
      this.autoExpandDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
    }
    getDragURI(node) {
      return this.dnd.getDragURI(node.element);
    }
    getDragLabel(nodes, originalEvent) {
      if (this.dnd.getDragLabel) {
        return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);
      }
    }
    onDragStart(data, originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 || _b.call(_a, asTreeDragAndDropData(data), originalEvent);
    }
    onDragOver(data, targetNode, targetIndex, originalEvent, raw = !0) {
      var result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
      const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;
      didChangeAutoExpandNode && (this.autoExpandDisposable.dispose(), this.autoExpandNode = targetNode);
      if (typeof targetNode === "undefined") {
        return result;
      }
      didChangeAutoExpandNode && typeof result !== "boolean" && result.autoExpand && (this.autoExpandDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.disposableTimeout)(() => {
        const model = this.modelProvider(), ref = model.getNodeLocation(targetNode);
        model.isCollapsed(ref) && model.setCollapsed(ref, !1);
        this.autoExpandNode = void 0;
      }, 500, this.disposables));
      if (typeof result === "boolean" || !result.accept || typeof result.bubble === "undefined" || result.feedback) {
        return raw ? result : {accept:typeof result === "boolean" ? result : result.accept, effect:typeof result === "boolean" ? void 0 : result.effect, feedback:[targetIndex]};
      }
      if (result.bubble === 1) {
        return result = this.modelProvider(), targetIndex = result.getNodeLocation(targetNode), raw = result.getParentNodeLocation(targetIndex), targetIndex = result.getNode(raw), result = raw && result.getListIndex(raw), this.onDragOver(data, targetIndex, result, originalEvent, !1);
      }
      originalEvent = this.modelProvider();
      targetIndex = originalEvent.getNodeLocation(targetNode);
      data = originalEvent.getListIndex(targetIndex);
      originalEvent = originalEvent.getListRenderCount(targetIndex);
      return {...result, feedback:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(data, data + originalEvent)};
    }
    drop(data, targetNode, targetIndex, originalEvent) {
      this.autoExpandDisposable.dispose();
      this.autoExpandNode = void 0;
      this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
    }
    onDragEnd(originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 || _b.call(_a, originalEvent);
    }
    dispose() {
      this.disposables.dispose();
      this.dnd.dispose();
    }
  }
  class ComposedTreeDelegate {
    constructor(delegate) {
      this.delegate = delegate;
    }
    getHeight(element) {
      return this.delegate.getHeight(element.element);
    }
    getTemplateId(element) {
      return this.delegate.getTemplateId(element.element);
    }
    hasDynamicHeight(element) {
      return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);
    }
    setDynamicHeight(element, height) {
      var _a, _b;
      (_b = (_a = this.delegate).setDynamicHeight) === null || _b === void 0 || _b.call(_a, element.element, height);
    }
  }
  var RenderIndentGuides;
  (function(RenderIndentGuides) {
    RenderIndentGuides.None = "none";
    RenderIndentGuides.OnHover = "onHover";
    RenderIndentGuides.Always = "always";
  })(RenderIndentGuides ||= {});
  class EventCollection {
    get elements() {
      return this._elements;
    }
    constructor(onDidChange, _elements = []) {
      this._elements = _elements;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.onDidChange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.forEach(onDidChange, elements => this._elements = elements, this.disposables);
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  class TreeRenderer {
    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, renderedIndentGuides, options = {}) {
      var _a;
      this.renderer = renderer;
      this.modelProvider = modelProvider;
      this.activeNodes = activeNodes;
      this.renderedIndentGuides = renderedIndentGuides;
      this.renderedElements = new Map();
      this.renderedNodes = new Map();
      this.indent = TreeRenderer.DefaultIndent;
      this.shouldRenderIndentGuides = this.hideTwistiesOfChildlessElements = !1;
      this.activeIndentNodes = new Set();
      this.indentGuidesDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.templateId = renderer.templateId;
      this.updateOptions(options);
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);
      (_a = renderer.onDidChangeTwistieState) === null || _a === void 0 || _a.call(renderer, this.onDidChangeTwistieState, this, this.disposables);
    }
    updateOptions(options = {}) {
      if (typeof options.indent !== "undefined") {
        var indent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(options.indent, 0, 40);
        if (indent !== this.indent) {
          this.indent = indent;
          for (const [node, templateData] of this.renderedNodes) {
            this.renderTreeElement(node, templateData);
          }
        }
      }
      if (typeof options.renderIndentGuides !== "undefined" && (indent = options.renderIndentGuides !== RenderIndentGuides.None, indent !== this.shouldRenderIndentGuides)) {
        this.shouldRenderIndentGuides = indent;
        for (const [node, templateData] of this.renderedNodes) {
          this._renderIndentGuides(node, templateData);
        }
        this.indentGuidesDisposable.dispose();
        indent && (indent = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore(), this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, indent), this.indentGuidesDisposable = indent, this._onDidChangeActiveNodes(this.activeNodes.elements));
      }
      typeof options.hideTwistiesOfChildlessElements !== "undefined" && (this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements);
    }
    renderTemplate(container) {
      var el = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.append)(container, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-tl-row"));
      const indent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.append)(el, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-tl-indent")), twistie = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.append)(el, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-tl-twistie"));
      el = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.append)(el, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-tl-contents"));
      el = this.renderer.renderTemplate(el);
      return {container, indent, twistie, indentGuidesDisposable:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None, templateData:el};
    }
    renderElement(node, index, templateData, height) {
      this.renderedNodes.set(node, templateData);
      this.renderedElements.set(node.element, node);
      this.renderTreeElement(node, templateData);
      this.renderer.renderElement(node, index, templateData.templateData, height);
    }
    disposeElement(node, index, templateData, height) {
      var _a, _b;
      templateData.indentGuidesDisposable.dispose();
      (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 || _b.call(_a, node, index, templateData.templateData, height);
      typeof height === "number" && (this.renderedNodes.delete(node), this.renderedElements.delete(node.element));
    }
    disposeTemplate(templateData) {
      this.renderer.disposeTemplate(templateData.templateData);
    }
    onDidChangeTwistieState(element) {
      if (element = this.renderedElements.get(element)) {
        this.onDidChangeNodeTwistieState(element);
      }
    }
    onDidChangeNodeTwistieState(node) {
      const templateData = this.renderedNodes.get(node);
      templateData && (this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderTreeElement(node, templateData));
    }
    renderTreeElement(node, templateData) {
      var indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;
      templateData.twistie.style.paddingLeft = `${indent}px`;
      templateData.indent.style.width = `${indent + this.indent - 16}px`;
      node.collapsible ? templateData.container.setAttribute("aria-expanded", String(!node.collapsed)) : templateData.container.removeAttribute("aria-expanded");
      templateData.twistie.classList.remove(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js.ThemeIcon.asClassNameArray(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.treeItemExpanded));
      indent = !1;
      this.renderer.renderTwistie && (indent = this.renderer.renderTwistie(node.element, templateData.twistie));
      node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0) ? (indent || templateData.twistie.classList.add(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js.ThemeIcon.asClassNameArray(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.treeItemExpanded)), templateData.twistie.classList.add("collapsible"), templateData.twistie.classList.toggle("collapsed", node.collapsed)) : 
      templateData.twistie.classList.remove("collapsible", "collapsed");
      this._renderIndentGuides(node, templateData);
    }
    _renderIndentGuides(node, templateData) {
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.clearNode)(templateData.indent);
      templateData.indentGuidesDisposable.dispose();
      if (this.shouldRenderIndentGuides) {
        for (var disposableStore = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore(), model = this.modelProvider();;) {
          node = model.getNodeLocation(node);
          node = model.getParentNodeLocation(node);
          if (!node) {
            break;
          }
          const parent = model.getNode(node), guide = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".indent-guide", {style:`width: ${this.indent}px`});
          this.activeIndentNodes.has(parent) && guide.classList.add("active");
          templateData.indent.childElementCount === 0 ? templateData.indent.appendChild(guide) : templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);
          this.renderedIndentGuides.add(parent, guide);
          disposableStore.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => this.renderedIndentGuides.delete(parent, guide)));
          node = parent;
        }
        templateData.indentGuidesDisposable = disposableStore;
      }
    }
    _onDidChangeActiveNodes(nodes) {
      if (this.shouldRenderIndentGuides) {
        var set = new Set(), model = this.modelProvider();
        nodes.forEach(node => {
          const ref = model.getNodeLocation(node);
          try {
            const parentRef = model.getParentNodeLocation(ref);
            node.collapsible && node.children.length > 0 && !node.collapsed ? set.add(node) : parentRef && set.add(model.getNode(parentRef));
          } catch (_a) {
          }
        });
        this.activeIndentNodes.forEach(node => {
          set.has(node) || this.renderedIndentGuides.forEach(node, line => line.classList.remove("active"));
        });
        set.forEach(node => {
          this.activeIndentNodes.has(node) || this.renderedIndentGuides.forEach(node, line => line.classList.add("active"));
        });
        this.activeIndentNodes = set;
      }
    }
    dispose() {
      this.renderedNodes.clear();
      this.renderedElements.clear();
      this.indentGuidesDisposable.dispose();
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this.disposables);
    }
  }
  TreeRenderer.DefaultIndent = 8;
  class FindFilter {
    get totalCount() {
      return this._totalCount;
    }
    get matchCount() {
      return this._matchCount;
    }
    constructor(tree, keyboardNavigationLabelProvider, _filter) {
      this.tree = tree;
      this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
      this._filter = _filter;
      this._matchCount = this._totalCount = 0;
      this._lowercasePattern = this._pattern = "";
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      tree.onWillRefilter(this.reset, this, this.disposables);
    }
    filter(element, parentVisibility) {
      var visibility = 1;
      if (this._filter && (visibility = this._filter.filter(element, parentVisibility), visibility = typeof visibility === "boolean" ? visibility ? 1 : 0 : (0,require$_DOT__SLASH_indexTreeModel_DOT_js.isFilterResult)(visibility) ? (0,require$_DOT__SLASH_indexTreeModel_DOT_js.getVisibleState)(visibility.visibility) : visibility, visibility === 0)) {
        return !1;
      }
      this._totalCount++;
      if (!this._pattern) {
        return this._matchCount++, {data:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.FuzzyScore.Default, visibility};
      }
      parentVisibility = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);
      parentVisibility = Array.isArray(parentVisibility) ? parentVisibility : [parentVisibility];
      for (const l of parentVisibility) {
        const labelStr = l && l.toString();
        if (typeof labelStr === "undefined") {
          return {data:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.FuzzyScore.Default, visibility};
        }
        let score;
        if (this.tree.findMatchType === TreeFindMatchType.Contiguous) {
          const index = labelStr.toLowerCase().indexOf(this._lowercasePattern);
          if (index > -1) {
            score = [Number.MAX_SAFE_INTEGER, 0];
            for (let i = this._lowercasePattern.length; i > 0; i--) {
              score.push(index + i - 1);
            }
          }
        } else {
          score = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.fuzzyScore)(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, {firstMatchCanBeWeak:!0, boostFullMatch:!0});
        }
        if (score) {
          return this._matchCount++, parentVisibility.length === 1 ? {data:score, visibility} : {data:{label:labelStr, score}, visibility};
        }
      }
      return this.tree.findMode === TreeFindMode.Filter ? typeof this.tree.options.defaultFindVisibility === "number" ? this.tree.options.defaultFindVisibility : this.tree.options.defaultFindVisibility ? this.tree.options.defaultFindVisibility(element) : 2 : {data:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.FuzzyScore.Default, visibility};
    }
    reset() {
      this._matchCount = this._totalCount = 0;
    }
    dispose() {
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this.disposables);
    }
  }
  class ModeToggle extends module.Toggle {
    constructor(opts) {
      var _a;
      super({icon:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.listFilter, title:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("filter", "Filter"), isChecked:(_a = opts.isChecked) !== null && _a !== void 0 ? _a : !1, inputActiveOptionBorder:opts.inputActiveOptionBorder, inputActiveOptionForeground:opts.inputActiveOptionForeground, inputActiveOptionBackground:opts.inputActiveOptionBackground});
    }
  }
  class FuzzyToggle extends module.Toggle {
    constructor(opts) {
      var _a;
      super({icon:require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.searchFuzzy, title:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("fuzzySearch", "Fuzzy Match"), isChecked:(_a = opts.isChecked) !== null && _a !== void 0 ? _a : !1, inputActiveOptionBorder:opts.inputActiveOptionBorder, inputActiveOptionForeground:opts.inputActiveOptionForeground, inputActiveOptionBackground:opts.inputActiveOptionBackground});
    }
  }
  var TreeFindMode;
  (function(TreeFindMode) {
    TreeFindMode[TreeFindMode.Highlight = 0] = "Highlight";
    TreeFindMode[TreeFindMode.Filter = 1] = "Filter";
  })(TreeFindMode ||= {});
  var TreeFindMatchType;
  (function(TreeFindMatchType) {
    TreeFindMatchType[TreeFindMatchType.Fuzzy = 0] = "Fuzzy";
    TreeFindMatchType[TreeFindMatchType.Contiguous = 1] = "Contiguous";
  })(TreeFindMatchType ||= {});
  class FindController {
    get pattern() {
      return this._pattern;
    }
    get mode() {
      return this._mode;
    }
    set mode(mode) {
      mode !== this._mode && (this._mode = mode, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(mode));
    }
    get matchType() {
      return this._matchType;
    }
    set matchType(matchType) {
      matchType !== this._matchType && (this._matchType = matchType, this.widget && (this.widget.matchType = this._matchType), this.tree.refilter(), this.render(), this._onDidChangeMatchType.fire(matchType));
    }
    constructor(tree, model, view, filter, contextViewProvider, options = {}) {
      var _a, _b;
      this.tree = tree;
      this.view = view;
      this.filter = filter;
      this.contextViewProvider = contextViewProvider;
      this.options = options;
      this._pattern = "";
      this.width = 0;
      this._onDidChangeMode = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeMode = this._onDidChangeMode.event;
      this._onDidChangeMatchType = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeMatchType = this._onDidChangeMatchType.event;
      this._onDidChangePattern = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this._onDidChangeOpenState = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeOpenState = this._onDidChangeOpenState.event;
      this.enabledDisposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._mode = (_a = tree.options.defaultFindMode) !== null && _a !== void 0 ? _a : TreeFindMode.Highlight;
      this._matchType = (_b = tree.options.defaultFindMatchType) !== null && _b !== void 0 ? _b : TreeFindMatchType.Fuzzy;
      model.onDidSplice(this.onDidSpliceModel, this, this.disposables);
    }
    updateOptions(optionsUpdate = {}) {
      optionsUpdate.defaultFindMode !== void 0 && (this.mode = optionsUpdate.defaultFindMode);
      optionsUpdate.defaultFindMatchType !== void 0 && (this.matchType = optionsUpdate.defaultFindMatchType);
    }
    onDidSpliceModel() {
      this.widget && this.pattern.length !== 0 && (this.tree.refilter(), this.render());
    }
    render() {
      var _a, _b, _c, _d;
      const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;
      this.pattern && noMatches ? ((_a = this.tree.options.showNotFoundMessage) !== null && _a !== void 0 ? _a : 1) ? (_b = this.widget) === null || _b === void 0 || _b.showMessage({type:2, content:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("not found", "No elements found.")}) : (_c = this.widget) === null || _c === void 0 || _c.showMessage({type:2}) : (_d = this.widget) === null || _d === void 0 || _d.clearMessage();
    }
    shouldAllowFocus(node) {
      return !this.widget || !this.pattern || this._mode === TreeFindMode.Filter || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_filters_DOT_js.FuzzyScore.isDefault(node.filterData);
    }
    layout(width) {
      var _a;
      this.width = width;
      (_a = this.widget) === null || _a === void 0 || _a.layout(width);
    }
    dispose() {
      this._history = void 0;
      this._onDidChangePattern.dispose();
      this.enabledDisposables.dispose();
      this.disposables.dispose();
    }
  }
  class StickyScrollState extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(stickyNodes = []) {
      super();
      this.stickyNodes = stickyNodes;
    }
    get count() {
      return this.stickyNodes.length;
    }
    equal(state) {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.equals)(this.stickyNodes, state.stickyNodes, stickyScrollNodeEquals);
    }
    addDisposable(disposable) {
      this._register(disposable);
    }
  }
  class StickyScrollController extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    get firstVisibleNode() {
      const index = this.view.firstVisibleIndex;
      if (!(index < 0 || index >= this.view.length)) {
        return this.view.element(index);
      }
    }
    constructor(tree, model, view, renderers, treeDelegate, options = {}) {
      super();
      this.tree = tree;
      this.model = model;
      this.view = view;
      this.treeDelegate = treeDelegate;
      this.maxWidgetViewRatio = 0.4;
      this.stickyScrollMaxItemCount = this.validateStickySettings(options).stickyScrollMaxItemCount;
      this._widget = this._register(new StickyScrollWidget(view.getScrollableElement(), view, model, renderers, treeDelegate));
      this._register(view.onDidScroll(() => this.update()));
      this._register(view.onDidChangeContentHeight(() => this.update()));
      this._register(tree.onDidChangeCollapseState(() => this.update()));
      this.update();
    }
    update() {
      var firstVisibleNode = this.firstVisibleNode;
      firstVisibleNode && this.tree.scrollTop !== 0 ? (firstVisibleNode = this.findStickyState(firstVisibleNode), this._widget.setState(firstVisibleNode)) : this._widget.setState(void 0);
    }
    findStickyState(firstVisibleNode) {
      const stickyNodes = [], maximumStickyWidgetHeight = this.view.renderHeight * this.maxWidgetViewRatio;
      let stickyNodesHeight = 0, nextStickyNode = this.getNextStickyNode(firstVisibleNode, void 0, stickyNodesHeight);
      for (; nextStickyNode && stickyNodesHeight + nextStickyNode.height < maximumStickyWidgetHeight;) {
        stickyNodes.push(nextStickyNode);
        stickyNodesHeight += nextStickyNode.height;
        if (stickyNodes.length >= this.stickyScrollMaxItemCount) {
          break;
        }
        firstVisibleNode = this.getNextVisibleNode(firstVisibleNode);
        if (!firstVisibleNode) {
          break;
        }
        nextStickyNode = this.getNextStickyNode(firstVisibleNode, nextStickyNode.node, stickyNodesHeight);
      }
      return stickyNodes.length ? new StickyScrollState(stickyNodes) : void 0;
    }
    getNextVisibleNode(node) {
      node = this.getNodeIndex(node);
      if (node !== -1 && node !== this.view.length - 1) {
        return this.view.element(node + 1);
      }
    }
    getNextStickyNode(firstVisibleNodeUnderWidget, previousStickyNode, stickyNodesHeight) {
      if ((previousStickyNode = this.getAncestorUnderPrevious(firstVisibleNodeUnderWidget, previousStickyNode)) && (previousStickyNode !== firstVisibleNodeUnderWidget || this.nodeIsUncollapsedParent(firstVisibleNodeUnderWidget) && !this.nodeTopAlignsWithStickyNodesBottom(firstVisibleNodeUnderWidget, stickyNodesHeight))) {
        return this.createStickyScrollNode(previousStickyNode, stickyNodesHeight);
      }
    }
    nodeTopAlignsWithStickyNodesBottom(node, stickyNodesHeight) {
      node = this.getNodeIndex(node);
      node = this.view.getElementTop(node);
      return this.view.scrollTop === node - stickyNodesHeight;
    }
    createStickyScrollNode(node, currentStickyNodesHeight) {
      const height = this.treeDelegate.getHeight(node), {startIndex, endIndex} = this.getNodeRange(node);
      currentStickyNodesHeight = this.calculateStickyNodePosition(endIndex, currentStickyNodesHeight);
      return {node, position:currentStickyNodesHeight, height, startIndex, endIndex};
    }
    getAncestorUnderPrevious(node, previousAncestor) {
      let parentOfcurrentAncestor = this.getParentNode(node);
      for (; parentOfcurrentAncestor;) {
        if (parentOfcurrentAncestor === previousAncestor) {
          return node;
        }
        node = parentOfcurrentAncestor;
        parentOfcurrentAncestor = this.getParentNode(node);
      }
      if (previousAncestor === void 0) {
        return node;
      }
    }
    calculateStickyNodePosition(lastDescendantIndex, stickyRowPositionTop) {
      var lastChildRelativeTop = this.view.getRelativeTop(lastDescendantIndex);
      if (lastChildRelativeTop === null && this.view.firstVisibleIndex === lastDescendantIndex && lastDescendantIndex + 1 < this.view.length) {
        lastChildRelativeTop = this.treeDelegate.getHeight(this.view.element(lastDescendantIndex));
        const nextNodeRelativeTop = this.view.getRelativeTop(lastDescendantIndex + 1);
        lastChildRelativeTop = nextNodeRelativeTop ? nextNodeRelativeTop - lastChildRelativeTop / this.view.renderHeight : null;
      }
      if (lastChildRelativeTop === null) {
        return stickyRowPositionTop;
      }
      lastDescendantIndex = this.view.element(lastDescendantIndex);
      lastDescendantIndex = this.treeDelegate.getHeight(lastDescendantIndex);
      lastChildRelativeTop *= this.view.renderHeight;
      return stickyRowPositionTop > lastChildRelativeTop && stickyRowPositionTop <= lastChildRelativeTop + lastDescendantIndex ? lastChildRelativeTop : stickyRowPositionTop;
    }
    getParentNode(node) {
      node = this.model.getNodeLocation(node);
      return (node = this.model.getParentNodeLocation(node)) ? this.model.getNode(node) : void 0;
    }
    nodeIsUncollapsedParent(node) {
      node = this.model.getNodeLocation(node);
      return this.model.getListRenderCount(node) > 1;
    }
    getNodeIndex(node, nodeLocation) {
      nodeLocation === void 0 && (nodeLocation = this.model.getNodeLocation(node));
      return this.model.getListIndex(nodeLocation);
    }
    getNodeRange(node) {
      var nodeLocation = this.model.getNodeLocation(node);
      node = this.model.getListIndex(nodeLocation);
      if (node < 0) {
        throw Error("Node not found in tree");
      }
      nodeLocation = this.model.getListRenderCount(nodeLocation);
      return {startIndex:node, endIndex:node + nodeLocation - 1};
    }
    nodePositionTopBelowWidget(node) {
      const ancestors = [];
      for (node = this.getParentNode(node); node;) {
        ancestors.push(node), node = this.getParentNode(node);
      }
      node = 0;
      for (let i = 0; i < ancestors.length && i < this.stickyScrollMaxItemCount; i++) {
        node += this.treeDelegate.getHeight(ancestors[i]);
      }
      return node;
    }
    updateOptions(optionsUpdate = {}) {
      optionsUpdate = this.validateStickySettings(optionsUpdate);
      this.stickyScrollMaxItemCount !== optionsUpdate.stickyScrollMaxItemCount && (this.stickyScrollMaxItemCount = optionsUpdate.stickyScrollMaxItemCount, this.update());
    }
    validateStickySettings(options) {
      let stickyScrollMaxItemCount = 5;
      typeof options.stickyScrollMaxItemCount === "number" && (stickyScrollMaxItemCount = Math.max(options.stickyScrollMaxItemCount, 1));
      return {stickyScrollMaxItemCount};
    }
  }
  class StickyScrollWidget {
    constructor(container, view, model, treeRenderers, treeDelegate) {
      this.view = view;
      this.model = model;
      this.treeRenderers = treeRenderers;
      this.treeDelegate = treeDelegate;
      this._rootDomNode = document.createElement("div");
      this._rootDomNode.classList.add("monaco-tree-sticky-container");
      container.appendChild(this._rootDomNode);
    }
    setState(state) {
      var _a, wasVisible = !!this._previousState && this._previousState.count > 0;
      const isVisible = !!state && state.count > 0;
      if (!(!wasVisible && !isVisible || wasVisible && isVisible && this._previousState.equal(state)) && (wasVisible !== isVisible && this.setVisible(isVisible), (_a = this._previousState) === null || _a === void 0 || _a.dispose(), this._previousState = state, isVisible)) {
        for (_a = state.count - 1; _a >= 0; _a--) {
          wasVisible = _a ? state.stickyNodes[_a - 1] : void 0;
          const {element, disposable} = this.createElement(state.stickyNodes[_a], wasVisible ? wasVisible.position + wasVisible.height : 0);
          this._rootDomNode.appendChild(element);
          state.addDisposable(disposable);
        }
        var shadow = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".monaco-tree-sticky-container-shadow");
        this._rootDomNode.appendChild(shadow);
        state.addDisposable((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => shadow.remove()));
        state = state.stickyNodes[state.count - 1];
        this._rootDomNode.style.height = `${state.position + state.height}px`;
      }
    }
    createElement(stickyNode, currentWidgetHeight) {
      currentWidgetHeight = this.model.getNodeLocation(stickyNode.node);
      currentWidgetHeight = this.model.getListIndex(currentWidgetHeight);
      const stickyElement = document.createElement("div");
      stickyElement.style.top = `${stickyNode.position}px`;
      stickyElement.style.height = `${stickyNode.height}px`;
      stickyElement.style.lineHeight = `${stickyNode.height}px`;
      stickyElement.classList.add("monaco-tree-sticky-row");
      stickyElement.classList.add("monaco-list-row");
      stickyElement.setAttribute("data-index", `${currentWidgetHeight}`);
      stickyElement.setAttribute("data-parity", currentWidgetHeight % 2 === 0 ? "even" : "odd");
      stickyElement.setAttribute("id", this.view.getElementID(currentWidgetHeight));
      const nodeTemplateId = this.treeDelegate.getTemplateId(stickyNode.node), renderer = this.treeRenderers.find(renderer => renderer.templateId === nodeTemplateId);
      if (!renderer) {
        throw Error(`No renderer found for template id ${nodeTemplateId}`);
      }
      const nodeCopy = new Proxy(stickyNode.node, {}), templateData = renderer.renderTemplate(stickyElement);
      renderer.renderElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);
      currentWidgetHeight = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => {
        renderer.disposeElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);
        renderer.disposeTemplate(templateData);
        stickyElement.remove();
      });
      return {element:stickyElement, disposable:currentWidgetHeight};
    }
    setVisible(visible) {
      this._rootDomNode.style.display = visible ? "block" : "none";
    }
    dispose() {
      var _a;
      (_a = this._previousState) === null || _a === void 0 || _a.dispose();
      this._rootDomNode.remove();
    }
  }
  class Trait {
    get nodeSet() {
      this._nodeSet || (this._nodeSet = this.createNodeSet());
      return this._nodeSet;
    }
    constructor(getFirstViewElementWithTrait, identityProvider) {
      this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;
      this.identityProvider = identityProvider;
      this.nodes = [];
      this._onDidChange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChange = this._onDidChange.event;
    }
    set(nodes, browserEvent) {
      (browserEvent !== null && browserEvent !== void 0 && browserEvent.__forceEvent || !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.equals)(this.nodes, nodes)) && this._set(nodes, !1, browserEvent);
    }
    _set(nodes, silent, browserEvent) {
      this.nodes = [...nodes];
      this._nodeSet = this.elements = void 0;
      if (!silent) {
        const that = this;
        this._onDidChange.fire({get elements() {
          return that.get();
        }, browserEvent});
      }
    }
    get() {
      this.elements || (this.elements = this.nodes.map(node => node.element));
      return [...this.elements];
    }
    getNodes() {
      return this.nodes;
    }
    has(node) {
      return this.nodeSet.has(node);
    }
    onDidModelSplice({insertedNodes, deletedNodes}) {
      if (this.identityProvider) {
        var deletedNodesIdSet = new Set(), deletedNodesVisitor = node => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());
        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));
        var insertedNodesMap = new Map(), insertedNodesVisitor = node => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);
        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));
        insertedNodes = [];
        for (var node of this.nodes) {
          deletedNodes = this.identityProvider.getId(node.element).toString(), deletedNodesIdSet.has(deletedNodes) ? (deletedNodes = insertedNodesMap.get(deletedNodes)) && deletedNodes.visible && insertedNodes.push(deletedNodes) : insertedNodes.push(node);
        }
        this.nodes.length > 0 && insertedNodes.length === 0 && (node = this.getFirstViewElementWithTrait()) && insertedNodes.push(node);
        this._set(insertedNodes, !0);
      } else {
        const set = this.createNodeSet(), visit = node => set.delete(node);
        deletedNodes.forEach(node => dfs(node, visit));
        this.set([...set.values()]);
      }
    }
    createNodeSet() {
      const set = new Set();
      for (const node of this.nodes) {
        set.add(node);
      }
      return set;
    }
  }
  class TreeNodeListMouseController extends require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.MouseController {
    constructor(list, tree, stickyScrollProvider) {
      super(list);
      this.tree = tree;
      this.stickyScrollProvider = stickyScrollProvider;
    }
    onViewPointer(e) {
      if (!((0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isButton)(e.browserEvent.target) || (0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isInputElement)(e.browserEvent.target) || (0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isMonacoEditor)(e.browserEvent.target) || e.browserEvent.isHandledByList)) {
        var node = e.element;
        if (!node || this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {
          return super.onViewPointer(e);
        }
        var target = e.browserEvent.target;
        target = target.classList.contains("monaco-tl-twistie") || target.classList.contains("monaco-icon-label") && target.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
        var isStickyElement = (0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isStickyScrollElement)(e.browserEvent.target);
        var expandOnlyOnTwistieClick = isStickyElement ? !0 : typeof this.tree.expandOnlyOnTwistieClick === "function" ? this.tree.expandOnlyOnTwistieClick(node.element) : !!this.tree.expandOnlyOnTwistieClick;
        if (isStickyElement) {
          this.handleStickyScrollMouseEvent(e, node);
        } else {
          if (expandOnlyOnTwistieClick && !target && e.browserEvent.detail !== 2 || !this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {
            return super.onViewPointer(e);
          }
        }
        if (node.collapsible && (!isStickyElement || target)) {
          node = this.tree.getNodeLocation(node);
          const recursive = e.browserEvent.altKey;
          this.tree.setFocus([node]);
          this.tree.toggleCollapsed(node, recursive);
          if (expandOnlyOnTwistieClick && target) {
            e.browserEvent.isHandledByList = !0;
            return;
          }
        }
        if (!isStickyElement) {
          super.onViewPointer(e);
        }
      }
    }
    handleStickyScrollMouseEvent(e, node) {
      if (!(0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isMonacoCustomToggle)(e.browserEvent.target) && !(0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isActionItem)(e.browserEvent.target)) {
        var stickyScrollController = this.stickyScrollProvider();
        if (!stickyScrollController) {
          throw Error("Sticky scroll controller not found");
        }
        e = this.list.indexOf(node);
        var elementScrollTop = this.list.getElementTop(e);
        node = stickyScrollController.nodePositionTopBelowWidget(node);
        this.tree.scrollTop = elementScrollTop - node;
        this.list.setFocus([e]);
        this.list.setSelection([e]);
      }
    }
    onDoubleClick(e) {
      if (!e.browserEvent.target.classList.contains("monaco-tl-twistie") && this.tree.expandOnDoubleClick && !e.browserEvent.isHandledByList) {
        super.onDoubleClick(e);
      }
    }
  }
  class TreeNodeList extends require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.List {
    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {
      super(user, container, virtualDelegate, renderers, options);
      this.focusTrait = focusTrait;
      this.selectionTrait = selectionTrait;
      this.anchorTrait = anchorTrait;
    }
    createMouseController(options) {
      return new TreeNodeListMouseController(this, options.tree, options.stickyScrollProvider);
    }
    splice(start, deleteCount, elements = []) {
      super.splice(start, deleteCount, elements);
      if (elements.length !== 0) {
        var additionalFocus = [], additionalSelection = [], anchor;
        elements.forEach((node, index) => {
          this.focusTrait.has(node) && additionalFocus.push(start + index);
          this.selectionTrait.has(node) && additionalSelection.push(start + index);
          this.anchorTrait.has(node) && (anchor = start + index);
        });
        additionalFocus.length > 0 && super.setFocus((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.distinct)([...super.getFocus(), ...additionalFocus]));
        additionalSelection.length > 0 && super.setSelection((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.distinct)([...super.getSelection(), ...additionalSelection]));
        typeof anchor === "number" && super.setAnchor(anchor);
      }
    }
    setFocus(indexes, browserEvent, fromAPI = !1) {
      super.setFocus(indexes, browserEvent);
      fromAPI || this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);
    }
    setSelection(indexes, browserEvent, fromAPI = !1) {
      super.setSelection(indexes, browserEvent);
      fromAPI || this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);
    }
    setAnchor(index, fromAPI = !1) {
      super.setAnchor(index);
      fromAPI || (typeof index === "undefined" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(index)]));
    }
  }
  class AbstractTree {
    get onDidScroll() {
      return this.view.onDidScroll;
    }
    get onDidChangeFocus() {
      return this.eventBufferer.wrapEvent(this.focus.onDidChange);
    }
    get onDidChangeSelection() {
      return this.eventBufferer.wrapEvent(this.selection.onDidChange);
    }
    get onMouseDblClick() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.filter(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== require$_DOT__SLASH_tree_DOT_js.TreeMouseEventTarget.Filter);
    }
    get onPointer() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.view.onPointer, asTreeMouseEvent);
    }
    get onDidFocus() {
      return this.view.onDidFocus;
    }
    get onDidChangeModel() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.signal(this.model.onDidSplice);
    }
    get onDidChangeCollapseState() {
      return this.model.onDidChangeCollapseState;
    }
    get findMode() {
      var _a, _b;
      return (_b = (_a = this.findController) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : TreeFindMode.Highlight;
    }
    set findMode(findMode) {
      this.findController && (this.findController.mode = findMode);
    }
    get findMatchType() {
      var _a, _b;
      return (_b = (_a = this.findController) === null || _a === void 0 ? void 0 : _a.matchType) !== null && _b !== void 0 ? _b : TreeFindMatchType.Fuzzy;
    }
    set findMatchType(findFuzzy) {
      this.findController && (this.findController.matchType = findFuzzy);
    }
    get expandOnDoubleClick() {
      return typeof this._options.expandOnDoubleClick === "undefined" ? !0 : this._options.expandOnDoubleClick;
    }
    get expandOnlyOnTwistieClick() {
      return typeof this._options.expandOnlyOnTwistieClick === "undefined" ? !0 : this._options.expandOnlyOnTwistieClick;
    }
    get onDidDispose() {
      return this.view.onDidDispose;
    }
    constructor(_user, container, delegate, renderers, _options = {}) {
      var _a;
      this._user = _user;
      this._options = _options;
      this.eventBufferer = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.EventBufferer();
      this.onDidChangeFindOpenState = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.None;
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._onWillRefilter = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onWillRefilter = this._onWillRefilter.event;
      this._onDidUpdateOptions = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.treeDelegate = new ComposedTreeDelegate(delegate);
      const onDidChangeCollapseStateRelay = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Relay();
      delegate = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Relay();
      const activeNodes = this.disposables.add(new EventCollection(delegate.event)), renderedIndentGuides = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_map_DOT_js.SetMap();
      this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, renderedIndentGuides, _options));
      for (const r of this.renderers) {
        this.disposables.add(r);
      }
      let filter;
      _options.keyboardNavigationLabelProvider && (filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter), _options = {..._options, filter}, this.disposables.add(filter));
      this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);
      this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);
      this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);
      this.view = new TreeNodeList(_user, container, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, {...asListOptions(() => this.model, _options), tree:this, stickyScrollProvider:() => this.stickyScrollController});
      this.model = this.createModel(_user, this.view, _options);
      onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;
      _user = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.forEach(this.model.onDidSplice, e => {
        this.eventBufferer.bufferEvents(() => {
          this.focus.onDidModelSplice(e);
          this.selection.onDidModelSplice(e);
        });
      }, this.disposables);
      _user(() => null, null, this.disposables);
      const activeNodesEmitter = this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter()), activeNodesDebounce = this.disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.Delayer(0));
      this.disposables.add(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.any(_user, this.focus.onDidChange, this.selection.onDidChange)(() => {
        activeNodesDebounce.trigger(() => {
          const set = new Set();
          for (const node of this.focus.getNodes()) {
            set.add(node);
          }
          for (const node of this.selection.getNodes()) {
            set.add(node);
          }
          activeNodesEmitter.fire([...set.values()]);
        });
      }));
      delegate.input = activeNodesEmitter.event;
      _options.keyboardSupport !== !1 && (_user = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(this.view.onKeyDown, $ => $.filter(e => !(0,require$_DOT__DOT__SLASH_list_SLASH_listWidget_DOT_js.isInputElement)(e.target)).map(e => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_keyboardEvent_DOT_js.StandardKeyboardEvent(e))), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(_user, $ => $.filter(e => e.keyCode === 
      15))(this.onLeftArrow, this, this.disposables), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(_user, $ => $.filter(e => e.keyCode === 17))(this.onRightArrow, this, this.disposables), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.chain(_user, $ => $.filter(e => e.keyCode === 10))(this.onSpace, this, this.disposables));
      ((_a = _options.findWidgetEnabled) !== null && _a !== void 0 ? _a : 1) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider ? (this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider, this.options.findWidgetStyles ? {styles:this.options.findWidgetStyles} : void 0), this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, 
      this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode, this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType) : this.onDidChangeFindMatchType = this.onDidChangeFindMode = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.None;
      _options.enableStickyScroll && (this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, _options));
      this.styleElement = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createStyleSheet)(this.view.getHTMLElement());
      this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === RenderIndentGuides.Always);
    }
    updateOptions(optionsUpdate = {}) {
      var _a;
      this._options = {...this._options, ...optionsUpdate};
      for (const renderer of this.renderers) {
        renderer.updateOptions(optionsUpdate);
      }
      this.view.updateOptions(this._options);
      (_a = this.findController) === null || _a === void 0 || _a.updateOptions(optionsUpdate);
      this.updateStickyScroll(optionsUpdate);
      this._onDidUpdateOptions.fire(this._options);
      this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === RenderIndentGuides.Always);
    }
    get options() {
      return this._options;
    }
    updateStickyScroll(optionsUpdate) {
      var _a;
      !this.stickyScrollController && this._options.enableStickyScroll ? this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, this._options) : this.stickyScrollController && !this._options.enableStickyScroll && (this.stickyScrollController.dispose(), this.stickyScrollController = void 0);
      (_a = this.stickyScrollController) === null || _a === void 0 || _a.updateOptions(optionsUpdate);
    }
    getHTMLElement() {
      return this.view.getHTMLElement();
    }
    get scrollTop() {
      return this.view.scrollTop;
    }
    set scrollTop(scrollTop) {
      this.view.scrollTop = scrollTop;
    }
    get scrollHeight() {
      return this.view.scrollHeight;
    }
    get renderHeight() {
      return this.view.renderHeight;
    }
    domFocus() {
      this.view.domFocus();
    }
    layout(height, width) {
      var _a;
      this.view.layout(height, width);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isNumber)(width) && ((_a = this.findController) === null || _a === void 0 || _a.layout(width));
    }
    style(styles) {
      const suffix = `.${this.view.domId}`, content = [];
      styles.treeIndentGuidesStroke && (content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeInactiveIndentGuidesStroke}; }`), content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`));
      styles.listBackground && (content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${styles.listBackground}; }`), content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${styles.listBackground}; }`));
      this.styleElement.textContent = content.join("\n");
      this.view.style(styles);
    }
    getParentElement(location) {
      location = this.model.getParentNodeLocation(location);
      return this.model.getNode(location).element;
    }
    getFirstElementChild(location) {
      return this.model.getFirstElementChild(location);
    }
    getNode(location) {
      return this.model.getNode(location);
    }
    getNodeLocation(node) {
      return this.model.getNodeLocation(node);
    }
    collapse(location, recursive = !1) {
      return this.model.setCollapsed(location, !0, recursive);
    }
    expand(location, recursive = !1) {
      return this.model.setCollapsed(location, !1, recursive);
    }
    toggleCollapsed(location, recursive = !1) {
      return this.model.setCollapsed(location, void 0, recursive);
    }
    isCollapsible(location) {
      return this.model.isCollapsible(location);
    }
    setCollapsible(location, collapsible) {
      return this.model.setCollapsible(location, collapsible);
    }
    isCollapsed(location) {
      return this.model.isCollapsed(location);
    }
    refilter() {
      this._onWillRefilter.fire(void 0);
      this.model.refilter();
    }
    setSelection(elements, browserEvent) {
      const nodes = elements.map(e => this.model.getNode(e));
      this.selection.set(nodes, browserEvent);
      elements = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);
      this.view.setSelection(elements, browserEvent, !0);
    }
    getSelection() {
      return this.selection.get();
    }
    setFocus(elements, browserEvent) {
      const nodes = elements.map(e => this.model.getNode(e));
      this.focus.set(nodes, browserEvent);
      elements = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);
      this.view.setFocus(elements, browserEvent, !0);
    }
    getFocus() {
      return this.focus.get();
    }
    reveal(location, relativeTop) {
      this.model.expandTo(location);
      const index = this.model.getListIndex(location);
      index !== -1 && (this.stickyScrollController ? (location = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(location)), this.view.reveal(index, relativeTop, location)) : this.view.reveal(index, relativeTop));
    }
    onLeftArrow(e) {
      e.preventDefault();
      e.stopPropagation();
      e = this.view.getFocusedElements();
      e.length !== 0 && (e = this.model.getNodeLocation(e[0]), !this.model.setCollapsed(e, !0) && (e = this.model.getParentNodeLocation(e))) && (e = this.model.getListIndex(e), this.view.reveal(e), this.view.setFocus([e]));
    }
    onRightArrow(e) {
      e.preventDefault();
      e.stopPropagation();
      e = this.view.getFocusedElements();
      if (e.length !== 0) {
        e = e[0];
        var location = this.model.getNodeLocation(e);
        !this.model.setCollapsed(location, !1) && e.children.some(child => child.visible) && ([e] = this.view.getFocus(), e += 1, this.view.reveal(e), this.view.setFocus([e]));
      }
    }
    onSpace(e) {
      e.preventDefault();
      e.stopPropagation();
      var nodes = this.view.getFocusedElements();
      nodes.length !== 0 && (nodes = this.model.getNodeLocation(nodes[0]), this.model.setCollapsed(nodes, void 0, e.browserEvent.altKey));
    }
    dispose() {
      var _a;
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this.disposables);
      (_a = this.stickyScrollController) === null || _a === void 0 || _a.dispose();
      this.view.dispose();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$abstractTree.js.map
