shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$currentLineHighlight$currentLineHighlight = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AbstractLineHighlightOverlay:{enumerable:!0, get:function() {
    return AbstractLineHighlightOverlay;
  }}, CurrentLineHighlightOverlay:{enumerable:!0, get:function() {
    return CurrentLineHighlightOverlay;
  }}, CurrentLineMarginHighlightOverlay:{enumerable:!0, get:function() {
    return CurrentLineMarginHighlightOverlay;
  }}});
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$currentLineHighlight$currentLineHighlight_css");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$dynamicViewOverlay");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$editorColorRegistry"), arrays = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays");
  exports = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$themeService");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_theme_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$theme");
  class AbstractLineHighlightOverlay extends module.DynamicViewOverlay {
    constructor(context) {
      super();
      this._context = context;
      context = this._context.configuration.options;
      const layoutInfo = context.get(143);
      this._lineHeight = context.get(66);
      this._renderLineHighlight = context.get(95);
      this._renderLineHighlightOnlyWhenFocus = context.get(96);
      this._contentLeft = layoutInfo.contentLeft;
      this._contentWidth = layoutInfo.contentWidth;
      this._selectionIsEmpty = !0;
      this._focused = !1;
      this._cursorLineNumbers = [1];
      this._selections = [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(1, 1, 1, 1)];
      this._renderData = null;
      this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this);
      super.dispose();
    }
    _readFromSelections() {
      let hasChanged = !1;
      var cursorsLineNumbers = this._selections.map(s => s.positionLineNumber);
      cursorsLineNumbers.sort((a, b) => a - b);
      arrays.equals(this._cursorLineNumbers, cursorsLineNumbers) || (this._cursorLineNumbers = cursorsLineNumbers, hasChanged = !0);
      cursorsLineNumbers = this._selections.every(s => s.isEmpty());
      this._selectionIsEmpty !== cursorsLineNumbers && (this._selectionIsEmpty = cursorsLineNumbers, hasChanged = !0);
      return hasChanged;
    }
    onThemeChanged(e) {
      return this._readFromSelections();
    }
    onConfigurationChanged(e) {
      e = this._context.configuration.options;
      const layoutInfo = e.get(143);
      this._lineHeight = e.get(66);
      this._renderLineHighlight = e.get(95);
      this._renderLineHighlightOnlyWhenFocus = e.get(96);
      this._contentLeft = layoutInfo.contentLeft;
      this._contentWidth = layoutInfo.contentWidth;
      return !0;
    }
    onCursorStateChanged(e) {
      this._selections = e.selections;
      return this._readFromSelections();
    }
    onFlushed(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollWidthChanged || e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    onFocusChanged(e) {
      if (!this._renderLineHighlightOnlyWhenFocus) {
        return !1;
      }
      this._focused = e.isFocused;
      return !0;
    }
    prepareRender(ctx) {
      if (this._shouldRenderThis()) {
        var renderedLine = this._renderOne(ctx), visibleStartLineNumber = ctx.visibleRange.startLineNumber;
        ctx = ctx.visibleRange.endLineNumber;
        var len = this._cursorLineNumbers.length, index = 0, renderData = [];
        for (let lineNumber = visibleStartLineNumber; lineNumber <= ctx; lineNumber++) {
          const lineIndex = lineNumber - visibleStartLineNumber;
          for (; index < len && this._cursorLineNumbers[index] < lineNumber;) {
            index++;
          }
          renderData[lineIndex] = index < len && this._cursorLineNumbers[index] === lineNumber ? renderedLine : "";
        }
        this._renderData = renderData;
      } else {
        this._renderData = null;
      }
    }
    render(startLineNumber, lineNumber) {
      if (!this._renderData) {
        return "";
      }
      startLineNumber = lineNumber - startLineNumber;
      return startLineNumber >= this._renderData.length ? "" : this._renderData[startLineNumber];
    }
    _shouldRenderInMargin() {
      return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
    }
    _shouldRenderInContent() {
      return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
    }
  }
  class CurrentLineHighlightOverlay extends AbstractLineHighlightOverlay {
    _renderOne(ctx) {
      return `<div class="${"current-line" + (this._shouldRenderOther() ? " current-line-both" : "")}" style="width:${Math.max(ctx.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;"></div>`;
    }
    _shouldRenderThis() {
      return this._shouldRenderInContent();
    }
    _shouldRenderOther() {
      return this._shouldRenderInMargin();
    }
  }
  class CurrentLineMarginHighlightOverlay extends AbstractLineHighlightOverlay {
    _renderOne(ctx) {
      return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "")}" style="width:${this._contentLeft}px; height:${this._lineHeight}px;"></div>`;
    }
    _shouldRenderThis() {
      return !0;
    }
    _shouldRenderOther() {
      return this._shouldRenderInContent();
    }
  }
  (0,exports.registerThemingParticipant)((theme, collector) => {
    var lineHighlight = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js.editorLineHighlight);
    lineHighlight && (collector.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${lineHighlight}; }`), collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${lineHighlight}; border: none; }`));
    if (!lineHighlight || lineHighlight.isTransparent() || theme.defines(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js.editorLineHighlightBorder)) {
      if (lineHighlight = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_editorColorRegistry_DOT_js.editorLineHighlightBorder)) {
        collector.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${lineHighlight}; }`), collector.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${lineHighlight}; }`), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_theme_DOT_js.isHighContrast)(theme.type) && (collector.addRule(".monaco-editor .view-overlays .current-line { border-width: 1px; }"), collector.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }"));
      }
    }
  });
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$currentLineHighlight$currentLineHighlight.js.map
