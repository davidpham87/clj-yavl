shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$selections$selections = function(require, module, exports) {
  function toStyledRange(item) {
    return new HorizontalRangeWithStyle(item);
  }
  function toStyled(item) {
    return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));
  }
  function abs(n) {
    return n < 0 ? -n : n;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SelectionsOverlay:{enumerable:!0, get:function() {
    return SelectionsOverlay;
  }}});
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$selections$selections_css");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$dynamicViewOverlay");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$colorRegistry");
  require = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$themeService");
  class HorizontalRangeWithStyle {
    constructor(other) {
      this.left = other.left;
      this.width = other.width;
      this.endStyle = this.startStyle = null;
    }
  }
  class LineVisibleRangesWithStyle {
    constructor(lineNumber, ranges) {
      this.lineNumber = lineNumber;
      this.ranges = ranges;
    }
  }
  class SelectionsOverlay extends module.DynamicViewOverlay {
    constructor(context) {
      super();
      this._previousFrameVisibleRangesWithStyle = [];
      this._context = context;
      context = this._context.configuration.options;
      this._lineHeight = context.get(66);
      this._roundedSelection = context.get(100);
      this._typicalHalfwidthCharacterWidth = context.get(50).typicalHalfwidthCharacterWidth;
      this._selections = [];
      this._renderResult = null;
      this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this);
      this._renderResult = null;
      super.dispose();
    }
    onConfigurationChanged(e) {
      e = this._context.configuration.options;
      this._lineHeight = e.get(66);
      this._roundedSelection = e.get(100);
      this._typicalHalfwidthCharacterWidth = e.get(50).typicalHalfwidthCharacterWidth;
      return !0;
    }
    onCursorStateChanged(e) {
      this._selections = e.selections.slice(0);
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _visibleRangesHaveGaps(linesVisibleRanges) {
      for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {
        if (linesVisibleRanges[i].ranges.length > 1) {
          return !0;
        }
      }
      return !1;
    }
    _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {
      const epsilon = this._typicalHalfwidthCharacterWidth / 4;
      let previousFrameTop = null, previousFrameBottom = null;
      if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {
        var topLineNumber = linesVisibleRanges[0].lineNumber;
        if (topLineNumber === viewport.startLineNumber) {
          for (var i$jscomp$0 = 0; !previousFrameTop && i$jscomp$0 < previousFrame.length; i$jscomp$0++) {
            previousFrame[i$jscomp$0].lineNumber === topLineNumber && (previousFrameTop = previousFrame[i$jscomp$0].ranges[0]);
          }
        }
        topLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;
        if (topLineNumber === viewport.endLineNumber) {
          for (viewport = previousFrame.length - 1; !previousFrameBottom && viewport >= 0; viewport--) {
            previousFrame[viewport].lineNumber === topLineNumber && (previousFrameBottom = previousFrame[viewport].ranges[0]);
          }
        }
        previousFrameTop && !previousFrameTop.startStyle && (previousFrameTop = null);
        previousFrameBottom && !previousFrameBottom.startStyle && (previousFrameBottom = null);
      }
      for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {
        previousFrame = linesVisibleRanges[i].ranges[0];
        viewport = previousFrame.left;
        topLineNumber = previousFrame.left + previousFrame.width;
        i$jscomp$0 = {top:0, bottom:0};
        const endStyle = {top:0, bottom:0};
        if (i > 0) {
          var prevLeft = linesVisibleRanges[i - 1].ranges[0].left, prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;
          abs(viewport - prevLeft) < epsilon ? i$jscomp$0.top = 2 : viewport > prevLeft && (i$jscomp$0.top = 1);
          abs(topLineNumber - prevRight) < epsilon ? endStyle.top = 2 : prevLeft < topLineNumber && topLineNumber < prevRight && (endStyle.top = 1);
        } else {
          previousFrameTop && (i$jscomp$0.top = previousFrameTop.startStyle.top, endStyle.top = previousFrameTop.endStyle.top);
        }
        i + 1 < len ? (prevLeft = linesVisibleRanges[i + 1].ranges[0].left, prevRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width, abs(viewport - prevLeft) < epsilon ? i$jscomp$0.bottom = 2 : prevLeft < viewport && viewport < prevRight && (i$jscomp$0.bottom = 1), abs(topLineNumber - prevRight) < epsilon ? endStyle.bottom = 2 : topLineNumber < prevRight && (endStyle.bottom = 1)) : previousFrameBottom && (i$jscomp$0.bottom = previousFrameBottom.startStyle.bottom, 
        endStyle.bottom = previousFrameBottom.endStyle.bottom);
        previousFrame.startStyle = i$jscomp$0;
        previousFrame.endStyle = endStyle;
      }
    }
    _getVisibleRangesWithStyle(selection, ctx, previousFrame) {
      selection = (ctx.linesVisibleRangesForRange(selection, !0) || []).map(toStyled);
      !this._visibleRangesHaveGaps(selection) && this._roundedSelection && this._enrichVisibleRangesWithStyle(ctx.visibleRange, selection, previousFrame);
      return selection;
    }
    _createSelectionPiece(top, height, className, left, width) {
      return '\x3cdiv class\x3d"cslr ' + className + '" style\x3d"top:' + top.toString() + "px;left:" + left.toString() + "px;width:" + width.toString() + "px;height:" + height + 'px;"\x3e\x3c/div\x3e';
    }
    _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {
      if (visibleRanges.length !== 0) {
        var visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle, fullLineHeight = this._lineHeight.toString(), reducedLineHeight = (this._lineHeight - 1).toString(), firstLineNumber = visibleRanges[0].lineNumber, lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;
        for (let i = 0, len = visibleRanges.length; i < len; i++) {
          const lineVisibleRanges = visibleRanges[i];
          var lineNumber = lineVisibleRanges.lineNumber;
          const lineIndex = lineNumber - visibleStartLineNumber, lineHeight = hasMultipleSelections ? lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight : fullLineHeight;
          lineNumber = hasMultipleSelections ? lineNumber === firstLineNumber ? 1 : 0 : 0;
          let innerCornerOutput = "", restOfSelectionOutput = "";
          for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {
            const visibleRange = lineVisibleRanges.ranges[j];
            if (visibleRangesHaveStyle) {
              var startStyle = visibleRange.startStyle, endStyle = visibleRange.endStyle;
              if (startStyle.top === 1 || startStyle.bottom === 1) {
                innerCornerOutput += this._createSelectionPiece(lineNumber, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                var className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                startStyle.top === 1 && (className += " " + SelectionsOverlay.SELECTION_TOP_RIGHT);
                startStyle.bottom === 1 && (className += " " + SelectionsOverlay.SELECTION_BOTTOM_RIGHT);
                innerCornerOutput += this._createSelectionPiece(lineNumber, lineHeight, className, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
              }
              if (endStyle.top === 1 || endStyle.bottom === 1) {
                innerCornerOutput += this._createSelectionPiece(lineNumber, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH), startStyle = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME, endStyle.top === 1 && (startStyle += " " + SelectionsOverlay.SELECTION_TOP_LEFT), endStyle.bottom === 1 && (startStyle += " " + SelectionsOverlay.SELECTION_BOTTOM_LEFT), innerCornerOutput += this._createSelectionPiece(lineNumber, lineHeight, 
                startStyle, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
              }
            }
            endStyle = SelectionsOverlay.SELECTION_CLASS_NAME;
            visibleRangesHaveStyle && (startStyle = visibleRange.startStyle, className = visibleRange.endStyle, startStyle.top === 0 && (endStyle += " " + SelectionsOverlay.SELECTION_TOP_LEFT), startStyle.bottom === 0 && (endStyle += " " + SelectionsOverlay.SELECTION_BOTTOM_LEFT), className.top === 0 && (endStyle += " " + SelectionsOverlay.SELECTION_TOP_RIGHT), className.bottom === 0 && (endStyle += " " + SelectionsOverlay.SELECTION_BOTTOM_RIGHT));
            restOfSelectionOutput += this._createSelectionPiece(lineNumber, lineHeight, endStyle, visibleRange.left, visibleRange.width);
          }
          output2[lineIndex][0] += innerCornerOutput;
          output2[lineIndex][1] += restOfSelectionOutput;
        }
      }
    }
    prepareRender(ctx) {
      const output = [], visibleStartLineNumber = ctx.visibleRange.startLineNumber;
      var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
      for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
        output[lineNumber - visibleStartLineNumber] = ["", ""];
      }
      visibleEndLineNumber = [];
      for (let i = 0, len = this._selections.length; i < len; i++) {
        lineNumber = this._selections[i], lineNumber.isEmpty() ? visibleEndLineNumber[i] = null : (lineNumber = this._getVisibleRangesWithStyle(lineNumber, ctx, this._previousFrameVisibleRangesWithStyle[i]), visibleEndLineNumber[i] = lineNumber, this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, lineNumber));
      }
      this._previousFrameVisibleRangesWithStyle = visibleEndLineNumber;
      this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);
    }
    render(startLineNumber, lineNumber) {
      if (!this._renderResult) {
        return "";
      }
      startLineNumber = lineNumber - startLineNumber;
      return startLineNumber < 0 || startLineNumber >= this._renderResult.length ? "" : this._renderResult[startLineNumber];
    }
  }
  SelectionsOverlay.SELECTION_CLASS_NAME = "selected-text";
  SelectionsOverlay.SELECTION_TOP_LEFT = "top-left-radius";
  SelectionsOverlay.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
  SelectionsOverlay.SELECTION_TOP_RIGHT = "top-right-radius";
  SelectionsOverlay.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
  SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
  SelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;
  (0,require.registerThemingParticipant)((theme, collector) => {
    (theme = theme.getColor(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_theme_SLASH_common_SLASH_colorRegistry_DOT_js.editorSelectionForeground)) && !theme.isTransparent() && collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${theme}; }`);
  });
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$selections$selections.js.map
