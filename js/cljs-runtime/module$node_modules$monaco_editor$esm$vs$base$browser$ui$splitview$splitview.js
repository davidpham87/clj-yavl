shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$splitview$splitview = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Sizing:{enumerable:!0, get:function() {
    return Sizing;
  }}, SplitView:{enumerable:!0, get:function() {
    return SplitView;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$event"), require$_DOT__DOT__SLASH_sash_SLASH_sash_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$sash$sash"), require$_DOT__DOT__SLASH_scrollbar_SLASH_scrollableElement_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$scrollbar$scrollableElement"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$color");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$numbers"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_scrollable_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$scrollable"), types = require("module$node_modules$monaco_editor$esm$vs$base$common$types");
  require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$splitview$splitview_css");
  const defaultStyles = {separatorBorder:module.Color.transparent};
  class ViewItem {
    set size(size) {
      this._size = size;
    }
    get size() {
      return this._size;
    }
    get visible() {
      return typeof this._cachedVisibleSize === "undefined";
    }
    setVisible(visible, size) {
      var _a, _b;
      if (visible !== this.visible) {
        visible ? (this.size = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof size === "number" ? size : this.size, this.size = 0);
        this.container.classList.toggle("visible", visible);
        try {
          (_b = (_a = this.view).setVisible) === null || _b === void 0 || _b.call(_a, visible);
        } catch (e) {
          console.error("Splitview: Failed to set visible view"), console.error(e);
        }
      }
    }
    get minimumSize() {
      return this.visible ? this.view.minimumSize : 0;
    }
    get viewMinimumSize() {
      return this.view.minimumSize;
    }
    get maximumSize() {
      return this.visible ? this.view.maximumSize : 0;
    }
    get viewMaximumSize() {
      return this.view.maximumSize;
    }
    get priority() {
      return this.view.priority;
    }
    get proportionalLayout() {
      var _a;
      return (_a = this.view.proportionalLayout) !== null && _a !== void 0 ? _a : !0;
    }
    get snap() {
      return !!this.view.snap;
    }
    set enabled(enabled) {
      this.container.style.pointerEvents = enabled ? "" : "none";
    }
    constructor(container, view, size, disposable) {
      this.container = container;
      this.view = view;
      this.disposable = disposable;
      this._cachedVisibleSize = void 0;
      typeof size === "number" ? (this._size = size, this._cachedVisibleSize = void 0, container.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = size.cachedVisibleSize);
    }
    layout(offset, layoutContext) {
      this.layoutContainer(offset);
      try {
        this.view.layout(this.size, offset, layoutContext);
      } catch (e) {
        console.error("Splitview: Failed to layout view"), console.error(e);
      }
    }
    dispose() {
      this.disposable.dispose();
    }
  }
  class VerticalViewItem extends ViewItem {
    layoutContainer(offset) {
      this.container.style.top = `${offset}px`;
      this.container.style.height = `${this.size}px`;
    }
  }
  class HorizontalViewItem extends ViewItem {
    layoutContainer(offset) {
      this.container.style.left = `${offset}px`;
      this.container.style.width = `${this.size}px`;
    }
  }
  var State;
  (function(State) {
    State[State.Idle = 0] = "Idle";
    State[State.Busy = 1] = "Busy";
  })(State ||= {});
  var Sizing;
  (function(Sizing) {
    Sizing.Distribute = {type:"distribute"};
    Sizing.Split = function(index) {
      return {type:"split", index};
    };
    Sizing.Auto = function(index) {
      return {type:"auto", index};
    };
    Sizing.Invisible = function(cachedVisibleSize) {
      return {type:"invisible", cachedVisibleSize};
    };
  })(Sizing ||= {});
  class SplitView extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    get orthogonalStartSash() {
      return this._orthogonalStartSash;
    }
    get orthogonalEndSash() {
      return this._orthogonalEndSash;
    }
    get startSnappingEnabled() {
      return this._startSnappingEnabled;
    }
    get endSnappingEnabled() {
      return this._endSnappingEnabled;
    }
    set orthogonalStartSash(sash) {
      for (const sashItem of this.sashItems) {
        sashItem.sash.orthogonalStartSash = sash;
      }
      this._orthogonalStartSash = sash;
    }
    set orthogonalEndSash(sash) {
      for (const sashItem of this.sashItems) {
        sashItem.sash.orthogonalEndSash = sash;
      }
      this._orthogonalEndSash = sash;
    }
    set startSnappingEnabled(startSnappingEnabled) {
      this._startSnappingEnabled !== startSnappingEnabled && (this._startSnappingEnabled = startSnappingEnabled, this.updateSashEnablement());
    }
    set endSnappingEnabled(endSnappingEnabled) {
      this._endSnappingEnabled !== endSnappingEnabled && (this._endSnappingEnabled = endSnappingEnabled, this.updateSashEnablement());
    }
    constructor(container, options = {}) {
      var _a, _b, _c, _d, _e;
      super();
      this._contentSize = this.size = 0;
      this.proportions = void 0;
      this.viewItems = [];
      this.sashItems = [];
      this.state = State.Idle;
      this._onDidSashChange = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter());
      this._onDidSashReset = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter());
      this._endSnappingEnabled = this._startSnappingEnabled = !0;
      this.onDidSashChange = this._onDidSashChange.event;
      this.onDidSashReset = this._onDidSashReset.event;
      this.orientation = (_a = options.orientation) !== null && _a !== void 0 ? _a : 0;
      this.inverseAltBehavior = (_b = options.inverseAltBehavior) !== null && _b !== void 0 ? _b : !1;
      this.proportionalLayout = (_c = options.proportionalLayout) !== null && _c !== void 0 ? _c : !0;
      this.getSashOrthogonalSize = options.getSashOrthogonalSize;
      this.el = document.createElement("div");
      this.el.classList.add("monaco-split-view2");
      this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal");
      container.appendChild(this.el);
      this.sashContainer = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.append)(this.el, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".sash-container"));
      this.viewContainer = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".split-view-container");
      this.scrollable = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_scrollable_DOT_js.Scrollable({forceIntegerValues:!0, smoothScrollDuration:125, scheduleAtNextAnimationFrame:callback => (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.scheduleAtNextAnimationFrame)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.getWindow)(this.el), callback)}));
      this.scrollableElement = this._register(new require$_DOT__DOT__SLASH_scrollbar_SLASH_scrollableElement_DOT_js.SmoothScrollableElement(this.viewContainer, {vertical:this.orientation === 0 ? (_d = options.scrollbarVisibility) !== null && _d !== void 0 ? _d : 1 : 2, horizontal:this.orientation === 1 ? (_e = options.scrollbarVisibility) !== null && _e !== void 0 ? _e : 1 : 2}, this.scrollable));
      container = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_event_DOT_js.DomEmitter(this.viewContainer, "scroll")).event;
      this._register(container(_ => {
        var position = this.scrollableElement.getScrollPosition();
        _ = Math.abs(this.viewContainer.scrollLeft - position.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft;
        position = Math.abs(this.viewContainer.scrollTop - position.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
        _ === void 0 && position === void 0 || this.scrollableElement.setScrollPosition({scrollLeft:_, scrollTop:position});
      }));
      this.onDidScroll = this.scrollableElement.onScroll;
      this._register(this.onDidScroll(e => {
        e.scrollTopChanged && (this.viewContainer.scrollTop = e.scrollTop);
        e.scrollLeftChanged && (this.viewContainer.scrollLeft = e.scrollLeft);
      }));
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.append)(this.el, this.scrollableElement.getDomNode());
      this.style(options.styles || defaultStyles);
      options.descriptor && (this.size = options.descriptor.size, options.descriptor.views.forEach((viewDescriptor, index) => {
        const sizing = types.isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : {type:"invisible", cachedVisibleSize:viewDescriptor.size};
        this.doAddView(viewDescriptor.view, sizing, index, !0);
      }), this._contentSize = this.viewItems.reduce((r, i) => r + i.size, 0), this.saveProportions());
    }
    style(styles) {
      styles.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", styles.separatorBorder.toString()));
    }
    addView(view, size, index = this.viewItems.length, skipLayout) {
      this.doAddView(view, size, index, skipLayout);
    }
    layout(size, layoutContext) {
      var previousSize = Math.max(this.size, this._contentSize);
      this.size = size;
      this.layoutContext = layoutContext;
      if (this.proportions) {
        previousSize = 0;
        for (layoutContext = 0; layoutContext < this.viewItems.length; layoutContext++) {
          var item = this.viewItems[layoutContext], proportion = this.proportions[layoutContext];
          typeof proportion === "number" ? previousSize += proportion : size -= item.size;
        }
        for (layoutContext = 0; layoutContext < this.viewItems.length; layoutContext++) {
          item = this.viewItems[layoutContext], proportion = this.proportions[layoutContext], typeof proportion === "number" && previousSize > 0 && (item.size = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(Math.round(proportion * size / previousSize), item.minimumSize, item.maximumSize));
        }
      } else {
        item = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(this.viewItems.length), layoutContext = item.filter(i => this.viewItems[i].priority === 1), item = item.filter(i => this.viewItems[i].priority === 2), this.resize(this.viewItems.length - 1, size - previousSize, void 0, layoutContext, item);
      }
      this.distributeEmptySpace();
      this.layoutViews();
    }
    saveProportions() {
      this.proportionalLayout && this._contentSize > 0 && (this.proportions = this.viewItems.map(v => v.proportionalLayout && v.visible ? v.size / this._contentSize : void 0));
    }
    onSashStart({sash, start, alt}) {
      for (const item of this.viewItems) {
        item.enabled = !1;
      }
      const index = this.sashItems.findIndex(item => item.sash === sash), disposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.combinedDisposable)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.el.ownerDocument.body, "keydown", e => resetSashDragState(this.sashDragState.current, e.altKey)), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.addDisposableListener)(this.el.ownerDocument.body, "keyup", () => 
      resetSashDragState(this.sashDragState.current, !1))), resetSashDragState = (start, alt) => {
        const sizes = this.viewItems.map(i => i.size);
        let minDelta = Number.NEGATIVE_INFINITY;
        var maxDelta = Number.POSITIVE_INFINITY;
        this.inverseAltBehavior && (alt = !alt);
        alt && (index === this.sashItems.length - 1 ? (maxDelta = this.viewItems[index], minDelta = (maxDelta.minimumSize - maxDelta.size) / 2, maxDelta = (maxDelta.maximumSize - maxDelta.size) / 2) : (maxDelta = this.viewItems[index + 1], minDelta = (maxDelta.size - maxDelta.maximumSize) / 2, maxDelta = (maxDelta.size - maxDelta.minimumSize) / 2));
        if (!alt) {
          var upIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index, -1), downIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index + 1, this.viewItems.length), minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0), maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].viewMaximumSize - sizes[i]), 0), maxDeltaDown = downIndexes.length === 
          0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
          const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].viewMaximumSize), 0);
          minDeltaUp = Math.max(minDeltaUp, minDeltaDown);
          maxDeltaUp = Math.min(maxDeltaDown, maxDeltaUp);
          upIndexes = this.findFirstSnapIndex(upIndexes);
          downIndexes = this.findFirstSnapIndex(downIndexes);
          if (typeof upIndexes === "number") {
            var snapBefore = this.viewItems[upIndexes];
            maxDeltaDown = Math.floor(snapBefore.viewMinimumSize / 2);
            snapBefore = {index:upIndexes, limitDelta:snapBefore.visible ? minDeltaUp - maxDeltaDown : minDeltaUp + maxDeltaDown, size:snapBefore.size};
          }
          if (typeof downIndexes === "number") {
            var snapAfter = this.viewItems[downIndexes];
            minDeltaUp = Math.floor(snapAfter.viewMinimumSize / 2);
            snapAfter = {index:downIndexes, limitDelta:snapAfter.visible ? maxDeltaUp + minDeltaUp : maxDeltaUp - minDeltaUp, size:snapAfter.size};
          }
        }
        this.sashDragState = {start, current:start, index, sizes, minDelta, maxDelta, alt, snapBefore, snapAfter, disposable};
      };
      resetSashDragState(start, alt);
    }
    onSashChange({current}) {
      const {index, start, sizes, alt, minDelta, maxDelta, snapBefore, snapAfter} = this.sashDragState;
      this.sashDragState.current = current;
      current = this.resize(index, current - start, sizes, void 0, void 0, minDelta, maxDelta, snapBefore, snapAfter);
      if (alt) {
        const isLastSash = index === this.sashItems.length - 1, newSizes = this.viewItems.map(i => i.size), viewItem = this.viewItems[isLastSash ? index : index + 1];
        this.resize(isLastSash ? index - 1 : index + 1, -current, newSizes, void 0, void 0, viewItem.size - viewItem.maximumSize, viewItem.size - viewItem.minimumSize);
      }
      this.distributeEmptySpace();
      this.layoutViews();
    }
    onSashEnd(index) {
      this._onDidSashChange.fire(index);
      this.sashDragState.disposable.dispose();
      this.saveProportions();
      for (const item of this.viewItems) {
        item.enabled = !0;
      }
    }
    onViewChange(item, size) {
      const index = this.viewItems.indexOf(item);
      index < 0 || index >= this.viewItems.length || (size = typeof size === "number" ? size : item.size, size = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(size, item.minimumSize, item.maximumSize), this.inverseAltBehavior && index > 0 ? (this.resize(index - 1, Math.floor((item.size - size) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (item.size = size, this.relayout([index], void 0)));
    }
    resizeView(index, size) {
      if (!(index < 0 || index >= this.viewItems.length)) {
        if (this.state !== State.Idle) {
          throw Error("Cant modify splitview");
        }
        this.state = State.Busy;
        try {
          const indexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(this.viewItems.length).filter(i => i !== index), lowPriorityIndexes = [...indexes.filter(i => this.viewItems[i].priority === 1), index], highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 2), item = this.viewItems[index];
          size = Math.round(size);
          size = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(size, item.minimumSize, Math.min(item.maximumSize, this.size));
          item.size = size;
          this.relayout(lowPriorityIndexes, highPriorityIndexes);
        } finally {
          this.state = State.Idle;
        }
      }
    }
    distributeViewSizes() {
      var flexibleViewItems = [], flexibleSize = 0;
      for (const item of this.viewItems) {
        item.maximumSize - item.minimumSize > 0 && (flexibleViewItems.push(item), flexibleSize += item.size);
      }
      flexibleSize = Math.floor(flexibleSize / flexibleViewItems.length);
      for (var item of flexibleViewItems) {
        item.size = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(flexibleSize, item.minimumSize, item.maximumSize);
      }
      item = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(this.viewItems.length);
      flexibleViewItems = item.filter(i => this.viewItems[i].priority === 1);
      item = item.filter(i => this.viewItems[i].priority === 2);
      this.relayout(flexibleViewItems, item);
    }
    getViewSize(index) {
      return index < 0 || index >= this.viewItems.length ? -1 : this.viewItems[index].size;
    }
    doAddView(view, size, index = this.viewItems.length, skipLayout) {
      if (this.state !== State.Idle) {
        throw Error("Cant modify splitview");
      }
      this.state = State.Busy;
      try {
        const container = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.$)(".split-view-view");
        index === this.viewItems.length ? this.viewContainer.appendChild(container) : this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));
        const onChangeDisposable = view.onDidChange(size => this.onViewChange(item, size)), containerDisposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.toDisposable)(() => this.viewContainer.removeChild(container)), disposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.combinedDisposable)(onChangeDisposable, containerDisposable);
        let viewSize;
        typeof size === "number" ? viewSize = size : (size.type === "auto" && (size = this.areViewsDistributed() ? {type:"distribute"} : {type:"split", index:size.index}), viewSize = size.type === "split" ? this.getViewSize(size.index) / 2 : size.type === "invisible" ? {cachedVisibleSize:size.cachedVisibleSize} : view.minimumSize);
        const item = this.orientation === 0 ? new VerticalViewItem(container, view, viewSize, disposable) : new HorizontalViewItem(container, view, viewSize, disposable);
        this.viewItems.splice(index, 0, item);
        if (this.viewItems.length > 1) {
          const opts = {orthogonalStartSash:this.orthogonalStartSash, orthogonalEndSash:this.orthogonalEndSash}, sash = this.orientation === 0 ? new require$_DOT__DOT__SLASH_sash_SLASH_sash_DOT_js.Sash(this.sashContainer, {getHorizontalSashTop:s => this.getSashPosition(s), getHorizontalSashWidth:this.getSashOrthogonalSize}, {...opts, orientation:1}) : new require$_DOT__DOT__SLASH_sash_SLASH_sash_DOT_js.Sash(this.sashContainer, {getVerticalSashLeft:s => this.getSashPosition(s), getVerticalSashHeight:this.getSashOrthogonalSize}, 
          {...opts, orientation:0}), sashEventMapper = this.orientation === 0 ? e => ({sash, start:e.startY, current:e.currentY, alt:e.altKey}) : e => ({sash, start:e.startX, current:e.currentX, alt:e.altKey}), onStartDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(sash.onDidStart, sashEventMapper)(this.onSashStart, this), onChangeDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(sash.onDidChange, 
          sashEventMapper)(this.onSashChange, this), onEndDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(sash.onDidEnd, () => this.sashItems.findIndex(item => item.sash === sash))(this.onSashEnd, this), onDidResetDisposable = sash.onDidReset(() => {
            const index = this.sashItems.findIndex(item => item.sash === sash);
            var upIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index, -1), downIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index + 1, this.viewItems.length);
            upIndexes = this.findFirstSnapIndex(upIndexes);
            downIndexes = this.findFirstSnapIndex(downIndexes);
            typeof upIndexes === "number" && !this.viewItems[upIndexes].visible || typeof downIndexes === "number" && !this.viewItems[downIndexes].visible || this._onDidSashReset.fire(index);
          }), disposable = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.combinedDisposable)(onStartDisposable, onChangeDisposable, onEndDisposable, onDidResetDisposable, sash);
          this.sashItems.splice(index - 1, 0, {sash, disposable});
        }
        container.appendChild(view.element);
        let highPriorityIndexes;
        typeof size !== "number" && size.type === "split" && (highPriorityIndexes = [size.index]);
        skipLayout || this.relayout([index], highPriorityIndexes);
        skipLayout || typeof size === "number" || size.type !== "distribute" || this.distributeViewSizes();
      } finally {
        this.state = State.Idle;
      }
    }
    relayout(lowPriorityIndexes, highPriorityIndexes) {
      const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      this.resize(this.viewItems.length - 1, this.size - contentSize, void 0, lowPriorityIndexes, highPriorityIndexes);
      this.distributeEmptySpace();
      this.layoutViews();
      this.saveProportions();
    }
    resize(index$jscomp$1, delta, sizes = this.viewItems.map(i => i.size), lowPriorityIndexes, highPriorityIndexes, overloadMinDelta = Number.NEGATIVE_INFINITY, overloadMaxDelta = Number.POSITIVE_INFINITY, snapBefore, snapAfter) {
      if (index$jscomp$1 < 0 || index$jscomp$1 >= this.viewItems.length) {
        return 0;
      }
      var upIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index$jscomp$1, -1), downIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index$jscomp$1 + 1, this.viewItems.length);
      if (highPriorityIndexes) {
        for (var index of highPriorityIndexes) {
          (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToStart)(upIndexes, index), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToStart)(downIndexes, index);
        }
      }
      if (lowPriorityIndexes) {
        for (var index$jscomp$0 of lowPriorityIndexes) {
          (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToEnd)(upIndexes, index$jscomp$0), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToEnd)(downIndexes, index$jscomp$0);
        }
      }
      const upItems = upIndexes.map(i => this.viewItems[i]), upSizes = upIndexes.map(i => sizes[i]);
      index = downIndexes.map(i => this.viewItems[i]);
      index$jscomp$0 = downIndexes.map(i => sizes[i]);
      var minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
      upIndexes = upIndexes.reduce((r, i) => r + (this.viewItems[i].maximumSize - sizes[i]), 0);
      var maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
      downIndexes = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].maximumSize), 0);
      downIndexes = Math.max(minDeltaUp, downIndexes, overloadMinDelta);
      minDeltaUp = Math.min(maxDeltaDown, upIndexes, overloadMaxDelta);
      upIndexes = !1;
      if (snapBefore) {
        maxDeltaDown = this.viewItems[snapBefore.index];
        const visible = delta >= snapBefore.limitDelta;
        upIndexes = visible !== maxDeltaDown.visible;
        maxDeltaDown.setVisible(visible, snapBefore.size);
      }
      !upIndexes && snapAfter && (snapBefore = this.viewItems[snapAfter.index], maxDeltaDown = delta < snapAfter.limitDelta, upIndexes = maxDeltaDown !== snapBefore.visible, snapBefore.setVisible(maxDeltaDown, snapAfter.size));
      if (upIndexes) {
        return this.resize(index$jscomp$1, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);
      }
      delta = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(delta, downIndexes, minDeltaUp);
      for (let i = 0, deltaUp = delta; i < upItems.length; i++) {
        index$jscomp$1 = upItems[i], lowPriorityIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(upSizes[i] + deltaUp, index$jscomp$1.minimumSize, index$jscomp$1.maximumSize), deltaUp -= lowPriorityIndexes - upSizes[i], index$jscomp$1.size = lowPriorityIndexes;
      }
      for (let i = 0, deltaDown = delta; i < index.length; i++) {
        index$jscomp$1 = index[i], lowPriorityIndexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(index$jscomp$0[i] - deltaDown, index$jscomp$1.minimumSize, index$jscomp$1.maximumSize), deltaDown += lowPriorityIndexes - index$jscomp$0[i], index$jscomp$1.size = lowPriorityIndexes;
      }
      return delta;
    }
    distributeEmptySpace(lowPriorityIndex) {
      var contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      contentSize = this.size - contentSize;
      const indexes = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(this.viewItems.length - 1, -1), lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 1), highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === 2);
      for (var index of highPriorityIndexes) {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToStart)(indexes, index);
      }
      for (var index$jscomp$0 of lowPriorityIndexes) {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToEnd)(indexes, index$jscomp$0);
      }
      typeof lowPriorityIndex === "number" && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.pushToEnd)(indexes, lowPriorityIndex);
      for (lowPriorityIndex = 0; contentSize !== 0 && lowPriorityIndex < indexes.length; lowPriorityIndex++) {
        index = this.viewItems[indexes[lowPriorityIndex]], index$jscomp$0 = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_numbers_DOT_js.clamp)(index.size + contentSize, index.minimumSize, index.maximumSize), contentSize -= index$jscomp$0 - index.size, index.size = index$jscomp$0;
      }
    }
    layoutViews() {
      this._contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      let offset = 0;
      for (const viewItem of this.viewItems) {
        viewItem.layout(offset, this.layoutContext), offset += viewItem.size;
      }
      this.sashItems.forEach(item => item.sash.layout());
      this.updateSashEnablement();
      this.updateScrollableElement();
    }
    updateScrollableElement() {
      this.orientation === 0 ? this.scrollableElement.setScrollDimensions({height:this.size, scrollHeight:this._contentSize}) : this.scrollableElement.setScrollDimensions({width:this.size, scrollWidth:this._contentSize});
    }
    updateSashEnablement() {
      let previous = !1;
      const collapsesDown = this.viewItems.map(i => previous = i.size - i.minimumSize > 0 || previous);
      previous = !1;
      const expandsDown = this.viewItems.map(i => previous = i.maximumSize - i.size > 0 || previous);
      var reverseViews = [...this.viewItems].reverse();
      previous = !1;
      const collapsesUp = reverseViews.map(i => previous = i.size - i.minimumSize > 0 || previous).reverse();
      previous = !1;
      reverseViews = reverseViews.map(i => previous = i.maximumSize - i.size > 0 || previous).reverse();
      let position = 0;
      for (let index = 0; index < this.sashItems.length; index++) {
        const {sash} = this.sashItems[index];
        position += this.viewItems[index].size;
        var min = !(collapsesDown[index] && reverseViews[index + 1]), max = !(expandsDown[index] && collapsesUp[index + 1]);
        min && max ? (min = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index, -1), max = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_arrays_DOT_js.range)(index + 1, this.viewItems.length), min = this.findFirstSnapIndex(min), max = this.findFirstSnapIndex(max), max = typeof max === "number" && !this.viewItems[max].visible, sash.state = typeof min === "number" && !this.viewItems[min].visible && collapsesUp[index] && 
        (position > 0 || this.startSnappingEnabled) ? 1 : max && collapsesDown[index] && (position < this._contentSize || this.endSnappingEnabled) ? 2 : 0) : sash.state = min && !max ? 1 : !min && max ? 2 : 3;
      }
    }
    getSashPosition(sash) {
      let position = 0;
      for (let i = 0; i < this.sashItems.length; i++) {
        if (position += this.viewItems[i].size, this.sashItems[i].sash === sash) {
          return position;
        }
      }
      return 0;
    }
    findFirstSnapIndex(indexes) {
      for (const index of indexes) {
        const viewItem = this.viewItems[index];
        if (viewItem.visible && viewItem.snap) {
          return index;
        }
      }
      for (const index of indexes) {
        indexes = this.viewItems[index];
        if (indexes.visible && indexes.maximumSize - indexes.minimumSize > 0) {
          break;
        }
        if (!indexes.visible && indexes.snap) {
          return index;
        }
      }
    }
    areViewsDistributed() {
      let min = void 0, max = void 0;
      for (const view of this.viewItems) {
        if (min = min === void 0 ? view.size : Math.min(min, view.size), max = max === void 0 ? view.size : Math.max(max, view.size), max - min > 2) {
          return !1;
        }
      }
      return !0;
    }
    dispose() {
      var _a;
      (_a = this.sashDragState) === null || _a === void 0 || _a.disposable.dispose();
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this.viewItems);
      this.viewItems = [];
      this.sashItems.forEach(i => i.disposable.dispose());
      this.sashItems = [];
      super.dispose();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$splitview$splitview.js.map
