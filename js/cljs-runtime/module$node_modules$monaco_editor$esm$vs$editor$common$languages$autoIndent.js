shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$autoIndent = function(require, module, exports) {
  function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = !0, languageConfigurationService) {
    if (autoIndent < 4) {
      return null;
    }
    autoIndent = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;
    if (!autoIndent) {
      return null;
    }
    if (lineNumber <= 1) {
      return {indentation:"", action:null};
    }
    for (languageConfigurationService = lineNumber - 1; languageConfigurationService > 0 && model.getLineContent(languageConfigurationService) === ""; languageConfigurationService--) {
      if (languageConfigurationService === 1) {
        return {indentation:"", action:null};
      }
    }
    a: {
      languageConfigurationService = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);
      if (lineNumber > 1) {
        var resultLineNumber = -1;
        for (--lineNumber; lineNumber >= 1; lineNumber--) {
          if (model.tokenization.getLanguageIdAtPosition(lineNumber, 0) !== languageConfigurationService) {
            lineNumber = resultLineNumber;
            break a;
          }
          resultLineNumber = model.getLineContent(lineNumber);
          if (autoIndent.shouldIgnore(resultLineNumber) || /^\s+$/.test(resultLineNumber) || resultLineNumber === "") {
            resultLineNumber = lineNumber;
          } else {
            break a;
          }
        }
      }
      lineNumber = -1;
    }
    if (lineNumber < 0) {
      return null;
    }
    if (lineNumber < 1) {
      return {indentation:"", action:null};
    }
    languageConfigurationService = model.getLineContent(lineNumber);
    if (autoIndent.shouldIncrease(languageConfigurationService) || autoIndent.shouldIndentNextLine(languageConfigurationService)) {
      return {indentation:strings.getLeadingWhitespace(languageConfigurationService), action:require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent, line:lineNumber};
    }
    if (autoIndent.shouldDecrease(languageConfigurationService)) {
      return {indentation:strings.getLeadingWhitespace(languageConfigurationService), action:null, line:lineNumber};
    }
    if (lineNumber === 1) {
      return {indentation:strings.getLeadingWhitespace(model.getLineContent(lineNumber)), action:null, line:lineNumber};
    }
    languageConfigurationService = lineNumber - 1;
    resultLineNumber = autoIndent.getIndentMetadata(model.getLineContent(languageConfigurationService));
    if (!(resultLineNumber & 3) && resultLineNumber & 4) {
      honorIntentialIndent = 0;
      for (lineNumber = languageConfigurationService - 1; lineNumber > 0; lineNumber--) {
        if (!autoIndent.shouldIndentNextLine(model.getLineContent(lineNumber))) {
          honorIntentialIndent = lineNumber;
          break;
        }
      }
      return {indentation:strings.getLeadingWhitespace(model.getLineContent(honorIntentialIndent + 1)), action:null, line:honorIntentialIndent + 1};
    }
    if (honorIntentialIndent) {
      return {indentation:strings.getLeadingWhitespace(model.getLineContent(lineNumber)), action:null, line:lineNumber};
    }
    for (honorIntentialIndent = lineNumber; honorIntentialIndent > 0; honorIntentialIndent--) {
      lineNumber = model.getLineContent(honorIntentialIndent);
      if (autoIndent.shouldIncrease(lineNumber)) {
        return {indentation:strings.getLeadingWhitespace(lineNumber), action:require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent, line:honorIntentialIndent};
      }
      if (autoIndent.shouldIndentNextLine(lineNumber)) {
        lineNumber = 0;
        for (languageConfigurationService = honorIntentialIndent - 1; languageConfigurationService > 0; languageConfigurationService--) {
          if (!autoIndent.shouldIndentNextLine(model.getLineContent(honorIntentialIndent))) {
            lineNumber = languageConfigurationService;
            break;
          }
        }
        return {indentation:strings.getLeadingWhitespace(model.getLineContent(lineNumber + 1)), action:null, line:lineNumber + 1};
      }
      if (autoIndent.shouldDecrease(lineNumber)) {
        return {indentation:strings.getLeadingWhitespace(lineNumber), action:null, line:honorIntentialIndent};
      }
    }
    return {indentation:strings.getLeadingWhitespace(model.getLineContent(1)), action:null, line:1};
  }
  function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {
    if (autoIndent < 4) {
      return null;
    }
    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);
    if (!richEditSupport) {
      return null;
    }
    languageId = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;
    if (!languageId) {
      return null;
    }
    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, void 0, languageConfigurationService);
    languageConfigurationService = virtualModel.getLineContent(lineNumber);
    if (indent) {
      const inheritLine = indent.line;
      if (inheritLine !== void 0) {
        let shouldApplyEnterRules = !0;
        for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {
          if (!/^\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {
            shouldApplyEnterRules = !1;
            break;
          }
        }
        if (shouldApplyEnterRules && (autoIndent = richEditSupport.onEnter(autoIndent, "", virtualModel.getLineContent(inheritLine), ""))) {
          return virtualModel = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine)), autoIndent.removeText && (virtualModel = virtualModel.substring(0, virtualModel.length - autoIndent.removeText)), autoIndent.indentAction === require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent || autoIndent.indentAction === require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.IndentOutdent ? virtualModel = indentConverter.shiftIndent(virtualModel) : autoIndent.indentAction === 
          require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Outdent && (virtualModel = indentConverter.unshiftIndent(virtualModel)), languageId.shouldDecrease(languageConfigurationService) && (virtualModel = indentConverter.unshiftIndent(virtualModel)), autoIndent.appendText && (virtualModel += autoIndent.appendText), strings.getLeadingWhitespace(virtualModel);
        }
      }
      return languageId.shouldDecrease(languageConfigurationService) ? indent.action === require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent ? indent.indentation : indentConverter.unshiftIndent(indent.indentation) : indent.action === require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent ? indentConverter.shiftIndent(indent.indentation) : indent.indentation;
    }
    return null;
  }
  function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {
    if (autoIndent < 4) {
      return null;
    }
    model.tokenization.forceTokenization(range.startLineNumber);
    var lineTokens = model.tokenization.getLineTokens(range.startLineNumber), scopedLineTokens = (0,require$_DOT__SLASH_supports_DOT_js.createScopedLineTokens)(lineTokens, range.startColumn - 1), scopedLineText = scopedLineTokens.getLineContent();
    let embeddedLanguage = !1;
    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
      embeddedLanguage = !0;
      var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);
    }
    scopedLineText = range.isEmpty() ? scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset) : (0,require$_DOT__SLASH_languageConfigurationRegistry_DOT_js.getScopedLineTokens)(model, range.endLineNumber, range.endColumn).getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
    scopedLineTokens = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;
    if (!scopedLineTokens) {
      return null;
    }
    const beforeEnterResult = beforeEnterText;
    beforeEnterText = strings.getLeadingWhitespace(beforeEnterText);
    lineTokens = strings.getLeadingWhitespace(lineTokens.getLineContent());
    autoIndent = getInheritIndentForLine(autoIndent, {tokenization:{getLineTokens:lineNumber => model.tokenization.getLineTokens(lineNumber), getLanguageId:() => model.getLanguageId(), getLanguageIdAtPosition:(lineNumber, column) => model.getLanguageIdAtPosition(lineNumber, column)}, getLineContent:lineNumber => lineNumber === range.startLineNumber ? beforeEnterResult : model.getLineContent(lineNumber)}, range.startLineNumber + 1, void 0, languageConfigurationService);
    if (!autoIndent) {
      return indentConverter = embeddedLanguage ? lineTokens : beforeEnterText, {beforeEnter:indentConverter, afterEnter:indentConverter};
    }
    languageConfigurationService = embeddedLanguage ? lineTokens : autoIndent.indentation;
    autoIndent.action === require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent && (languageConfigurationService = indentConverter.shiftIndent(languageConfigurationService));
    scopedLineTokens.shouldDecrease(scopedLineText) && (languageConfigurationService = indentConverter.unshiftIndent(languageConfigurationService));
    return {beforeEnter:embeddedLanguage ? lineTokens : beforeEnterText, afterEnter:languageConfigurationService};
  }
  function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {
    if (autoIndent < 4) {
      return null;
    }
    var scopedLineTokens = (0,require$_DOT__SLASH_languageConfigurationRegistry_DOT_js.getScopedLineTokens)(model, range.startLineNumber, range.startColumn);
    if (scopedLineTokens.firstCharOffset) {
      return null;
    }
    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;
    if (!indentRulesSupport) {
      return null;
    }
    const scopedLineText = scopedLineTokens.getLineContent(), beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
    scopedLineTokens = range.isEmpty() ? scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset) : (0,require$_DOT__SLASH_languageConfigurationRegistry_DOT_js.getScopedLineTokens)(model, range.endLineNumber, range.endColumn).getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
    if (!indentRulesSupport.shouldDecrease(beforeTypeText + scopedLineTokens) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + scopedLineTokens)) {
      autoIndent = getInheritIndentForLine(autoIndent, model, range.startLineNumber, !1, languageConfigurationService);
      if (!autoIndent) {
        return null;
      }
      model = autoIndent.indentation;
      autoIndent.action !== require$_DOT__SLASH_languageConfiguration_DOT_js.IndentAction.Indent && (model = indentConverter.unshiftIndent(model));
      return model;
    }
    return null;
  }
  function getIndentMetadata(model, lineNumber, languageConfigurationService) {
    languageConfigurationService = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;
    return !languageConfigurationService || lineNumber < 1 || lineNumber > model.getLineCount() ? null : languageConfigurationService.getIndentMetadata(model.getLineContent(lineNumber));
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, getGoodIndentForLine:{enumerable:!0, get:function() {
    return getGoodIndentForLine;
  }}, getIndentActionForType:{enumerable:!0, get:function() {
    return getIndentActionForType;
  }}, getIndentForEnter:{enumerable:!0, get:function() {
    return getIndentForEnter;
  }}, getIndentMetadata:{enumerable:!0, get:function() {
    return getIndentMetadata;
  }}, getInheritIndentForLine:{enumerable:!0, get:function() {
    return getInheritIndentForLine;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__SLASH_languageConfiguration_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfiguration"), require$_DOT__SLASH_supports_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports"), require$_DOT__SLASH_languageConfigurationRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfigurationRegistry");
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$autoIndent.js.map
