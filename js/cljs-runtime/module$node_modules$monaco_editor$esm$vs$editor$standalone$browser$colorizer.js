shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$standalone$browser$colorizer = function(require, module, exports) {
  function _colorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
    return new Promise((c, e) => {
      const execute = () => {
        var JSCompiler_inline_result = [];
        var state = tokenizationSupport.getInitialState();
        for (let i = 0, length = lines.length; i < length; i++) {
          var line = lines[i];
          state = tokenizationSupport.tokenizeEncoded(line, !0, state);
          require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens.convertToEndOffset(state.tokens, line.length);
          const lineTokens = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens(state.tokens, line, languageIdCodec), isBasicASCII = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewLineRenderingData.isBasicASCII(line, !0), containsRTL = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewLineRenderingData.containsRTL(line, isBasicASCII, !0);
          line = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.renderViewLine2)(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.RenderLineInput(!1, !0, line, !1, isBasicASCII, containsRTL, 0, lineTokens.inflate(), [], tabSize, 0, 0, 0, 0, -1, "none", !1, !1, null));
          JSCompiler_inline_result = JSCompiler_inline_result.concat(line.html);
          JSCompiler_inline_result.push("\x3cbr/\x3e");
          state = state.endState;
        }
        JSCompiler_inline_result = JSCompiler_inline_result.join("");
        if (tokenizationSupport instanceof require$_DOT__DOT__SLASH_common_SLASH_monarch_SLASH_monarchLexer_DOT_js.MonarchTokenizer && (line = tokenizationSupport.getLoadStatus(), line.loaded === !1)) {
          line.promise.then(execute, e);
          return;
        }
        c(JSCompiler_inline_result);
      };
      execute();
    });
  }
  function _fakeColorize(lines, tabSize, languageIdCodec) {
    let html = [];
    const tokens = new Uint32Array(2);
    tokens[0] = 0;
    tokens[1] = 33587200;
    for (let i = 0, length = lines.length; i < length; i++) {
      var line = lines[i];
      tokens[0] = line.length;
      const lineTokens = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens(tokens, line, languageIdCodec), isBasicASCII = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewLineRenderingData.isBasicASCII(line, !0), containsRTL = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewLineRenderingData.containsRTL(line, isBasicASCII, !0);
      line = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.renderViewLine2)(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.RenderLineInput(!1, !0, line, !1, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, 0, 0, 0, -1, "none", !1, !1, null));
      html = html.concat(line.html);
      html.push("\x3cbr/\x3e");
    }
    return html.join("");
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Colorizer:{enumerable:!0, get:function() {
    return Colorizer;
  }}});
  module = require("module$node_modules$monaco_editor$esm$vs$base$browser$trustedTypes");
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_tokens_SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$viewLineRenderer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel"), require$_DOT__DOT__SLASH_common_SLASH_monarch_SLASH_monarchLexer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$standalone$common$monarch$monarchLexer");
  const ttPolicy = (0,module.createTrustedTypesPolicy)("standaloneColorizer", {createHTML:value => value});
  class Colorizer {
    static colorizeElement(themeService, languageService, domNode, options) {
      options = options || {};
      const theme = options.theme || "vs";
      var mimeType = options.mimeType || domNode.getAttribute("lang") || domNode.getAttribute("data-lang");
      if (!mimeType) {
        return console.error("Mode not detected"), Promise.resolve();
      }
      mimeType = languageService.getLanguageIdByMimeType(mimeType) || mimeType;
      themeService.setTheme(theme);
      themeService = domNode.firstChild ? domNode.firstChild.nodeValue : "";
      domNode.className += " " + theme;
      return this.colorize(languageService, themeService || "", mimeType, options).then(str => {
        var _a;
        const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _a !== void 0 ? _a : str;
        domNode.innerHTML = trustedhtml;
      }, err => console.error(err));
    }
    static async colorize(languageService, text, languageId, options) {
      const languageIdCodec = languageService.languageIdCodec;
      let tabSize = 4;
      options && typeof options.tabSize === "number" && (tabSize = options.tabSize);
      strings.startsWithUTF8BOM(text) && (text = text.substr(1));
      text = strings.splitLines(text);
      return languageService.isRegisteredLanguageId(languageId) ? (languageService = await require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js.TokenizationRegistry.getOrCreate(languageId)) ? _colorize(text, tabSize, languageService, languageIdCodec) : _fakeColorize(text, tabSize, languageIdCodec) : _fakeColorize(text, tabSize, languageIdCodec);
    }
    static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
      mightContainNonBasicASCII = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
      mightContainRTL = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewModel_DOT_js.ViewLineRenderingData.containsRTL(line, mightContainNonBasicASCII, mightContainRTL);
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.renderViewLine2)(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_viewLayout_SLASH_viewLineRenderer_DOT_js.RenderLineInput(!1, !0, line, !1, mightContainNonBasicASCII, mightContainRTL, 0, tokens, [], tabSize, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
    }
    static colorizeModelLine(model, lineNumber, tabSize = 4) {
      const content = model.getLineContent(lineNumber);
      model.tokenization.forceTokenization(lineNumber);
      lineNumber = model.tokenization.getLineTokens(lineNumber).inflate();
      return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), lineNumber, tabSize);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$standalone$browser$colorizer.js.map
