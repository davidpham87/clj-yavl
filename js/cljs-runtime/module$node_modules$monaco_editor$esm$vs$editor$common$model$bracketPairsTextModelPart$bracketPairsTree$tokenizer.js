shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$tokenizer = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, FastTokenizer:{enumerable:!0, get:function() {
    return FastTokenizer;
  }}, TextBufferTokenizer:{enumerable:!0, get:function() {
    return TextBufferTokenizer;
  }}, Token:{enumerable:!0, get:function() {
    return Token;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_encodedTokenAttributes_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$encodedTokenAttributes"), require$_DOT__SLASH_ast_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$ast"), 
  require$_DOT__SLASH_length_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$length"), require$_DOT__SLASH_smallImmutableSet_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$smallImmutableSet");
  class Token {
    constructor(length, kind, bracketId, bracketIds, astNode) {
      this.length = length;
      this.kind = kind;
      this.bracketId = bracketId;
      this.bracketIds = bracketIds;
      this.astNode = astNode;
    }
  }
  class TextBufferTokenizer {
    constructor(textModel, bracketTokens) {
      this.textModel = textModel;
      this.bracketTokens = bracketTokens;
      this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);
      this._offset = require$_DOT__SLASH_length_DOT_js.lengthZero;
      this.didPeek = !1;
      this.peeked = null;
      this.textBufferLineCount = textModel.getLineCount();
      this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
    }
    get offset() {
      return this._offset;
    }
    get length() {
      return (0,require$_DOT__SLASH_length_DOT_js.toLength)(this.textBufferLineCount - 1, this.textBufferLastLineLength);
    }
    skip(length) {
      this.didPeek = !1;
      this._offset = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(this._offset, length);
      length = (0,require$_DOT__SLASH_length_DOT_js.lengthToObj)(this._offset);
      this.reader.setPosition(length.lineCount, length.columnCount);
    }
    read() {
      let token;
      this.peeked ? (this.didPeek = !1, token = this.peeked) : token = this.reader.read();
      token && (this._offset = (0,require$_DOT__SLASH_length_DOT_js.lengthAdd)(this._offset, token.length));
      return token;
    }
    peek() {
      this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0);
      return this.peeked;
    }
  }
  class NonPeekableTextBufferTokenizer {
    constructor(textModel, bracketTokens) {
      this.textModel = textModel;
      this.bracketTokens = bracketTokens;
      this.lineIdx = 0;
      this.line = null;
      this.lineCharOffset = 0;
      this.lineTokens = null;
      this.lineTokenOffset = 0;
      this.peekedToken = null;
      this.textBufferLineCount = textModel.getLineCount();
      this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
    }
    setPosition(lineIdx, column) {
      lineIdx === this.lineIdx ? (this.lineCharOffset = column, this.line !== null && (this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))) : (this.lineIdx = lineIdx, this.lineCharOffset = column, this.line = null);
      this.peekedToken = null;
    }
    read() {
      if (this.peekedToken) {
        var token = this.peekedToken;
        this.peekedToken = null;
        this.lineCharOffset += (0,require$_DOT__SLASH_length_DOT_js.lengthGetColumnCountIfZeroLineCount)(token.length);
        return token;
      }
      if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength) {
        return null;
      }
      this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
      token = this.lineIdx;
      const startLineCharOffset = this.lineCharOffset;
      let lengthHeuristic = 0;
      for (;;) {
        var lineTokens = this.lineTokens, tokenCount = lineTokens.getCount();
        let peekedBracketToken = null;
        if (this.lineTokenOffset < tokenCount) {
          for (var tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset); this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1);) {
            this.lineTokenOffset++;
          }
          tokenCount = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getTokenType(tokenMetadata) === 0;
          var containsBracketType = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.containsBalancedBrackets(tokenMetadata);
          tokenMetadata = lineTokens.getEndOffset(this.lineTokenOffset);
          containsBracketType && tokenCount && this.lineCharOffset < tokenMetadata && (tokenCount = lineTokens.getLanguageId(this.lineTokenOffset), lineTokens = this.line.substring(this.lineCharOffset, tokenMetadata), tokenCount = this.bracketTokens.getSingleLanguageBracketTokens(tokenCount), containsBracketType = tokenCount.regExpGlobal) && (containsBracketType.lastIndex = 0, lineTokens = containsBracketType.exec(lineTokens)) && (peekedBracketToken = tokenCount.getToken(lineTokens[0])) && (this.lineCharOffset += 
          lineTokens.index);
          lengthHeuristic += tokenMetadata - this.lineCharOffset;
          if (peekedBracketToken) {
            if (token !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {
              this.peekedToken = peekedBracketToken;
              break;
            } else {
              return this.lineCharOffset += (0,require$_DOT__SLASH_length_DOT_js.lengthGetColumnCountIfZeroLineCount)(peekedBracketToken.length), peekedBracketToken;
            }
          } else {
            this.lineTokenOffset++, this.lineCharOffset = tokenMetadata;
          }
        } else {
          if (this.lineIdx === this.textBufferLineCount - 1) {
            break;
          }
          this.lineIdx++;
          this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);
          this.lineTokenOffset = 0;
          this.line = this.lineTokens.getLineContent();
          this.lineCharOffset = 0;
          lengthHeuristic += 33;
          if (lengthHeuristic > 1000) {
            break;
          }
        }
        if (lengthHeuristic > 1500) {
          break;
        }
      }
      token = (0,require$_DOT__SLASH_length_DOT_js.lengthDiff)(token, startLineCharOffset, this.lineIdx, this.lineCharOffset);
      return new Token(token, 0, -1, require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), new require$_DOT__SLASH_ast_DOT_js.TextAstNode(token));
    }
  }
  class FastTokenizer {
    constructor(text, brackets) {
      this.text = text;
      this._offset = require$_DOT__SLASH_length_DOT_js.lengthZero;
      this.idx = 0;
      var regExpStr = brackets.getRegExpStr();
      const regexp = regExpStr ? new RegExp(regExpStr + "|\n", "gi") : null;
      regExpStr = [];
      var match;
      let curLineCount = 0, lastLineBreakOffset = 0;
      var lastTokenEndOffset = 0, lastTokenEndLine = 0;
      const smallTextTokens0Line = [];
      for (var i = 0; i < 60; i++) {
        smallTextTokens0Line.push(new Token((0,require$_DOT__SLASH_length_DOT_js.toLength)(0, i), 0, -1, require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), new require$_DOT__SLASH_ast_DOT_js.TextAstNode((0,require$_DOT__SLASH_length_DOT_js.toLength)(0, i))));
      }
      i = [];
      for (var i$jscomp$0 = 0; i$jscomp$0 < 60; i$jscomp$0++) {
        i.push(new Token((0,require$_DOT__SLASH_length_DOT_js.toLength)(1, i$jscomp$0), 0, -1, require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), new require$_DOT__SLASH_ast_DOT_js.TextAstNode((0,require$_DOT__SLASH_length_DOT_js.toLength)(1, i$jscomp$0))));
      }
      if (regexp) {
        for (regexp.lastIndex = 0; (match = regexp.exec(text)) !== null;) {
          i$jscomp$0 = match.index, match = match[0], match === "\n" ? (curLineCount++, lastLineBreakOffset = i$jscomp$0 + 1) : (lastTokenEndOffset !== i$jscomp$0 && (lastTokenEndLine === curLineCount ? (lastTokenEndOffset = i$jscomp$0 - lastTokenEndOffset, lastTokenEndOffset < smallTextTokens0Line.length ? lastTokenEndOffset = smallTextTokens0Line[lastTokenEndOffset] : (lastTokenEndOffset = (0,require$_DOT__SLASH_length_DOT_js.toLength)(0, lastTokenEndOffset), lastTokenEndOffset = new Token(lastTokenEndOffset, 
          0, -1, require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), new require$_DOT__SLASH_ast_DOT_js.TextAstNode(lastTokenEndOffset)))) : (lastTokenEndOffset = curLineCount - lastTokenEndLine, lastTokenEndLine = i$jscomp$0 - lastLineBreakOffset, lastTokenEndOffset === 1 && lastTokenEndLine < i.length ? lastTokenEndOffset = i[lastTokenEndLine] : (lastTokenEndOffset = (0,require$_DOT__SLASH_length_DOT_js.toLength)(lastTokenEndOffset, lastTokenEndLine), lastTokenEndOffset = 
          new Token(lastTokenEndOffset, 0, -1, require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), new require$_DOT__SLASH_ast_DOT_js.TextAstNode(lastTokenEndOffset)))), regExpStr.push(lastTokenEndOffset)), regExpStr.push(brackets.getToken(match)), lastTokenEndOffset = i$jscomp$0 + match.length, lastTokenEndLine = curLineCount);
        }
      }
      text = text.length;
      lastTokenEndOffset !== text && (brackets = lastTokenEndLine === curLineCount ? (0,require$_DOT__SLASH_length_DOT_js.toLength)(0, text - lastTokenEndOffset) : (0,require$_DOT__SLASH_length_DOT_js.toLength)(curLineCount - lastTokenEndLine, text - lastLineBreakOffset), regExpStr.push(new Token(brackets, 0, -1, require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), new require$_DOT__SLASH_ast_DOT_js.TextAstNode(brackets))));
      this.length = (0,require$_DOT__SLASH_length_DOT_js.toLength)(curLineCount, text - lastLineBreakOffset);
      this.tokens = regExpStr;
    }
    get offset() {
      return this._offset;
    }
    read() {
      return this.tokens[this.idx++] || null;
    }
    peek() {
      return this.tokens[this.idx] || null;
    }
    skip(length) {
      throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.NotSupportedError();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$tokenizer.js.map
