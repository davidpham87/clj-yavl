shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$richEditBrackets = function(require, module, exports) {
  function groupFuzzyBrackets(brackets) {
    const N = brackets.length;
    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);
    const group = [];
    for (var i = 0; i < N; i++) {
      group[i] = i;
    }
    i = (a, b) => {
      const [aOpen, aClose] = a, [bOpen, bClose] = b;
      return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;
    };
    var mergeGroups = (g1, g2) => {
      const newG = Math.min(g1, g2);
      g1 = Math.max(g1, g2);
      for (g2 = 0; g2 < N; g2++) {
        group[g2] === g1 && (group[g2] = newG);
      }
    };
    for (var i$jscomp$0 = 0; i$jscomp$0 < N; i$jscomp$0++) {
      var a = brackets[i$jscomp$0];
      for (var j = i$jscomp$0 + 1; j < N; j++) {
        i(a, brackets[j]) && mergeGroups(group[i$jscomp$0], group[j]);
      }
    }
    i = [];
    for (mergeGroups = 0; mergeGroups < N; mergeGroups++) {
      i$jscomp$0 = [];
      a = [];
      for (j = 0; j < N; j++) {
        if (group[j] === mergeGroups) {
          const [open, close] = brackets[j];
          i$jscomp$0.push(open);
          a.push(close);
        }
      }
      i$jscomp$0.length > 0 && i.push({open:i$jscomp$0, close:a});
    }
    return i;
  }
  function collectSuperstrings(str, brackets, currentIndex, dest) {
    for (let i = 0, len = brackets.length; i < len; i++) {
      if (i === currentIndex) {
        continue;
      }
      const bracket = brackets[i];
      for (const open of bracket.open) {
        open.indexOf(str) >= 0 && dest.push(open);
      }
      for (const close of bracket.close) {
        close.indexOf(str) >= 0 && dest.push(close);
      }
    }
  }
  function lengthcmp(a, b) {
    return a.length - b.length;
  }
  function unique(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const result = [], seen = new Set();
    for (const element of arr) {
      seen.has(element) || (result.push(element), seen.add(element));
    }
    return result;
  }
  function getRegexForBrackets(brackets) {
    let pieces = [];
    for (const bracket of brackets) {
      for (const open of bracket.open) {
        pieces.push(open);
      }
      for (const close of bracket.close) {
        pieces.push(close);
      }
    }
    pieces = unique(pieces);
    return createBracketOrRegExp(pieces);
  }
  function getReversedRegexForBrackets(brackets) {
    let pieces = [];
    for (const bracket of brackets) {
      for (const open of bracket.open) {
        pieces.push(open);
      }
      for (const close of bracket.close) {
        pieces.push(close);
      }
    }
    pieces = unique(pieces);
    return createBracketOrRegExp(pieces.map(toReversedString));
  }
  function prepareBracketForRegExp(str) {
    const insertWordBoundaries = /^[\w ]+$/.test(str);
    str = strings.escapeRegExpCharacters(str);
    return insertWordBoundaries ? `\\b${str}\\b` : str;
  }
  function createBracketOrRegExp(pieces) {
    pieces = `(${pieces.map(prepareBracketForRegExp).join(")|(")})`;
    return strings.createRegExp(pieces, !0);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BracketsUtils:{enumerable:!0, get:function() {
    return BracketsUtils;
  }}, RichEditBracket:{enumerable:!0, get:function() {
    return RichEditBracket;
  }}, RichEditBrackets:{enumerable:!0, get:function() {
    return RichEditBrackets;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), stringBuilder = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class RichEditBracket {
    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {
      this._richEditBracketBrand = void 0;
      this.languageId = languageId;
      this.index = index;
      this.open = open;
      this.close = close;
      this.forwardRegex = forwardRegex;
      this.reversedRegex = reversedRegex;
      this._openSet = RichEditBracket._toSet(this.open);
      this._closeSet = RichEditBracket._toSet(this.close);
    }
    isOpen(text) {
      return this._openSet.has(text);
    }
    isClose(text) {
      return this._closeSet.has(text);
    }
    static _toSet(arr) {
      const result = new Set();
      for (const element of arr) {
        result.add(element);
      }
      return result;
    }
  }
  class RichEditBrackets {
    constructor(languageId, _brackets) {
      this._richEditBracketsBrand = void 0;
      const brackets = groupFuzzyBrackets(_brackets);
      this.brackets = brackets.map((b, index) => {
        var JSCompiler_temp_const = b.open, JSCompiler_temp_const$jscomp$0 = b.close;
        var JSCompiler_inline_result = b.close;
        var pieces = [];
        pieces = pieces.concat(b.open);
        pieces = pieces.concat(JSCompiler_inline_result);
        for (let i = 0, len = pieces.length; i < len; i++) {
          collectSuperstrings(pieces[i], brackets, index, pieces);
        }
        pieces = unique(pieces);
        pieces.sort(lengthcmp);
        pieces.reverse();
        JSCompiler_inline_result = createBracketOrRegExp(pieces);
        pieces = b.close;
        let pieces$jscomp$0 = [];
        pieces$jscomp$0 = pieces$jscomp$0.concat(b.open);
        pieces$jscomp$0 = pieces$jscomp$0.concat(pieces);
        for (let i = 0, len = pieces$jscomp$0.length; i < len; i++) {
          collectSuperstrings(pieces$jscomp$0[i], brackets, index, pieces$jscomp$0);
        }
        pieces$jscomp$0 = unique(pieces$jscomp$0);
        pieces$jscomp$0.sort(lengthcmp);
        pieces$jscomp$0.reverse();
        b = createBracketOrRegExp(pieces$jscomp$0.map(toReversedString));
        return new RichEditBracket(languageId, index, JSCompiler_temp_const, JSCompiler_temp_const$jscomp$0, JSCompiler_inline_result, b);
      });
      this.forwardRegex = getRegexForBrackets(this.brackets);
      this.reversedRegex = getReversedRegexForBrackets(this.brackets);
      this.textIsBracket = {};
      this.textIsOpenBracket = {};
      this.maxBracketLength = 0;
      for (const bracket of this.brackets) {
        for (const open of bracket.open) {
          this.textIsBracket[open] = bracket, this.textIsOpenBracket[open] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, open.length);
        }
        for (const close of bracket.close) {
          this.textIsBracket[close] = bracket, this.textIsOpenBracket[close] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, close.length);
        }
      }
    }
  }
  const toReversedString = function() {
    let lastInput = null, lastOutput = null;
    return function(str) {
      if (lastInput !== str) {
        str = lastInput = str;
        const arr = new Uint16Array(str.length);
        let offset = 0;
        for (let i = str.length - 1; i >= 0; i--) {
          arr[offset++] = str.charCodeAt(i);
        }
        lastOutput = stringBuilder.getPlatformTextDecoder().decode(arr);
      }
      return lastOutput;
    };
  }();
  class BracketsUtils {
    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {
      reversedBracketRegex = reversedText.match(reversedBracketRegex);
      if (!reversedBracketRegex) {
        return null;
      }
      reversedText = offset + (reversedText.length - (reversedBracketRegex.index || 0));
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, reversedText - reversedBracketRegex[0].length + 1, lineNumber, reversedText + 1);
    }
    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {
      lineText = toReversedString(lineText).substring(lineText.length - endOffset, lineText.length - startOffset);
      return this._findPrevBracketInText(reversedBracketRegex, lineNumber, lineText, startOffset);
    }
    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {
      text = text.match(bracketRegex);
      if (!text) {
        return null;
      }
      bracketRegex = text[0].length;
      if (bracketRegex === 0) {
        return null;
      }
      offset += text.index || 0;
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, offset + 1, lineNumber, offset + 1 + bracketRegex);
    }
    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {
      lineText = lineText.substring(startOffset, endOffset);
      return this.findNextBracketInText(bracketRegex, lineNumber, lineText, startOffset);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports$richEditBrackets.js.map
