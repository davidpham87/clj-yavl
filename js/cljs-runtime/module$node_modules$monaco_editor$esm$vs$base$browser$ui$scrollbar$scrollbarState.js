shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$scrollbar$scrollbarState = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ScrollbarState:{enumerable:!0, get:function() {
    return ScrollbarState;
  }}});
  class ScrollbarState {
    constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {
      this._scrollbarSize = Math.round(scrollbarSize);
      this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
      this._arrowSize = Math.round(arrowSize);
      this._visibleSize = visibleSize;
      this._scrollSize = scrollSize;
      this._scrollPosition = scrollPosition;
      this._computedAvailableSize = 0;
      this._computedIsNeeded = !1;
      this._computedSliderPosition = this._computedSliderRatio = this._computedSliderSize = 0;
      this._refreshComputedValues();
    }
    clone() {
      return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    }
    setVisibleSize(visibleSize) {
      visibleSize = Math.round(visibleSize);
      return this._visibleSize !== visibleSize ? (this._visibleSize = visibleSize, this._refreshComputedValues(), !0) : !1;
    }
    setScrollSize(scrollSize) {
      scrollSize = Math.round(scrollSize);
      return this._scrollSize !== scrollSize ? (this._scrollSize = scrollSize, this._refreshComputedValues(), !0) : !1;
    }
    setScrollPosition(scrollPosition) {
      scrollPosition = Math.round(scrollPosition);
      return this._scrollPosition !== scrollPosition ? (this._scrollPosition = scrollPosition, this._refreshComputedValues(), !0) : !1;
    }
    setScrollbarSize(scrollbarSize) {
      this._scrollbarSize = Math.round(scrollbarSize);
    }
    setOppositeScrollbarSize(oppositeScrollbarSize) {
      this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
    }
    static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {
      oppositeScrollbarSize = Math.max(0, visibleSize - oppositeScrollbarSize);
      const computedRepresentableSize = Math.max(0, oppositeScrollbarSize - 2 * arrowSize);
      arrowSize = scrollSize > 0 && scrollSize > visibleSize;
      if (!arrowSize) {
        return {computedAvailableSize:Math.round(oppositeScrollbarSize), computedIsNeeded:arrowSize, computedSliderSize:Math.round(computedRepresentableSize), computedSliderRatio:0, computedSliderPosition:0};
      }
      const computedSliderSize = Math.round(Math.max(20, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));
      visibleSize = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);
      return {computedAvailableSize:Math.round(oppositeScrollbarSize), computedIsNeeded:arrowSize, computedSliderSize:Math.round(computedSliderSize), computedSliderRatio:visibleSize, computedSliderPosition:Math.round(scrollPosition * visibleSize)};
    }
    _refreshComputedValues() {
      const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
      this._computedAvailableSize = r.computedAvailableSize;
      this._computedIsNeeded = r.computedIsNeeded;
      this._computedSliderSize = r.computedSliderSize;
      this._computedSliderRatio = r.computedSliderRatio;
      this._computedSliderPosition = r.computedSliderPosition;
    }
    getArrowSize() {
      return this._arrowSize;
    }
    getScrollPosition() {
      return this._scrollPosition;
    }
    getRectangleLargeSize() {
      return this._computedAvailableSize;
    }
    getRectangleSmallSize() {
      return this._scrollbarSize;
    }
    isNeeded() {
      return this._computedIsNeeded;
    }
    getSliderSize() {
      return this._computedSliderSize;
    }
    getSliderPosition() {
      return this._computedSliderPosition;
    }
    getDesiredScrollPositionFromOffset(offset) {
      return this._computedIsNeeded ? Math.round((offset - this._arrowSize - this._computedSliderSize / 2) / this._computedSliderRatio) : 0;
    }
    getDesiredScrollPositionFromOffsetPaged(offset) {
      if (!this._computedIsNeeded) {
        return 0;
      }
      let desiredScrollPosition = this._scrollPosition;
      return desiredScrollPosition = offset - this._arrowSize < this._computedSliderPosition ? desiredScrollPosition - this._visibleSize : desiredScrollPosition + this._visibleSize;
    }
    getDesiredScrollPositionFromDelta(delta) {
      return this._computedIsNeeded ? Math.round((this._computedSliderPosition + delta) / this._computedSliderRatio) : 0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$scrollbar$scrollbarState.js.map
