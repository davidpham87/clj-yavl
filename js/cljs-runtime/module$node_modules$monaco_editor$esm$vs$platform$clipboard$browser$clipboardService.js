shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$clipboard$browser$clipboardService = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BrowserClipboardService:{enumerable:!0, get:function() {
    return BrowserClipboardService;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_browser_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$browser"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  exports = require("module$node_modules$monaco_editor$esm$vs$platform$layout$browser$layoutService");
  require = require("module$node_modules$monaco_editor$esm$vs$platform$log$common$log");
  var __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  let BrowserClipboardService = class extends module.Disposable {
    constructor(layoutService, logService) {
      super();
      this.layoutService = layoutService;
      this.logService = logService;
      this.mapTextToType = new Map();
      this.findText = "";
      this.resources = [];
      (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_browser_DOT_js.isSafari || require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_browser_DOT_js.isWebkitWebView) && this.installWebKitWriteTextWorkaround();
    }
    installWebKitWriteTextWorkaround() {
      const handler = () => {
        const currentWritePromise = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.DeferredPromise();
        this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel();
        this.webKitPendingClipboardWritePromise = currentWritePromise;
        navigator.clipboard.write([new ClipboardItem({"text/plain":currentWritePromise.p})]).catch(async err => {
          err instanceof Error && err.name === "NotAllowedError" && currentWritePromise.isRejected || this.logService.error(err);
        });
      };
      this._register(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({container, disposables}) => {
        disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js.addDisposableListener)(container, "click", handler));
        disposables.add((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js.addDisposableListener)(container, "keydown", handler));
      }, {container:this.layoutService.mainContainer, disposables:this._store}));
    }
    async writeText(text, type) {
      if (type) {
        this.mapTextToType.set(type, text);
      } else {
        if (this.webKitPendingClipboardWritePromise) {
          return this.webKitPendingClipboardWritePromise.complete(text);
        }
        try {
          return await navigator.clipboard.writeText(text);
        } catch (error) {
          console.error(error);
        }
        type = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js.getActiveDocument)();
        var activeElement = type.activeElement, textArea = type.body.appendChild((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_dom_DOT_js.$)("textarea", {"aria-hidden":!0}));
        textArea.style.height = "1px";
        textArea.style.width = "1px";
        textArea.style.position = "absolute";
        textArea.value = text;
        textArea.focus();
        textArea.select();
        type.execCommand("copy");
        activeElement instanceof HTMLElement && activeElement.focus();
        type.body.removeChild(textArea);
      }
    }
    async readText(type) {
      if (type) {
        return this.mapTextToType.get(type) || "";
      }
      try {
        return await navigator.clipboard.readText();
      } catch (error) {
        return console.error(error), "";
      }
    }
    async readFindText() {
      return this.findText;
    }
    async writeFindText(text) {
      this.findText = text;
    }
    async writeResources(resources) {
      this.resources = resources;
    }
    async readResources() {
      return this.resources;
    }
  };
  BrowserClipboardService = (this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  })([__param(0, exports.ILayoutService), __param(1, require.ILogService)], BrowserClipboardService);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$clipboard$browser$clipboardService.js.map
