shadow$provide.module$node_modules$vega_regression$build$vega_regression = function(require, module, exports) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("module$node_modules$vega_statistics$build$vega_statistics"), require("module$node_modules$vega_dataflow$build$vega_dataflow"), require("module$node_modules$vega_util$build$vega_util")) : typeof define === "function" && define.amd ? define(["exports", "vega-statistics", "vega-dataflow", "vega-util"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.vega = 
    {}, global.vega, global.vega, global.vega));
  })(this, function(exports, vegaStatistics, vegaDataflow, vegaUtil) {
    function partition(data, groupby) {
      var groups = [], get = function(f) {
        return f(t);
      }, n;
      if (groupby == null) {
        groups.push(data);
      } else {
        var map = {};
        var i = 0;
        for (n = data.length; i < n; ++i) {
          var t = data[i];
          var k = groupby.map(get);
          var g = map[k];
          g || (map[k] = g = [], g.dims = k, groups.push(g));
          g.push(t);
        }
      }
      return groups;
    }
    function Loess(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    function Regression(params) {
      vegaDataflow.Transform.call(this, null, params);
    }
    Loess.Definition = {type:"Loess", metadata:{generates:!0}, params:[{name:"x", type:"field", required:!0}, {name:"y", type:"field", required:!0}, {name:"groupby", type:"field", array:!0}, {name:"bandwidth", type:"number", "default":0.3}, {name:"as", type:"string", array:!0}]};
    vegaUtil.inherits(Loess, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      if (!this.value || pulse.changed() || _.modified()) {
        pulse = pulse.materialize(pulse.SOURCE).source;
        pulse = partition(pulse, _.groupby);
        const names = (_.groupby || []).map(vegaUtil.accessorName), m = names.length, as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)], values = [];
        pulse.forEach(g => {
          vegaStatistics.regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {
            const t = {};
            for (let i = 0; i < m; ++i) {
              t[names[i]] = g.dims[i];
            }
            t[as[0]] = p[0];
            t[as[1]] = p[1];
            values.push(vegaDataflow.ingest(t));
          });
        });
        this.value && (out.rem = this.value);
        this.value = out.add = out.source = values;
      }
      return out;
    }});
    const Methods = {constant:vegaStatistics.regressionConstant, linear:vegaStatistics.regressionLinear, log:vegaStatistics.regressionLog, exp:vegaStatistics.regressionExp, pow:vegaStatistics.regressionPow, quad:vegaStatistics.regressionQuad, poly:vegaStatistics.regressionPoly};
    Regression.Definition = {type:"Regression", metadata:{generates:!0}, params:[{name:"x", type:"field", required:!0}, {name:"y", type:"field", required:!0}, {name:"groupby", type:"field", array:!0}, {name:"method", type:"string", "default":"linear", values:Object.keys(Methods)}, {name:"order", type:"number", "default":3}, {name:"extent", type:"number", array:!0, length:2}, {name:"params", type:"boolean", "default":!1}, {name:"as", type:"string", array:!0}]};
    vegaUtil.inherits(Regression, vegaDataflow.Transform, {transform(_, pulse) {
      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
      if (!this.value || pulse.changed() || _.modified()) {
        var source = pulse.materialize(pulse.SOURCE).source;
        source = partition(source, _.groupby);
        const names = (_.groupby || []).map(vegaUtil.accessorName), method = _.method || "linear", order = _.order == null ? 3 : _.order, dof = method === "poly" ? order : method === "quad" ? 2 : 1, as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)], fit = Methods[method], values = [];
        let domain = _.extent;
        vegaUtil.hasOwnProperty(Methods, method) || vegaUtil.error("Invalid regression method: " + method);
        domain != null && method === "log" && domain[0] <= 0 && (pulse.dataflow.warn("Ignoring extent with values \x3c\x3d 0 for log regression."), domain = null);
        source.forEach(g => {
          if (g.length <= dof) {
            pulse.dataflow.warn("Skipping regression with more parameters than data points.");
          } else {
            var model = fit(g, _.x, _.y, order);
            if (_.params) {
              values.push(vegaDataflow.ingest({keys:g.dims, coef:model.coef, rSquared:model.rSquared}));
            } else {
              var dom = domain || vegaUtil.extent(g, _.x), add = p => {
                const t = {};
                for (let i = 0; i < names.length; ++i) {
                  t[names[i]] = g.dims[i];
                }
                t[as[0]] = p[0];
                t[as[1]] = p[1];
                values.push(vegaDataflow.ingest(t));
              };
              method === "linear" || method === "constant" ? dom.forEach(x => add([x, model.predict(x)])) : vegaStatistics.sampleCurve(model.predict, dom, 25, 200).forEach(add);
            }
          }
        });
        this.value && (out.rem = this.value);
        this.value = out.add = out.source = values;
      }
      return out;
    }});
    exports.loess = Loess;
    exports.regression = Regression;
  });
};

//# sourceMappingURL=module$node_modules$vega_regression$build$vega_regression.js.map
