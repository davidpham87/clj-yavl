shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$monospaceLineBreaksComputer = function(require, module, exports) {
  function createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {
    _lineText = require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText.applyInjectedText(_lineText, injectedTexts);
    let injectionOptions, injectionOffsets;
    injectedTexts && injectedTexts.length > 0 ? (injectionOptions = injectedTexts.map(t => t.options), injectionOffsets = injectedTexts.map(text => text.column - 1)) : injectionOffsets = injectionOptions = null;
    if (firstLineBreakColumn === -1) {
      return injectionOptions ? new require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectionOffsets, injectionOptions, [_lineText.length], [], 0) : null;
    }
    const len = _lineText.length;
    if (len <= 1) {
      return injectionOptions ? new require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectionOffsets, injectionOptions, [_lineText.length], [], 0) : null;
    }
    wordBreak = wordBreak === "keepAll";
    wrappingIndent = computeWrappedTextIndentLength(_lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);
    const wrappedLineBreakColumn = firstLineBreakColumn - wrappingIndent, breakingOffsets = [], breakingOffsetsVisibleColumn = [];
    let breakingOffsetsCount = 0, breakOffset = 0, breakOffsetVisibleColumn = 0, prevCharCode = _lineText.charCodeAt(0), prevCharCodeClass = classifier.get(prevCharCode), visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);
    var startOffset = 1;
    strings.isHighSurrogate(prevCharCode) && (visibleColumn += 1, prevCharCode = _lineText.charCodeAt(1), prevCharCodeClass = classifier.get(prevCharCode), startOffset++);
    for (; startOffset < len; startOffset++) {
      const charStartOffset = startOffset, charCode = _lineText.charCodeAt(startOffset);
      let charCodeClass, charWidth;
      strings.isHighSurrogate(charCode) ? (startOffset++, charCodeClass = 0, charWidth = 2) : (charCodeClass = classifier.get(charCode), charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar));
      canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, wordBreak) && (breakOffset = charStartOffset, breakOffsetVisibleColumn = visibleColumn);
      visibleColumn += charWidth;
      if (visibleColumn > firstLineBreakColumn) {
        if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {
          breakOffset = charStartOffset, breakOffsetVisibleColumn = visibleColumn - charWidth;
        }
        breakingOffsets[breakingOffsetsCount] = breakOffset;
        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;
        breakingOffsetsCount++;
        firstLineBreakColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;
        breakOffset = 0;
      }
      prevCharCode = charCode;
      prevCharCodeClass = charCodeClass;
    }
    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {
      return null;
    }
    breakingOffsets[breakingOffsetsCount] = len;
    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;
    return new require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappingIndent);
  }
  function computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {
    return charCode === 9 ? tabSize - visibleColumn % tabSize : strings.isFullWidthCharacter(charCode) || charCode < 32 ? columnsForFullWidthChar : 1;
  }
  function canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {
    return charCode !== 32 && (prevCharCodeClass === 2 && charCodeClass !== 2 || prevCharCodeClass !== 1 && charCodeClass === 1 || !isKeepAll && prevCharCodeClass === 3 && charCodeClass !== 2 || !isKeepAll && charCodeClass === 3 && prevCharCodeClass !== 1);
  }
  function computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {
    let wrappedTextIndentLength = 0;
    if (wrappingIndent !== 0) {
      const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);
      if (firstNonWhitespaceIndex !== -1) {
        for (let i = 0; i < firstNonWhitespaceIndex; i++) {
          const charWidth = lineText.charCodeAt(i) === 9 ? tabSize - wrappedTextIndentLength % tabSize : 1;
          wrappedTextIndentLength += charWidth;
        }
        lineText = wrappingIndent === 3 ? 2 : wrappingIndent === 2 ? 1 : 0;
        for (wrappingIndent = 0; wrappingIndent < lineText; wrappingIndent++) {
          wrappedTextIndentLength += tabSize - wrappedTextIndentLength % tabSize;
        }
        wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn && (wrappedTextIndentLength = 0);
      }
    }
    return wrappedTextIndentLength;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MonospaceLineBreaksComputerFactory:{enumerable:!0, get:function() {
    return MonospaceLineBreaksComputerFactory;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$characterClassifier");
  var require$_DOT__DOT__SLASH_textModelEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents"), require$_DOT__DOT__SLASH_modelLineProjectionData_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$modelLineProjectionData");
  class MonospaceLineBreaksComputerFactory {
    static create(options) {
      return new MonospaceLineBreaksComputerFactory(options.get(132), options.get(131));
    }
    constructor(breakBeforeChars, breakAfterChars) {
      this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);
    }
    createLineBreaksComputer(fontInfo, tabSize$jscomp$0, wrappingColumn, wrappingIndent, wordBreak) {
      const requests = [], injectedTexts = [], previousBreakingData = [];
      return {addRequest:(lineText, injectedText, previousLineBreakData) => {
        requests.push(lineText);
        injectedTexts.push(injectedText);
        previousBreakingData.push(previousLineBreakData);
      }, finalize:() => {
        const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth, result = [];
        for (let i = 0, len = requests.length; i < len; i++) {
          var injectedText = injectedTexts[i], previousLineBreakData = previousBreakingData[i];
          if (!previousLineBreakData || previousLineBreakData.injectionOptions || injectedText) {
            result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize$jscomp$0, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);
          } else {
            injectedText = i;
            a: {
              var JSCompiler_inline_result = this.classifier;
              var lineText = requests[i], tabSize = tabSize$jscomp$0, firstLineBreakColumn = wrappingColumn;
              if (firstLineBreakColumn === -1) {
                JSCompiler_inline_result = null;
                break a;
              }
              const len = lineText.length;
              if (len <= 1) {
                JSCompiler_inline_result = null;
                break a;
              }
              const isKeepAll = wordBreak === "keepAll", prevBreakingOffsets = previousLineBreakData.breakOffsets, prevBreakingOffsetsVisibleColumn = previousLineBreakData.breakOffsetsVisibleColumn, wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent), wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength, breakingOffsets = arrPool1, breakingOffsetsVisibleColumn = arrPool2;
              let breakingOffsetsCount = 0, lastBreakingOffset = 0, lastBreakingOffsetVisibleColumn = 0;
              var breakingColumn = firstLineBreakColumn;
              firstLineBreakColumn = prevBreakingOffsets.length;
              let prevIndex = 0;
              if (prevIndex >= 0) {
                for (var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn); prevIndex + 1 < firstLineBreakColumn;) {
                  var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);
                  if (distance >= bestDistance) {
                    break;
                  }
                  bestDistance = distance;
                  prevIndex++;
                }
              }
              for (; prevIndex < firstLineBreakColumn;) {
                var prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex], prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];
                lastBreakingOffset > prevBreakOffset && (prevBreakOffset = lastBreakingOffset, prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn);
                let forcedBreakOffset = distance = bestDistance = 0, forcedBreakOffsetVisibleColumn = 0;
                if (prevBreakOffsetVisibleColumn <= breakingColumn) {
                  var visibleColumn = prevBreakOffsetVisibleColumn, prevCharCode = prevBreakOffset === 0 ? 0 : lineText.charCodeAt(prevBreakOffset - 1), prevCharCodeClass = prevBreakOffset === 0 ? 0 : JSCompiler_inline_result.get(prevCharCode), entireLineFits = !0;
                  for (var i$jscomp$0 = prevBreakOffset; i$jscomp$0 < len; i$jscomp$0++) {
                    var charStartOffset = i$jscomp$0, charCode = lineText.charCodeAt(i$jscomp$0);
                    let charCodeClass, charWidth;
                    strings.isHighSurrogate(charCode) ? (i$jscomp$0++, charCodeClass = 0, charWidth = 2) : (charCodeClass = JSCompiler_inline_result.get(charCode), charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar));
                    charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) && (bestDistance = charStartOffset, distance = visibleColumn);
                    visibleColumn += charWidth;
                    if (visibleColumn > breakingColumn) {
                      charStartOffset > lastBreakingOffset ? (forcedBreakOffset = charStartOffset, forcedBreakOffsetVisibleColumn = visibleColumn - charWidth) : (forcedBreakOffset = i$jscomp$0 + 1, forcedBreakOffsetVisibleColumn = visibleColumn);
                      visibleColumn - distance > wrappedLineBreakColumn && (bestDistance = 0);
                      entireLineFits = !1;
                      break;
                    }
                    prevCharCode = charCode;
                    prevCharCodeClass = charCodeClass;
                  }
                  if (entireLineFits) {
                    breakingOffsetsCount > 0 && (breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1], breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1], breakingOffsetsCount++);
                    break;
                  }
                }
                if (bestDistance === 0) {
                  visibleColumn = prevBreakOffsetVisibleColumn;
                  prevCharCode = lineText.charCodeAt(prevBreakOffset);
                  prevCharCodeClass = JSCompiler_inline_result.get(prevCharCode);
                  prevBreakOffsetVisibleColumn = !1;
                  for (--prevBreakOffset; prevBreakOffset >= lastBreakingOffset; prevBreakOffset--) {
                    entireLineFits = prevBreakOffset + 1;
                    i$jscomp$0 = lineText.charCodeAt(prevBreakOffset);
                    if (i$jscomp$0 === 9) {
                      prevBreakOffsetVisibleColumn = !0;
                      break;
                    }
                    strings.isLowSurrogate(i$jscomp$0) ? (prevBreakOffset--, charStartOffset = 0, charCode = 2) : (charStartOffset = JSCompiler_inline_result.get(i$jscomp$0), charCode = strings.isFullWidthCharacter(i$jscomp$0) ? columnsForFullWidthChar : 1);
                    if (visibleColumn <= breakingColumn) {
                      forcedBreakOffset === 0 && (forcedBreakOffset = entireLineFits, forcedBreakOffsetVisibleColumn = visibleColumn);
                      if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {
                        break;
                      }
                      if (canBreak(i$jscomp$0, charStartOffset, prevCharCode, prevCharCodeClass, isKeepAll)) {
                        bestDistance = entireLineFits;
                        distance = visibleColumn;
                        break;
                      }
                    }
                    visibleColumn -= charCode;
                    prevCharCode = i$jscomp$0;
                    prevCharCodeClass = charStartOffset;
                  }
                  bestDistance !== 0 && (prevBreakOffset = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - distance), prevBreakOffset <= tabSize && (visibleColumn = lineText.charCodeAt(forcedBreakOffset), visibleColumn = strings.isHighSurrogate(visibleColumn) ? 2 : computeCharWidth(visibleColumn, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar), prevBreakOffset - visibleColumn < 0 && (bestDistance = 0)));
                  if (prevBreakOffsetVisibleColumn) {
                    prevIndex--;
                    continue;
                  }
                }
                bestDistance === 0 && (bestDistance = forcedBreakOffset, distance = forcedBreakOffsetVisibleColumn);
                bestDistance <= lastBreakingOffset && (breakingColumn = lineText.charCodeAt(lastBreakingOffset), strings.isHighSurrogate(breakingColumn) ? (bestDistance = lastBreakingOffset + 2, distance = lastBreakingOffsetVisibleColumn + 2) : (bestDistance = lastBreakingOffset + 1, distance = lastBreakingOffsetVisibleColumn + computeCharWidth(breakingColumn, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar)));
                lastBreakingOffset = bestDistance;
                breakingOffsets[breakingOffsetsCount] = bestDistance;
                lastBreakingOffsetVisibleColumn = distance;
                breakingOffsetsVisibleColumn[breakingOffsetsCount] = distance;
                breakingOffsetsCount++;
                for (breakingColumn = distance + wrappedLineBreakColumn; prevIndex < 0 || prevIndex < firstLineBreakColumn && prevBreakingOffsetsVisibleColumn[prevIndex] < distance;) {
                  prevIndex++;
                }
                for (bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn); prevIndex + 1 < firstLineBreakColumn;) {
                  distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);
                  if (distance >= bestDistance) {
                    break;
                  }
                  bestDistance = distance;
                  prevIndex++;
                }
              }
              breakingOffsetsCount === 0 ? JSCompiler_inline_result = null : (breakingOffsets.length = breakingOffsetsCount, breakingOffsetsVisibleColumn.length = breakingOffsetsCount, arrPool1 = previousLineBreakData.breakOffsets, arrPool2 = previousLineBreakData.breakOffsetsVisibleColumn, previousLineBreakData.breakOffsets = breakingOffsets, previousLineBreakData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn, previousLineBreakData.wrappedTextIndentLength = wrappedTextIndentLength, JSCompiler_inline_result = 
              previousLineBreakData);
            }
            result[injectedText] = JSCompiler_inline_result;
          }
        }
        arrPool1.length = 0;
        arrPool2.length = 0;
        return result;
      }};
    }
  }
  class WrappingCharacterClassifier extends module.CharacterClassifier {
    constructor(BREAK_BEFORE, BREAK_AFTER) {
      super(0);
      for (let i = 0; i < BREAK_BEFORE.length; i++) {
        this.set(BREAK_BEFORE.charCodeAt(i), 1);
      }
      for (BREAK_BEFORE = 0; BREAK_BEFORE < BREAK_AFTER.length; BREAK_BEFORE++) {
        this.set(BREAK_AFTER.charCodeAt(BREAK_BEFORE), 2);
      }
    }
    get(charCode) {
      return charCode >= 0 && charCode < 256 ? this._asciiMap[charCode] : charCode >= 12352 && charCode <= 12543 || charCode >= 13312 && charCode <= 19903 || charCode >= 19968 && charCode <= 40959 ? 3 : this._map.get(charCode) || this._defaultValue;
    }
  }
  let arrPool1 = [], arrPool2 = [];
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$monospaceLineBreaksComputer.js.map
