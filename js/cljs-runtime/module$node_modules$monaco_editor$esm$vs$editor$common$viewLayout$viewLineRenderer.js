shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$viewLineRenderer = function(require, module, exports) {
  function renderViewLine(input, sb) {
    if (input.lineContent.length === 0) {
      if (input.lineDecorations.length > 0) {
        sb.appendString("\x3cspan\x3e");
        let beforeCount = 0, afterCount = 0, containsForeignElements = 0;
        for (const lineDecoration of input.lineDecorations) {
          if (lineDecoration.type === 1 || lineDecoration.type === 2) {
            sb.appendString('\x3cspan class\x3d"'), sb.appendString(lineDecoration.className), sb.appendString('"\x3e\x3c/span\x3e'), lineDecoration.type === 1 && (containsForeignElements |= 1, beforeCount++), lineDecoration.type === 2 && (containsForeignElements |= 2, afterCount++);
          }
        }
        sb.appendString("\x3c/span\x3e");
        const characterMapping = new CharacterMapping(1, beforeCount + afterCount);
        characterMapping.setColumnInfo(1, beforeCount, 0, 0);
        return new RenderLineOutput(characterMapping, !1, containsForeignElements);
      }
      sb.appendString("\x3cspan\x3e\x3cspan\x3e\x3c/span\x3e\x3c/span\x3e");
      return new RenderLineOutput(new CharacterMapping(0, 0), !1, 0);
    }
    const lineContent = input.lineContent;
    let isOverflowing, overflowingCharCount, len;
    input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length ? (isOverflowing = !0, overflowingCharCount = lineContent.length - input.stopRenderingLineAfter, len = input.stopRenderingLineAfter) : (isOverflowing = !1, overflowingCharCount = 0, len = lineContent.length);
    var lineContainsRTL = input.containsRTL, tokens = input.lineTokens, fauxIndentLength = input.fauxIndentLength, len$jscomp$0 = len;
    const result = [];
    let resultLen = 0;
    fauxIndentLength > 0 && (result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(fauxIndentLength, "", 0, !1));
    let startOffset = fauxIndentLength;
    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {
      const endIndex = tokens.getEndOffset(tokenIndex);
      if (endIndex <= fauxIndentLength) {
        continue;
      }
      const type = tokens.getClassName(tokenIndex);
      if (endIndex >= len$jscomp$0) {
        const tokenContainsRTL = lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len$jscomp$0)) : !1;
        result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(len$jscomp$0, type, 0, tokenContainsRTL);
        break;
      }
      const tokenContainsRTL = lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : !1;
      result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(endIndex, type, 0, tokenContainsRTL);
      startOffset = endIndex;
    }
    let tokens$jscomp$0 = result;
    if (input.renderControlCharacters && !input.isBasicASCII) {
      var tokens$jscomp$1 = tokens$jscomp$0;
      const result = [];
      let lastLinePart = new require$_DOT__SLASH_linePart_DOT_js.LinePart(0, "", 0, !1), charOffset = 0;
      for (const token of tokens$jscomp$1) {
        const tokenEndIndex = token.endIndex;
        for (; charOffset < tokenEndIndex; charOffset++) {
          const charCode = lineContent.charCodeAt(charOffset);
          isControlCharacter(charCode) && (charOffset > lastLinePart.endIndex && (lastLinePart = new require$_DOT__SLASH_linePart_DOT_js.LinePart(charOffset, token.type, token.metadata, token.containsRTL), result.push(lastLinePart)), lastLinePart = new require$_DOT__SLASH_linePart_DOT_js.LinePart(charOffset + 1, "mtkcontrol", token.metadata, !1), result.push(lastLinePart));
        }
        charOffset > lastLinePart.endIndex && (lastLinePart = new require$_DOT__SLASH_linePart_DOT_js.LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL), result.push(lastLinePart));
      }
      tokens$jscomp$0 = result;
    }
    if (input.renderWhitespace === 4 || input.renderWhitespace === 1 || input.renderWhitespace === 2 && input.selectionsOnLine || input.renderWhitespace === 3 && !input.continuesWithWrappedLine) {
      var len$jscomp$1 = len, tokens$jscomp$2 = tokens$jscomp$0;
      const continuesWithWrappedLine = input.continuesWithWrappedLine, fauxIndentLength = input.fauxIndentLength, tabSize = input.tabSize, startVisibleColumn = input.startVisibleColumn, useMonospaceOptimizations = input.useMonospaceOptimizations, selections = input.selectionsOnLine, onlyBoundary = input.renderWhitespace === 1, onlyTrailing = input.renderWhitespace === 3, generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth, result = [];
      let resultLen = 0, tokenIndex = 0, tokenType = tokens$jscomp$2[tokenIndex].type, tokenContainsRTL = tokens$jscomp$2[tokenIndex].containsRTL, tokenEndIndex = tokens$jscomp$2[tokenIndex].endIndex;
      const tokensLength = tokens$jscomp$2.length;
      let lineIsEmptyOrWhitespace = !1, firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent), lastNonWhitespaceIndex;
      firstNonWhitespaceIndex === -1 ? (lineIsEmptyOrWhitespace = !0, lastNonWhitespaceIndex = firstNonWhitespaceIndex = len$jscomp$1) : lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);
      let wasInWhitespace = !1, currentSelectionIndex = 0, currentSelection = selections && selections[currentSelectionIndex], tmpIndent = startVisibleColumn % tabSize;
      for (let charIndex = fauxIndentLength; charIndex < len$jscomp$1; charIndex++) {
        const chCode = lineContent.charCodeAt(charIndex);
        currentSelection && charIndex >= currentSelection.endOffset && (currentSelectionIndex++, currentSelection = selections && selections[currentSelectionIndex]);
        let isInWhitespace;
        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {
          isInWhitespace = !0;
        } else if (chCode === 9) {
          isInWhitespace = !0;
        } else if (chCode === 32) {
          if (onlyBoundary) {
            if (wasInWhitespace) {
              isInWhitespace = !0;
            } else {
              const nextChCode = charIndex + 1 < len$jscomp$1 ? lineContent.charCodeAt(charIndex + 1) : 0;
              isInWhitespace = nextChCode === 32 || nextChCode === 9;
            }
          } else {
            isInWhitespace = !0;
          }
        } else {
          isInWhitespace = !1;
        }
        isInWhitespace && selections && (isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex);
        isInWhitespace && onlyTrailing && (isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex);
        isInWhitespace && tokenContainsRTL && charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex && (isInWhitespace = !1);
        if (wasInWhitespace) {
          if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {
            if (generateLinePartForEachWhitespace) {
              const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;
              for (let i = lastEndIndex + 1; i <= charIndex; i++) {
                result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(i, "mtkw", 1, !1);
              }
            } else {
              result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(charIndex, "mtkw", 1, !1);
            }
            tmpIndent %= tabSize;
          }
        } else {
          if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {
            result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(charIndex, tokenType, 0, tokenContainsRTL), tmpIndent %= tabSize;
          }
        }
        chCode === 9 ? tmpIndent = tabSize : strings.isFullWidthCharacter(chCode) ? tmpIndent += 2 : tmpIndent++;
        for (wasInWhitespace = isInWhitespace; charIndex === tokenEndIndex;) {
          if (tokenIndex++, tokenIndex < tokensLength) {
            tokenType = tokens$jscomp$2[tokenIndex].type, tokenContainsRTL = tokens$jscomp$2[tokenIndex].containsRTL, tokenEndIndex = tokens$jscomp$2[tokenIndex].endIndex;
          } else {
            break;
          }
        }
      }
      let generateWhitespace = !1;
      if (wasInWhitespace) {
        if (continuesWithWrappedLine && onlyBoundary) {
          const lastCharCode = len$jscomp$1 > 0 ? lineContent.charCodeAt(len$jscomp$1 - 1) : 0, prevCharCode = len$jscomp$1 > 1 ? lineContent.charCodeAt(len$jscomp$1 - 2) : 0;
          if (lastCharCode !== 32 || prevCharCode === 32 || prevCharCode === 9) {
            generateWhitespace = !0;
          }
        } else {
          generateWhitespace = !0;
        }
      }
      if (generateWhitespace) {
        if (generateLinePartForEachWhitespace) {
          const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;
          for (let i = lastEndIndex + 1; i <= len$jscomp$1; i++) {
            result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(i, "mtkw", 1, !1);
          }
        } else {
          result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(len$jscomp$1, "mtkw", 1, !1);
        }
      } else {
        result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(len$jscomp$1, tokenType, 0, tokenContainsRTL);
      }
      tokens$jscomp$0 = result;
    }
    let containsForeignElements = 0;
    if (input.lineDecorations.length > 0) {
      for (let i = 0, len = input.lineDecorations.length; i < len; i++) {
        const lineDecoration = input.lineDecorations[i];
        lineDecoration.type === 3 ? containsForeignElements |= 1 : lineDecoration.type === 1 ? containsForeignElements |= 1 : lineDecoration.type === 2 && (containsForeignElements |= 2);
      }
      var tokens$jscomp$3 = tokens$jscomp$0, _lineDecorations = input.lineDecorations;
      _lineDecorations.sort(require$_DOT__SLASH_lineDecorations_DOT_js.LineDecoration.compare);
      const lineDecorations = require$_DOT__SLASH_lineDecorations_DOT_js.LineDecorationsNormalizer.normalize(lineContent, _lineDecorations), lineDecorationsLen = lineDecorations.length;
      let lineDecorationIndex = 0;
      const result = [];
      let resultLen = 0, lastResultEndIndex = 0;
      for (let tokenIndex = 0, len = tokens$jscomp$3.length; tokenIndex < len; tokenIndex++) {
        const token = tokens$jscomp$3[tokenIndex], tokenEndIndex = token.endIndex, tokenType = token.type, tokenMetadata = token.metadata, tokenContainsRTL = token.containsRTL;
        for (; lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex;) {
          const lineDecoration = lineDecorations[lineDecorationIndex];
          lineDecoration.startOffset > lastResultEndIndex && (lastResultEndIndex = lineDecoration.startOffset, result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL));
          if (lineDecoration.endOffset + 1 <= tokenEndIndex) {
            lastResultEndIndex = lineDecoration.endOffset + 1, result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(lastResultEndIndex, tokenType + " " + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL), lineDecorationIndex++;
          } else {
            lastResultEndIndex = tokenEndIndex;
            result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(lastResultEndIndex, tokenType + " " + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);
            break;
          }
        }
        tokenEndIndex > lastResultEndIndex && (lastResultEndIndex = tokenEndIndex, result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL));
      }
      const lastTokenEndIndex = tokens$jscomp$3[tokens$jscomp$3.length - 1].endIndex;
      if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {
        for (; lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex;) {
          const lineDecoration = lineDecorations[lineDecorationIndex];
          result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, !1);
          lineDecorationIndex++;
        }
      }
      tokens$jscomp$0 = result;
    }
    if (!input.containsRTL) {
      var tokens$jscomp$4 = tokens$jscomp$0;
      let lastTokenEndIndex = 0;
      const result = [];
      let resultLen = 0;
      if (!input.isBasicASCII || input.fontLigatures) {
        for (let i = 0, len = tokens$jscomp$4.length; i < len; i++) {
          const token = tokens$jscomp$4[i], tokenEndIndex = token.endIndex;
          if (lastTokenEndIndex + 50 < tokenEndIndex) {
            const tokenType = token.type, tokenMetadata = token.metadata, tokenContainsRTL = token.containsRTL;
            let lastSpaceOffset = -1, currTokenStart = lastTokenEndIndex;
            for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {
              lineContent.charCodeAt(j) === 32 && (lastSpaceOffset = j), lastSpaceOffset !== -1 && j - currTokenStart >= 50 && (result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL), currTokenStart = lastSpaceOffset + 1, lastSpaceOffset = -1);
            }
            currTokenStart !== tokenEndIndex && (result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL));
          } else {
            result[resultLen++] = token;
          }
          lastTokenEndIndex = tokenEndIndex;
        }
      } else {
        for (let i = 0, len = tokens$jscomp$4.length; i < len; i++) {
          const token = tokens$jscomp$4[i], tokenEndIndex = token.endIndex, diff = tokenEndIndex - lastTokenEndIndex;
          if (diff > 50) {
            const tokenType = token.type, tokenMetadata = token.metadata, tokenContainsRTL = token.containsRTL, piecesCount = Math.ceil(diff / 50);
            for (let j = 1; j < piecesCount; j++) {
              const pieceEndIndex = lastTokenEndIndex + j * 50;
              result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);
            }
            result[resultLen++] = new require$_DOT__SLASH_linePart_DOT_js.LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);
          } else {
            result[resultLen++] = token;
          }
          lastTokenEndIndex = tokenEndIndex;
        }
      }
      tokens$jscomp$0 = result;
    }
    var JSCompiler_inline_result = new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens$jscomp$0, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);
    const fontIsMonospace = JSCompiler_inline_result.fontIsMonospace, canUseHalfwidthRightwardsArrow = JSCompiler_inline_result.canUseHalfwidthRightwardsArrow, containsForeignElements$jscomp$0 = JSCompiler_inline_result.containsForeignElements, lineContent$jscomp$0 = JSCompiler_inline_result.lineContent, len$jscomp$2 = JSCompiler_inline_result.len, isOverflowing$jscomp$0 = JSCompiler_inline_result.isOverflowing, overflowingCharCount$jscomp$0 = JSCompiler_inline_result.overflowingCharCount, parts = 
    JSCompiler_inline_result.parts, fauxIndentLength$jscomp$0 = JSCompiler_inline_result.fauxIndentLength, tabSize = JSCompiler_inline_result.tabSize, startVisibleColumn = JSCompiler_inline_result.startVisibleColumn, containsRTL = JSCompiler_inline_result.containsRTL, spaceWidth = JSCompiler_inline_result.spaceWidth, renderSpaceCharCode = JSCompiler_inline_result.renderSpaceCharCode, renderWhitespace = JSCompiler_inline_result.renderWhitespace, renderControlCharacters = JSCompiler_inline_result.renderControlCharacters, 
    characterMapping = new CharacterMapping(len$jscomp$2 + 1, parts.length);
    let lastCharacterMappingDefined = !1, charIndex = 0, visibleColumn = startVisibleColumn, charOffsetInPart = 0, charHorizontalOffset = 0, partDisplacement = 0;
    containsRTL ? sb.appendString('\x3cspan dir\x3d"ltr"\x3e') : sb.appendString("\x3cspan\x3e");
    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {
      const part = parts[partIndex], partEndIndex = part.endIndex, partType = part.type, partContainsRTL = part.containsRTL, partRendersWhitespace = renderWhitespace !== 0 && part.isWhitespace(), partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === "mtkw" || !containsForeignElements$jscomp$0), partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.isPseudoAfter();
      charOffsetInPart = 0;
      sb.appendString("\x3cspan ");
      partContainsRTL && sb.appendString('style\x3d"unicode-bidi:isolate" ');
      sb.appendString('class\x3d"');
      sb.appendString(partRendersWhitespaceWithWidth ? "mtkz" : partType);
      sb.appendASCIICharCode(34);
      if (partRendersWhitespace) {
        let partWidth = 0, _charIndex = charIndex, _visibleColumn = visibleColumn;
        for (; _charIndex < partEndIndex; _charIndex++) {
          const charWidth = (lineContent$jscomp$0.charCodeAt(_charIndex) === 9 ? tabSize - _visibleColumn % tabSize : 1) | 0;
          partWidth += charWidth;
          _charIndex >= fauxIndentLength$jscomp$0 && (_visibleColumn += charWidth);
        }
        partRendersWhitespaceWithWidth && (sb.appendString(' style\x3d"width:'), sb.appendString(String(spaceWidth * partWidth)), sb.appendString('px"'));
        for (sb.appendASCIICharCode(62); charIndex < partEndIndex; charIndex++) {
          characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);
          partDisplacement = 0;
          let producedCharacters, charWidth;
          if (lineContent$jscomp$0.charCodeAt(charIndex) === 9) {
            charWidth = producedCharacters = tabSize - visibleColumn % tabSize | 0;
            !canUseHalfwidthRightwardsArrow || charWidth > 1 ? sb.appendCharCode(8594) : sb.appendCharCode(65515);
            for (let space = 2; space <= charWidth; space++) {
              sb.appendCharCode(160);
            }
          } else {
            producedCharacters = 2, charWidth = 1, sb.appendCharCode(renderSpaceCharCode), sb.appendCharCode(8204);
          }
          charOffsetInPart += producedCharacters;
          charHorizontalOffset += charWidth;
          charIndex >= fauxIndentLength$jscomp$0 && (visibleColumn += charWidth);
        }
      } else {
        for (sb.appendASCIICharCode(62); charIndex < partEndIndex; charIndex++) {
          characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);
          partDisplacement = 0;
          const charCode = lineContent$jscomp$0.charCodeAt(charIndex);
          let producedCharacters = 1, charWidth = 1;
          switch(charCode) {
            case 9:
              charWidth = producedCharacters = tabSize - visibleColumn % tabSize;
              for (let space = 1; space <= producedCharacters; space++) {
                sb.appendCharCode(160);
              }
              break;
            case 32:
              sb.appendCharCode(160);
              break;
            case 60:
              sb.appendString("\x26lt;");
              break;
            case 62:
              sb.appendString("\x26gt;");
              break;
            case 38:
              sb.appendString("\x26amp;");
              break;
            case 0:
              renderControlCharacters ? sb.appendCharCode(9216) : sb.appendString("\x26#00;");
              break;
            case 65279:
            case 8232:
            case 8233:
            case 133:
              sb.appendCharCode(65533);
              break;
            default:
              strings.isFullWidthCharacter(charCode) && charWidth++, renderControlCharacters && charCode < 32 ? sb.appendCharCode(9216 + charCode) : renderControlCharacters && charCode === 127 ? sb.appendCharCode(9249) : renderControlCharacters && isControlCharacter(charCode) ? (sb.appendString("[U+"), sb.appendString(charCode.toString(16).toUpperCase().padStart(4, "0")), sb.appendString("]"), charWidth = producedCharacters = 8) : sb.appendCharCode(charCode);
          }
          charOffsetInPart += producedCharacters;
          charHorizontalOffset += charWidth;
          charIndex >= fauxIndentLength$jscomp$0 && (visibleColumn += charWidth);
        }
      }
      partIsEmptyAndHasPseudoAfter ? partDisplacement++ : partDisplacement = 0;
      charIndex >= len$jscomp$2 && !lastCharacterMappingDefined && part.isPseudoAfter() && (lastCharacterMappingDefined = !0, characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset));
      sb.appendString("\x3c/span\x3e");
    }
    lastCharacterMappingDefined || characterMapping.setColumnInfo(len$jscomp$2 + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);
    isOverflowing$jscomp$0 && (sb.appendString('\x3cspan class\x3d"mtkoverflow"\x3e'), sb.appendString(nls.localize("showMore", "Show more ({0})", overflowingCharCount$jscomp$0 < 1024 ? nls.localize("overflow.chars", "{0} chars", overflowingCharCount$jscomp$0) : overflowingCharCount$jscomp$0 < 1048576 ? `${(overflowingCharCount$jscomp$0 / 1024).toFixed(1)} KB` : `${(overflowingCharCount$jscomp$0 / 1024 / 1024).toFixed(1)} MB`)), sb.appendString("\x3c/span\x3e"));
    sb.appendString("\x3c/span\x3e");
    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements$jscomp$0);
  }
  function renderViewLine2(input) {
    const sb = new require$_DOT__DOT__SLASH_core_SLASH_stringBuilder_DOT_js.StringBuilder(10000);
    input = renderViewLine(input, sb);
    return new RenderLineOutput2(input.characterMapping, sb.build(), input.containsRTL, input.containsForeignElements);
  }
  function isControlCharacter(charCode) {
    return charCode < 32 ? charCode !== 9 : charCode === 127 || charCode >= 8234 && charCode <= 8238 || charCode >= 8294 && charCode <= 8297 || charCode >= 8206 && charCode <= 8207 || charCode === 1564 ? !0 : !1;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CharacterMapping:{enumerable:!0, get:function() {
    return CharacterMapping;
  }}, DomPosition:{enumerable:!0, get:function() {
    return DomPosition;
  }}, LineRange:{enumerable:!0, get:function() {
    return LineRange;
  }}, RenderLineInput:{enumerable:!0, get:function() {
    return RenderLineInput;
  }}, RenderLineOutput:{enumerable:!0, get:function() {
    return RenderLineOutput;
  }}, RenderLineOutput2:{enumerable:!0, get:function() {
    return RenderLineOutput2;
  }}, renderViewLine:{enumerable:!0, get:function() {
    return renderViewLine;
  }}, renderViewLine2:{enumerable:!0, get:function() {
    return renderViewLine2;
  }}});
  var nls = require("module$node_modules$monaco_editor$esm$vs$nls"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_core_SLASH_stringBuilder_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder"), require$_DOT__SLASH_lineDecorations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$lineDecorations"), require$_DOT__SLASH_linePart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$linePart");
  class LineRange {
    constructor(startIndex, endIndex) {
      this.startOffset = startIndex;
      this.endOffset = endIndex;
    }
    equals(otherLineRange) {
      return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;
    }
  }
  class RenderLineInput {
    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {
      this.useMonospaceOptimizations = useMonospaceOptimizations;
      this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;
      this.lineContent = lineContent;
      this.continuesWithWrappedLine = continuesWithWrappedLine;
      this.isBasicASCII = isBasicASCII;
      this.containsRTL = containsRTL;
      this.fauxIndentLength = fauxIndentLength;
      this.lineTokens = lineTokens;
      this.lineDecorations = lineDecorations.sort(require$_DOT__SLASH_lineDecorations_DOT_js.LineDecoration.compare);
      this.tabSize = tabSize;
      this.startVisibleColumn = startVisibleColumn;
      this.spaceWidth = spaceWidth;
      this.stopRenderingLineAfter = stopRenderingLineAfter;
      this.renderWhitespace = renderWhitespace === "all" ? 4 : renderWhitespace === "boundary" ? 1 : renderWhitespace === "selection" ? 2 : renderWhitespace === "trailing" ? 3 : 0;
      this.renderControlCharacters = renderControlCharacters;
      this.fontLigatures = fontLigatures;
      this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);
      Math.abs(wsmiddotWidth - spaceWidth) < Math.abs(middotWidth - spaceWidth) ? (this.renderSpaceWidth = wsmiddotWidth, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = middotWidth, this.renderSpaceCharCode = 183);
    }
    sameSelection(otherSelections) {
      if (this.selectionsOnLine === null) {
        return otherSelections === null;
      }
      if (otherSelections === null || otherSelections.length !== this.selectionsOnLine.length) {
        return !1;
      }
      for (let i = 0; i < this.selectionsOnLine.length; i++) {
        if (!this.selectionsOnLine[i].equals(otherSelections[i])) {
          return !1;
        }
      }
      return !0;
    }
    equals(other) {
      return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && 
      this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && require$_DOT__SLASH_lineDecorations_DOT_js.LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && 
      this.sameSelection(other.selectionsOnLine);
    }
  }
  class DomPosition {
    constructor(partIndex, charIndex) {
      this.partIndex = partIndex;
      this.charIndex = charIndex;
    }
  }
  class CharacterMapping {
    static getPartIndex(partData) {
      return (partData & 4294901760) >>> 16;
    }
    static getCharIndex(partData) {
      return (partData & 65535) >>> 0;
    }
    constructor(length, partCount) {
      this.length = length;
      this._data = new Uint32Array(this.length);
      this._horizontalOffset = new Uint32Array(this.length);
    }
    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {
      this._data[column - 1] = (partIndex << 16 | charIndex << 0) >>> 0;
      this._horizontalOffset[column - 1] = horizontalOffset;
    }
    getHorizontalOffset(column) {
      return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[column - 1];
    }
    charOffsetToPartData(charOffset) {
      return this.length === 0 ? 0 : charOffset < 0 ? this._data[0] : charOffset >= this.length ? this._data[this.length - 1] : this._data[charOffset];
    }
    getDomPosition(column) {
      var partData = this.charOffsetToPartData(column - 1);
      column = CharacterMapping.getPartIndex(partData);
      partData = CharacterMapping.getCharIndex(partData);
      return new DomPosition(column, partData);
    }
    getColumn(domPosition, partLength) {
      return this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex) + 1;
    }
    partDataToCharOffset(partIndex, partLength, charIndex) {
      if (this.length === 0) {
        return 0;
      }
      var searchEntry = (partIndex << 16 | charIndex << 0) >>> 0;
      partIndex = 0;
      let max = this.length - 1;
      for (; partIndex + 1 < max;) {
        var mid = partIndex + max >>> 1, midEntry = this._data[mid];
        if (midEntry === searchEntry) {
          return mid;
        }
        midEntry > searchEntry ? max = mid : partIndex = mid;
      }
      if (partIndex === max) {
        return partIndex;
      }
      midEntry = this._data[partIndex];
      mid = this._data[max];
      if (midEntry === searchEntry) {
        return partIndex;
      }
      if (mid === searchEntry) {
        return max;
      }
      searchEntry = CharacterMapping.getPartIndex(midEntry);
      midEntry = CharacterMapping.getCharIndex(midEntry);
      const maxPartIndex = CharacterMapping.getPartIndex(mid);
      partLength = searchEntry !== maxPartIndex ? partLength : CharacterMapping.getCharIndex(mid);
      return charIndex - midEntry <= partLength - charIndex ? partIndex : max;
    }
  }
  class RenderLineOutput {
    constructor(characterMapping, containsRTL, containsForeignElements) {
      this._renderLineOutputBrand = void 0;
      this.characterMapping = characterMapping;
      this.containsRTL = containsRTL;
      this.containsForeignElements = containsForeignElements;
    }
  }
  class RenderLineOutput2 {
    constructor(characterMapping, html, containsRTL, containsForeignElements) {
      this.characterMapping = characterMapping;
      this.html = html;
      this.containsRTL = containsRTL;
      this.containsForeignElements = containsForeignElements;
    }
  }
  class ResolvedRenderLineInput {
    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {
      this.fontIsMonospace = fontIsMonospace;
      this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;
      this.lineContent = lineContent;
      this.len = len;
      this.isOverflowing = isOverflowing;
      this.overflowingCharCount = overflowingCharCount;
      this.parts = parts;
      this.containsForeignElements = containsForeignElements;
      this.fauxIndentLength = fauxIndentLength;
      this.tabSize = tabSize;
      this.startVisibleColumn = startVisibleColumn;
      this.containsRTL = containsRTL;
      this.spaceWidth = spaceWidth;
      this.renderSpaceCharCode = renderSpaceCharCode;
      this.renderWhitespace = renderWhitespace;
      this.renderControlCharacters = renderControlCharacters;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$viewLineRenderer.js.map
