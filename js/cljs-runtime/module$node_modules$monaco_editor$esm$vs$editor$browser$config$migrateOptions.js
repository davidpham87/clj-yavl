shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$config$migrateOptions = function(require, module, exports) {
  function registerEditorSettingMigration(key, migrate) {
    EditorSettingMigration.items.push(new EditorSettingMigration(key, migrate));
  }
  function registerSimpleEditorSettingMigration(key, values) {
    registerEditorSettingMigration(key, (value, read, write) => {
      if (typeof value !== "undefined") {
        for (const [oldValue, newValue] of values) {
          if (value === oldValue) {
            write(key, newValue);
            break;
          }
        }
      }
    });
  }
  function migrateOptions(options) {
    EditorSettingMigration.items.forEach(migration => migration.apply(options));
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, EditorSettingMigration:{enumerable:!0, get:function() {
    return EditorSettingMigration;
  }}, migrateOptions:{enumerable:!0, get:function() {
    return migrateOptions;
  }}});
  class EditorSettingMigration {
    constructor(key, migrate) {
      this.key = key;
      this.migrate = migrate;
    }
    apply(options) {
      const value = EditorSettingMigration._read(options, this.key);
      this.migrate(value, key => EditorSettingMigration._read(options, key), (key, value) => EditorSettingMigration._write(options, key, value));
    }
    static _read(source, key) {
      if (typeof source !== "undefined") {
        var firstDotIndex = key.indexOf(".");
        if (firstDotIndex >= 0) {
          const firstSegment = key.substring(0, firstDotIndex);
          return this._read(source[firstSegment], key.substring(firstDotIndex + 1));
        }
        return source[key];
      }
    }
    static _write(target, key, value) {
      const firstDotIndex = key.indexOf(".");
      if (firstDotIndex >= 0) {
        const firstSegment = key.substring(0, firstDotIndex);
        target[firstSegment] = target[firstSegment] || {};
        this._write(target[firstSegment], key.substring(firstDotIndex + 1), value);
      } else {
        target[key] = value;
      }
    }
  }
  EditorSettingMigration.items = [];
  registerSimpleEditorSettingMigration("wordWrap", [[!0, "on"], [!1, "off"]]);
  registerSimpleEditorSettingMigration("lineNumbers", [[!0, "on"], [!1, "off"]]);
  registerSimpleEditorSettingMigration("cursorBlinking", [["visible", "solid"]]);
  registerSimpleEditorSettingMigration("renderWhitespace", [[!0, "boundary"], [!1, "none"]]);
  registerSimpleEditorSettingMigration("renderLineHighlight", [[!0, "line"], [!1, "none"]]);
  registerSimpleEditorSettingMigration("acceptSuggestionOnEnter", [[!0, "on"], [!1, "off"]]);
  registerSimpleEditorSettingMigration("tabCompletion", [[!1, "off"], [!0, "onlySnippets"]]);
  registerSimpleEditorSettingMigration("hover", [[!0, {enabled:!0}], [!1, {enabled:!1}]]);
  registerSimpleEditorSettingMigration("parameterHints", [[!0, {enabled:!0}], [!1, {enabled:!1}]]);
  registerSimpleEditorSettingMigration("autoIndent", [[!1, "advanced"], [!0, "full"]]);
  registerSimpleEditorSettingMigration("matchBrackets", [[!0, "always"], [!1, "never"]]);
  registerSimpleEditorSettingMigration("renderFinalNewline", [[!0, "on"], [!1, "off"]]);
  registerSimpleEditorSettingMigration("cursorSmoothCaretAnimation", [[!0, "on"], [!1, "off"]]);
  registerSimpleEditorSettingMigration("occurrencesHighlight", [[!0, "singleFile"], [!1, "off"]]);
  registerSimpleEditorSettingMigration("wordBasedSuggestions", [[!0, "matchingDocuments"], [!1, "off"]]);
  registerEditorSettingMigration("autoClosingBrackets", (value, read, write) => {
    value === !1 && (write("autoClosingBrackets", "never"), typeof read("autoClosingQuotes") === "undefined" && write("autoClosingQuotes", "never"), typeof read("autoSurround") === "undefined" && write("autoSurround", "never"));
  });
  registerEditorSettingMigration("renderIndentGuides", (value, read, write) => {
    typeof value !== "undefined" && (write("renderIndentGuides", void 0), typeof read("guides.indentation") === "undefined" && write("guides.indentation", !!value));
  });
  registerEditorSettingMigration("highlightActiveIndentGuide", (value, read, write) => {
    typeof value !== "undefined" && (write("highlightActiveIndentGuide", void 0), typeof read("guides.highlightActiveIndentation") === "undefined" && write("guides.highlightActiveIndentation", !!value));
  });
  const suggestFilteredTypesMapping = {method:"showMethods", function:"showFunctions", constructor:"showConstructors", deprecated:"showDeprecated", field:"showFields", variable:"showVariables", class:"showClasses", struct:"showStructs", interface:"showInterfaces", module:"showModules", property:"showProperties", event:"showEvents", operator:"showOperators", unit:"showUnits", value:"showValues", constant:"showConstants", enum:"showEnums", enumMember:"showEnumMembers", keyword:"showKeywords", text:"showWords", 
  color:"showColors", file:"showFiles", reference:"showReferences", folder:"showFolders", typeParameter:"showTypeParameters", snippet:"showSnippets"};
  registerEditorSettingMigration("suggest.filteredTypes", (value, read, write) => {
    if (value && typeof value === "object") {
      for (const entry of Object.entries(suggestFilteredTypesMapping)) {
        value[entry[0]] === !1 && typeof read(`suggest.${entry[1]}`) === "undefined" && write(`suggest.${entry[1]}`, !1);
      }
      write("suggest.filteredTypes", void 0);
    }
  });
  registerEditorSettingMigration("quickSuggestions", (input, read, write) => {
    typeof input === "boolean" && (input = input ? "on" : "off", write("quickSuggestions", {comments:input, strings:input, other:input}));
  });
  registerEditorSettingMigration("experimental.stickyScroll.enabled", (value, read, write) => {
    typeof value === "boolean" && (write("experimental.stickyScroll.enabled", void 0), typeof read("stickyScroll.enabled") === "undefined" && write("stickyScroll.enabled", value));
  });
  registerEditorSettingMigration("experimental.stickyScroll.maxLineCount", (value, read, write) => {
    typeof value === "number" && (write("experimental.stickyScroll.maxLineCount", void 0), typeof read("stickyScroll.maxLineCount") === "undefined" && write("stickyScroll.maxLineCount", value));
  });
  registerEditorSettingMigration("codeActionsOnSave", (value, read, write) => {
    if (value && typeof value === "object") {
      read = !1;
      const newValue = {};
      for (const entry of Object.entries(value)) {
        typeof entry[1] === "boolean" ? (read = !0, newValue[entry[0]] = entry[1] ? "explicit" : "never") : newValue[entry[0]] = entry[1];
      }
      read && write("codeActionsOnSave", newValue);
    }
  });
  registerEditorSettingMigration("codeActionWidget.includeNearbyQuickfixes", (value, read, write) => {
    typeof value === "boolean" && (write("codeActionWidget.includeNearbyQuickfixes", void 0), typeof read("codeActionWidget.includeNearbyQuickFixes") === "undefined" && write("codeActionWidget.includeNearbyQuickFixes", value));
  });
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$config$migrateOptions.js.map
