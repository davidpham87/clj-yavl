shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$viewModelLines = function(require, module, exports) {
  function normalizeLineRanges(ranges) {
    if (ranges.length === 0) {
      return [];
    }
    ranges = ranges.slice();
    ranges.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
    const result = [];
    let currentRangeStart = ranges[0].startLineNumber, currentRangeEnd = ranges[0].endLineNumber;
    for (let i = 1, len = ranges.length; i < len; i++) {
      const range = ranges[i];
      range.startLineNumber > currentRangeEnd + 1 ? (result.push(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(currentRangeStart, 1, currentRangeEnd, 1)), currentRangeStart = range.startLineNumber, currentRangeEnd = range.endLineNumber) : range.endLineNumber > currentRangeEnd && (currentRangeEnd = range.endLineNumber);
    }
    result.push(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(currentRangeStart, 1, currentRangeEnd, 1));
    return result;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ViewModelLinesFromModelAsIs:{enumerable:!0, get:function() {
    return ViewModelLinesFromModelAsIs;
  }}, ViewModelLinesFromProjectedModel:{enumerable:!0, get:function() {
    return ViewModelLinesFromProjectedModel;
  }}});
  var arrays = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_textModelGuides_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelGuides"), require$_DOT__DOT__SLASH_model_SLASH_textModel_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModel"), require$_DOT__DOT__SLASH_textModelEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents"), viewEvents = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewEvents"), require$_DOT__SLASH_modelLineProjection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$modelLineProjection"), require$_DOT__DOT__SLASH_model_SLASH_prefixSumComputer_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$model$prefixSumComputer"), require$_DOT__DOT__SLASH_viewModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel");
  class ViewModelLinesFromProjectedModel {
    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {
      this._editorId = editorId;
      this.model = model;
      this._validModelVersionId = -1;
      this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;
      this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;
      this.fontInfo = fontInfo;
      this.tabSize = tabSize;
      this.wrappingStrategy = wrappingStrategy;
      this.wrappingColumn = wrappingColumn;
      this.wrappingIndent = wrappingIndent;
      this.wordBreak = wordBreak;
      this._constructLines(!0, null);
    }
    dispose() {
      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
    }
    createCoordinatesConverter() {
      return new CoordinatesConverter(this);
    }
    _constructLines(resetHiddenAreas, previousLineBreaks) {
      this.modelLineProjections = [];
      resetHiddenAreas && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
      var linesContent = this.model.getLinesContent(), injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);
      resetHiddenAreas = linesContent.length;
      var lineBreaksComputer = this.createLineBreaksComputer();
      injectedTextDecorations = new arrays.ArrayQueue(require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText.fromDecorations(injectedTextDecorations));
      for (let i = 0; i < resetHiddenAreas; i++) {
        var lineInjectedText = injectedTextDecorations.takeWhile(t => t.lineNumber === i + 1);
        lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);
      }
      previousLineBreaks = lineBreaksComputer.finalize();
      linesContent = [];
      lineBreaksComputer = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
      injectedTextDecorations = 1;
      lineInjectedText = 0;
      let hiddenAreaIdx = -1, nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < lineBreaksComputer.length ? lineInjectedText + 1 : resetHiddenAreas + 2;
      for (let i = 0; i < resetHiddenAreas; i++) {
        var lineNumber = i + 1;
        lineNumber === nextLineNumberToUpdateHiddenArea && (hiddenAreaIdx++, injectedTextDecorations = lineBreaksComputer[hiddenAreaIdx].startLineNumber, lineInjectedText = lineBreaksComputer[hiddenAreaIdx].endLineNumber, nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < lineBreaksComputer.length ? lineInjectedText + 1 : resetHiddenAreas + 2);
        lineNumber = (0,require$_DOT__SLASH_modelLineProjection_DOT_js.createModelLineProjection)(previousLineBreaks[i], !(lineNumber >= injectedTextDecorations && lineNumber <= lineInjectedText));
        linesContent[i] = lineNumber.getViewLineCount();
        this.modelLineProjections[i] = lineNumber;
      }
      this._validModelVersionId = this.model.getVersionId();
      this.projectedModelLineLineCounts = new require$_DOT__DOT__SLASH_model_SLASH_prefixSumComputer_DOT_js.ConstantTimePrefixSumComputer(linesContent);
    }
    getHiddenAreas() {
      return this.hiddenAreasDecorationIds.map(decId => this.model.getDecorationRange(decId));
    }
    setHiddenAreas(_ranges) {
      _ranges = _ranges.map(r => this.model.validateRange(r));
      _ranges = normalizeLineRanges(_ranges);
      var oldRanges = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts);
      if (_ranges.length === oldRanges.length) {
        var hasDifference = !1;
        for (var i$jscomp$0 = 0; i$jscomp$0 < _ranges.length; i$jscomp$0++) {
          if (!_ranges[i$jscomp$0].equalsRange(oldRanges[i$jscomp$0])) {
            hasDifference = !0;
            break;
          }
        }
        if (!hasDifference) {
          return !1;
        }
      }
      oldRanges = _ranges.map(r => ({range:r, options:require$_DOT__DOT__SLASH_model_SLASH_textModel_DOT_js.ModelDecorationOptions.EMPTY}));
      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, oldRanges);
      oldRanges = 1;
      hasDifference = 0;
      i$jscomp$0 = -1;
      let nextLineNumberToUpdateHiddenArea = i$jscomp$0 + 1 < _ranges.length ? hasDifference + 1 : this.modelLineProjections.length + 2, hasVisibleLine = !1;
      for (let i = 0; i < this.modelLineProjections.length; i++) {
        var lineNumber = i + 1;
        lineNumber === nextLineNumberToUpdateHiddenArea && (i$jscomp$0++, oldRanges = _ranges[i$jscomp$0].startLineNumber, hasDifference = _ranges[i$jscomp$0].endLineNumber, nextLineNumberToUpdateHiddenArea = i$jscomp$0 + 1 < _ranges.length ? hasDifference + 1 : this.modelLineProjections.length + 2);
        let lineChanged = !1;
        lineNumber >= oldRanges && lineNumber <= hasDifference ? this.modelLineProjections[i].isVisible() && (this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(!1), lineChanged = !0) : (hasVisibleLine = !0, this.modelLineProjections[i].isVisible() || (this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(!0), lineChanged = !0));
        lineChanged && (lineNumber = this.modelLineProjections[i].getViewLineCount(), this.projectedModelLineLineCounts.setValue(i, lineNumber));
      }
      hasVisibleLine || this.setHiddenAreas([]);
      return !0;
    }
    modelPositionIsVisible(modelLineNumber, _modelColumn) {
      return modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length ? !1 : this.modelLineProjections[modelLineNumber - 1].isVisible();
    }
    getModelLineViewLineCount(modelLineNumber) {
      return modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length ? 1 : this.modelLineProjections[modelLineNumber - 1].getViewLineCount();
    }
    setTabSize(newTabSize) {
      if (this.tabSize === newTabSize) {
        return !1;
      }
      this.tabSize = newTabSize;
      this._constructLines(!1, null);
      return !0;
    }
    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {
      const equalFontInfo = this.fontInfo.equals(fontInfo), equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy, equalWrappingColumn = this.wrappingColumn === wrappingColumn, equalWrappingIndent = this.wrappingIndent === wrappingIndent, equalWordBreak = this.wordBreak === wordBreak;
      if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {
        return !1;
      }
      this.fontInfo = fontInfo;
      this.wrappingStrategy = wrappingStrategy;
      this.wrappingColumn = wrappingColumn;
      this.wrappingIndent = wrappingIndent;
      this.wordBreak = wordBreak;
      fontInfo = null;
      if (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak) {
        fontInfo = [];
        for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {
          fontInfo[i] = this.modelLineProjections[i].getProjectionData();
        }
      }
      this._constructLines(!1, fontInfo);
      return !0;
    }
    createLineBreaksComputer() {
      return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);
    }
    onModelFlushed() {
      this._constructLines(!0, null);
    }
    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {
      if (!versionId || versionId <= this._validModelVersionId) {
        return null;
      }
      versionId = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;
      const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);
      this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
      this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
      return new viewEvents.ViewLinesDeletedEvent(versionId, outputToLineNumber);
    }
    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {
      if (!versionId || versionId <= this._validModelVersionId) {
        return null;
      }
      versionId = fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible();
      _toLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;
      let totalOutputLineCount = 0;
      const insertLines = [], insertPrefixSumValues = [];
      for (let i = 0, len = lineBreaks.length; i < len; i++) {
        var line = (0,require$_DOT__SLASH_modelLineProjection_DOT_js.createModelLineProjection)(lineBreaks[i], !versionId);
        insertLines.push(line);
        line = line.getViewLineCount();
        totalOutputLineCount += line;
        insertPrefixSumValues[i] = line;
      }
      this.modelLineProjections = this.modelLineProjections.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.modelLineProjections.slice(fromLineNumber - 1));
      this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);
      return new viewEvents.ViewLinesInsertedEvent(_toLineNumber, _toLineNumber + totalOutputLineCount - 1);
    }
    onModelLineChanged(versionId, lineNumber, lineBreakData) {
      if (versionId !== null && versionId <= this._validModelVersionId) {
        return [!1, null, null, null];
      }
      versionId = lineNumber - 1;
      var oldOutputLineCount = this.modelLineProjections[versionId].getViewLineCount(), isVisible = this.modelLineProjections[versionId].isVisible();
      lineBreakData = (0,require$_DOT__SLASH_modelLineProjection_DOT_js.createModelLineProjection)(lineBreakData, isVisible);
      this.modelLineProjections[versionId] = lineBreakData;
      const newOutputLineCount = this.modelLineProjections[versionId].getViewLineCount();
      lineBreakData = !1;
      let changeTo, insertFrom = 0, insertTo = -1;
      isVisible = 0;
      let deleteTo = -1;
      oldOutputLineCount > newOutputLineCount ? (lineNumber = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1, changeTo = lineNumber + newOutputLineCount - 1, isVisible = changeTo + 1, deleteTo = isVisible + (oldOutputLineCount - newOutputLineCount) - 1, lineBreakData = !0) : oldOutputLineCount < newOutputLineCount ? (lineNumber = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1, changeTo = lineNumber + oldOutputLineCount - 1, insertFrom = changeTo + 1, insertTo = 
      insertFrom + (newOutputLineCount - oldOutputLineCount) - 1, lineBreakData = !0) : (lineNumber = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1, changeTo = lineNumber + newOutputLineCount - 1);
      this.projectedModelLineLineCounts.setValue(versionId, newOutputLineCount);
      versionId = lineNumber <= changeTo ? new viewEvents.ViewLinesChangedEvent(lineNumber, changeTo - lineNumber + 1) : null;
      oldOutputLineCount = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;
      lineNumber = isVisible <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(isVisible, deleteTo) : null;
      return [lineBreakData, versionId, oldOutputLineCount, lineNumber];
    }
    acceptVersionId(versionId) {
      this._validModelVersionId = versionId;
      this.modelLineProjections.length !== 1 || this.modelLineProjections[0].isVisible() || this.setHiddenAreas([]);
    }
    getViewLineCount() {
      return this.projectedModelLineLineCounts.getTotalSum();
    }
    _toValidViewLineNumber(viewLineNumber) {
      if (viewLineNumber < 1) {
        return 1;
      }
      const viewLineCount = this.getViewLineCount();
      return viewLineNumber > viewLineCount ? viewLineCount : viewLineNumber | 0;
    }
    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {
      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
      minLineNumber = this._toValidViewLineNumber(minLineNumber);
      maxLineNumber = this._toValidViewLineNumber(maxLineNumber);
      viewLineNumber = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));
      minLineNumber = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));
      maxLineNumber = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));
      maxLineNumber = this.model.guides.getActiveIndentGuide(viewLineNumber.lineNumber, minLineNumber.lineNumber, maxLineNumber.lineNumber);
      viewLineNumber = this.convertModelPositionToViewPosition(maxLineNumber.startLineNumber, 1);
      minLineNumber = this.convertModelPositionToViewPosition(maxLineNumber.endLineNumber, this.model.getLineMaxColumn(maxLineNumber.endLineNumber));
      return {startLineNumber:viewLineNumber.lineNumber, endLineNumber:minLineNumber.lineNumber, indent:maxLineNumber.indent};
    }
    getViewLineInfo(viewLineNumber) {
      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
      viewLineNumber = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);
      return new ViewLineInfo(viewLineNumber.index + 1, viewLineNumber.remainder);
    }
    getMinColumnOfViewLine(viewLineInfo) {
      return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);
    }
    getMaxColumnOfViewLine(viewLineInfo) {
      return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);
    }
    getModelStartPositionOfViewLine(viewLineInfo) {
      var line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];
      const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);
      line = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(viewLineInfo.modelLineNumber, line);
    }
    getModelEndPositionOfViewLine(viewLineInfo) {
      var line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];
      const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);
      line = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(viewLineInfo.modelLineNumber, line);
    }
    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {
      viewStartLineNumber = this.getViewLineInfo(viewStartLineNumber);
      const endViewLine = this.getViewLineInfo(viewEndLineNumber);
      viewEndLineNumber = [];
      var lastVisibleModelPos = this.getModelStartPositionOfViewLine(viewStartLineNumber);
      let viewLines = [];
      for (let curModelLine = viewStartLineNumber.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {
        var line = this.modelLineProjections[curModelLine - 1];
        if (line.isVisible()) {
          var startOffset = curModelLine === viewStartLineNumber.modelLineNumber ? viewStartLineNumber.modelLineWrappedLineIdx : 0;
          const endOffset = curModelLine === endViewLine.modelLineNumber ? endViewLine.modelLineWrappedLineIdx + 1 : line.getViewLineCount();
          for (; startOffset < endOffset; startOffset++) {
            viewLines.push(new ViewLineInfo(curModelLine, startOffset));
          }
        }
        !line.isVisible() && lastVisibleModelPos ? (line = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1), lastVisibleModelPos = require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(lastVisibleModelPos, line), viewEndLineNumber.push(new ViewLineInfoGroupedByModelRange(lastVisibleModelPos, viewLines)), viewLines = [], lastVisibleModelPos = null) : line.isVisible() && !lastVisibleModelPos && (lastVisibleModelPos = 
        new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(curModelLine, 1));
      }
      lastVisibleModelPos && (viewStartLineNumber = require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine)), viewEndLineNumber.push(new ViewLineInfoGroupedByModelRange(viewStartLineNumber, viewLines)));
      return viewEndLineNumber;
    }
    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {
      activeViewPosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;
      const resultPerViewLine = [];
      for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {
        viewStartLineNumber = group.modelRange.startLineNumber;
        viewEndLineNumber = this.model.guides.getLinesBracketGuides(viewStartLineNumber, group.modelRange.endLineNumber, activeViewPosition, options);
        for (const viewLineInfo of group.viewLines) {
          const result = viewEndLineNumber[viewLineInfo.modelLineNumber - viewStartLineNumber].map(g => {
            if (!(g.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn).lineNumber >= viewLineInfo.modelLineWrappedLineIdx || g.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn).lineNumber < viewLineInfo.modelLineWrappedLineIdx)) {
              if (!g.horizontalLine) {
                return g;
              }
              var column = -1;
              if (g.column !== -1) {
                var p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);
                if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {
                  column = p.column;
                } else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {
                  column = this.getMinColumnOfViewLine(viewLineInfo);
                } else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {
                  return;
                }
              }
              p = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);
              var p$jscomp$0 = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);
              if (p$jscomp$0.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {
                return new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuide(g.visibleColumn, column, g.className, new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuideHorizontalLine(g.horizontalLine.top, p.column), -1, -1);
              }
              if (!(p$jscomp$0.lineNumber < viewLineInfo.modelLineWrappedLineIdx)) {
                return g.visibleColumn !== -1 ? void 0 : new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuide(g.visibleColumn, column, g.className, new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);
              }
            }
          });
          resultPerViewLine.push(result.filter(r => !!r));
        }
      }
      return resultPerViewLine;
    }
    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {
      viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);
      viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);
      var modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber)), modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));
      let result = [];
      const resultRepeatCount = [], resultRepeatOption = [];
      var modelStartLineIndex = modelStart.lineNumber - 1, modelEndLineIndex = modelEnd.lineNumber - 1, reqStart = null;
      for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {
        const line = this.modelLineProjections[modelLineIndex];
        if (line.isVisible()) {
          const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1), viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1)), count = viewLineEndIndex - viewLineStartIndex + 1;
          let option = 0;
          count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1 && (option = viewLineStartIndex === 0 ? 1 : 2);
          resultRepeatCount.push(count);
          resultRepeatOption.push(option);
          reqStart === null && (reqStart = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(modelLineIndex + 1, 0));
        } else {
          reqStart !== null && (result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex)), reqStart = null);
        }
      }
      reqStart !== null && (result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber)));
      viewStartLineNumber = viewEndLineNumber - viewStartLineNumber + 1;
      viewEndLineNumber = Array(viewStartLineNumber);
      modelStart = 0;
      for (let i = 0, len = result.length; i < len; i++) {
        for (modelEnd = result[i], modelStartLineIndex = Math.min(viewStartLineNumber - modelStart, resultRepeatCount[i]), modelEndLineIndex = resultRepeatOption[i], modelEndLineIndex = modelEndLineIndex === 2 ? 0 : modelEndLineIndex === 1 ? 1 : modelStartLineIndex, reqStart = 0; reqStart < modelStartLineIndex; reqStart++) {
          reqStart === modelEndLineIndex && (modelEnd = 0), viewEndLineNumber[modelStart++] = modelEnd;
        }
      }
      return viewEndLineNumber;
    }
    getViewLineContent(viewLineNumber) {
      viewLineNumber = this.getViewLineInfo(viewLineNumber);
      return this.modelLineProjections[viewLineNumber.modelLineNumber - 1].getViewLineContent(this.model, viewLineNumber.modelLineNumber, viewLineNumber.modelLineWrappedLineIdx);
    }
    getViewLineLength(viewLineNumber) {
      viewLineNumber = this.getViewLineInfo(viewLineNumber);
      return this.modelLineProjections[viewLineNumber.modelLineNumber - 1].getViewLineLength(this.model, viewLineNumber.modelLineNumber, viewLineNumber.modelLineWrappedLineIdx);
    }
    getViewLineMinColumn(viewLineNumber) {
      viewLineNumber = this.getViewLineInfo(viewLineNumber);
      return this.modelLineProjections[viewLineNumber.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineNumber.modelLineNumber, viewLineNumber.modelLineWrappedLineIdx);
    }
    getViewLineMaxColumn(viewLineNumber) {
      viewLineNumber = this.getViewLineInfo(viewLineNumber);
      return this.modelLineProjections[viewLineNumber.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineNumber.modelLineNumber, viewLineNumber.modelLineWrappedLineIdx);
    }
    getViewLineData(viewLineNumber) {
      viewLineNumber = this.getViewLineInfo(viewLineNumber);
      return this.modelLineProjections[viewLineNumber.modelLineNumber - 1].getViewLineData(this.model, viewLineNumber.modelLineNumber, viewLineNumber.modelLineWrappedLineIdx);
    }
    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {
      viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);
      viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);
      var start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);
      let viewLineNumber = viewStartLineNumber;
      const startModelLineIndex = start.index;
      start = start.remainder;
      const result = [];
      for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {
        const line = this.modelLineProjections[modelLineIndex];
        if (!line.isVisible()) {
          continue;
        }
        const fromViewLineIndex = modelLineIndex === startModelLineIndex ? start : 0;
        let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex, lastLine = !1;
        viewLineNumber + remainingViewLineCount > viewEndLineNumber && (lastLine = !0, remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1);
        line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);
        viewLineNumber += remainingViewLineCount;
        if (lastLine) {
          break;
        }
      }
      return result;
    }
    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {
      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);
      var r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);
      const lineIndex = r.index;
      r = r.remainder;
      const line = this.modelLineProjections[lineIndex], minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, r), maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, r);
      viewColumn < minColumn && (viewColumn = minColumn);
      viewColumn > maxColumn && (viewColumn = maxColumn);
      r = line.getModelColumnOfViewPosition(r, viewColumn);
      return this.model.validatePosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineIndex + 1, r)).equals(expectedModelPosition) ? new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(viewLineNumber, viewColumn) : this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);
    }
    validateViewRange(viewRange, expectedModelRange) {
      const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());
      viewRange = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(validViewStart.lineNumber, validViewStart.column, viewRange.lineNumber, viewRange.column);
    }
    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {
      viewLineNumber = this.getViewLineInfo(viewLineNumber);
      viewColumn = this.modelLineProjections[viewLineNumber.modelLineNumber - 1].getModelColumnOfViewPosition(viewLineNumber.modelLineWrappedLineIdx, viewColumn);
      return this.model.validatePosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(viewLineNumber.modelLineNumber, viewColumn));
    }
    convertViewRangeToModelRange(viewRange) {
      const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);
      viewRange = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(start.lineNumber, start.column, viewRange.lineNumber, viewRange.column);
    }
    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2, allowZeroLineNumber = !1, belowHiddenRanges = !1) {
      _modelColumn = this.model.validatePosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_modelLineNumber, _modelColumn));
      _modelLineNumber = _modelColumn.lineNumber;
      _modelColumn = _modelColumn.column;
      let lineIndex = _modelLineNumber - 1, lineIndexChanged = !1;
      if (belowHiddenRanges) {
        for (; lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible();) {
          lineIndex++, lineIndexChanged = !0;
        }
      } else {
        for (; lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible();) {
          lineIndex--, lineIndexChanged = !0;
        }
      }
      if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {
        return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(allowZeroLineNumber ? 0 : 1, 1);
      }
      allowZeroLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);
      return lineIndexChanged ? belowHiddenRanges ? this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(allowZeroLineNumber, 1, affinity) : this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(allowZeroLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity) : this.modelLineProjections[_modelLineNumber - 1].getViewPositionOfModelPosition(allowZeroLineNumber, _modelColumn, affinity);
    }
    convertModelRangeToViewRange(modelRange, affinity = 0) {
      if (modelRange.isEmpty()) {
        return modelRange = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(modelRange);
      }
      affinity = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1);
      modelRange = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0);
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(affinity.lineNumber, affinity.column, modelRange.lineNumber, modelRange.column);
    }
    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {
      --modelLineNumber;
      if (this.modelLineProjections[modelLineNumber].isVisible()) {
        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(modelLineNumber);
        return this.modelLineProjections[modelLineNumber].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);
      }
      for (; modelLineNumber > 0 && !this.modelLineProjections[modelLineNumber].isVisible();) {
        modelLineNumber--;
      }
      if (modelLineNumber === 0 && !this.modelLineProjections[modelLineNumber].isVisible()) {
        return 1;
      }
      modelColumn = 1 + this.projectedModelLineLineCounts.getPrefixSum(modelLineNumber);
      return this.modelLineProjections[modelLineNumber].getViewLineNumberOfModelPosition(modelColumn, this.model.getLineMaxColumn(modelLineNumber + 1));
    }
    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {
      const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn), modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);
      if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {
        return this.model.getDecorationsInRange(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);
      }
      range = [];
      onlyMarginDecorations = modelStart.lineNumber - 1;
      const modelEndLineIndex = modelEnd.lineNumber - 1;
      let reqStart = null;
      for (let modelLineIndex = onlyMarginDecorations; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {
        if (this.modelLineProjections[modelLineIndex].isVisible()) {
          reqStart === null && (reqStart = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(modelLineIndex + 1, modelLineIndex === onlyMarginDecorations ? modelStart.column : 1));
        } else {
          if (reqStart !== null) {
            const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);
            range = range.concat(this.model.getDecorationsInRange(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));
            reqStart = null;
          }
        }
      }
      reqStart !== null && (range = range.concat(this.model.getDecorationsInRange(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations)), reqStart = null);
      range.sort((a, b) => {
        const res = require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts(a.range, b.range);
        return res === 0 ? a.id < b.id ? -1 : a.id > b.id ? 1 : 0 : res;
      });
      ownerId = [];
      filterOutValidation = 0;
      onlyMinimapDecorations = null;
      for (const dec of range) {
        range = dec.id, onlyMinimapDecorations !== range && (onlyMinimapDecorations = range, ownerId[filterOutValidation++] = dec);
      }
      return ownerId;
    }
    getInjectedTextAt(position) {
      const info = this.getViewLineInfo(position.lineNumber);
      return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);
    }
    normalizePosition(position, affinity) {
      const info = this.getViewLineInfo(position.lineNumber);
      return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);
    }
    getLineIndentColumn(lineNumber) {
      lineNumber = this.getViewLineInfo(lineNumber);
      return lineNumber.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(lineNumber.modelLineNumber) : 0;
    }
  }
  class ViewLineInfo {
    constructor(modelLineNumber, modelLineWrappedLineIdx) {
      this.modelLineNumber = modelLineNumber;
      this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;
    }
  }
  class ViewLineInfoGroupedByModelRange {
    constructor(modelRange, viewLines) {
      this.modelRange = modelRange;
      this.viewLines = viewLines;
    }
  }
  class CoordinatesConverter {
    constructor(lines) {
      this._lines = lines;
    }
    convertViewPositionToModelPosition(viewPosition) {
      return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
    }
    convertViewRangeToModelRange(viewRange) {
      return this._lines.convertViewRangeToModelRange(viewRange);
    }
    validateViewPosition(viewPosition, expectedModelPosition) {
      return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);
    }
    validateViewRange(viewRange, expectedModelRange) {
      return this._lines.validateViewRange(viewRange, expectedModelRange);
    }
    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {
      return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);
    }
    convertModelRangeToViewRange(modelRange, affinity) {
      return this._lines.convertModelRangeToViewRange(modelRange, affinity);
    }
    modelPositionIsVisible(modelPosition) {
      return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);
    }
    getModelLineViewLineCount(modelLineNumber) {
      return this._lines.getModelLineViewLineCount(modelLineNumber);
    }
    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {
      return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);
    }
  }
  class ViewModelLinesFromModelAsIs {
    constructor(model) {
      this.model = model;
    }
    dispose() {
    }
    createCoordinatesConverter() {
      return new IdentityCoordinatesConverter(this);
    }
    getHiddenAreas() {
      return [];
    }
    setHiddenAreas(_ranges) {
      return !1;
    }
    setTabSize(_newTabSize) {
      return !1;
    }
    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {
      return !1;
    }
    createLineBreaksComputer() {
      const result = [];
      return {addRequest:(lineText, injectedText, previousLineBreakData) => {
        result.push(null);
      }, finalize:() => result};
    }
    onModelFlushed() {
    }
    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {
      return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);
    }
    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {
      return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);
    }
    onModelLineChanged(_versionId, lineNumber, lineBreakData) {
      return [!1, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];
    }
    acceptVersionId(_versionId) {
    }
    getViewLineCount() {
      return this.model.getLineCount();
    }
    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {
      return {startLineNumber:viewLineNumber, endLineNumber:viewLineNumber, indent:0};
    }
    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {
      return Array(endLineNumber - startLineNumber + 1).fill([]);
    }
    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {
      viewStartLineNumber = viewEndLineNumber - viewStartLineNumber + 1;
      viewEndLineNumber = Array(viewStartLineNumber);
      for (let i = 0; i < viewStartLineNumber; i++) {
        viewEndLineNumber[i] = 0;
      }
      return viewEndLineNumber;
    }
    getViewLineContent(viewLineNumber) {
      return this.model.getLineContent(viewLineNumber);
    }
    getViewLineLength(viewLineNumber) {
      return this.model.getLineLength(viewLineNumber);
    }
    getViewLineMinColumn(viewLineNumber) {
      return this.model.getLineMinColumn(viewLineNumber);
    }
    getViewLineMaxColumn(viewLineNumber) {
      return this.model.getLineMaxColumn(viewLineNumber);
    }
    getViewLineData(viewLineNumber) {
      viewLineNumber = this.model.tokenization.getLineTokens(viewLineNumber);
      const lineContent = viewLineNumber.getLineContent();
      return new require$_DOT__DOT__SLASH_viewModel_DOT_js.ViewLineData(lineContent, !1, 1, lineContent.length + 1, 0, viewLineNumber.inflate(), null);
    }
    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {
      var lineCount = this.model.getLineCount();
      viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);
      viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);
      lineCount = [];
      for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {
        const idx = lineNumber - viewStartLineNumber;
        lineCount[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;
      }
      return lineCount;
    }
    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {
      return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);
    }
    normalizePosition(position, affinity) {
      return this.model.normalizePosition(position, affinity);
    }
    getLineIndentColumn(lineNumber) {
      return this.model.getLineIndentColumn(lineNumber);
    }
    getInjectedTextAt(position) {
      return null;
    }
  }
  class IdentityCoordinatesConverter {
    constructor(lines) {
      this._lines = lines;
    }
    _validPosition(pos) {
      return this._lines.model.validatePosition(pos);
    }
    _validRange(range) {
      return this._lines.model.validateRange(range);
    }
    convertViewPositionToModelPosition(viewPosition) {
      return this._validPosition(viewPosition);
    }
    convertViewRangeToModelRange(viewRange) {
      return this._validRange(viewRange);
    }
    validateViewPosition(_viewPosition, expectedModelPosition) {
      return this._validPosition(expectedModelPosition);
    }
    validateViewRange(_viewRange, expectedModelRange) {
      return this._validRange(expectedModelRange);
    }
    convertModelPositionToViewPosition(modelPosition) {
      return this._validPosition(modelPosition);
    }
    convertModelRangeToViewRange(modelRange) {
      return this._validRange(modelRange);
    }
    modelPositionIsVisible(modelPosition) {
      const lineCount = this._lines.model.getLineCount();
      return modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount ? !1 : !0;
    }
    getModelLineViewLineCount(modelLineNumber) {
      return 1;
    }
    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {
      return modelLineNumber;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$viewModelLines.js.map
