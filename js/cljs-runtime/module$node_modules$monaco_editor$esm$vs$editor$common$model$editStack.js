shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$editStack = function(require, module, exports) {
  function isEditStackElement(element) {
    return element ? element instanceof SingleModelEditStackElement || element instanceof MultiModelEditStackElement : !1;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, EditStack:{enumerable:!0, get:function() {
    return EditStack;
  }}, MultiModelEditStackElement:{enumerable:!0, get:function() {
    return MultiModelEditStackElement;
  }}, SingleModelEditStackData:{enumerable:!0, get:function() {
    return SingleModelEditStackData;
  }}, SingleModelEditStackElement:{enumerable:!0, get:function() {
    return SingleModelEditStackElement;
  }}, isEditStackElement:{enumerable:!0, get:function() {
    return isEditStackElement;
  }}});
  var nls = require("module$node_modules$monaco_editor$esm$vs$nls"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$uri"), 
  require$_DOT__DOT__SLASH_core_SLASH_textChange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$textChange"), buffer = require("module$node_modules$monaco_editor$esm$vs$base$common$buffer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_resources_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$resources");
  class SingleModelEditStackData {
    static create(model, beforeCursorState) {
      const alternativeVersionId = model.getAlternativeVersionId();
      model = model.getEOL() === "\n" ? 0 : 1;
      return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, model, model, beforeCursorState, beforeCursorState, []);
    }
    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {
      this.beforeVersionId = beforeVersionId;
      this.afterVersionId = afterVersionId;
      this.beforeEOL = beforeEOL;
      this.afterEOL = afterEOL;
      this.beforeCursorState = beforeCursorState;
      this.afterCursorState = afterCursorState;
      this.changes = changes;
    }
    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
      textChanges.length > 0 && (this.changes = (0,require$_DOT__DOT__SLASH_core_SLASH_textChange_DOT_js.compressConsecutiveTextChanges)(this.changes, textChanges));
      this.afterEOL = afterEOL;
      this.afterVersionId = afterVersionId;
      this.afterCursorState = afterCursorState;
    }
    static _writeSelectionsSize(selections) {
      return 4 + 16 * (selections ? selections.length : 0);
    }
    static _writeSelections(b, selections, offset) {
      buffer.writeUInt32BE(b, selections ? selections.length : 0, offset);
      offset += 4;
      if (selections) {
        for (const selection of selections) {
          buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset), offset += 4, buffer.writeUInt32BE(b, selection.selectionStartColumn, offset), offset += 4, buffer.writeUInt32BE(b, selection.positionLineNumber, offset), offset += 4, buffer.writeUInt32BE(b, selection.positionColumn, offset), offset += 4;
        }
      }
      return offset;
    }
    static _readSelections(b, offset, dest) {
      const count = buffer.readUInt32BE(b, offset);
      offset += 4;
      for (let i = 0; i < count; i++) {
        const selectionStartLineNumber = buffer.readUInt32BE(b, offset);
        offset += 4;
        const selectionStartColumn = buffer.readUInt32BE(b, offset);
        offset += 4;
        const positionLineNumber = buffer.readUInt32BE(b, offset);
        offset += 4;
        const positionColumn = buffer.readUInt32BE(b, offset);
        offset += 4;
        dest.push(new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));
      }
      return offset;
    }
    serialize() {
      var necessarySize = 10 + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState) + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState) + 4;
      for (var change$jscomp$0 of this.changes) {
        necessarySize += change$jscomp$0.writeSize();
      }
      necessarySize = new Uint8Array(necessarySize);
      change$jscomp$0 = 0;
      buffer.writeUInt32BE(necessarySize, this.beforeVersionId, change$jscomp$0);
      change$jscomp$0 += 4;
      buffer.writeUInt32BE(necessarySize, this.afterVersionId, change$jscomp$0);
      change$jscomp$0 += 4;
      buffer.writeUInt8(necessarySize, this.beforeEOL, change$jscomp$0);
      change$jscomp$0 += 1;
      buffer.writeUInt8(necessarySize, this.afterEOL, change$jscomp$0);
      change$jscomp$0 = SingleModelEditStackData._writeSelections(necessarySize, this.beforeCursorState, change$jscomp$0 + 1);
      change$jscomp$0 = SingleModelEditStackData._writeSelections(necessarySize, this.afterCursorState, change$jscomp$0);
      buffer.writeUInt32BE(necessarySize, this.changes.length, change$jscomp$0);
      change$jscomp$0 += 4;
      for (const change of this.changes) {
        change$jscomp$0 = change.write(necessarySize, change$jscomp$0);
      }
      return necessarySize.buffer;
    }
    static deserialize(source) {
      source = new Uint8Array(source);
      let offset = 0;
      const beforeVersionId = buffer.readUInt32BE(source, offset);
      offset += 4;
      const afterVersionId = buffer.readUInt32BE(source, offset);
      offset += 4;
      const beforeEOL = buffer.readUInt8(source, offset);
      offset += 1;
      const afterEOL = buffer.readUInt8(source, offset), beforeCursorState = [];
      offset = SingleModelEditStackData._readSelections(source, offset + 1, beforeCursorState);
      const afterCursorState = [];
      offset = SingleModelEditStackData._readSelections(source, offset, afterCursorState);
      const changeCount = buffer.readUInt32BE(source, offset);
      offset += 4;
      const changes = [];
      for (let i = 0; i < changeCount; i++) {
        offset = require$_DOT__DOT__SLASH_core_SLASH_textChange_DOT_js.TextChange.read(source, offset, changes);
      }
      return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);
    }
  }
  class SingleModelEditStackElement {
    get type() {
      return 0;
    }
    get resource() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(this.model) ? this.model : this.model.uri;
    }
    constructor(label, code, model, beforeCursorState) {
      this.label = label;
      this.code = code;
      this.model = model;
      this._data = SingleModelEditStackData.create(model, beforeCursorState);
    }
    toString() {
      return (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data)).changes.map(change => change.toString()).join(", ");
    }
    matchesResource(resource) {
      return (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(this.model) ? this.model : this.model.uri).toString() === resource.toString();
    }
    setModel(model) {
      this.model = model;
    }
    canAppend(model) {
      return this.model === model && this._data instanceof SingleModelEditStackData;
    }
    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
      this._data instanceof SingleModelEditStackData && this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
    }
    close() {
      this._data instanceof SingleModelEditStackData && (this._data = this._data.serialize());
    }
    open() {
      this._data instanceof SingleModelEditStackData || (this._data = SingleModelEditStackData.deserialize(this._data));
    }
    undo() {
      if (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(this.model)) {
        throw Error("Invalid SingleModelEditStackElement");
      }
      this._data instanceof SingleModelEditStackData && (this._data = this._data.serialize());
      const data = SingleModelEditStackData.deserialize(this._data);
      this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);
    }
    redo() {
      if (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(this.model)) {
        throw Error("Invalid SingleModelEditStackElement");
      }
      this._data instanceof SingleModelEditStackData && (this._data = this._data.serialize());
      const data = SingleModelEditStackData.deserialize(this._data);
      this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);
    }
    heapSize() {
      this._data instanceof SingleModelEditStackData && (this._data = this._data.serialize());
      return this._data.byteLength + 168;
    }
  }
  class MultiModelEditStackElement {
    get resources() {
      return this._editStackElementsArr.map(editStackElement => editStackElement.resource);
    }
    constructor(label, code, editStackElements) {
      this.label = label;
      this.code = code;
      this.type = 1;
      this._isOpen = !0;
      this._editStackElementsArr = editStackElements.slice(0);
      this._editStackElementsMap = new Map();
      for (const editStackElement of this._editStackElementsArr) {
        this._editStackElementsMap.set(editStackElement.resource.toString(), editStackElement);
      }
      this._delegate = null;
    }
    prepareUndoRedo() {
      if (this._delegate) {
        return this._delegate.prepareUndoRedo(this);
      }
    }
    matchesResource(resource) {
      return this._editStackElementsMap.has(resource.toString());
    }
    setModel(model) {
      var JSCompiler_inline_result = (require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.isUri(model) ? model : model.uri).toString();
      this._editStackElementsMap.has(JSCompiler_inline_result) && this._editStackElementsMap.get(JSCompiler_inline_result).setModel(model);
    }
    canAppend(model) {
      if (!this._isOpen) {
        return !1;
      }
      const key = model.uri.toString();
      return this._editStackElementsMap.has(key) ? this._editStackElementsMap.get(key).canAppend(model) : !1;
    }
    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
      this._editStackElementsMap.get(model.uri.toString()).append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
    }
    close() {
      this._isOpen = !1;
    }
    open() {
    }
    undo() {
      this._isOpen = !1;
      for (const editStackElement of this._editStackElementsArr) {
        editStackElement.undo();
      }
    }
    redo() {
      for (const editStackElement of this._editStackElementsArr) {
        editStackElement.redo();
      }
    }
    heapSize(resource) {
      resource = resource.toString();
      return this._editStackElementsMap.has(resource) ? this._editStackElementsMap.get(resource).heapSize() : 0;
    }
    split() {
      return this._editStackElementsArr;
    }
    toString() {
      const result = [];
      for (const editStackElement of this._editStackElementsArr) {
        result.push(`${(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_resources_DOT_js.basename)(editStackElement.resource)}: ${editStackElement}`);
      }
      return `{${result.join(", ")}}`;
    }
  }
  class EditStack {
    constructor(model, undoRedoService) {
      this._model = model;
      this._undoRedoService = undoRedoService;
    }
    pushStackElement() {
      const lastElement = this._undoRedoService.getLastElement(this._model.uri);
      isEditStackElement(lastElement) && lastElement.close();
    }
    popStackElement() {
      const lastElement = this._undoRedoService.getLastElement(this._model.uri);
      isEditStackElement(lastElement) && lastElement.open();
    }
    clear() {
      this._undoRedoService.removeElements(this._model.uri);
    }
    _getOrCreateEditStackElement(beforeCursorState, group) {
      const lastElement = this._undoRedoService.getLastElement(this._model.uri);
      if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {
        return lastElement;
      }
      beforeCursorState = new SingleModelEditStackElement(nls.localize("edit", "Typing"), "undoredo.textBufferEdit", this._model, beforeCursorState);
      this._undoRedoService.pushElement(beforeCursorState, group);
      return beforeCursorState;
    }
    pushEOL(eol) {
      const editStackElement = this._getOrCreateEditStackElement(null, void 0);
      this._model.setEOL(eol);
      editStackElement.append(this._model, [], this._model.getEOL() === "\n" ? 0 : 1, this._model.getAlternativeVersionId(), null);
    }
    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {
      beforeCursorState = this._getOrCreateEditStackElement(beforeCursorState, group);
      editOperations = this._model.applyEdits(editOperations, !0);
      cursorStateComputer = EditStack._computeCursorState(cursorStateComputer, editOperations);
      editOperations = editOperations.map((op, index) => ({index, textChange:op.textChange}));
      editOperations.sort((a, b) => a.textChange.oldPosition === b.textChange.oldPosition ? a.index - b.index : a.textChange.oldPosition - b.textChange.oldPosition);
      beforeCursorState.append(this._model, editOperations.map(op => op.textChange), this._model.getEOL() === "\n" ? 0 : 1, this._model.getAlternativeVersionId(), cursorStateComputer);
      return cursorStateComputer;
    }
    static _computeCursorState(cursorStateComputer, inverseEditOperations) {
      try {
        return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;
      } catch (e) {
        return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e), null;
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$editStack.js.map
