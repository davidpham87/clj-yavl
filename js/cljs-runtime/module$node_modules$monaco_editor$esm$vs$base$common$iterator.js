shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$iterator = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Iterable:{enumerable:!0, get:function() {
    return Iterable;
  }}});
  var Iterable;
  (function(Iterable) {
    function is(thing) {
      return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
    }
    function* single(element) {
      yield element;
    }
    Iterable.is = is;
    const _empty = Object.freeze([]);
    Iterable.empty = function() {
      return _empty;
    };
    Iterable.single = single;
    Iterable.wrap = function(iterableOrElement) {
      return is(iterableOrElement) ? iterableOrElement : single(iterableOrElement);
    };
    Iterable.from = function(iterable) {
      return iterable || _empty;
    };
    Iterable.reverse = function*(array) {
      for (let i = array.length - 1; i >= 0; i--) {
        yield array[i];
      }
    };
    Iterable.isEmpty = function(iterable) {
      return !iterable || iterable[Symbol.iterator]().next().done === !0;
    };
    Iterable.first = function(iterable) {
      return iterable[Symbol.iterator]().next().value;
    };
    Iterable.some = function(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return !0;
        }
      }
      return !1;
    };
    Iterable.find = function(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return element;
        }
      }
    };
    Iterable.filter = function*(iterable, predicate) {
      for (const element of iterable) {
        predicate(element) && (yield element);
      }
    };
    Iterable.map = function*(iterable, fn) {
      let index = 0;
      for (const element of iterable) {
        yield fn(element, index++);
      }
    };
    Iterable.concat = function*(...iterables) {
      for (const iterable of iterables) {
        yield* iterable;
      }
    };
    Iterable.reduce = function(iterable, reducer, initialValue) {
      for (const element of iterable) {
        initialValue = reducer(initialValue, element);
      }
      return initialValue;
    };
    Iterable.slice = function*(arr, from, to = arr.length) {
      from < 0 && (from += arr.length);
      to < 0 ? to += arr.length : to > arr.length && (to = arr.length);
      for (; from < to; from++) {
        yield arr[from];
      }
    };
    Iterable.consume = function(iterable, atMost = Number.POSITIVE_INFINITY) {
      const consumed = [];
      if (atMost === 0) {
        return [consumed, iterable];
      }
      const iterator = iterable[Symbol.iterator]();
      for (iterable = 0; iterable < atMost; iterable++) {
        const next = iterator.next();
        if (next.done) {
          return [consumed, Iterable.empty()];
        }
        consumed.push(next.value);
      }
      return [consumed, {[Symbol.iterator]() {
        return iterator;
      }}];
    };
  })(Iterable ||= {});
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$iterator.js.map
