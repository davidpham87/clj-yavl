shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$guidesTextModelPart = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BracketPairGuidesClassNames:{enumerable:!0, get:function() {
    return BracketPairGuidesClassNames;
  }}, GuidesTextModelPart:{enumerable:!0, get:function() {
    return GuidesTextModelPart;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arraysFind"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$cursorColumns"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelPart");
  var require$_DOT__SLASH_utils_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$utils"), require$_DOT__DOT__SLASH_textModelGuides_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelGuides"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors");
  class GuidesTextModelPart extends module.TextModelPart {
    constructor(textModel, languageConfigurationService) {
      super();
      this.textModel = textModel;
      this.languageConfigurationService = languageConfigurationService;
    }
    getLanguageConfiguration(languageId) {
      return this.languageConfigurationService.getLanguageConfiguration(languageId);
    }
    _computeIndentLevel(lineIndex) {
      return (0,require$_DOT__SLASH_utils_DOT_js.computeIndentLevel)(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);
    }
    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
      this.assertNotDisposed();
      const lineCount = this.textModel.getLineCount();
      if (lineNumber < 1 || lineNumber > lineCount) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      var foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
      foldingRules = !(!foldingRules || !foldingRules.offSide);
      let up_aboveContentLineIndex = -2, up_aboveContentLineIndent = -1, up_belowContentLineIndex = -2, up_belowContentLineIndent = -1;
      const up_resolveIndents = lineNumber => {
        if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {
          up_aboveContentLineIndent = up_aboveContentLineIndex = -1;
          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
            const indent = this._computeIndentLevel(lineIndex);
            if (indent >= 0) {
              up_aboveContentLineIndex = lineIndex;
              up_aboveContentLineIndent = indent;
              break;
            }
          }
        }
        if (up_belowContentLineIndex === -2) {
          for (up_belowContentLineIndent = up_belowContentLineIndex = -1; lineNumber < lineCount; lineNumber++) {
            if (lineIndex = this._computeIndentLevel(lineNumber), lineIndex >= 0) {
              up_belowContentLineIndex = lineNumber;
              up_belowContentLineIndent = lineIndex;
              break;
            }
          }
        }
      };
      let down_aboveContentLineIndex = -2, down_aboveContentLineIndent = -1, down_belowContentLineIndex = -2, down_belowContentLineIndent = -1;
      const down_resolveIndents = lineNumber => {
        if (down_aboveContentLineIndex === -2) {
          down_aboveContentLineIndent = down_aboveContentLineIndex = -1;
          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
            const indent = this._computeIndentLevel(lineIndex);
            if (indent >= 0) {
              down_aboveContentLineIndex = lineIndex;
              down_aboveContentLineIndent = indent;
              break;
            }
          }
        }
        if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {
          for (down_belowContentLineIndent = down_belowContentLineIndex = -1; lineNumber < lineCount; lineNumber++) {
            if (lineIndex = this._computeIndentLevel(lineNumber), lineIndex >= 0) {
              down_belowContentLineIndex = lineNumber;
              down_belowContentLineIndent = lineIndex;
              break;
            }
          }
        }
      };
      let startLineNumber = 0, goUp = !0, endLineNumber = 0, goDown = !0, indent = 0, initialIndent = 0;
      for (let distance = 0; goUp || goDown; distance++) {
        const upLineNumber = lineNumber - distance, downLineNumber = lineNumber + distance;
        distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber) && (goUp = !1);
        distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber) && (goDown = !1);
        distance > 50000 && (goDown = goUp = !1);
        var upLineIndentLevel = -1;
        goUp && upLineNumber >= 1 && (upLineIndentLevel = this._computeIndentLevel(upLineNumber - 1), upLineIndentLevel >= 0 ? (up_belowContentLineIndex = upLineNumber - 1, up_belowContentLineIndent = upLineIndentLevel, upLineIndentLevel = Math.ceil(upLineIndentLevel / this.textModel.getOptions().indentSize)) : (up_resolveIndents(upLineNumber), upLineIndentLevel = this._getIndentLevelForWhitespaceLine(foldingRules, up_aboveContentLineIndent, up_belowContentLineIndent)));
        var downLineIndentLevel = -1;
        goDown && downLineNumber <= lineCount && (downLineIndentLevel = this._computeIndentLevel(downLineNumber - 1), downLineIndentLevel >= 0 ? (down_aboveContentLineIndex = downLineNumber - 1, down_aboveContentLineIndent = downLineIndentLevel, downLineIndentLevel = Math.ceil(downLineIndentLevel / this.textModel.getOptions().indentSize)) : (down_resolveIndents(downLineNumber), downLineIndentLevel = this._getIndentLevelForWhitespaceLine(foldingRules, down_aboveContentLineIndent, down_belowContentLineIndent)));
        if (distance === 0) {
          initialIndent = upLineIndentLevel;
        } else {
          if (distance === 1) {
            if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {
              goUp = !1;
              endLineNumber = startLineNumber = downLineNumber;
              indent = downLineIndentLevel;
              continue;
            }
            if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {
              goDown = !1;
              endLineNumber = startLineNumber = upLineNumber;
              indent = upLineIndentLevel;
              continue;
            }
            endLineNumber = startLineNumber = lineNumber;
            indent = initialIndent;
            if (indent === 0) {
              break;
            }
          }
          goUp && (upLineIndentLevel >= indent ? startLineNumber = upLineNumber : goUp = !1);
          goDown && (downLineIndentLevel >= indent ? endLineNumber = downLineNumber : goDown = !1);
        }
      }
      return {startLineNumber, endLineNumber, indent};
    }
    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {
      var _a;
      const result = [];
      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        result.push([]);
      }
      var bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();
      lineNumber = void 0;
      activePosition && bracketPairs.length > 0 && (lineNumber = (startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber ? bracketPairs : this.textModel.bracketPairs.getBracketPairsInRange(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(activePosition)).toArray()).filter(bp => require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.strictContainsPosition(bp.range, activePosition)), lineNumber = (_a = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLast)(lineNumber, 
      i => !0)) === null || _a === void 0 ? void 0 : _a.range);
      _a = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;
      const colorProvider = new BracketPairGuidesClassNames();
      for (const pair of bracketPairs) {
        if (!pair.closingBracketRange) {
          continue;
        }
        var isActive = lineNumber && pair.range.equalsRange(lineNumber);
        if (!isActive && !options.includeInactive) {
          continue;
        }
        bracketPairs = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, _a) + (options.highlightActive && isActive ? " " + colorProvider.activeClassName : "");
        const start = pair.openingBracketRange.getStartPosition(), end = pair.closingBracketRange.getStartPosition();
        isActive = options.horizontalGuides === require$_DOT__DOT__SLASH_textModelGuides_DOT_js.HorizontalGuidesState.Enabled || options.horizontalGuides === require$_DOT__DOT__SLASH_textModelGuides_DOT_js.HorizontalGuidesState.EnabledForActive && isActive;
        if (pair.range.startLineNumber === pair.range.endLineNumber) {
          isActive && result[pair.range.startLineNumber - startLineNumber].push(new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, bracketPairs, new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuideHorizontalLine(!1, end.column), -1, -1));
          continue;
        }
        const endVisibleColumn = this.getVisibleColumnFromPosition(end), startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);
        let renderHorizontalEndLineAtTheBottom = !1;
        strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber)) < pair.closingBracketRange.startColumn - 1 && (renderHorizontalEndLineAtTheBottom = !0);
        var visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);
        const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber), offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;
        for (; visibleGuideStartLineNumber < visibleGuideEndLineNumber + offset; visibleGuideStartLineNumber++) {
          result[visibleGuideStartLineNumber - startLineNumber].push(new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuide(guideVisibleColumn, -1, bracketPairs, null, visibleGuideStartLineNumber === start.lineNumber ? start.column : -1, visibleGuideStartLineNumber === end.lineNumber ? end.column : -1));
        }
        isActive && (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn && result[start.lineNumber - startLineNumber].push(new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuide(guideVisibleColumn, -1, bracketPairs, new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuideHorizontalLine(!1, start.column), -1, -1)), end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn && result[end.lineNumber - startLineNumber].push(new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuide(guideVisibleColumn, 
        -1, bracketPairs, new require$_DOT__DOT__SLASH_textModelGuides_DOT_js.IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1)));
      }
      for (const guides of result) {
        guides.sort((a, b) => a.visibleColumn - b.visibleColumn);
      }
      return result;
    }
    getVisibleColumnFromPosition(position) {
      return require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1;
    }
    getLinesIndentGuides(startLineNumber, endLineNumber) {
      this.assertNotDisposed();
      const lineCount = this.textModel.getLineCount();
      if (startLineNumber < 1 || startLineNumber > lineCount) {
        throw Error("Illegal value for startLineNumber");
      }
      if (endLineNumber < 1 || endLineNumber > lineCount) {
        throw Error("Illegal value for endLineNumber");
      }
      const options = this.textModel.getOptions();
      var foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
      foldingRules = !(!foldingRules || !foldingRules.offSide);
      const result = Array(endLineNumber - startLineNumber + 1);
      let aboveContentLineIndex = -2, aboveContentLineIndent = -1, belowContentLineIndex = -2, belowContentLineIndent = -1;
      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        const resultIndex = lineNumber - startLineNumber;
        var currentIndent = this._computeIndentLevel(lineNumber - 1);
        if (currentIndent >= 0) {
          aboveContentLineIndex = lineNumber - 1, aboveContentLineIndent = currentIndent, result[resultIndex] = Math.ceil(currentIndent / options.indentSize);
        } else {
          if (aboveContentLineIndex === -2) {
            for (aboveContentLineIndent = aboveContentLineIndex = -1, currentIndent = lineNumber - 2; currentIndent >= 0; currentIndent--) {
              var indent = this._computeIndentLevel(currentIndent);
              if (indent >= 0) {
                aboveContentLineIndex = currentIndent;
                aboveContentLineIndent = indent;
                break;
              }
            }
          }
          if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
            for (belowContentLineIndent = belowContentLineIndex = -1, currentIndent = lineNumber; currentIndent < lineCount; currentIndent++) {
              if (indent = this._computeIndentLevel(currentIndent), indent >= 0) {
                belowContentLineIndex = currentIndent;
                belowContentLineIndent = indent;
                break;
              }
            }
          }
          result[resultIndex] = this._getIndentLevelForWhitespaceLine(foldingRules, aboveContentLineIndent, belowContentLineIndent);
        }
      }
      return result;
    }
    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {
      const options = this.textModel.getOptions();
      return aboveContentLineIndent === -1 || belowContentLineIndent === -1 ? 0 : aboveContentLineIndent < belowContentLineIndent ? 1 + Math.floor(aboveContentLineIndent / options.indentSize) : aboveContentLineIndent === belowContentLineIndent ? Math.ceil(belowContentLineIndent / options.indentSize) : offSide ? Math.ceil(belowContentLineIndent / options.indentSize) : 1 + Math.floor(belowContentLineIndent / options.indentSize);
    }
  }
  class BracketPairGuidesClassNames {
    constructor() {
      this.activeClassName = "indent-active";
    }
    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {
      return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);
    }
    getInlineClassNameOfLevel(level) {
      return `bracket-indent-guide lvl-${level % 30}`;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$guidesTextModelPart.js.map
