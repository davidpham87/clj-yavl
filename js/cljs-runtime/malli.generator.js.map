{"version":3,"sources":["malli/generator.cljc"],"mappings":";AAgBA,AAAA;AAAA;AAAA;AAAA;AAAA,AAEA,AAAA;AAAA;;;4BAAA,5BAAaO;;AAAb,IAAAP,iDAAA,WACeQ,MAAKC;AADpB,AAAA,IAAAR,kBAAA,EAAA,UAAA,OAAA,hBACeO,qBAAAA;IADfN,kBAAA,CAAAC,2BAAA,AAAAC,YAAAH;AAAA,AAAA,GAAA,GAAA,CAAAC,mBAAA;AAAA,QAAAA,gDAAAA,+DAAAA,jBACeM,2CAAAA,rCAAKC,2CAAAA;;AADpB,IAAAJ,kBAAA,CAAAF,2BAAA;AAAA,AAAA,GAAA,GAAA,CAAAE,mBAAA;AAAA,QAAAA,gDAAAA,+DAAAA,jBACeG,2CAAAA,rCAAKC,2CAAAA;;AADpB,MAAA,AAAAH,2BAAA,uBACeE;;;;AADf,AAAA;;;6BAAA,7BACGL,kEAAYK,MAAKC;AADpB,AAAA,GAAA,EAAA,GAAA,UAAA,aAAA,GAAA,CAAA,sDAAA,hFACeD,0BAAAA;AADf,OACeA,mDAAAA,MAAKC;;AADpB,OAAAT,+CACeQ,MAAKC;;;;AADpB,AAkCA,AAAKC,0BAAQ,sCAAA,tCAACC;AAEd,yBAAA,zBAAOC,0DAAQC,OAAOJ;AAAtB,AAA+B,OAACK,gBAAM,AAACC,kDAAWF,OAAOJ;;AACzD,6BAAA,7BAAOO,kEAAYH,OAAOJ;AAA1B,AAAmC,IAAAQ,WAAW,AAACL,uBAAOC,OAAOJ;IAA1BS,WAAmCT;AAAnC,AAAA,0HAAAQ,SAAAC,gDAAAD,SAAAC,pLAACC,0DAAAA,6EAAAA;;AAEpC;;;6BAAA,qCAAAC,lEAAMI;AAAN,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;eAAAA,XAE2CK;gCAF3C,AAAAH,4CAAAF,eAAA,vFAEYI;AAFZ,AAGE,OAACE,oBAAU,AAACC,oCAAU,WAAKC;AAAL,AACE,4DAAA,rDAACC,sKACS,iBAAAC,WAAA;AAAA,AAAA,oBACEN;AAA0B,qDAAAM,SAAA,vDAACC,iHAAcP;;AAD3CM;;;IAFlC,2CAAA,4FAAA,KAAA,6HAKwCN;;AAE1C;;;0CAAA,1CAAMQ,4FAEHC;AAFH,AAEM,0BAAA,AAAA,0HAAI,AAACC,eAAKD,5JAAeE;;AAE/B,mCAAA,nCAAMC,8EAAkBH;AAAxB,AAA2B,GAAU,AAACD,wCAAkBC;AAA7B;;AAAA,AAAgCA;;;AAC3D,+BAAA,/BAAMI,sEAAcJ;AAApB,AAAuB,GAAM,AAACD,wCAAkBC;AAAzB,AAA4BA;;AAA5B;;;AAEvB,0BAAA,1BAAOK,4DAASC;AAAhB,AAAsB,oBAAIA;AAAK,OAACC,oEAAmBD;;AAAM,OAACC;;;AAE1D,2BAAA,3BAAMC,8DAAU7B,OAAOJ;AAAvB,AACE,IAAAkC,aAA0D,AAACK,oDAAanC,OAAOJ;IAA/EkC,iBAAA,AAAArB,4BAAAqB;cAAA,AAAApB,4CAAAoB,eAAA,rEAAuBG;cAAvB,AAAAvB,4CAAAoB,eAAA,rEAAwCI;UAAxC,AAAAxB,4CAAAoB,eAAA,jEAAcC;UAAd,AAAArB,4CAAAoB,eAAA,jEAAkBE;AAAlB,AACE,oBAAM,iBAAAI,oBAAKL;AAAL,AAAA,oBAAAK;AAAA,IAAAA,wBAASH;AAAT,AAAA,oBAAAG;AAAiB,QAAGH,UAAQF;;AAA5BK;;;AAAAA;;;AAAN,AACE,qDAAA,0GAAA,2CAAA,oDAAA,uDAAA,8DAAA,nXAACnB,2WAAmDgB,0DAAcF;;AADpE;;AAEA,oBAAM,iBAAAK,oBAAKJ;AAAL,AAAA,oBAAAI;AAAA,IAAAA,wBAASF;AAAT,AAAA,oBAAAE;AAAiB,QAAGF,UAAQF;;AAA5BI;;;AAAAA;;;AAAN,AACE,qDAAA,0GAAA,2CAAA,oDAAA,sDAAA,8DAAA,lXAACnB,0WAAmDgB,yDAAcF;;AADpE;;AAHF,kDAAA,kDAKQ,iBAAAM,mBAAIJ;AAAJ,AAAA,oBAAAI;AAAAA;;AAAYN;;KALpB,iDAMQ,iBAAAM,mBAAIH;AAAJ,AAAA,oBAAAG;AAAAA;;AAAYL;;;;AAEtB,0BAAA,1BAAOM,4DAAStC,OAAOJ;AAAvB,AACE,IAAA2C,aAAmC,AAACJ,oDAAanC;IAAjDuC,iBAAA,AAAA9B,4BAAA8B;sBAAA,AAAA7B,4CAAA6B,eAAA,7EAAkBC;iBAAlB,AAAA9B,4CAAA6B,eAAA,xEAA4BE;AAA5B,AAAA,kDAAA,gFAAA,hBACcD,sEAAgBC;;AAEhC,2BAAA,3BAAOC,8DAAUC,EAAEC;AAAnB,AAAwB,IAAAP,mBAAI,AAACZ,6BAAamB;AAAlB,AAAA,oBAAAP;AAAAA;;AAAuB,OAACQ,mCAASF,EAAEC;;;AAC3D,2BAAA,3BAAOE,8DAAUF;AAAjB,AAAsB,gCAAA,WAAAG,pCAACL;AAAD,AAAW,sEAAAK,/DAACC,8CAAMC;GAAUL;;AAClD,4BAAA,5BAAOM,gEAAWC;AAAlB,AAAwB,IAAAd,mBAAI,AAACe,eAAK3B,6BAAa0B;AAAvB,AAAA,oBAAAd;AAAAA;;AAA6B,OAACW,8CAAMK,oCAAUF;;;AACtE,4BAAA,5BAAOG,gEAAWjC;AAAlB,AAAqB,GAAI,AAACD,wCAAkBC;AAAGxB;;AAAQ,4CAAA,rCAAC0D,wHAAY1D,wBAAQwB;;;AAC5E,iCAAA,2CAAA,gEAAA,MAAA,sDAAA,xMAAemC;AACf,6BAAA,7BAAOC,kEAAYC;AAAnB,AAAyB,OAACC,yIAAgB,AAACC,6CAAKJ,+BAAeE,3HAAM,iIAAA,kDAAA,WAAAG,9LAACC,/CAAgC,AAACA;AAAlC,AAAc,IAAAC,WAAAF;AAAA,AAAA,GAAA,CAAAE,YAAA;AAAA;;AAAAA;;IAAmB,iDAAA,WAAAC;AAAA,AAAc,IAAAC,WAAAD;AAAA,AAAA,GAAA,CAAAC,YAAA;AAAA;;AAAAA;;;;AAEpH,6BAAA,qCAAAC,lEAAOE,2EAA8B/C;AAArC,AAAA,IAAA8C,aAAAD;IAAAC,iBAAA,AAAA1D,4BAAA0D;UAAA,AAAAzD,4CAAAyD,eAAA,jEAA2BpC;UAA3B,AAAArB,4CAAAyD,eAAA,jEAA+BnC;AAA/B,AACE,GACE,AAACZ,wCAAkBC;AAAG,GAAI,CAAO,iBAAAgB,mBAAIN;AAAJ,AAAA,oBAAAM;AAAAA;;AAAA;;SAAP;AAAmB,6CAAA,tCAACvC;;AAAeuB;;;AAD/D,oBAEE,iBAAAe,oBAAKL;AAAL,AAAA,oBAAAK;AAAS,OAACiC,6CAAEtC,IAAIC;;AAAhBI;;;AAAsB,OAACkC,mEAAWjD,EAAEU;;AAFtC,oBAGE,iBAAAK,oBAAKL;AAAL,AAAA,oBAAAK;AAASJ;;AAATI;;;AAAc,OAACkC,mEAAWjD,EAAEU,IAAIC;;AAHlC,oBAIED;AAAI,OAACwC,kDAAU,oCAAA,WAAAC,/CAACzD;AAAD,AAAY,OAACuD,mEAAWjD,EAAEU,IAAI,OAAAyC,NAAGzC;oBAA5C,qGAAA,2CAAA,kDAAA,kEAAA,iEAAA,rVAAqD0C,mVAAkDpD,oDAAOU;;AAJpH,oBAKEC;AAAI,4EAAA,rEAACsC,mEAAWjD,MAAIW;;AALtB,AAMQ,OAACsC,mEAAWjD;;;;;;;;AAEtB,yCAAA,wDAAAqD,jGAAOE,0FAAwB5E,gBAA2B2C,EAAEtB;AAA5D,AAAA,IAAAsD,aAAAD;IAAAC,iBAAA,AAAAlE,4BAAAkE;QAAAA,JAAuDE;UAAvD,AAAAnE,4CAAAiE,eAAA,jEAA8C5C;AAA9C,AACE,GAAI,AAACX,wCAAkBC;AACrB,GAAI,6CAAA,7CAACgD,iDAAI,iBAAAhC,mBAAIN;AAAJ,AAAA,oBAAAM;AAAAA;;AAAA;;;AAAY,6CAAA,tCAACvC;;AAAeuB;;;AACrC,OAACyD,+EAAuBnC,EAAEtB,EAAE,AAACuC,6CAAK,kBAAI,iBAAAxB,oBAAKL;AAAL,AAAA,oBAAAK;AAAS,OAACiC,6CAAEtC,IAAIiD;;AAAhB5C;;4bAAV,2CAAA,gEAAA,MAAA,uDAAA,WAAA2C,zmBAAM,2CAAA,qEACiBhD,YACf,0BAAA,2CAAA,kDAAA,oEAAA,iDAAA,5OAACkD,wBAAgBJ;AAFzB,AAIe,6BAAA,tBAACK,qJAA0C,8CAAAH,iBAAA,/DAAC5D,yHAAgBnB;;;;AAE3G,8BAAA,9BAAOmF,oEAAanF,OAAOJ;AAA3B,AACE,OAAC8C,yBAAS0C,oBAAS,AAAChB,2BAAW,AAACvC,yBAAS7B,OAAOJ,SAASyF;;AAE3D,AAAA,4BAAA,oCAAAC,hEAAOE;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAOD,qEACHxF,OAAOJ;AADX,AACoB,OAAC8F,wDAAU1F,OAAO2F,mBAAS/F;;;AAD/C,CAAA,0DAAA,1DAAO4F,qEAEHxF,OAAO2C,EAAE/C;AAFb,AAEsB,OAAC8C,yBAASC,EAAE,AAACyB,2BAAW,AAACvC,yBAAS7B,OAAOJ,SAAS,AAACO,2BAAWH,OAAOJ;;;AAF3F,CAAA,oDAAA,pDAAO4F;;AAAP,AAIA,sCAAA,tCAAOI,oFAAqB5F,OAAO6E,EAAExD;AAArC,AAAwC,OAACuD,uCAAuB5E,OAAO6E,EAAEc,mBAAStE;;AAElF,qCAAA,rCAAOwE,kFAAoB7F,OAAO2C,EAAE/C;AAApC,AACE,OAAC8C,yBAASC,EAAE,AAACiD,oCAAoB5F,OAAO,AAAC6B,yBAAS7B,OAAOJ,SAAS,AAACO,2BAAWH,OAAOJ;;AAEvF,sCAAA,tCAAOmG,oFAAkB/F;AAAzB,AAAA,kDAAA,gEAAA,MAAA,uDAAA,WAAA8F;AAAA,AAAyD,6BAAA,tBAACZ,iIAAiC,8CAAAY,iBAAA,/DAAC3E,yHAAgBnB;;;AAC5G,gCAAA,hCAAOgG,wEAAehG,OAAOiG,KAAKrD;AAAlC,AAAuC,IAAAP,mBAAI,AAACZ,6BAAamB;AAAlB,AAAA,oBAAAP;AAAAA;;AAAuB,OAAC6D,sEAAcD,KAAKrD,IAAI,AAACmD,oCAAiB/F;;;AAExG,2BAAA,3BAAMmG,8DAAUnG,OAAOJ;AAAvB,AACE,OAACoG,8BAAchG,OAAO,AAACoG,mDAAYpG,OAAOJ,SAAS,AAACO,2BAAWH,OAAOJ;;AAExE,6BAAA,7BAAOyG,kEAAYzG,QAAQ0G;AAA3B,AACE,IAAAC,qBAAa,AAACC,oBAAU,6CAAA,7CAAC5C,8EAAQ,AAAC6C,6CAAKjF,kCAAkB8E;AAAzD,AAAA,GAAA,CAAAC,sBAAA;AAEE,OAAC5F,2BAAWf;;AAFd,aAAA2G,TAAUD;AAAV,AACE,GAAI,6CAAA,7CAACjC,iDAAI,AAACqC,gBAAMJ;AAAK,0DAAA,nDAACK,4CAAIL;;AAAM,OAAC/C,qCAAW+C;;;;AAGhD,+BAAA,/BAAOM,sEAAc5G,OAAOJ;AAA5B,AACE,IAAAiH,aAAoB,AAAChF,yBAAS7B,OAAOJ;IAArCiH,iBAAA,AAAApG,4BAAAoG;UAAA,AAAAnG,4CAAAmG,eAAA,jEAAc9E;IACR+E,KAAG,AAAC/G,uBAAOC,OAAOJ;AADxB,AAEE,OAACyG,2BACAzG,8HAEI,iBAAAmH,WAAA,zEAGA,AAACnD,7CAED,AAACoD,5BACD,iBAAAQ;AANA,AAAA,GACE,EAAI,QAAA,PAAMzF,kBAAK,SAAA,RAAOA;AACtB,oDAAAgF,7CAACC,sDAAKnH;;AAFRkH;;KAGM,4CAAA,WAAAG,vDAACC;AAAD,AAAM,sEAAAD,/DAACxB,wDAAU1F,wBAASJ;IAAhC,uIAAA,WAAAqH,/DACOtB,mBAASyB,cAAIC;AADpB,AAC8B,0DAAAJ,nDAACK;YACzB,AAACzB,mCAAmB7F,OAAOuH,cAAI3H;AACrC,AAAA,GACE,EAAK,6CAAA,7CAACyE,oGAAS,AAACoD,8CAAOX,UAClB,6CAAA,7CAACzC,iDAAI,AAACqC,gBAAM,AAACxG,kDAAW4G;AAC7B,oDAAAU,7CAACR,sDAAK,iBAAAU,aAAY,AAACxH,kDAAW4G;QAAxB,AAAAH,4CAAAe,WAAA,IAAA,/DAAOC;QAAP,AAAAhB,4CAAAe,WAAA,IAAA,/DAASE;AAAT,AACE,IAAAC,WAAA,mFAAA,yDAAoB,iBAAAxF,mBAAI,AAACF,oDAAanC;AAAlB,AAAA,oBAAAqC;AAAAA;;AAAA;;KAA8BsF,EAAEC;IAApDE,WAAuDlI;AAAvD,AAAA,0HAAAiI,SAAAC,gDAAAD,SAAAC,pLAACxH,0DAAAA,6EAAAA;;;AAJXkH;;;;AAMT,0BAAA,1BAAMO,4DAAS/H,OAAOJ;AAAtB,AACE,OAACyG,2BAAWzG,QAAQ,4CAAA,WAAAoI,vDAACb;AAAD,AAAM,0HAAAa,gEAAAA,lLAAC1H,0DAAAA,oFAAAA,XAAYV,gEAAAA;GAAS,AAACM,kDAAWF,OAAOJ;;AAErE,2DAAA,3DAAOqI,8HAA0CjI;AAAjD,AACE,IAAMkI,WAAS,AAAA,2FAAA,oDAAIlI,pDAAOmC;AAA1B,AACE,IAAAgG,WAAQnI;AAAR,AAAA,GACE,qBAAAoI,pBAAUF;AACV,kEAAAC,SAAA,WAAAE,/EAACC;AAAD,AACE,OAACnB,4CAAI,WAAAoB;AAAA,AAAA,IAAAC,aAAAD;QAAA,AAAA5B,4CAAA6B,WAAA,IAAA,/DAAMb;QAANa,JAAYC;AAAZ,AACE,IAAAC,WAAQD;AAAR,AAAA,GACE,gDAAA,hDAACE,+HAAiBhB;AAClB,sDAAAe,SAAA,qBAAA,mFAAA,mDAAA,4FAAA,mFAAA,+CAAA,jbAAC5E,4DAAS8E,0OAAgBV,gJAAiBP;;AAF7Ce;;GADPL;GAID,AAACQ,iDAAU7I;;AAPdmI;;;AASJ,6BAAA,7BAAMW,kEAAY9I,OAAOJ;AAAzB,AACE,OAACyG,2BAAWzG,QAAQ,4CAAA,WAAAmJ,vDAAC5B;AAAD,AAAM,IAAA6B,WAAW,eAAAD,fAACG;IAAZD,WAAoBrJ;AAApB,AAAA,0HAAAoJ,SAAAC,gDAAAD,SAAAC,pLAAC3I,0DAAAA,6EAAAA;GAA4B,AAAC6I,iDAAU,AAAClB,yDAAyCjI,QAAQJ;;AAEtH,6BAAA,7BAAOwJ,kEAAYC;AAAnB,AACE,OAACC,2BACA,AAACC,+CACA,eAAAC,JAAKE;AAAL,AAAA,IAAAD,aAAAD;QAAA,AAAA7C,4CAAA8C,WAAA,IAAA,/DAAU9B;QAAV,AAAAhB,4CAAA8C,WAAA,IAAA,/DAAY7B;AAAZ,AACE,GAAM,EAAK,+CAAA,/CAACvD,6CAAEsD,uFAAe,AAACgC,qBAAK/B;AAAI,OAACgC,oBAAUC,sBAAOH,IAAI9B;;AAA7D,GACM,MAAA,LAAMD;AAAG+B;;AADf,AAEY,OAACI,oDAAOJ,IAAI/B,EAAEC;;;;GAC5B,qBAAA,rBAACmC,yDAAcV;;AAEnB,6BAAA,qCAAAW,lEAAOE,2EAAkBtK;AAAzB,AAAA,IAAAqK,aAAAD;QAAA,AAAArD,4CAAAsD,WAAA,IAAA,/DAAoBtC;QAApB,AAAAhB,4CAAAsD,WAAA,IAAA,/DAAsBE;AAAtB,AACE,IAAAC,WAAS,yBAAA,WAAAC,pCAAC3H;AAAD,AAAW,AAAA,4FAAA2H,FAAK1C;GAAM,CAACrH,0DAAAA,qEAAAA,bAAU6J,iDAAAA,/CAAEvK,iDAAAA;AAA5C,AAAA,oBAAsD,AAAA,2FAAA,oDAAIuK,pDAAEhI;AAA5D,iCAAAiI,1BAAoF9G;;AAApF8G;;;AAEF,2BAAA,3BAAME,8DAAUtK,OAAOJ;AAAvB,qFACwB,4CAAA,WAAA2K,vDAACpD,1BAA6BjE,3DAAU,2DAAA,pDAACR,yBAAS0G;AAAlD,AAAM,kCAAAmB,3BAACL,4CAAatK;oDAArCI,jDAAOmJ,AAAU;;AAExB,8BAAA,9BAAMqB,oEAAaxK,OAAOJ;AAA1B,AAGO,gCAAA,WAAA+K,pCAACjI;AAAD,AAAW,oDAAA,mCAAAiI,hFAAC/G;GADZ,uFAAA,WAAA8G,lGAAC9F,uCAAuB5E,OAAO,AAAC6B,yBAAS7B,OAAOJ;AAAhD,AAA0D,mDAAA8K,iBAAA,7DAAC/D;GAD3D,AAACzD,0BAAU,4CAAA,WAAAuH,vDAACtD;AAAD,AAAM,0HAAAsD,gEAAAA,lLAACnK,0DAAAA,oFAAAA,XAAYV,gEAAAA;GAAS,AAACM,kDAAWF,OAAOJ;;AA6GjE,2BAAA,3BAAMgL,8DAAU5K,OAAOJ;AAAvB,AACE,IAAMiL,SAAO,AAACC,gCAAuB9K;AAArC,AACE,IAAAqC,mBAAI,AAAC0I,gBAAM,uDAAA,mFAAA,1IAACC,+CAAOpL,iLAAmBiL;AAAtC,AAAA,oBAAAxI;AAAAA;;AACI,IAAM4I,iBAAe,KAAAC,gBAAA;AAAA,AAAO,OAACvK,2BAAWf;GAAnB;IACfuL,UAAQ,AAACC,+CAAQpL;AADvB,AAEE,IAAAqL,WAAS,iBAAAC,WAAWH;IAAXI,WAAmB,2BAAA,mFAAA,9GAACC,mBAAS5L,iLAAmBiL,eAAQI;AAAxD,AAAA,0HAAAK,SAAAC,gDAAAD,SAAAC,pLAACjL,0DAAAA,6EAAAA;;AAAV,AAAA,GACE,AAACmL,0BAAUR;AAAgB,mDAAA,WAAAS,vDAACC;AAAD,AACE,IAAAC,WAAWT;IAAXU,WAAmB,2BAAA,mFAAA,qGAAAH,nNAACF,mBAAS5L,iLAAmBiL;AAAhD,AAAA,0HAAAe,SAAAC,gDAAAD,SAAAC,pLAACvL,0DAAAA,6EAAAA;GADH+K;;AAD7BA;;;;AAIV,gCAAA,hCAAMS,wEAAS9L,OAAOJ;AAAtB,AACE,IAAMmM,mBAAiB,iBAAAC,WAAW,AAAA,wFAAS,AAACE,0BAAiBlM;IAAtCiM,WAA+CrM;AAA/C,AAAA,0HAAAoM,SAAAC,gDAAAD,SAAAC,pLAAC3L,0DAAAA,6EAAAA;;AAAxB,AACE,OAACR,sCAAW,qDAAA,2CAAA,hGAACqM,0JAAuBnM,eAAQ;mCAAOgB;AAAP,AAAU,QAACoL,yDAAAA,mFAAAA,5BAASL,+DAAAA,9CAAiBnM,+DAAAA;;;IAA9BoB;;;;EAAAA;;oCAAAA;;;IAAAA;0BAAAA;;;;;;;AAEvD,gCAAA,hCAAMqL,wEAAerM,OAAOJ;AAA5B,AACE,OAACE,sCAAW,qDAAA,2CAAA,iEAAA,kDAAA,WAAAwM,9NAACH,0JAAuBnM;AAAxB,AAAsC,wHAAAsM,+DAAAA,/KAACF,yDAAAA,mFAAAA,XAAWxM,+DAAAA;WAAlD,KAAgEA;;AAE9E,mCAAA,nCAAM2M,8EAAkBvM,OAAOJ;AAA/B,AACE,IAAA4M,WAAQ,CAAClM,0DAAAA,0EAAAA,lBAAUN,sDAAAA,/CAAOJ,sDAAAA;AAA1B,AAAA,GAAmC,AAAC6M,cAAI,AAACC,4BAAa1M;AAAS,iCAAA,KAAA2M,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAAH,UAAA,tHAAWtJ;;AAA1EsJ;;;AAEF,gCAAA,hCAAOI,wEAAenE,EAAE7I;AAAxB,AAAiC,OAAC2M,iCAAiB,EAAI,AAACM,wBAAQpE,IAAG,8CAAA,9CAAC/H,4CAAI+H,OAAKA,GAAG7I;;AAEhF,2BAAA,3BAAMkN,8DAAU9M,OAAOJ;AAAvB,AACE,gCAAA,0BAAiC,4CAAA,WAAAmN,vDAAC5F,1BAAgCjE,zBAAUJ;AAA3C,AAAM,qCAAAiK,9BAACH,+CAAgBhN;GAAnD,AAACM,kDAAWF,OAAOJ;;AAE1B,2BAAA,3BAAMoN,8DAAUhN,OAAOJ;AAAvB,0CACmC,4CAAA,WAAAqN,vDAAC9F,1CAAgC,OAACd,2BAAWzG;AAA7C,AAAM,qCAAAqN,9BAACL,+CAAgBhN;GAAnD,AAACM,kDAAWF,OAAOJ;;AAE1B,+BAAA,/BAAMsN,sEAAQlN,OAAOJ;AAArB,AACE,IAAMuN,QAAM,AAACpN,uBAAOC,OAAOJ;AAA3B,AACE,IAAA2G,qBAAY,AAAC/E,iCAAiB,CAAClB,0DAAAA,yEAAAA,jBAAU6M,qDAAAA,/CAAMvN,qDAAAA;AAA/C,AAAA,GAAA,CAAA2G,sBAAA;AAIE,6CAAA,tCAACzG;;AAJH,QAAAyG,JAAUlF;AAAV,AACE,oBAAI,AAACqL,4BAAaS;AAChB,4CAAA,rCAAC5J,wHAAYlC,EAAE,sCAAA,tCAACvB;;AAChB,4EAAA,IAAA,zEAACwE,mEAAWjD;;;;AAGpB,8BAAA,9BAAM+L,oEAAQpN,OAAOJ;AAArB,AACE,IAAMuN,QAAM,AAACpN,uBAAOC,OAAOJ;AAA3B,AACE,IAAAyN,WAAS,AAACjJ,2BACA,AAACvC,yBAAS7B,OAAOJ,SACjB,CAACU,0DAAAA,yEAAAA,jBAAU6M,qDAAAA,/CAAMvN,qDAAAA;AAF3B,AAAA,oBAGE,AAAC8M,4BAAaS;AAHhB,gCAAAE,zBAGuBvK;;AAHvBuK;;;AAKJ,8BAAA,9BAAMC,oEAAQtN,OAAOJ;AAArB,AACE,IAAMuN,QAAM,AAACpN,uBAAOC,OAAOJ;AAA3B,AACE,IAAA2N,WAAS,AAACnJ,0EACI,AAACvC,yBAAS7B,OAAOJ,/EAGjB,wFAAA,xFAACkE,0IAAY,2DAAA,3DAAC0J,6CAAKxI,oBACvB,CAAC1E,0DAAAA,yEAAAA,jBAAU6M,qDAAAA,/CAAMvN,qDAAAA;AAL3B,AAAA,oBAME,AAAC8M,4BAAaS;AANhB,gCAAAI,zBAMuBzK;;AANvByK;;;AAQJ,8BAAA,9BAAME,oEAAazN,OAAOJ;AAA1B,AACE,IAAAyC,mBAAI,iBAAAqL,WAAQ,AAAChI,wDAAU1F,OAAOJ;IAA1B8N,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iCAAAA,jCAAmClM;AAAnC,AAAA,GAAA,CAAAkM,gBAAA;AAAA;;AAAoD,IAAAC,WAAAD;AAAA,AAAA,oBAAQ,AAAChB,4BAAa,AAAC3M,uBAAOC,OAAOJ;AAArC,gCAAA+N,zBAA+C7K;;AAA/C6K;;;;AAAxD,AAAA,oBAAAtL;AAAAA;;AACI,6CAAA,tCAACvC;;;AAEP,uCAAA,vCAAM8N,sFAAsB5N,OAAO6N,iBAAiBC,uBAAuB7H,KAAKrD;AAAhF,AACE,IAAAmL,qBAA4B,AAAA,6FAAY,AAAC5L,oDAAanC;AAAtD,AAAA,oBAAA+N;AAAA,yBAAAA,rBAASC;AAAT,AACE,OAACtL,yBAAS,WAAKiF;AAAL,AAAQ,IAAAsG,WAAkB,AAACE,eAAKH;IAAxBE,WAA4C,AAACC,eAAKxG;AAAlD,AAAA,wGAAAsG,SAAAC,uCAAAD,SAAAC,zJAACL,iDAAAA,oEAAAA;GAAsDC;;AACzE,OAAC9H,8BAAchG,OAAOiG,KAAKrD;;;AAE/B,yCAAA,zCAAMwL,0FAAwBpO;AAA9B,AACE,OAAC4N,qCAAqB5N,OAAOqO,kBAAQC,sCAAYC,mCAAmBC;;AAEtE,wCAAA,xCAAMC,wFAAuBzO;AAA7B,AACE,OAAC4N,qCAAqB5N,OAAO0O,iBAAOC,qCAAWC,kCAAkBC;;AAEnE,+BAAA,/BAAOC,sEAAcC;AAArB,AACE,GAAI,6CAAA,7CAAC1K,iDAAI,AAACqC,gBAAMqI;AACd,OAACjP,sCAAW,AAACG,gBAAM8O;;AACnB,OAACC,uCAAaD;;;AAElB,6BAAA,7BAAOE,kEAAYjP,OAAOJ;AAA1B,AACE,OAAC+D,2CAAY,AAACuL,uGAAM,iBAAMC,QAAM,AAAChN,oDAAanC,OAAOJ;AAAjC,AAAA,kDAAA,8LAAA,9HACc,kDAAA,qEAAA,vHAACc,4CAAIyO,wIACV,kDAAA,2DAAA,7GAACzO,4CAAIyO;mGACV,AAACtN,yBAAS7B,OAAOJ,/EACjB,wFAAA,kDAAA,WAAAwP,rJAACtL,/CACD,AAACA;AADD,AAAc,IAAAuL,WAAAD;AAAA,AAAA,GAAA,CAAAC,YAAA;AAAA;;AAAAA;;IACd,iDAAA,WAAAC;AAAA,AAAc,IAAAC,WAAAD;AAAA,AAAA,GAAA,CAAAC,YAAA;AAAA;;AAAAA;;;;AAExC,GAAA,QAAAC,kCAAAC,4CAAAC;AAAA;AAAA,AAAA,oCAAA,iBAAAC,6BAAA,AAAAC,6CAAA,/HAAUQ;IAAVP,6BAAA,AAAAD,6CAAA;IAAAE,6BAAA,AAAAF,6CAAA;IAAAG,iCAAA,AAAAH,6CAAA;IAAAI,0BAAA,AAAAtP,4CAAA,2CAAA,4DAAA,gGAAA,gEAAA,iBAAAuP,eAAA;AAAA,AAAA,QAAAA,6CAAAA,+CAAAA;;AAAA,AAAA,YAAAC,kBAAA,AAAAC,+CAAA,kBAAA,qBAA4B,WAAKnQ,OAAOJ;AAAZ,AAAqB,OAAC6H,8CAAOzH,OAAOJ;GAAhE,wFAAAoQ,wBAAAL,2BAAAE,2BAAAC,2BAAAC;;;AAEA,AAAAK,8EAAA,wFAAA,WAAwCpQ,OAAOJ;AAA/C,AAAwD,OAACyQ,iCAAgB,AAACjK,mDAAYpG,OAAOJ;;AAE7F,AAAAwQ,8EAAA,AAAA,2DAAA,WAAsCpP,EAAEA;AAAxC,AAA2C,OAACqP,iCAAgBC;;AAC5D,AAAAF,8EAAA,+CAAA,WAAiCpQ,OAAOJ;AAAxC,AAAiD,kCAAA,2CAAA,tEAAC6D,wHAAiB,0CAAA,zCAAK,AAAC1D,uBAAOC,OAAOJ;;AACvF,AAAAwQ,8EAAA,iDAAA,WAAkCpQ,OAAOJ;AAAzC,AAAkD,kCAAA,2CAAA,tEAAC6D,wHAAiB,AAAC1D,uBAAOC,OAAOJ;;AACnF,AAAAwQ,8EAAA,+CAAA,WAAiCpQ,OAAOJ;AAAxC,AAAiD,kCAAA,2CAAA,tEAAC6D,uHAAiB,0CAAA,zCAAK,AAAC1D,uBAAOC,OAAOJ;;AACvF,AAAAwQ,8EAAA,iDAAA,WAAkCpQ,OAAOJ;AAAzC,AAAkD,kCAAA,2CAAA,tEAAC6D,uHAAiB,AAAC1D,uBAAOC,OAAOJ;;AACnF,AAAAwQ,8EAAA,+CAAA,WAAiCpQ,OAAOJ;AAAxC,AAAiD,OAACE,sCAAW,AAACC,uBAAOC,OAAOJ;;AAC5E,AAAAwQ,8EAAA,qDAAA,WAAoCpQ,OAAOJ;AAA3C,AAAoD,4CAAA,WAAA2Q,hDAACvK,8BAAchG;AAAf,AAAuB,uDAAAuQ,hDAAC5H,iEAAO,AAAC5I,uBAAOC,OAAOJ;GAAU4Q;;AAC5G,AAAAJ,8EAAA,AAAA,yDAAA,WAAoCpP,EAAEpB;AAAtC,AAA+C,4CAAA,rCAAC2D,wHAAY,2BAAA,2CAAA,kDAAA,xHAACE,wIAA2B,AAACf,yBAAS+N,cAAIC;;AACtG,AAAAN,8EAAA,AAAA,0DAAA,WAAoCpP,EAAEpB;AAAtC,AAA+C,4CAAA,rCAAC2D,wHAAY,2BAAA,2CAAA,iDAAA,vHAACE,wIAA4B,AAACf,yBAAS,AAACiO,6CAAKC,cAAIC,aAAGH;;AAChH,AAAAN,8EAAA,mDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACoG,8BAAchG,OAAO,AAACoG,mDAAYpG,OAAOJ,SAAS,AAACyQ,iCAAgBS;;AACvH,AAAAV,8EAAA,mDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACuG,yBAASnG,OAAOJ;;AACpE,AAAAwQ,8EAAA,qDAAA,WAAoCpQ,OAAOJ;AAA3C,AAAoD,OAACuG,yBAAS,qDAAA,rDAAC4K,wGAAmB,AAAC5O,oDAAanC,QAAQ,AAACmH,4CAAI+B,eAAK,AAAChJ,kDAAWF,SAAS,AAAC6I,iDAAU7I,SAASJ;;AAC3J,AAAAwQ,8EAAA,gDAAA,WAAkCpQ,OAAOJ;AAAzC,AAAkD,OAACmI,wBAAQ/H,OAAOJ;;AAClE,AAAAwQ,8EAAA,kDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACmI,wBAAQ,qDAAA,rDAACgJ,qGAAkB,AAAC5O,oDAAanC,QAAQ,AAACmH,4CAAI+B,eAAK,AAAChJ,kDAAWF,SAAS,AAAC6I,iDAAU7I,SAASJ;;AACxJ,AAAAwQ,8EAAA,oEAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,OAACO,2BAAWH,OAAOJ;;AACzE,AAAAwQ,8EAAA,mDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAAC0K,yBAAStK,OAAOJ;;AACpE,AAAAwQ,8EAAA,yDAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,OAAC4K,4BAAYxK,OAAOJ;;AAC1E,AAAAwQ,8EAAA,uDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,OAACkJ,2BAAW9I,OAAOJ;;AACxE,AAAAwQ,8EAAA,yDAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,OAAC8F,wDAAU1F,OAAOJ;;AACxE,AAAAwQ,8EAAA,kEAAA,WAA0CpQ,OAAOJ;AAAjD,AAA0D,OAAC8F,wDAAU1F,OAAOJ;;AAC5E,AAAAwQ,8EAAA,kDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACiG,mCAAmB7F,OAAOuH,cAAI3H;;AAClF,AAAAwQ,8EAAA,qDAAA,WAAoCpQ,OAAOJ;AAA3C,AAAoD,OAACkP,6BAAa,AAAC5O,kDAAWF,OAAOJ;;AACrF,AAAAwQ,8EAAA,4DAAA,WAAuCpQ,OAAOJ;AAA9C,AAAuD,OAACgH,6BAAa5G,OAAOJ;;AAC5E,AAAAwQ,8EAAA,wDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,OAACgH,6BAAa5G,OAAOJ;;AAC1E,AAAAwQ,8EAAA,uDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,OAAC0D,0BAAU,AAACnD,2BAAWH,OAAOJ;;AACnF,AAAAwQ,8EAAA,uDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,OAACsD,0BAAU,4CAAA,WAAA8N,vDAAC7J;AAAD,AAAM,0HAAA6J,gEAAAA,lLAAC1Q,0DAAAA,oFAAAA,XAAYV,gEAAAA;GAAS,AAACM,kDAAWF,OAAOJ;;AAE/G,AAAAwQ,8EAAA,mDAAA,WAAmCpP,EAAEA;AAArC,AAAwC,OAACqP,iCAAgBS;;AACzD,AAAAV,8EAAA,sDAAA,WAAoCpP,EAAEA;AAAtC,AAAyCwP;;AACzC,AAAAJ,8EAAA,iDAAA,WAAmCpP,EAAEA;AAArC,AAAwCnB;;AACxC,AAAAuQ,8EAAA,0DAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,OAACuF,4BAAYnF,OAAOJ;;AAC1E,AAAAwQ,8EAAA,oDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACqR,kDAAmB,AAACpP,yBAAS7B,OAAOJ;;AACxF,AAAAwQ,8EAAA,wDAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,OAACqP,2BAAWjP,OAAOJ;;AACzE,AAAAwQ,8EAAA,wDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,OAACqP,2BAAWjP,OAAOJ;;AACxE,AAAAwQ,8EAAA,4DAAA,WAAuCpP,EAAEA;AAAzC,AAA4CkQ;;AAC5C,AAAAd,8EAAA,0DAAA,WAAuCpP,EAAEA;AAAzC,AAA4CsN;;AAC5C,AAAA8B,8EAAA,0DAAA,WAAsCpP,EAAEA;AAAxC,AAA2C2N;;AAC3C,AAAAyB,8EAAA,8EAAA,WAAiDpQ,OAAOgB;AAAxD,AAA2D,OAACoN,uCAAuBpO;;AACnF,AAAAoQ,8EAAA,6EAAA,WAAgDpQ,OAAOgB;AAAvD,AAA0D,OAACyN,sCAAsBzO;;AACjF,AAAAoQ,8EAAA,sDAAA,WAAoCpP,EAAEA;AAAtC,AAAyCmQ;;AAEzC,AAAAf,8EAAA,iDAAA,WAAkCpQ,OAAOJ;AAAzC,AAAkD,OAACkM,8BAAQ9L,OAAOJ;;AAClE,AAAAwQ,8EAAA,gDAAA,WAAkCpQ,OAAOJ;AAAzC,AAAkD,OAACkM,8BAAQ9L,OAAOJ;;AAClE,AAAAwQ,8EAAA,8DAAA,WAAwCpQ,OAAOJ;AAA/C,AAAwD,OAACyM,8BAAcrM,OAAOJ;;AAC9E,AAAAwQ,8EAAA,AAAA,0DAAA,WAAoCpP,EAAEA;AAAtC,AAAyCsN;;AACzC,AAAA8B,8EAAA,mDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACgL,yBAAS5K,OAAOJ;;AACpE,AAAAwQ,8EAAA,0DAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,IAAAwR,WAAW,AAAChG,+CAAQpL;IAApBqR,WAA4BzR;AAA5B,AAAA,0HAAAwR,SAAAC,gDAAAD,SAAAC,pLAAC/Q,0DAAAA,6EAAAA;;AACvD,AAAA8P,8EAAA,6EAAA,WAAyCpQ,OAAOJ;AAAhD,AAAyD,IAAA0R,WAAW,AAAClG,+CAAQpL;IAApBuR,WAA4B3R;AAA5B,AAAA,0HAAA0R,SAAAC,gDAAAD,SAAAC,pLAACjR,0DAAAA,6EAAAA;;AAE1D,AAAA8P,8EAAA,wDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,IAAA4R,WAAW,AAACpG,+CAAQpL;IAApByR,WAA4B7R;AAA5B,AAAA,0HAAA4R,SAAAC,gDAAAD,SAAAC,pLAACnR,0DAAAA,6EAAAA;;AACtD,AAAA8P,8EAAA,uDAAA,WAAqCpQ,OAAOJ;AAA5C,AAAqD,IAAA8R,WAAW,AAACtG,+CAAQpL;IAApB2R,WAA4B/R;AAA5B,AAAA,0HAAA8R,SAAAC,gDAAAD,SAAAC,pLAACrR,0DAAAA,6EAAAA;;AACtD,AAAA8P,8EAAA,mEAAA,WAA2CpQ,OAAOJ;AAAlD,AAA2D,IAAAgS,WAAW,AAACxG,+CAAQpL;IAApB6R,WAA4BjS;AAA5B,AAAA,0HAAAgS,SAAAC,gDAAAD,SAAAC,pLAACvR,0DAAAA,6EAAAA;;AAE5D,AAAA8P,8EAAA,oDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACkN,yBAAS9M,OAAOJ;;AACpE,AAAAwQ,8EAAA,oDAAA,WAAoCpQ,OAAOJ;AAA3C,AAAoD,OAACkN,yBAAS9M,OAAOJ;;AACrE,AAAAwQ,8EAAA,iDAAA,WAAmCpQ,OAAOJ;AAA1C,AAAmD,OAACoN,yBAAShN,OAAOJ;;AACpE,AAAAwQ,8EAAA,qDAAA,WAAoCpQ,OAAOJ;AAA3C,AAAoD,OAACoN,yBAAShN,OAAOJ;;AAErE,AAAAwQ,8EAAA,gDAAA,WAAiCpQ,OAAOJ;AAAxC,AAAiD,OAACsN,6BAAOlN,OAAOJ;;AAChE,AAAAwQ,8EAAA,gDAAA,WAAiCpQ,OAAOJ;AAAxC,AAAiD,OAACwN,4BAAOpN,OAAOJ;;AAChE,AAAAwQ,8EAAA,+CAAA,WAAiCpQ,OAAOJ;AAAxC,AAAiD,OAAC0N,4BAAOtN,OAAOJ;;AAChE,AAAAwQ,8EAAA,wDAAA,WAAsCpQ,OAAOJ;AAA7C,AAAsD,OAAC6N,4BAAYzN,OAAOJ;;AAM1E,sCAAA,tCAAOkS,oFAAqB3C;AAA5B,AACE,GAAM,gCAAA,hCAAC4C,0BAAU5C;AAAjB,AACE,OAACrP,sCAAW,AAAA,6FAAaqP;;AAD3B;;;AAGF,wCAAA,xCAAO6C,wFAAuB7C;AAA9B,AACE,IAAA8C,WAAQ,AAAA,+FAAe9C;AAAvB,AAAA,GAAA,CAAA8C,YAAA;AAAA;;AAAA,oCAAAA,7BAA8BnD;;;AAEhC,AAAA,AAAA,CAAApP,0BAAA,OAAA;;AAAA,CAAAJ,2BAAA,OAEE,WAAaU,OAAOJ;AAApB,AACE,OAACwQ,gEAAkBpQ,OAAO,sDAAA,tDAACmB,8CAAMvB,qIAAoCI;;AAEzE,mCAAA,nCAAOkS,8EACJ/C,MAAMnP,OAAOJ;AADhB,AAEE,IAAAyC,mBAAI,AAAA,qFAAU8M;AAAd,AAAA,oBAAA9M;AAAAA;;AACI,oBAAU,AAAA,+FAAe8M;AAAzB;;AAAA,AACE,OAAC7P,2BAAWU,OAAOJ;;;;AAE3B,sCAAA,tCAAOuS,oFAAqBhD,MAAMvP;AAAlC,AACE,IAAAwS,WAAQ,AAAA,6FAAajD;AAArB,AAAA,GAAA,CAAAiD,YAAA;AAAA;;AAA4B,0HAAAA,wDAAAA,1KAAC9R,0DAAAA,4EAAAA,XAAUV,wDAAAA;;;AAEzC,oCAAA,pCAAOyS,gFAAmBzP,IAAIuM,MAAMnP,OAAOJ;AAA3C,AACE,IAAA0S,qBAAiB,AAAA,yFAAWnD;AAA5B,AAAA,GAAA,CAAAmD,sBAAA;AAAA;;AAAA,WAAAA,PAAYC;AAAZ,AACE,OAAC1P,mCAAS,AAAC2P,8CAAOD,KAAK,iBAAAlQ,mBAAIzC;AAAJ,AAAA,oBAAAyC;AAAAA;;AAAY,OAACwG,iDAAU7I;;MACpC4C;;;AAEd,0BAAA,1BAAO6P,4DAASzS,OAAOJ;AAAvB,AACE,IAAMuP,QAAM,AAACuD,uBAAO,AAACC,yDAAkB3S,QACnB,AAACmC,oDAAanC;IAC5B4C,MAAI,iBAAAP,mBAAI,AAACyP,oCAAoB3C;AAAzB,AAAA,oBAAA9M;AAAAA;;AAAA,IAAAA,uBACI,AAAC2P,sCAAsB7C;AAD3B,AAAA,oBAAA9M;AAAAA;;AAAA,IAAAA,uBAEI,AAAC8P,oCAAoBhD,MAAMvP;AAF/B,AAAA,oBAAAyC;AAAAA;;AAAA,IAAAA,uBAGI,AAAC6P,iCAAiB/C,MAAMnP,OAAOJ;AAHnC,AAAA,oBAAAyC;AAAAA;;AAII,4DAAA,iGAAA,2CAAA,iEAAA,lQAACpB,0PAAkCrB,kEACDI;;;;;;AAPhD,AAQE,IAAAqC,mBAAI,AAACgQ,kCAAkBzP,IAAIuM,MAAMnP,OAAOJ;AAAxC,AAAA,oBAAAyC;AAAAA;;AACIO;;;AAMR,AAAA,4BAAA,oCAAA0C,hEAAMhF;AAAN,AAAA,IAAAsS,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAtS,wDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAmF,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAMnF,qEACFuS;AADJ,AAEG,6EAAA,tEAACC,wDAAUD;;;AAFd,CAAA,0DAAA,1DAAMvS,qEAGFuS,cAAQjT;AAHZ,AAIG,oBAAI,AAAA,oHAAWA;AAEb,OAAC6S,wBAAQ,AAACM,gDAASF,cAAQjT,SAASA;;AACpC,iGAAA,+DAAA,WAAAoT,pKAACC,mBAAU,AAACF,gDAASF,cAAQjT;AAA7B,AAAkD,+BAAAoT,xBAACP,yCAAU7S;;;;;AAPlE,CAAA,oDAAA,pDAAMU;;AAAN,AASA,AAAA,2BAAA,mCAAAgF,9DAAM8G;AAAN,AAAA,IAAA8G,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAA9G,uDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,uDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA3G,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,yDAAA,zDAAM2G,oEACFiH;AADJ,AAEG,mFAAA,5EAACC,uDAASD;;;AAFb,CAAA,yDAAA,gCAAAF,zFAAM/G,oEAGFiH;AAHJ,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAA3S,4BAAA2S;cAAAA,VAGwDxT;WAHxD,AAAAc,4CAAA0S,eAAA,lEAG2BzR;WAH3B,AAAAjB,4CAAA0S,eAAA,qDAAA,vHAGgCG;AAHhC,AAIG,IAAM3Q,MAAI,EAAI,AAAC4Q,+CAAeH,uBAAgBA,qBAAe,AAACP,wDAAUO,qBAAezT;AAAvF,AACE,OAAC6T,kCAAU,AAACC,uCAAa9Q,IAAI,AAAClB,wBAAQC,MAAM4R;;;AALjD,CAAA,mDAAA,nDAAMnH;;AAAN,AAOA,AAAA,yBAAA,iCAAA9G,1DAAMsO;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,qDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,qDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAnO,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,uDAAA,vDAAMmO,kEACFP;AADJ,AAEG,iFAAA,1EAACU,qDAAOV;;;AAFX,CAAA,uDAAA,gCAAAQ,vFAAMD,kEAGFP;AAHJ,AAAA,IAAAS,aAAAD;IAAAC,iBAAA,AAAArT,4BAAAqT;cAAAA,VAGwDlU;WAHxD,AAAAc,4CAAAoT,eAAA,lEAG2BnS;WAH3B,AAAAjB,4CAAAoT,eAAA,qDAAA,vHAGgCP;AAHhC,AAIG,IAAM3Q,MAAI,EAAI,AAAC4Q,+CAAeH,uBAAgBA,qBAAe,AAACP,wDAAUO,qBAAezT;AAAvF,yDAEO,4CAAA,WAAAqU,iBAAAC,xEAAC/M,zDAED,OAACiN,6CAAKb;AAFN,AAAM,OAACE,kCAAU,2CAAAQ,iBAAAC,5DAACR,uCAAa9Q;mFAD/B,AAACoR,kDAAwBT,lIAEpB,AAACY,iDAAuB,AAACzS,wBAAQC;;;AAPhD,CAAA,iDAAA,jDAAMiS;;AAAN,AAcA,AAAA,mCAAA,2CAAAtO,9EAAMgP;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,+DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,+DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA7O,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,iEAAA,jEAAM6O,4EACFzB;AADJ,AACa,oFAAA,7EAAC4B,+DAAiB5B;;;AAD/B,CAAA,iEAAA,yBAAA0B,1FAAMD,4EAEFzB;AAFJ,AAAA,IAAA2B,aAAAD;IAAAC,iBAAA,AAAA/T,4BAAA+T;cAAAA,VAE8D5U;yBAF9D,AAAAc,4CAAA8T,eAAA,mGAAA,nLAEqBE;AAFrB,AAGG,IAAM1U,SAAO,AAAC+S,gDAASF,cAAQjT;IACzB+U,OAAK,WAAKhS;AAAL,AAAQ,IAAA,AAAA,+KAAA,rFAAM,CAACA,kCAAAA,oCAAAA;gBAAP,GAAA,CAAAiS,kBAAgDnP;AAAhD,QAAAmP,JAA0DnM;AAA1D,AAAA,4FAAA,FAA6DA;;AAA7D,AAAA,MAAAmM;;;;IACbC,QAAM,WAAK7U;AAAL,AACE,IAAA8U,aAAmC,AAAC5I,0BAAiBlM;IAArD8U,iBAAA,AAAArU,4BAAAqU;YAAA,AAAApU,4CAAAoU,eAAA,nEAAcC;aAAd,AAAArU,4CAAAoU,eAAA,pEAAoBE;YAApB,AAAAtU,4CAAAoU,eAAA,nEAA2BG;IACrBC,kBAAgB,AAACpC,wDAAUiC,MAAMnV;IACjCuV,sBAAc,AAAC/O,mDAAY4O,OAAOpV;IAClCwV,qBAAa,kBAAIH,OAAM,AAAC7O,mDAAY6O,MAAMrV,SAAS,qBAAA,rBAACyV;IACpDC,WAAS,WAAK3S,EAAE4S;AAAP,AAAa,QAAM,AAACvS,8CAAML,EAAE4S,pDAAMC;AAArB,AAAuB,IAAApT,oBAAK,CAAC+S,oDAAAA,uDAAAA,LAAcK,mCAAAA;AAApB,AAAA,oBAAApT;AAAuB,IAAAqT,WAAA,mFAAeF,KAAKC;AAApB,AAAA,4GAAAC,yCAAAA,7IAACL,mDAAAA,6DAAAA;;AAAxBhT;;;AAJnD,AAKE,kBAAKO;AAAL,AACE,IAAA+S,+DAAmC,4CAAA,2GAAA,WAAAG,lKAACC,+HAAeZ,jLAChB,AAACa,+BAAkBrB;AADnB,AAAkC,kBAAAmB,XAACP,SAAS3S;;IAA/E+S,iBAAA,AAAAjV,4BAAAiV;aAAA,AAAAhV,4CAAAgV,eAAA,pEAAcC;aAAd,AAAAjV,4CAAAgV,eAAA,pEAAqBE;IAEfI,WAAS,gBAAA,AAAA,2FAAIJ,3GAAiB3V;AAFpC,AAGE,GAAU,AAAO0V;AAAjB;;AAAA,AACE,IAAMO,gBAAc,AAACC,iDAAUpB,MAAMiB;IAArCC,aACuB,iCAAA,KAAA,pBAAUC,oBAAc,AAACvB,KAAK;AAAA,AAAO,OAAC3R,8CAAML,EAAEqT;;iBADrE,AAAArP,4CAAAsP,WAAA,IAAA,xEACON;cADP,AAAAhP,4CAAAsP,WAAA,IAAA,rEACcG;IACRC,iBAAe,kBAAM,iBAAAjU,oBAAKgU;AAAL,AAAA,oBAAAhU;AAAa,OAACqK,cAAIyJ;;AAAlB9T;;MAAN,oEAAA,pEAAwC,AAAC+T,iDAAUnB,OAAOW;IACzEW,gBAAc,kBAAM,iBAAAlU,oBAAKgU;AAAL,AAAA,oBAAAhU;AAAA,IAAAA,wBAAa6S;AAAb,AAAA,oBAAA7S;AAAmB,OAACqK,cAAI4J;;AAAxBjU;;;AAAAA;;MAAN,uKAAA,vKAA+C,uDAAA,vDAAC+T,iDAAUlB,yFAAOe,SAASL;AAH9F,AAIE,IAAAY,WAAQ,qDAAA,rDAACpV,8CAAMyU,mFAAkBD;IAAjCY,eAAA,iMAAAA,/KACEL,eAAc,8CAAAK,SAAA,vDAACpV,iJAAwB+U;IADzCK,eAAA,yMAAAA,vLAEEF,gBAAe,8CAAAE,aAAA,3DAACpV,uJAAyBkV;IAF3CE,eAAA,sMAAAA,pLAGED,eAAc,8CAAAC,aAAA,3DAACpV,sJAAwBmV;AAHzC,AAAA,oBAIE,AAACE,qBAAWb;sDAAY,+CAAAY,aAAA,5DAACzS,qHAAe0S,3KAAY,iMAAA,1LAACC;;AAJvDF;;;;;AAjBxB,AAsBE,oBAAI,AAACrK,0BAAiBlM;AACpB,OAAC6U,MAAM7U;;AACP,oBAAI,AAAC0W,mCAAoB1W;AACvB,IAAM2W,WAAS,4CAAA,WAAAC,vDAACzP;AAAD,AAAM,sEAAAyP,/DAACnC,gFAAmB7U;GAAS,AAACiX,oCAA2B7W;AAA9E,AACE,kBAAK8W;AAAL,qBAAsB,6CAAA,WAAAC,xDAACtQ,rBAAa,OAACuQ;AAAf,AAAO,QAAAD,iDAAAA,oDAAAA,LAAGD,gCAAAA;GAAnBH;;;AACf,4DAAA,yHAAA,2CAAA,zNAAC1V,8QAA0C,AAACgW,iBAAQjX;;;;;AA9B7D,CAAA,2DAAA,3DAAMsU;;AAAN,AAgCA,AAAA,wBAAA,gCAAAhP,xDAAM6R;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA1R,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sDAAA,tDAAM0R,iEACFtE,cAAQlQ;AADZ,AACe,2EAAA,pEAACyU,oDAAMvE,cAAQlQ;;;AAD9B,CAAA,sDAAA,tDAAMwU,iEAEFtE,cAAQlQ,EAAE/C;AAFd,AAGG,IAAMI,SAAO,AAAC+S,gDAASF,cAAQjT;AAA/B,AACE,OAACuW,iDAAU,kCAAA,WAAAkB,7CAACC,2BAAkBtX;AAAnB,AAA2B,qDAAAqX,iBAAA,/DAAClW,+JAA6BmT;IAAmB3R;;;AAJ5F,CAAA,gDAAA,hDAAMwU;;AAAN","names":["malli$generator$Generator$_generator$dyn","x__5373__auto__","m__5374__auto__","malli.generator/-generator","goog/typeOf","m__5372__auto__","cljs.core/missing-protocol","malli.generator/Generator","this","options","malli.generator/nil-gen","clojure.test.check.generators/return","malli.generator/-child","schema","cljs.core/first","malli.core.children","malli.generator/-child-gen","G__41869","G__41870","malli.generator/generator","p__41871","map__41872","cljs.core/--destructure-map","cljs.core.get","malli.generator/-never-gen","original-generator-schema","_options","cljs.core/with-meta","clojure.test.check.generators/sized","_","malli.core._fail_BANG_","G__41873","cljs.core.assoc","malli.generator/-unreachable-gen?","g","cljs.core/meta","cljs.core/boolean","malli.generator/-not-unreachable","malli.generator/-unreachable","malli.generator/-random","seed","clojure.test.check.random.make_random","malli.generator/-min-max","map__41875","min","max","gen-min","gen-max","malli.core.properties","and__5023__auto__","or__5025__auto__","malli.generator/inf-nan","map__41888","infinite?","NaN?","malli.generator/gen-fmap","f","gen","clojure.test.check.generators/fmap","malli.generator/gen-fcat","p1__41890#","cljs.core.apply","cljs.core/concat","malli.generator/gen-tuple","gens","cljs.core/some","clojure.test.check.generators/tuple","malli.generator/gen-maybe","clojure.test.check.generators/one-of","malli.generator/double-default","malli.generator/gen-double","opts","clojure.test.check.generators/double*","cljs.core.into","p1__41895#","cljs.core.update","G__41898","p1__41897#","G__41899","p__41901","map__41902","malli.generator/gen-vector","cljs.core._EQ_","clojure.test.check.generators.vector","cljs.core.vary_meta","p1__41900#","cljs.core/assoc","p__41904","map__41905","malli.generator/gen-vector-distinct-by","m","clojure.test.check.generators.vector_distinct_by","p1__41903#","cljs.core/max","clojure.set/rename-keys","malli.core/-exception","malli.generator/-string-gen","clojure.string/join","clojure.test.check.generators/char-alphanumeric","var_args","G__41909","malli.generator/-coll-gen","js/Error","malli.generator._coll_gen","cljs.core/identity","malli.generator/gen-vector-distinct","malli.generator/-coll-distinct-gen","p1__41912#","malli.generator/->such-that-opts","malli.generator/gen-such-that","pred","clojure.test.check.generators.such_that","malli.generator/-and-gen","malli.core.validator","malli.generator/gen-one-of","gs","temp__5827__auto__","cljs.core/not-empty","cljs.core.keep","cljs.core/count","cljs.core.nth","malli.generator/-seqable-gen","map__41919","el","G__41922","cljs.core.conj","p1__41918#","p1__41917#","cljs.core.map","cljs.core/vec","cljs.core/eduction","cljs.core.into_array","cljs.core/set","G__41920","malli.core.type","vec__41925","k","v","G__41928","G__41929","malli.generator/-or-gen","p1__41930#","malli.generator/-merge-keyword-dispatch-map-into-entries","dispatch","G__41932","cljs.core/Keyword","p1__41931#","malli.util.transform_entries","p__41933","vec__41934","e","G__41937","cljs.core.not_EQ_","malli.util/merge","malli.core.options","malli.generator/-multi-gen","p1__41941#","G__41942","G__41943","cljs.core/last","malli.core.entries","malli.generator/-build-map","kvs","cljs.core/persistent!","cljs.core.reduce","p__41944","vec__41945","acc","cljs.core/map?","cljs.core/reduce-kv","cljs.core/assoc!","cljs.core.assoc_BANG_","cljs.core/transient","p__41949","vec__41950","malli.generator/-entry-gen","s","G__41954","p1__41948#","malli.generator/-map-gen","p1__41956#","malli.generator/-map-of-gen","p1__41959#","p1__41960#","p1__41961#","malli.generator/-ref-gen","ref-id","malli.core/-identify-ref-schema","cljs.core/force","cljs.core.get_in","scalar-ref-gen","cljs.core/Delay","dschema","malli.core.deref","G__41965","G__41966","G__41967","cljs.core/assoc-in","cljs.core/realized?","p1__41962#","clojure.test.check.generators/recursive-gen","G__41968","G__41969","malli.generator/-=>-gen","output-generator","G__41972","G__41973","malli.core/-function-info","malli.core._instrument","malli.generator/generate","malli.generator/-function-gen","p1__41974#","malli.generator/-regex-generator","G__41975","cljs.core/not","malli.core/-regex-op?","cljs.core/PersistentVector","malli.generator/-re-entry-gen","cljs.core/vector?","malli.generator/-cat-gen","p1__41978#","malli.generator/-alt-gen","p1__41979#","malli.generator/-?-gen","child","malli.generator/-*-gen","G__41982","malli.generator/-+-gen","G__41983","cljs.core.fnil","malli.generator/-repeat-gen","G__41986","G__41987","malli.generator/-qualified-ident-gen","mk-value-with-ns","value-with-ns-gen-size","temp__5823__auto__","namespace-unparsed","G__41990","G__41991","cljs.core/name","malli.generator/-qualified-keyword-gen","cljs.core/keyword","clojure.test.check.generators/keyword","cljs.core/qualified-keyword?","clojure.test.check.generators/keyword-ns","malli.generator/-qualified-symbol-gen","cljs.core/symbol","clojure.test.check.generators/symbol","cljs.core/qualified-symbol?","clojure.test.check.generators/symbol-ns","malli.generator/gen-elements","es","clojure.test.check.generators/elements","malli.generator/double-gen","cljs.core.merge","props","p1__41994#","G__41996","p1__41995#","G__41997","js/malli","js/malli.generator","js/malli.generator.-schema-generator","method-table__5622__auto__","cljs.core.atom","prefer-table__5623__auto__","method-cache__5624__auto__","cached-hierarchy__5625__auto__","hierarchy__5626__auto__","fexpr__41998","cljs.core/MultiFn","cljs.core.symbol","malli.generator/-schema-generator","cljs.spec.gen.alpha/gen-for-pred","cljs.core/empty?","p1__42004#","clojure.test.check.generators/any-printable","cljs.core/inc","clojure.test.check.generators/nat","cljs.core.comp","cljs.core/dec","cljs.core/-","cljs.core/any?","malli.core.into_schema","p1__42019#","clojure.test.check.generators/large-integer*","clojure.test.check.generators/boolean","clojure.test.check.generators/uuid","G__42028","G__42029","G__42030","G__42031","G__42035","G__42036","G__42037","G__42038","G__42039","G__42040","malli.generator/-create-from-return","cljs.core/contains?","malli.generator/-create-from-elements","G__42044","malli.generator/-create-from-gen","malli.generator/-create-from-schema","G__42051","malli.generator/-create-from-fmap","temp__5829__auto__","fmap","malli.core.eval","malli.generator/-create","malli.impl.util/-merge","malli.core.type_properties","G__42066","?schema","malli.generator.generator","malli.core.schema","p1__42061#","malli.core/-cached","G__42074","p__42075","map__42076","?gen-or-schema","malli.generator.generate","size","clojure.test.check.generators/generator?","clojure.test.check.rose-tree/root","clojure.test.check.generators/call-gen","G__42083","malli.generator/sample","p__42084","map__42085","malli.generator.sample","clojure.test.check.generators/make-size-range-seq","p1__42080#","p2__42081#","clojure.test.check.generators/lazy-random-states","cljs.core.take","G__42090","malli.generator/function-checker","p__42091","map__42092","malli.generator.function_checker","=>iterations","-try","e42093","check","map__42094","input","output","guard","input-generator","valid-output?","valid-guard?","cljs.core/constantly","validate","args","$","G__42095","map__42097","result","shrunk","p1__42086#","clojure.test.check.properties/for-all*","clojure.test.check/quick-check","smallest","vec__42098","explain-input","malli.core.explain","success","explain-output","explain-guard","G__42101","cljs.core/ex-message","cljs.core.dissoc","malli.core/-function-schema?","checkers","p1__42087#","malli.core/-function-schema-arities","x","p1__42088#","cljs.core/seq","malli.core/-type","G__42105","malli.generator/check","malli.generator.check","p1__42102#","malli.core/-update-options"],"sourcesContent":[";; See also `malli.generator-ast` for viewing generators as data\n(ns malli.generator\n  (:require [clojure.set :as set]\n            [clojure.spec.gen.alpha :as ga]\n            [clojure.string :as str]\n            [clojure.test.check :as check]\n            [clojure.test.check.generators :as gen]\n            [clojure.test.check.properties :as prop]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            [malli.core :as m]\n            [malli.registry :as mr]\n            [malli.util :as mu]\n            [malli.impl.util :refer [-last -merge]]\n            #?(:clj [borkdude.dynaload :as dynaload])))\n\n(declare generator generate -create gen-one-of gen-double)\n\n(defprotocol Generator\n  (-generator [this options] \"returns generator for schema\"))\n\n;;\n;; generators\n;;\n\n\n;; # Notes for implementors\n;;\n;; For the most part, -schema-generator is a pretty direct translation from schemas to generators.\n;; However, the naive implementation of recursive ref's (creating a generator for the dereferenced ref\n;; and cutting off the generation at a certain depth) tends to create exponentially large test cases.\n;;\n;; We use a more sophisticated algorithm to achieve linearly sized test cases with recursive refs.\n;; The next section describes the strategy implementors should use to participate in this improved behavior.\n;; The theory behind this strategy is described in the section below (\"Approach for recursive generators\").\n;;\n;; ## Implementation strategy\n;;\n;; Say you have a composite schema you want to generate values for. You should extend `-schema-generator` and\n;; call `generator` recursively on the `m/children`. Now, for every child generator, you need to consider the case\n;; that the child generator generates no values, and how this might change the final generator.\n;;\n;; Use `-unreachable-gen?` to test whether your child generator generates no values (we'll call this an \"unreachable\" schema/generator).\n;; If your parent generator cannot generate values, use `-never-gen` to return an unreachable generator.\n;;\n;; Here are a few examples---compare them with the logic in their respective -schema-generator methods:\n;;   [:maybe M] would generate like :nil if M were unreachable.\n;;   [:map [:a M]] would itself be unreachable if M were unreachable.\n;;   [:map [:a {:optional true} M]] would generate like [:map] if M were unreachable.\n;;   [:vector M] would generate like [:= []] if M were unreachable.\n;;   [:vector {:min 1} M] would itself be unreachable if M were unreachable.\n\n(def nil-gen (gen/return nil))\n\n(defn- -child [schema options] (first (m/children schema options)))\n(defn- -child-gen [schema options] (generator (-child schema options) options))\n\n(defn -never-gen\n  \"Return a generator of no values that is compatible with -unreachable-gen?.\"\n  [{::keys [original-generator-schema] :as _options}]\n  (with-meta (gen/sized (fn [_]\n                          (m/-fail! ::unsatisfiable-schema\n                                    (cond-> {}\n                                      original-generator-schema (assoc :schema original-generator-schema)))))\n             {::never-gen true\n              ::original-generator-schema original-generator-schema}))\n\n(defn -unreachable-gen?\n  \"Returns true iff generator g generators no values.\"\n  [g] (-> (meta g) ::never-gen boolean))\n\n(defn -not-unreachable [g] (when-not (-unreachable-gen? g) g))\n(defn -unreachable [g] (when (-unreachable-gen? g) g))\n\n(defn- -random [seed] (if seed (random/make-random seed) (random/make-random)))\n\n(defn -min-max [schema options]\n  (let [{:keys [min max] gen-min :gen/min gen-max :gen/max} (m/properties schema options)]\n    (when (and min gen-min (< gen-min min))\n      (m/-fail! ::invalid-property {:key :gen/min, :value gen-min, :min min}))\n    (when (and max gen-max (> gen-max max))\n      (m/-fail! ::invalid-property {:key :gen/max, :value gen-min, :max min}))\n    {:min (or gen-min min)\n     :max (or gen-max max)}))\n\n(defn- inf-nan [schema options]\n  (let [{:gen/keys [infinite? NaN?]} (m/properties schema)]\n    {:infinite? infinite? :NaN? NaN?}))\n\n(defn- gen-fmap [f gen] (or (-unreachable gen) (gen/fmap f gen)))\n(defn- gen-fcat [gen] (gen-fmap #(apply concat %) gen))\n(defn- gen-tuple [gens] (or (some -unreachable gens) (apply gen/tuple gens)))\n(defn- gen-maybe [g] (if (-unreachable-gen? g) nil-gen (gen/one-of [nil-gen g])))\n(def ^:private double-default {:infinite? false, :NaN? false})\n(defn- gen-double [opts] (gen/double* (-> (into double-default opts) (update :min #(some-> % double)) (update :max #(some-> % double)))))\n\n(defn- gen-vector [{:keys [min max]} g]\n  (cond\n    (-unreachable-gen? g) (if (zero? (or min 0)) (gen/return []) g)\n    (and min (= min max)) (gen/vector g min)\n    (and min max) (gen/vector g min max)\n    min (vary-meta (gen/sized #(gen/vector g min (+ min %))) assoc ::generator-ast {:op :vector-min :generator g :min min})\n    max (gen/vector g 0 max)\n    :else (gen/vector g)))\n\n(defn- gen-vector-distinct-by [schema {:keys [min] :as m} f g]\n  (if (-unreachable-gen? g)\n    (if (= 0 (or min 0)) (gen/return []) g)\n    (gen/vector-distinct-by f g (into (if (and min (= min max))\n                                        {:num-elements min}\n                                        (set/rename-keys m {:min :min-elements :max :max-elements}))\n                                      {:max-tries 100\n                                       :ex-fn #(m/-exception ::distinct-generator-failure (assoc % :schema schema))}))))\n\n(defn- -string-gen [schema options]\n  (gen-fmap str/join (gen-vector (-min-max schema options) gen/char-alphanumeric)))\n\n(defn- -coll-gen\n  ([schema options] (-coll-gen schema identity options))\n  ([schema f options] (gen-fmap f (gen-vector (-min-max schema options) (-child-gen schema options)))))\n\n(defn- gen-vector-distinct [schema m g] (gen-vector-distinct-by schema m identity g))\n\n(defn- -coll-distinct-gen [schema f options]\n  (gen-fmap f (gen-vector-distinct schema (-min-max schema options) (-child-gen schema options))))\n\n(defn- ->such-that-opts [schema] {:max-tries 100 :ex-fn #(m/-exception ::such-that-failure (assoc % :schema schema))})\n(defn- gen-such-that [schema pred gen] (or (-unreachable gen) (gen/such-that pred gen (->such-that-opts schema))))\n\n(defn -and-gen [schema options]\n  (gen-such-that schema (m/validator schema options) (-child-gen schema options)))\n\n(defn- gen-one-of [options gs]\n  (if-some [gs (not-empty (into [] (keep -not-unreachable) gs))]\n    (if (= 1 (count gs)) (nth gs 0) (gen/one-of gs))\n    (-never-gen options)))\n\n(defn- -seqable-gen [schema options]\n  (let [{:keys [min]} (-min-max schema options)\n        el (-child schema options)]\n    (gen-one-of\n     options\n     (-> []\n         (cond->\n           (or (nil? min) (zero? min))\n           (conj nil-gen))\n         (into (map #(-coll-gen schema % options))\n               [identity vec eduction #(into-array #?(:clj Object) %)])\n         (conj (-coll-distinct-gen schema set options))\n         (cond->\n           (and (= :tuple (m/type el))\n                (= 2 (count (m/children el))))\n           (conj (let [[k v] (m/children el)]\n                   (generator [:map-of (or (m/properties schema) {}) k v] options))))))))\n\n(defn -or-gen [schema options]\n  (gen-one-of options (map #(generator % options) (m/children schema options))))\n\n(defn- -merge-keyword-dispatch-map-into-entries [schema]\n  (let [dispatch (-> schema m/properties :dispatch)]\n    (cond-> schema\n      (keyword? dispatch)\n      (mu/transform-entries\n       #(map (fn [[k :as e]]\n               (cond-> e\n                 (not= ::m/default k)\n                 (update 2 mu/merge [:map [dispatch [:= nil k]]]))) %)\n       (m/options schema)))))\n\n(defn -multi-gen [schema options]\n  (gen-one-of options (map #(generator (last %) options) (m/entries (-merge-keyword-dispatch-map-into-entries schema) options))))\n\n(defn- -build-map [kvs]\n  (persistent!\n   (reduce\n    (fn [acc [k v]]\n      (cond (and (= k ::m/default) (map? v)) (reduce-kv assoc! acc v)\n            (nil? k) acc\n            :else (assoc! acc k v)))\n    (transient {}) kvs)))\n\n(defn- -entry-gen [[k s] options]\n  (cond->> (gen-fmap #(do [k %]) (generator s options)) (-> s m/properties :optional) gen-maybe))\n\n(defn -map-gen [schema options]\n  (->> schema m/entries (map #(-entry-gen % options)) gen-tuple (gen-fmap -build-map)))\n\n(defn -map-of-gen [schema options]\n  (->> (gen-tuple (map #(generator % options) (m/children schema options)))\n       (gen-vector-distinct-by schema (-min-max schema options) #(nth % 0))\n       (gen-fmap #(into {} %))))\n\n#?(:clj\n   (defn -re-gen [schema options]\n     ;; [com.gfredericks/test.chuck \"0.2.10\"+]\n     (if-let [string-from-regex @(dynaload/dynaload 'com.gfredericks.test.chuck.generators/string-from-regex {:default nil})]\n       (let [re (or (first (m/children schema options)) (m/form schema options))]\n         (string-from-regex (re-pattern (str/replace (str re) #\"^\\^?(.*?)(\\$?)$\" \"$1\"))))\n       (m/-fail! :test-chuck-not-available))))\n\n;; # Approach for recursive generators\n;;\n;; `-ref-gen` is the only place where recursive generators can be created, and we use `gen/recursive-gen`\n;; to handle the recursion. The challenge is that gen/recursive-gen requires _two_ arguments: the base\n;; case (scalar gen) and the recursive case (container gen). We need to automatically split the schema argument into\n;; these two cases.\n;;\n;; The main insight we use is that a base case for the schema cannot contain recursive references to itself.\n;; A particularly useful base case is simply to \"delete\" all recursive references. To simulate this, we have the concept of\n;; an \"unreachable\" generator, which represents a \"deleted\" recursive reference.\n;;\n;; For infinitely expanding schemas, this will return an unreachable generator--when the base case generator is used,\n;; the error message in `-never-gen` will advise users that their schema is infinite.\n;;\n;;\n;; Examples of base cases of some recursive schemas:\n;;\n;; Schema:    [:schema {:registry {::cons [:maybe [:vector [:tuple pos-int? [:ref ::cons]]]]}} ::cons]\n;; Base case: [:schema {:registry {::cons [:nil                                            ]}} ::cons]\n;;\n;; Schema:    [:schema\n;;             {:registry {::ping [:tuple [:= \"ping\"] [:maybe [:ref ::pong]]]\n;;                         ::pong [:tuple [:= \"pong\"] [:maybe [:ref ::ping]]]}}\n;;             ::ping]\n;; Base case: [:schema\n;;             {:registry {::ping [:tuple [:= \"ping\"] [:maybe [:ref ::pong]]]\n;;                         ::pong [:tuple [:= \"pong\"] :nil                  ]}}\n;;             ::ping]\n;;\n;; Once we have the base case, we first need determine if the schema is recursive---it's recursive\n;; if more than one recursive reference was successfully \"deleted\" while creating the base case (see below for how we determine recursive references).\n;; We can then construct the recursive case by providing `gen/recursive-gen` the base case\n;; (this is why this particular base case is so useful) and then propagate the (smaller) generator\n;; supplied by `gen/recursive-gen` to convert recursive references.\n\n;; ## Identifying schema recursion\n;;\n;; Refs are uniquely identified by their paired name and scope. If we see a ref with the\n;; same name and scope as another ref we've dereferenced previously, we know that this is a recursion\n;; point back to the previously seen ref. The rest of this section explains why.\n;;\n;; Refs resolve via dynamic scope, which means its dereferenced value is the latest binding found\n;; while expanding the schema until the point of finding the ref.\n;; This makes the (runtime) scope at the ref's location part of a ref's identity---if the scope\n;; is different, then it's (possibly) not the same ref because scope determines how schemas\n;; transitively expand.\n;;\n;; To illustrate why a ref's name is an insufficient identifier, here is a schema that is equivalent to `[:= 42]`:\n;;\n;;   [:schema {:registry {::a [:schema {:registry {::a [:= 42]}}\n;;                             ;; (2)\n;;                             [:ref ::a]]}}\n;;    ;; (1)\n;;    [:ref ::a]]\n;;\n;; If we identify refs just by name, we would have incorrectly detected (2) to be an (infinitely expanding) recursive\n;; reference.\n;;\n;; In studying the previous example, we might think that since (1) and (2) deref to different schemas, it might sufficient to identify refs just by their derefs.\n;; Unfortunately this just pushes the problem elsewhere.\n;;\n;; For example, here is another schema equivalent to `[:= 42]`:\n;;\n;;   [:schema {:registry {::a [:ref ::b] ;; (2)\n;;                        ::b [:schema {:registry {::a [:ref ::b] ;; (4)\n;;                                                 ::b [:= 42]}}\n;;                             ;; (3)\n;;                             [:ref ::a]]}}\n;;    ;; (1)\n;;    [:ref ::a]]\n;;\n;; If we identified ::a by its deref, it would look like (3) deref'ing to (4)\n;; is a recursion point after witnessing (1) deref'ing to (2), since (2) == (4). Except this\n;; is wrong since it's a different ::b at (2) and (4)! OTOH, if we identified (2) and (4) with their\n;; dynamic scopes along with their form, they would be clearly different. Indeed, this\n;; is another way to identify refs: pairing their derefs with their deref's scopes.\n;; It is slightly more direct to use the ref's direct name and scope, which is why\n;; we choose that identifier. The more general insight is that any schema is identified by its form+scope\n;; (note: but only after trimming the scope of irrelevant bindings, see next pararaph).\n;; That insight may be useful for detecting recursion at places other than refs.\n;;\n;; Ref identifiers could be made smarter by trimming irrelevant entries in identifying scope.\n;; Not all scope differences are relevant, so generators may expand more than strictly necessary\n;; in the quest to find the \"same\" ref schema again. It could skip over refs that generate exactly the\n;; same values, but their scopes are uninterestingly different (eg., unused bindings are different).\n;;\n;; For example, the following schema is recursive \"in spirit\" between (1) and (2), but since ::b\n;; changes, the scope will differ, so the recursion will be detected between (2) and itself instead\n;; (where the scope is constant):\n;;\n;;   [:schema {:registry {::a [:schema {:registry {::b :boolean}}\n;;                             ;; (2)\n;;                             [:or [:ref ::a] [:ref ::b]]]}}\n;;    [:schema {:registry {::b :int}}\n;;     ;; (1)\n;;     [:or [:ref ::a] [:ref ::b]]]]\n\n(defn -ref-gen [schema options]\n  (let [ref-id (m/-identify-ref-schema schema)]\n    (or (force (get-in options [::rec-gen ref-id]))\n        (let [scalar-ref-gen (delay (-never-gen options))\n              dschema (m/deref schema)]\n          (cond->> (generator dschema (assoc-in options [::rec-gen ref-id] scalar-ref-gen))\n            (realized? scalar-ref-gen) (gen/recursive-gen\n                                        #(generator dschema (assoc-in options [::rec-gen ref-id] %))))))))\n\n(defn -=>-gen [schema options]\n  (let [output-generator (generator (:output (m/-function-info schema)) options)]\n    (gen/return (m/-instrument {:schema schema} (fn [& _] (generate output-generator options))))))\n\n(defn -function-gen [schema options]\n  (gen/return (m/-instrument {:schema schema, :gen #(generate % options)} nil options)))\n\n(defn -regex-generator [schema options]\n  (cond-> (generator schema options) (not (m/-regex-op? schema)) (-> vector gen-tuple)))\n\n(defn- -re-entry-gen [e options] (-regex-generator (if (vector? e) (get e 2) e) options))\n\n(defn -cat-gen [schema options]\n  (->> (m/children schema options) (map #(-re-entry-gen % options)) gen-tuple gen-fcat))\n\n(defn -alt-gen [schema options]\n  (->> (m/children schema options) (map #(-re-entry-gen % options)) (gen-one-of options)))\n\n(defn -?-gen [schema options]\n  (let [child (-child schema options)]\n    (if-some [g (-not-unreachable (generator child options))]\n      (if (m/-regex-op? child)\n        (gen/one-of [g (gen/return ())])\n        (gen/vector g 0 1))\n      (gen/return ()))))\n\n(defn -*-gen [schema options]\n  (let [child (-child schema options)]\n    (cond->> (gen-vector\n              (-min-max schema options)\n              (generator child options))\n      (m/-regex-op? child) gen-fcat)))\n\n(defn -+-gen [schema options]\n  (let [child (-child schema options)]\n    (cond->> (gen-vector\n              (-> (-min-max schema options)\n                  ;; When generating from :+ the base minimum value must be 1\n                  ;; to ensure that :+ is always fulfilled\n                  (update :min (fnil max 1)))\n              (generator child options))\n      (m/-regex-op? child) gen-fcat)))\n\n(defn -repeat-gen [schema options]\n  (or (some-> (-coll-gen schema options) -not-unreachable (cond-> (m/-regex-op? (-child schema options)) gen-fcat))\n      (gen/return ())))\n\n(defn -qualified-ident-gen [schema mk-value-with-ns value-with-ns-gen-size pred gen]\n  (if-let [namespace-unparsed (:namespace (m/properties schema))]\n    (gen-fmap (fn [k] (mk-value-with-ns (name namespace-unparsed) (name k))) value-with-ns-gen-size)\n    (gen-such-that schema pred gen)))\n\n(defn -qualified-keyword-gen [schema]\n  (-qualified-ident-gen schema keyword gen/keyword qualified-keyword? gen/keyword-ns))\n\n(defn -qualified-symbol-gen [schema]\n  (-qualified-ident-gen schema symbol gen/symbol qualified-symbol? gen/symbol-ns))\n\n(defn- gen-elements [es]\n  (if (= 1 (count es))\n    (gen/return (first es))\n    (gen/elements es)))\n\n(defn- double-gen [schema options]\n  (gen/double* (merge (let [props (m/properties schema options)]\n                        {:infinite? (get props :gen/infinite? false)\n                         :NaN? (get props :gen/NaN? false)})\n                      (-> (-min-max schema options)\n                          (update :min #(some-> % double))\n                          (update :max #(some-> % double))))))\n\n(defmulti -schema-generator (fn [schema options] (m/type schema options)) :default ::default)\n\n(defmethod -schema-generator ::default [schema options] (ga/gen-for-pred (m/validator schema options)))\n\n(defmethod -schema-generator 'empty? [_ _] (ga/gen-for-pred empty?))\n(defmethod -schema-generator :> [schema options] (gen-double {:min (inc (-child schema options))}))\n(defmethod -schema-generator :>= [schema options] (gen-double {:min (-child schema options)}))\n(defmethod -schema-generator :< [schema options] (gen-double {:max (dec (-child schema options))}))\n(defmethod -schema-generator :<= [schema options] (gen-double {:max (-child schema options)}))\n(defmethod -schema-generator := [schema options] (gen/return (-child schema options)))\n(defmethod -schema-generator :not= [schema options] (gen-such-that schema #(not= % (-child schema options)) gen/any-printable))\n(defmethod -schema-generator 'pos? [_ options] (gen/one-of [(gen-double {:min 0.00001}) (gen-fmap inc gen/nat)]))\n(defmethod -schema-generator 'neg? [_ options] (gen/one-of [(gen-double {:max -0.00001}) (gen-fmap (comp dec -) gen/nat)]))\n(defmethod -schema-generator :not [schema options] (gen-such-that schema (m/validator schema options) (ga/gen-for-pred any?)))\n(defmethod -schema-generator :and [schema options] (-and-gen schema options))\n(defmethod -schema-generator :andn [schema options] (-and-gen (m/into-schema :and (m/properties schema) (map last (m/children schema)) (m/options schema)) options))\n(defmethod -schema-generator :or [schema options] (-or-gen schema options))\n(defmethod -schema-generator :orn [schema options] (-or-gen (m/into-schema :or (m/properties schema) (map last (m/children schema)) (m/options schema)) options))\n(defmethod -schema-generator ::m/val [schema options] (-child-gen schema options))\n(defmethod -schema-generator :map [schema options] (-map-gen schema options))\n(defmethod -schema-generator :map-of [schema options] (-map-of-gen schema options))\n(defmethod -schema-generator :multi [schema options] (-multi-gen schema options))\n(defmethod -schema-generator :vector [schema options] (-coll-gen schema options))\n(defmethod -schema-generator :sequential [schema options] (-coll-gen schema options))\n(defmethod -schema-generator :set [schema options] (-coll-distinct-gen schema set options))\n(defmethod -schema-generator :enum [schema options] (gen-elements (m/children schema options)))\n(defmethod -schema-generator :seqable [schema options] (-seqable-gen schema options))\n(defmethod -schema-generator :every [schema options] (-seqable-gen schema options)) ;;infinite seqs?\n(defmethod -schema-generator :maybe [schema options] (gen-maybe (-child-gen schema options)))\n(defmethod -schema-generator :tuple [schema options] (gen-tuple (map #(generator % options) (m/children schema options))))\n#?(:clj (defmethod -schema-generator :re [schema options] (-re-gen schema options)))\n(defmethod -schema-generator :any [_ _] (ga/gen-for-pred any?))\n(defmethod -schema-generator :some [_ _] gen/any-printable)\n(defmethod -schema-generator :nil [_ _] nil-gen)\n(defmethod -schema-generator :string [schema options] (-string-gen schema options))\n(defmethod -schema-generator :int [schema options] (gen/large-integer* (-min-max schema options)))\n(defmethod -schema-generator :double [schema options] (double-gen schema options))\n(defmethod -schema-generator :float [schema options] (double-gen schema options))\n(defmethod -schema-generator :boolean [_ _] gen/boolean)\n(defmethod -schema-generator :keyword [_ _] gen/keyword)\n(defmethod -schema-generator :symbol [_ _] gen/symbol)\n(defmethod -schema-generator :qualified-keyword [schema _] (-qualified-keyword-gen schema))\n(defmethod -schema-generator :qualified-symbol [schema _] (-qualified-symbol-gen schema))\n(defmethod -schema-generator :uuid [_ _] gen/uuid)\n\n(defmethod -schema-generator :=> [schema options] (-=>-gen schema options))\n(defmethod -schema-generator :-> [schema options] (-=>-gen schema options))\n(defmethod -schema-generator :function [schema options] (-function-gen schema options))\n(defmethod -schema-generator 'ifn? [_ _] gen/keyword)\n(defmethod -schema-generator :ref [schema options] (-ref-gen schema options))\n(defmethod -schema-generator :schema [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator ::m/schema [schema options] (generator (m/deref schema) options))\n\n(defmethod -schema-generator :merge [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator :union [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator :select-keys [schema options] (generator (m/deref schema) options))\n\n(defmethod -schema-generator :cat [schema options] (-cat-gen schema options))\n(defmethod -schema-generator :catn [schema options] (-cat-gen schema options))\n(defmethod -schema-generator :alt [schema options] (-alt-gen schema options))\n(defmethod -schema-generator :altn [schema options] (-alt-gen schema options))\n\n(defmethod -schema-generator :? [schema options] (-?-gen schema options))\n(defmethod -schema-generator :* [schema options] (-*-gen schema options))\n(defmethod -schema-generator :+ [schema options] (-+-gen schema options))\n(defmethod -schema-generator :repeat [schema options] (-repeat-gen schema options))\n\n;;\n;; Creating a generator by different means, centralized under [[-create]]\n;;\n\n(defn- -create-from-return [props]\n  (when (contains? props :gen/return)\n    (gen/return (:gen/return props))))\n\n(defn- -create-from-elements [props]\n  (some-> (:gen/elements props) gen-elements))\n\n(extend-protocol Generator\n  #?(:clj Object, :cljs default)\n  (-generator [schema options]\n    (-schema-generator schema (assoc options ::original-generator-schema schema))))\n\n(defn- -create-from-gen\n  [props schema options]\n  (or (:gen/gen props)\n      (when-not (:gen/elements props)\n        (-generator schema options))))\n\n(defn- -create-from-schema [props options]\n  (some-> (:gen/schema props) (generator options)))\n\n(defn- -create-from-fmap [gen props schema options]\n  (when-some [fmap (:gen/fmap props)]\n    (gen/fmap (m/eval fmap (or options (m/options schema)))\n              gen)))\n\n(defn- -create [schema options]\n  (let [props (-merge (m/type-properties schema)\n                      (m/properties schema))\n        gen (or (-create-from-return props)\n                (-create-from-elements props)\n                (-create-from-schema props options)\n                (-create-from-gen props schema options)\n                (m/-fail! ::no-generator {:options options\n                                          :schema schema}))]\n    (or (-create-from-fmap gen props schema options)\n        gen)))\n\n;;\n;; public api\n;;\n\n(defn generator\n  ([?schema]\n   (generator ?schema nil))\n  ([?schema options]\n   (if (::rec-gen options)\n     ;; disable cache while calculating recursive schemas. caches don't distinguish options.\n     (-create (m/schema ?schema options) options)\n     (m/-cached (m/schema ?schema options) :generator #(-create % options)))))\n\n(defn generate\n  ([?gen-or-schema]\n   (generate ?gen-or-schema nil))\n  ([?gen-or-schema {:keys [seed size] :or {size 30} :as options}]\n   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]\n     (rose/root (gen/call-gen gen (-random seed) size)))))\n\n(defn sample\n  ([?gen-or-schema]\n   (sample ?gen-or-schema nil))\n  ([?gen-or-schema {:keys [seed size] :or {size 10} :as options}]\n   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]\n     (->> (gen/make-size-range-seq size)\n          (map #(rose/root (gen/call-gen gen %1 %2))\n               (gen/lazy-random-states (-random seed)))\n          (take size)))))\n\n;;\n;; functions\n;;\n\n(defn function-checker\n  ([?schema] (function-checker ?schema nil))\n  ([?schema {::keys [=>iterations] :or {=>iterations 100} :as options}]\n   (let [schema (m/schema ?schema options)\n         -try (fn [f] (try [(f) true] (catch #?(:clj Exception, :cljs js/Error) e [e false])))\n         check (fn [schema]\n                 (let [{:keys [input output guard]} (m/-function-info schema)\n                       input-generator (generator input options)\n                       valid-output? (m/validator output options)\n                       valid-guard? (if guard (m/validator guard options) (constantly true))\n                       validate (fn [f args] (as-> (apply f args) $ (and (valid-output? $) (valid-guard? [args $]))))]\n                   (fn [f]\n                     (let [{:keys [result shrunk]} (->> (prop/for-all* [input-generator] #(validate f %))\n                                                        (check/quick-check =>iterations))\n                           smallest (-> shrunk :smallest first)]\n                       (when-not (true? result)\n                         (let [explain-input (m/explain input smallest)\n                               [result success] (when-not explain-input (-try (fn [] (apply f smallest))))\n                               explain-output (when (and success (not explain-input)) (m/explain output result))\n                               explain-guard (when (and success guard (not explain-output)) (m/explain guard [smallest result]))]\n                           (cond-> (assoc shrunk ::m/result result)\n                             explain-input (assoc ::m/explain-input explain-input)\n                             explain-output (assoc ::m/explain-output explain-output)\n                             explain-guard (assoc ::m/explain-guard explain-guard)\n                             (ex-message result) (-> (update :result ex-message) (dissoc :result-data)))))))))]\n     (if (m/-function-info schema)\n       (check schema)\n       (if (m/-function-schema? schema)\n         (let [checkers (map #(function-checker % options) (m/-function-schema-arities schema))]\n           (fn [x] (->> checkers (keep #(% x)) (seq))))\n         (m/-fail! ::invalid-function-schema {:type (m/-type schema)}))))))\n\n(defn check\n  ([?schema f] (check ?schema f nil))\n  ([?schema f options]\n   (let [schema (m/schema ?schema options)]\n     (m/explain (m/-update-options schema #(assoc % ::m/function-checker function-checker)) f))))\n"],"x_google_ignoreList":[0]}