shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimapCharRendererFactory = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MinimapCharRendererFactory:{enumerable:!0, get:function() {
    return MinimapCharRendererFactory;
  }}});
  var require$_DOT__SLASH_minimapCharRenderer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimapCharRenderer"), require$_DOT__SLASH_minimapCharSheet_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimapCharSheet"), require$_DOT__SLASH_minimapPreBaked_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimapPreBaked"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uint_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$uint");
  class MinimapCharRendererFactory {
    static create(scale, fontFamily) {
      if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {
        return this.lastCreated;
      }
      scale = require$_DOT__SLASH_minimapPreBaked_DOT_js.prebakedMiniMaps[scale] ? new require$_DOT__SLASH_minimapCharRenderer_DOT_js.MinimapCharRenderer(require$_DOT__SLASH_minimapPreBaked_DOT_js.prebakedMiniMaps[scale](), scale) : MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);
      this.lastFontFamily = fontFamily;
      return this.lastCreated = scale;
    }
    static createSampleData(fontFamily) {
      const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
      canvas.style.height = "16px";
      canvas.height = 16;
      canvas.width = 960;
      canvas.style.width = "960px";
      ctx.fillStyle = "#ffffff";
      ctx.font = `bold ${16}px ${fontFamily}`;
      ctx.textBaseline = "middle";
      fontFamily = 0;
      for (const code of require$_DOT__SLASH_minimapCharSheet_DOT_js.allCharCodes) {
        ctx.fillText(String.fromCharCode(code), fontFamily, 8), fontFamily += 10;
      }
      return ctx.getImageData(0, 0, 960, 16);
    }
    static createFromSampleData(source, scale) {
      if (source.length !== 61440) {
        throw Error("Unexpected source in MinimapCharRenderer");
      }
      source = MinimapCharRendererFactory._downsample(source, scale);
      return new require$_DOT__SLASH_minimapCharRenderer_DOT_js.MinimapCharRenderer(source, scale);
    }
    static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {
      const width = 1 * scale;
      scale *= 2;
      let brightest = 0;
      for (let y = 0; y < scale; y++) {
        const sourceY1 = y / scale * 16, sourceY2 = (y + 1) / scale * 16;
        for (let x = 0; x < width; x++) {
          var sourceX1 = x / width * 10;
          const sourceX2 = (x + 1) / width * 10;
          let value = 0, samples = 0;
          for (let sy = sourceY1; sy < sourceY2; sy++) {
            const sourceRow = sourceOffset + Math.floor(sy) * 3840, yBalance = 1 - (sy - Math.floor(sy));
            for (let sx = sourceX1; sx < sourceX2; sx++) {
              const sourceIndex = sourceRow + Math.floor(sx) * 4, weight = (1 - (sx - Math.floor(sx))) * yBalance;
              samples += weight;
              value += source[sourceIndex] * source[sourceIndex + 3] / 255 * weight;
            }
          }
          sourceX1 = value / samples;
          brightest = Math.max(brightest, sourceX1);
          dest[destOffset++] = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uint_DOT_js.toUint8)(sourceX1);
        }
      }
      return brightest;
    }
    static _downsample(data, scale) {
      const pixelsPerCharacter = 2 * scale * scale, resultLen = pixelsPerCharacter * 96, result = new Uint8ClampedArray(resultLen);
      let resultOffset = 0, sourceOffset = 0, brightest = 0;
      for (let charIndex = 0; charIndex < 96; charIndex++) {
        brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale)), resultOffset += pixelsPerCharacter, sourceOffset += 40;
      }
      if (brightest > 0) {
        for (data = 255 / brightest, scale = 0; scale < resultLen; scale++) {
          result[scale] *= data;
        }
      }
      return result;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$minimap$minimapCharRendererFactory.js.map
