shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$iconLabel$iconLabelHover = function(require, module, exports) {
  function setupNativeHover(htmlElement, tooltip) {
    (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isString)(tooltip) ? htmlElement.title = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iconLabels_DOT_js.stripIcons)(tooltip) : (tooltip === null || tooltip === void 0 ? 0 : tooltip.markdownNotSupportedFallback) ? htmlElement.title = tooltip.markdownNotSupportedFallback : htmlElement.removeAttribute("title");
  }
  function setupCustomHover(hoverDelegate, htmlElement, content, options) {
    let hoverPreparation, hoverWidget;
    const hideHover = (disposeWidget, disposePreparation) => {
      var _a;
      const hadHover = hoverWidget !== void 0;
      disposeWidget && (hoverWidget === null || hoverWidget === void 0 || hoverWidget.dispose(), hoverWidget = void 0);
      disposePreparation && (hoverPreparation === null || hoverPreparation === void 0 || hoverPreparation.dispose(), hoverPreparation = void 0);
      hadHover && ((_a = hoverDelegate.onDidHideHover) === null || _a === void 0 || _a.call(hoverDelegate));
    }, triggerShowHover = (delay, focus, target) => new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.TimeoutTimer(async() => {
      if (!hoverWidget || hoverWidget.isDisposed) {
        hoverWidget = new UpdatableHoverWidget(hoverDelegate, target || htmlElement, delay > 0), await hoverWidget.update(content, focus, options);
      }
    }, delay), mouseOverDomEmitter = dom.addDisposableListener(htmlElement, dom.EventType.MOUSE_OVER, () => {
      if (!hoverPreparation) {
        var toDispose = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
        toDispose.add(dom.addDisposableListener(htmlElement, dom.EventType.MOUSE_LEAVE, e => hideHover(!1, e.fromElement === htmlElement), !0));
        toDispose.add(dom.addDisposableListener(htmlElement, dom.EventType.MOUSE_DOWN, () => hideHover(!0, !0), !0));
        var target = {targetElements:[htmlElement], dispose:() => {
        }};
        hoverDelegate.placement !== void 0 && hoverDelegate.placement !== "mouse" || toDispose.add(dom.addDisposableListener(htmlElement, dom.EventType.MOUSE_MOVE, e => {
          target.x = e.x + 10;
          e.target instanceof HTMLElement && e.target.classList.contains("action-label") && hideHover(!0, !0);
        }, !0));
        toDispose.add(triggerShowHover(hoverDelegate.delay, !1, target));
        hoverPreparation = toDispose;
      }
    }, !0), focusDomEmitter = dom.addDisposableListener(htmlElement, dom.EventType.FOCUS, () => {
      if (!hoverPreparation) {
        var target = {targetElements:[htmlElement], dispose:() => {
        }}, toDispose = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
        toDispose.add(dom.addDisposableListener(htmlElement, dom.EventType.BLUR, () => hideHover(!0, !0), !0));
        toDispose.add(triggerShowHover(hoverDelegate.delay, !1, target));
        hoverPreparation = toDispose;
      }
    }, !0);
    return {show:focus => {
      hideHover(!1, !0);
      triggerShowHover(0, focus);
    }, hide:() => {
      hideHover(!0, !0);
    }, update:async(newContent, hoverOptions) => {
      content = newContent;
      await (hoverWidget === null || hoverWidget === void 0 ? void 0 : hoverWidget.update(content, void 0, hoverOptions));
    }, dispose:() => {
      mouseOverDomEmitter.dispose();
      focusDomEmitter.dispose();
      hideHover(!0, !0);
    }};
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, setupCustomHover:{enumerable:!0, get:function() {
    return setupCustomHover;
  }}, setupNativeHover:{enumerable:!0, get:function() {
    return setupNativeHover;
  }}});
  var dom = require("module$node_modules$monaco_editor$esm$vs$base$browser$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_cancellation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$cancellation"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$htmlContent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iconLabels_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iconLabels"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js = require("module$node_modules$monaco_editor$esm$vs$nls");
  class UpdatableHoverWidget {
    constructor(hoverDelegate, target, fadeInAnimation) {
      this.hoverDelegate = hoverDelegate;
      this.target = target;
      this.fadeInAnimation = fadeInAnimation;
    }
    async update(content, focus, options) {
      this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0);
      if (!this.isDisposed) {
        if (content === void 0 || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isString)(content) || content instanceof HTMLElement) {
          var resolvedContent = content;
        } else if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isFunction)(content.markdown)) {
          this._hoverWidget || this.show((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("iconLabel.loading", "Loading..."), focus);
          this._cancellationTokenSource = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_cancellation_DOT_js.CancellationTokenSource();
          var _a = this._cancellationTokenSource.token;
          resolvedContent = await content.markdown(_a);
          resolvedContent === void 0 && (resolvedContent = content.markdownNotSupportedFallback);
          if (this.isDisposed || _a.isCancellationRequested) {
            return;
          }
        } else {
          resolvedContent = (_a = content.markdown) !== null && _a !== void 0 ? _a : content.markdownNotSupportedFallback;
        }
        this.show(resolvedContent, focus, options);
      }
    }
    show(content, focus, options) {
      const oldHoverWidget = this._hoverWidget;
      this.hasContent(content) && (this._hoverWidget = this.hoverDelegate.showHover({content, target:this.target, appearance:{showPointer:this.hoverDelegate.placement === "element", skipFadeInAnimation:!this.fadeInAnimation || !!oldHoverWidget}, position:{hoverPosition:2}, ...options}, focus));
      oldHoverWidget === null || oldHoverWidget === void 0 || oldHoverWidget.dispose();
    }
    hasContent(content) {
      return content ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_htmlContent_DOT_js.isMarkdownString)(content) ? !!content.value : !0 : !1;
    }
    get isDisposed() {
      var _a;
      return (_a = this._hoverWidget) === null || _a === void 0 ? void 0 : _a.isDisposed;
    }
    dispose() {
      var _a, _b;
      (_a = this._hoverWidget) === null || _a === void 0 || _a.dispose();
      (_b = this._cancellationTokenSource) === null || _b === void 0 || _b.dispose(!0);
      this._cancellationTokenSource = void 0;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$iconLabel$iconLabelHover.js.map
