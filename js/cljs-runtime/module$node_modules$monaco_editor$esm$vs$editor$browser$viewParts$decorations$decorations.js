shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$decorations$decorations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DecorationsOverlay:{enumerable:!0, get:function() {
    return DecorationsOverlay;
  }}});
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$decorations$decorations_css");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$dynamicViewOverlay");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$renderingContext"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class DecorationsOverlay extends module.DynamicViewOverlay {
    constructor(context) {
      super();
      this._context = context;
      context = this._context.configuration.options;
      this._lineHeight = context.get(66);
      this._typicalHalfwidthCharacterWidth = context.get(50).typicalHalfwidthCharacterWidth;
      this._renderResult = null;
      this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this);
      this._renderResult = null;
      super.dispose();
    }
    onConfigurationChanged(e) {
      e = this._context.configuration.options;
      this._lineHeight = e.get(66);
      this._typicalHalfwidthCharacterWidth = e.get(50).typicalHalfwidthCharacterWidth;
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged || e.scrollWidthChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    prepareRender(ctx) {
      var _decorations = ctx.getDecorationsInViewport();
      let decorations = [];
      var decorationsLen = 0;
      for (let i = 0, len = _decorations.length; i < len; i++) {
        var d = _decorations[i];
        d.options.className && (decorations[decorationsLen++] = d);
      }
      decorations = decorations.sort((a, b) => {
        if (a.options.zIndex < b.options.zIndex) {
          return -1;
        }
        if (a.options.zIndex > b.options.zIndex) {
          return 1;
        }
        const aClassName = a.options.className, bClassName = b.options.className;
        return aClassName < bClassName ? -1 : aClassName > bClassName ? 1 : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts(a.range, b.range);
      });
      _decorations = ctx.visibleRange.startLineNumber;
      decorationsLen = ctx.visibleRange.endLineNumber;
      d = [];
      for (let lineNumber = _decorations; lineNumber <= decorationsLen; lineNumber++) {
        d[lineNumber - _decorations] = "";
      }
      this._renderWholeLineDecorations(ctx, decorations, d);
      this._renderNormalDecorations(ctx, decorations, d);
      this._renderResult = d;
    }
    _renderWholeLineDecorations(ctx, decorations, output) {
      const lineHeight = String(this._lineHeight), visibleStartLineNumber = ctx.visibleRange.startLineNumber;
      ctx = ctx.visibleRange.endLineNumber;
      for (let i = 0, lenI = decorations.length; i < lenI; i++) {
        var d = decorations[i];
        if (!d.options.isWholeLine) {
          continue;
        }
        const decorationOutput = '\x3cdiv class\x3d"cdr ' + d.options.className + '" style\x3d"left:0;width:100%;height:' + lineHeight + 'px;"\x3e\x3c/div\x3e';
        var startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
        for (d = Math.min(d.range.endLineNumber, ctx); startLineNumber <= d; startLineNumber++) {
          output[startLineNumber - visibleStartLineNumber] += decorationOutput;
        }
      }
    }
    _renderNormalDecorations(ctx, decorations, output) {
      var _a;
      const lineHeight = String(this._lineHeight), visibleStartLineNumber = ctx.visibleRange.startLineNumber;
      let prevClassName = null, prevShowIfCollapsed = !1, prevRange = null, prevShouldFillLineOnLineBreak = !1;
      for (let i = 0, lenI = decorations.length; i < lenI; i++) {
        const d = decorations[i];
        if (d.options.isWholeLine) {
          continue;
        }
        const className = d.options.className, showIfCollapsed = !!d.options.showIfCollapsed;
        let range = d.range;
        showIfCollapsed && range.endColumn === 1 && range.endLineNumber !== range.startLineNumber && (range = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(range.startLineNumber, range.startColumn, range.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(range.endLineNumber - 1)));
        prevClassName === className && prevShowIfCollapsed === showIfCollapsed && require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.areIntersectingOrTouching(prevRange, range) ? prevRange = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.plusRange(prevRange, range) : (prevClassName !== null && this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShouldFillLineOnLineBreak, prevShowIfCollapsed, 
        lineHeight, visibleStartLineNumber, output), prevClassName = className, prevShowIfCollapsed = showIfCollapsed, prevRange = range, prevShouldFillLineOnLineBreak = (_a = d.options.shouldFillLineOnLineBreak) !== null && _a !== void 0 ? _a : !1);
      }
      prevClassName !== null && this._renderNormalDecoration(ctx, prevRange, prevClassName, prevShouldFillLineOnLineBreak, prevShowIfCollapsed, lineHeight, visibleStartLineNumber, output);
    }
    _renderNormalDecoration(ctx, range, className, shouldFillLineOnLineBreak, showIfCollapsed, lineHeight, visibleStartLineNumber, output) {
      if (ctx = ctx.linesVisibleRangesForRange(range, className === "findMatch")) {
        for (let j = 0, lenJ = ctx.length; j < lenJ; j++) {
          range = ctx[j];
          if (range.outsideRenderedLine) {
            continue;
          }
          const lineIndex = range.lineNumber - visibleStartLineNumber;
          if (showIfCollapsed && range.ranges.length === 1) {
            var singleVisibleRange = range.ranges[0];
            singleVisibleRange.width < this._typicalHalfwidthCharacterWidth && (range.ranges[0] = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.HorizontalRange(Math.max(0, Math.round(Math.round(singleVisibleRange.left + singleVisibleRange.width / 2) - this._typicalHalfwidthCharacterWidth / 2)), this._typicalHalfwidthCharacterWidth));
          }
          for (let k = 0, lenK = range.ranges.length; k < lenK; k++) {
            singleVisibleRange = range.ranges[k], output[lineIndex] += '\x3cdiv class\x3d"cdr ' + className + '" style\x3d"left:' + String(singleVisibleRange.left) + (shouldFillLineOnLineBreak && range.continuesOnNextLine && lenK === 1 ? "px;width:100%;height:" : "px;width:" + String(singleVisibleRange.width) + "px;height:") + lineHeight + 'px;"\x3e\x3c/div\x3e';
          }
        }
      }
    }
    render(startLineNumber, lineNumber) {
      if (!this._renderResult) {
        return "";
      }
      startLineNumber = lineNumber - startLineNumber;
      return startLineNumber < 0 || startLineNumber >= this._renderResult.length ? "" : this._renderResult[startLineNumber];
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$decorations$decorations.js.map
