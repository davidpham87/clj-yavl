shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$base = function(require, module, exports) {
  function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {
    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;
  }
  function _setDerivedOpts(derived) {
    _derived = derived;
  }
  function transaction(fn, getDebugName) {
    getDebugName = new TransactionImpl(fn, getDebugName);
    try {
      fn(getDebugName);
    } finally {
      getDebugName.finish();
    }
  }
  function globalTransaction(fn) {
    if (_globalTransaction) {
      fn(_globalTransaction);
    } else {
      const tx = new TransactionImpl(fn, void 0);
      _globalTransaction = tx;
      try {
        fn(tx);
      } finally {
        tx.finish(), _globalTransaction = void 0;
      }
    }
  }
  async function asyncTransaction(fn, getDebugName) {
    getDebugName = new TransactionImpl(fn, getDebugName);
    try {
      await fn(getDebugName);
    } finally {
      getDebugName.finish();
    }
  }
  function subtransaction(tx, fn, getDebugName) {
    tx ? fn(tx) : transaction(fn, getDebugName);
  }
  function getDebugName(obj, debugNameFn, fn, owner, self) {
    var _a, cached = cachedDebugName.get(obj);
    if (cached) {
      return cached;
    }
    a: {
      if (cached = cachedDebugName.get(obj)) {
        fn = cached;
      } else {
        if (owner) {
          if (cached = ownerId.get(owner)) {
            var JSCompiler_temp = cached;
          } else {
            cached = (cached = owner.constructor) ? cached.name : "Object";
            var count = (JSCompiler_temp = countPerClassName.get(cached)) !== null && JSCompiler_temp !== void 0 ? JSCompiler_temp : 0;
            count++;
            countPerClassName.set(cached, count);
            JSCompiler_temp = count === 1 ? cached : `${cached}#${count}`;
            ownerId.set(owner, JSCompiler_temp);
          }
          JSCompiler_temp += ".";
        } else {
          JSCompiler_temp = "";
        }
        if (debugNameFn !== void 0) {
          if (typeof debugNameFn === "function") {
            if (debugNameFn = debugNameFn(), debugNameFn !== void 0) {
              fn = JSCompiler_temp + debugNameFn;
              break a;
            }
          } else {
            fn = JSCompiler_temp + debugNameFn;
            break a;
          }
        }
        if (fn !== void 0 && (debugNameFn = getFunctionName(fn), debugNameFn !== void 0)) {
          fn = JSCompiler_temp + debugNameFn;
          break a;
        }
        if (owner !== void 0) {
          for (const key in owner) {
            if (owner[key] === self) {
              fn = JSCompiler_temp + key;
              break a;
            }
          }
        }
        fn = void 0;
      }
    }
    if (fn) {
      return owner = (_a = countPerName.get(fn)) !== null && _a !== void 0 ? _a : 0, owner++, countPerName.set(fn, owner), _a = owner === 1 ? fn : `${fn}#${owner}`, cachedDebugName.set(obj, _a), _a;
    }
  }
  function getFunctionName(fn) {
    fn = (fn = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(fn.toString())) ? fn[1] : void 0;
    return fn === null || fn === void 0 ? void 0 : fn.trim();
  }
  function observableValue(nameOrOwner, initialValue) {
    return typeof nameOrOwner === "string" ? new ObservableValue(void 0, nameOrOwner, initialValue) : new ObservableValue(nameOrOwner, void 0, initialValue);
  }
  function disposableObservableValue(nameOrOwner, initialValue) {
    return typeof nameOrOwner === "string" ? new DisposableObservableValue(void 0, nameOrOwner, initialValue) : new DisposableObservableValue(nameOrOwner, void 0, initialValue);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BaseObservable:{enumerable:!0, get:function() {
    return BaseObservable;
  }}, ConvenientObservable:{enumerable:!0, get:function() {
    return ConvenientObservable;
  }}, DisposableObservableValue:{enumerable:!0, get:function() {
    return DisposableObservableValue;
  }}, ObservableValue:{enumerable:!0, get:function() {
    return ObservableValue;
  }}, TransactionImpl:{enumerable:!0, get:function() {
    return TransactionImpl;
  }}, _setDerivedOpts:{enumerable:!0, get:function() {
    return _setDerivedOpts;
  }}, _setRecomputeInitiallyAndOnChange:{enumerable:!0, get:function() {
    return _setRecomputeInitiallyAndOnChange;
  }}, asyncTransaction:{enumerable:!0, get:function() {
    return asyncTransaction;
  }}, disposableObservableValue:{enumerable:!0, get:function() {
    return disposableObservableValue;
  }}, getDebugName:{enumerable:!0, get:function() {
    return getDebugName;
  }}, getFunctionName:{enumerable:!0, get:function() {
    return getFunctionName;
  }}, globalTransaction:{enumerable:!0, get:function() {
    return globalTransaction;
  }}, observableValue:{enumerable:!0, get:function() {
    return observableValue;
  }}, subtransaction:{enumerable:!0, get:function() {
    return subtransaction;
  }}, transaction:{enumerable:!0, get:function() {
    return transaction;
  }}});
  var require$_DOT__SLASH_logging_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$logging");
  let _recomputeInitiallyAndOnChange, _derived;
  class ConvenientObservable {
    get TChange() {
      return null;
    }
    reportChanges() {
      this.get();
    }
    read(reader) {
      return reader ? reader.readObservable(this) : this.get();
    }
    map(fnOrOwner, fnOrUndefined) {
      const owner = fnOrUndefined === void 0 ? void 0 : fnOrOwner, fn = fnOrUndefined === void 0 ? fnOrOwner : fnOrUndefined;
      return _derived({owner, debugName:() => {
        var name = getFunctionName(fn);
        if (name !== void 0) {
          return name;
        }
        if (name = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(fn.toString())) {
          return `${this.debugName}.${name[2]}`;
        }
        if (!owner) {
          return `${this.debugName} (mapped)`;
        }
      }}, reader => fn(this.read(reader), reader));
    }
    recomputeInitiallyAndOnChange(store, handleValue) {
      store.add(_recomputeInitiallyAndOnChange(this, handleValue));
      return this;
    }
  }
  class BaseObservable extends ConvenientObservable {
    constructor() {
      super(...arguments);
      this.observers = new Set();
    }
    addObserver(observer) {
      const len = this.observers.size;
      this.observers.add(observer);
      if (len === 0) {
        this.onFirstObserverAdded();
      }
    }
    removeObserver(observer) {
      if (this.observers.delete(observer) && this.observers.size === 0) {
        this.onLastObserverRemoved();
      }
    }
    onFirstObserverAdded() {
    }
    onLastObserverRemoved() {
    }
  }
  let _globalTransaction = void 0;
  class TransactionImpl {
    constructor(_fn, _getDebugName) {
      var _a;
      this._fn = _fn;
      this._getDebugName = _getDebugName;
      this.updatingObservers = [];
      (_a = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _a === void 0 || _a.handleBeginTransaction(this);
    }
    getDebugName() {
      return this._getDebugName ? this._getDebugName() : getFunctionName(this._fn);
    }
    updateObserver(observer, observable) {
      this.updatingObservers.push({observer, observable});
      observer.beginUpdate(observable);
    }
    finish() {
      var _a;
      const updatingObservers = this.updatingObservers;
      for (let i = 0; i < updatingObservers.length; i++) {
        const {observer, observable} = updatingObservers[i];
        observer.endUpdate(observable);
      }
      this.updatingObservers = null;
      (_a = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _a === void 0 || _a.handleEndTransaction();
    }
  }
  const countPerName = new Map(), cachedDebugName = new WeakMap(), countPerClassName = new Map(), ownerId = new WeakMap();
  class ObservableValue extends BaseObservable {
    get debugName() {
      var _a;
      return (_a = getDebugName(this, this._debugName, void 0, this._owner, this)) !== null && _a !== void 0 ? _a : "ObservableValue";
    }
    constructor(_owner, _debugName, initialValue) {
      super();
      this._owner = _owner;
      this._debugName = _debugName;
      this._value = initialValue;
    }
    get() {
      return this._value;
    }
    set(value, tx, change) {
      var _a;
      if (this._value !== value) {
        var _tx;
        tx ||= _tx = new TransactionImpl(() => {
        }, () => `Setting ${this.debugName}`);
        try {
          const oldValue = this._value;
          this._setValue(value);
          (_a = (0,require$_DOT__SLASH_logging_DOT_js.getLogger)()) === null || _a === void 0 || _a.handleObservableChanged(this, {oldValue, newValue:value, change, didChange:!0, hadValue:!0});
          for (const observer of this.observers) {
            tx.updateObserver(observer, this), observer.handleChange(this, change);
          }
        } finally {
          _tx && _tx.finish();
        }
      }
    }
    toString() {
      return `${this.debugName}: ${this._value}`;
    }
    _setValue(newValue) {
      this._value = newValue;
    }
  }
  class DisposableObservableValue extends ObservableValue {
    _setValue(newValue) {
      this._value !== newValue && (this._value && this._value.dispose(), this._value = newValue);
    }
    dispose() {
      var _a;
      (_a = this._value) === null || _a === void 0 || _a.dispose();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$observableInternal$base.js.map
