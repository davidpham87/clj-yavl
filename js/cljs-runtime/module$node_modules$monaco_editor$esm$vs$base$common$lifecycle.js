shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$lifecycle = function(require, module, exports) {
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 || disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 || disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 || disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (disposableTracker) {
      for (const child of children) {
        disposableTracker.setParent(child, parent);
      }
    }
  }
  function markAsSingleton(singleton) {
    disposableTracker === null || disposableTracker === void 0 || disposableTracker.markAsSingleton(singleton);
    return singleton;
  }
  function isDisposable(thing) {
    return typeof thing.dispose === "function" && thing.dispose.length === 0;
  }
  function dispose(arg) {
    if (require$_DOT__SLASH_iterator_DOT_js.Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    }
    if (arg) {
      return arg.dispose(), arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self = trackDisposable({dispose:(0,require$_DOT__SLASH_functional_DOT_js.createSingleCallFunction)(() => {
      markAsDisposed(self);
      fn();
    })});
    return self;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Disposable:{enumerable:!0, get:function() {
    return Disposable;
  }}, DisposableMap:{enumerable:!0, get:function() {
    return DisposableMap;
  }}, DisposableStore:{enumerable:!0, get:function() {
    return DisposableStore;
  }}, ImmortalReference:{enumerable:!0, get:function() {
    return ImmortalReference;
  }}, MutableDisposable:{enumerable:!0, get:function() {
    return MutableDisposable;
  }}, RefCountedDisposable:{enumerable:!0, get:function() {
    return RefCountedDisposable;
  }}, combinedDisposable:{enumerable:!0, get:function() {
    return combinedDisposable;
  }}, dispose:{enumerable:!0, get:function() {
    return dispose;
  }}, isDisposable:{enumerable:!0, get:function() {
    return isDisposable;
  }}, markAsDisposed:{enumerable:!0, get:function() {
    return markAsDisposed;
  }}, markAsSingleton:{enumerable:!0, get:function() {
    return markAsSingleton;
  }}, setDisposableTracker:{enumerable:!0, get:function() {
    return setDisposableTracker;
  }}, toDisposable:{enumerable:!0, get:function() {
    return toDisposable;
  }}, trackDisposable:{enumerable:!0, get:function() {
    return trackDisposable;
  }}});
  var require$_DOT__SLASH_functional_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$functional"), require$_DOT__SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator");
  let disposableTracker = null;
  class DisposableStore {
    constructor() {
      this._toDispose = new Set();
      this._isDisposed = !1;
      trackDisposable(this);
    }
    dispose() {
      this._isDisposed || (markAsDisposed(this), this._isDisposed = !0, this.clear());
    }
    get isDisposed() {
      return this._isDisposed;
    }
    clear() {
      if (this._toDispose.size !== 0) {
        try {
          dispose(this._toDispose);
        } finally {
          this._toDispose.clear();
        }
      }
    }
    add(o) {
      if (!o) {
        return o;
      }
      if (o === this) {
        throw Error("Cannot register a disposable on itself!");
      }
      setParentOfDisposable(o, this);
      this._isDisposed ? DisposableStore.DISABLE_DISPOSED_WARNING || console.warn(Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(o);
      return o;
    }
    deleteAndLeak(o) {
      o && this._toDispose.has(o) && (this._toDispose.delete(o), setParentOfDisposable(o, null));
    }
  }
  DisposableStore.DISABLE_DISPOSED_WARNING = !1;
  class Disposable {
    constructor() {
      this._store = new DisposableStore();
      trackDisposable(this);
      setParentOfDisposable(this._store, this);
    }
    dispose() {
      markAsDisposed(this);
      this._store.dispose();
    }
    _register(o) {
      if (o === this) {
        throw Error("Cannot register a disposable on itself!");
      }
      return this._store.add(o);
    }
  }
  Disposable.None = Object.freeze({dispose() {
  }});
  class MutableDisposable {
    constructor() {
      this._isDisposed = !1;
      trackDisposable(this);
    }
    get value() {
      return this._isDisposed ? void 0 : this._value;
    }
    set value(value) {
      var _a;
      this._isDisposed || value === this._value || ((_a = this._value) === null || _a === void 0 || _a.dispose(), value && setParentOfDisposable(value, this), this._value = value);
    }
    clear() {
      this.value = void 0;
    }
    dispose() {
      var _a;
      this._isDisposed = !0;
      markAsDisposed(this);
      (_a = this._value) === null || _a === void 0 || _a.dispose();
      this._value = void 0;
    }
  }
  class RefCountedDisposable {
    constructor(_disposable) {
      this._disposable = _disposable;
      this._counter = 1;
    }
    acquire() {
      this._counter++;
      return this;
    }
    release() {
      --this._counter === 0 && this._disposable.dispose();
      return this;
    }
  }
  class ImmortalReference {
    constructor(object) {
      this.object = object;
    }
    dispose() {
    }
  }
  class DisposableMap {
    constructor() {
      this._store = new Map();
      this._isDisposed = !1;
      trackDisposable(this);
    }
    dispose() {
      markAsDisposed(this);
      this._isDisposed = !0;
      this.clearAndDisposeAll();
    }
    clearAndDisposeAll() {
      if (this._store.size) {
        try {
          dispose(this._store.values());
        } finally {
          this._store.clear();
        }
      }
    }
    get(key) {
      return this._store.get(key);
    }
    set(key, value, skipDisposeOnOverwrite = !1) {
      var _a;
      this._isDisposed && console.warn(Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
      skipDisposeOnOverwrite || (_a = this._store.get(key)) === null || _a === void 0 || _a.dispose();
      this._store.set(key, value);
    }
    deleteAndDispose(key) {
      var _a;
      (_a = this._store.get(key)) === null || _a === void 0 || _a.dispose();
      this._store.delete(key);
    }
    [Symbol.iterator]() {
      return this._store[Symbol.iterator]();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$lifecycle.js.map
