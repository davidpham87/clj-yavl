shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorCollection = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CursorCollection:{enumerable:!0, get:function() {
    return CursorCollection;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arraysFind"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), require$_DOT__SLASH_oneCursor_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$oneCursor"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection");
  class CursorCollection {
    constructor(context) {
      this.context = context;
      this.cursors = [new require$_DOT__SLASH_oneCursor_DOT_js.Cursor(context)];
      this.lastAddedCursorIndex = 0;
    }
    dispose() {
      for (const cursor of this.cursors) {
        cursor.dispose(this.context);
      }
    }
    startTrackingSelections() {
      for (const cursor of this.cursors) {
        cursor.startTrackingSelection(this.context);
      }
    }
    stopTrackingSelections() {
      for (const cursor of this.cursors) {
        cursor.stopTrackingSelection(this.context);
      }
    }
    updateContext(context) {
      this.context = context;
    }
    ensureValidState() {
      for (const cursor of this.cursors) {
        cursor.ensureValidState(this.context);
      }
    }
    readSelectionFromMarkers() {
      return this.cursors.map(c => c.readSelectionFromMarkers(this.context));
    }
    getAll() {
      return this.cursors.map(c => c.asCursorState());
    }
    getViewPositions() {
      return this.cursors.map(c => c.viewState.position);
    }
    getTopMostViewPosition() {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findFirstMinBy)(this.cursors, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(c => c.viewState.position, require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position.compare)).viewState.position;
    }
    getBottomMostViewPosition() {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMaxBy)(this.cursors, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(c => c.viewState.position, require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position.compare)).viewState.position;
    }
    getSelections() {
      return this.cursors.map(c => c.modelState.selection);
    }
    getViewSelections() {
      return this.cursors.map(c => c.viewState.selection);
    }
    setSelections(selections) {
      this.setStates(require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelSelections(selections));
    }
    getPrimaryCursor() {
      return this.cursors[0].asCursorState();
    }
    setStates(states) {
      states !== null && (this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState), this._setSecondaryStates(states.slice(1)));
    }
    _setSecondaryStates(secondaryStates) {
      var secondaryCursorsLength = this.cursors.length - 1;
      const secondaryStatesLength = secondaryStates.length;
      if (secondaryCursorsLength < secondaryStatesLength) {
        secondaryCursorsLength = secondaryStatesLength - secondaryCursorsLength;
        for (var i = 0; i < secondaryCursorsLength; i++) {
          this._addSecondaryCursor();
        }
      } else if (secondaryCursorsLength > secondaryStatesLength) {
        for (secondaryCursorsLength -= secondaryStatesLength, i = 0; i < secondaryCursorsLength; i++) {
          this._removeSecondaryCursor(this.cursors.length - 2);
        }
      }
      for (secondaryCursorsLength = 0; secondaryCursorsLength < secondaryStatesLength; secondaryCursorsLength++) {
        this.cursors[secondaryCursorsLength + 1].setState(this.context, secondaryStates[secondaryCursorsLength].modelState, secondaryStates[secondaryCursorsLength].viewState);
      }
    }
    killSecondaryCursors() {
      this._setSecondaryStates([]);
    }
    _addSecondaryCursor() {
      this.cursors.push(new require$_DOT__SLASH_oneCursor_DOT_js.Cursor(this.context));
      this.lastAddedCursorIndex = this.cursors.length - 1;
    }
    getLastAddedCursorIndex() {
      return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
    }
    _removeSecondaryCursor(removeIndex) {
      this.lastAddedCursorIndex >= removeIndex + 1 && this.lastAddedCursorIndex--;
      this.cursors[removeIndex + 1].dispose(this.context);
      this.cursors.splice(removeIndex + 1, 1);
    }
    normalize() {
      if (this.cursors.length !== 1) {
        var cursors = this.cursors.slice(0), sortedCursors = [];
        for (let i = 0, len = cursors.length; i < len; i++) {
          sortedCursors.push({index:i, selection:cursors[i].modelState.selection});
        }
        sortedCursors.sort((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.compareBy)(s => s.selection, require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts));
        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {
          var current = sortedCursors[sortedCursorIndex], next = sortedCursors[sortedCursorIndex + 1], currentSelection = current.selection, nextSelection = next.selection;
          if (this.context.cursorConfig.multiCursorMergeOverlapping && (nextSelection.isEmpty() || currentSelection.isEmpty() ? nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition()) : nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition()))) {
            currentSelection = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;
            current = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;
            next = sortedCursors[current].index;
            nextSelection = sortedCursors[currentSelection].index;
            var looserSelection = sortedCursors[current].selection, winnerSelection = sortedCursors[currentSelection].selection;
            if (!looserSelection.equalsSelection(winnerSelection)) {
              var resultingRange = looserSelection.plusRange(winnerSelection);
              looserSelection = looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn;
              winnerSelection = winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn;
              next === this.lastAddedCursorIndex && (winnerSelection = looserSelection, this.lastAddedCursorIndex = nextSelection);
              resultingRange = winnerSelection ? new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn) : new require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);
              sortedCursors[currentSelection].selection = resultingRange;
              currentSelection = require$_DOT__DOT__SLASH_cursorCommon_DOT_js.CursorState.fromModelSelection(resultingRange);
              cursors[nextSelection].setState(this.context, currentSelection.modelState, currentSelection.viewState);
            }
            for (const sortedCursor of sortedCursors) {
              sortedCursor.index > next && sortedCursor.index--;
            }
            cursors.splice(next, 1);
            sortedCursors.splice(current, 1);
            this._removeSecondaryCursor(next - 1);
            sortedCursorIndex--;
          }
        }
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorCollection.js.map
