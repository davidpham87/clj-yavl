shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$rangeMap = function(require, module, exports) {
  function groupIntersect(range, groups) {
    const result = [];
    for (const r of groups) {
      if (!(range.start >= r.range.end)) {
        if (range.end < r.range.start) {
          break;
        }
        groups = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.intersect(range, r.range);
        require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js.Range.isEmpty(groups) || result.push({range:groups, size:r.size});
      }
    }
    return result;
  }
  function shift({start, end}, much) {
    return {start:start + much, end:end + much};
  }
  function consolidate(groups) {
    const result = [];
    let previousGroup = null;
    for (const group of groups) {
      groups = group.range.start;
      const end = group.range.end, size = group.size;
      previousGroup && size === previousGroup.size ? previousGroup.range.end = end : (previousGroup = {range:{start:groups, end}, size}, result.push(previousGroup));
    }
    return result;
  }
  function concat(...groups) {
    return consolidate(groups.reduce((r, g) => r.concat(g), []));
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, RangeMap:{enumerable:!0, get:function() {
    return RangeMap;
  }}, consolidate:{enumerable:!0, get:function() {
    return consolidate;
  }}, groupIntersect:{enumerable:!0, get:function() {
    return groupIntersect;
  }}, shift:{enumerable:!0, get:function() {
    return shift;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$range");
  class RangeMap {
    get paddingTop() {
      return this._paddingTop;
    }
    set paddingTop(paddingTop) {
      this._size = this._size + paddingTop - this._paddingTop;
      this._paddingTop = paddingTop;
    }
    constructor(topPadding) {
      this.groups = [];
      this._paddingTop = this._size = 0;
      this._size = this._paddingTop = topPadding !== null && topPadding !== void 0 ? topPadding : 0;
    }
    splice(index, deleteCount, items = []) {
      const diff = items.length - deleteCount, before = groupIntersect({start:0, end:index}, this.groups);
      deleteCount = groupIntersect({start:index + deleteCount, end:Number.POSITIVE_INFINITY}, this.groups).map(g => ({range:shift(g.range, diff), size:g.size}));
      items = items.map((item, i) => ({range:{start:index + i, end:index + i + 1}, size:item.size}));
      this.groups = concat(before, items, deleteCount);
      this._size = this._paddingTop + this.groups.reduce((t, g) => t + g.size * (g.range.end - g.range.start), 0);
    }
    get count() {
      const len = this.groups.length;
      return len ? this.groups[len - 1].range.end : 0;
    }
    get size() {
      return this._size;
    }
    indexAt(position) {
      if (position < 0) {
        return -1;
      }
      if (position < this._paddingTop) {
        return 0;
      }
      let index = 0, size = this._paddingTop;
      for (const group of this.groups) {
        const count = group.range.end - group.range.start, newSize = size + count * group.size;
        if (position < newSize) {
          return index + Math.floor((position - size) / group.size);
        }
        index += count;
        size = newSize;
      }
      return index;
    }
    indexAfter(position) {
      return Math.min(this.indexAt(position) + 1, this.count);
    }
    positionAt(index) {
      if (index < 0) {
        return -1;
      }
      let position = 0, count = 0;
      for (const group of this.groups) {
        const groupCount = group.range.end - group.range.start, newCount = count + groupCount;
        if (index < newCount) {
          return this._paddingTop + position + (index - count) * group.size;
        }
        position += groupCount * group.size;
        count = newCount;
      }
      return -1;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$rangeMap.js.map
