shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBufferBuilder = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, PieceTreeTextBufferBuilder:{enumerable:!0, get:function() {
    return PieceTreeTextBufferBuilder;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__SLASH_pieceTreeBase_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeBase"), require$_DOT__SLASH_pieceTreeTextBuffer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBuffer");
  class PieceTreeTextBufferFactory {
    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {
      this._chunks = _chunks;
      this._bom = _bom;
      this._cr = _cr;
      this._lf = _lf;
      this._crlf = _crlf;
      this._containsRTL = _containsRTL;
      this._containsUnusualLineTerminators = _containsUnusualLineTerminators;
      this._isBasicASCII = _isBasicASCII;
      this._normalizeEOL = _normalizeEOL;
    }
    _getEOL(defaultEOL) {
      const totalEOLCount = this._cr + this._lf + this._crlf;
      return totalEOLCount === 0 ? defaultEOL === 1 ? "\n" : "\r\n" : this._cr + this._crlf > totalEOLCount / 2 ? "\r\n" : "\n";
    }
    create(defaultEOL) {
      defaultEOL = this._getEOL(defaultEOL);
      const chunks = this._chunks;
      if (this._normalizeEOL && (defaultEOL === "\r\n" && (this._cr > 0 || this._lf > 0) || defaultEOL === "\n" && (this._cr > 0 || this._crlf > 0))) {
        for (let i = 0, len = chunks.length; i < len; i++) {
          const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, defaultEOL), newLineStart = (0,require$_DOT__SLASH_pieceTreeBase_DOT_js.createLineStartsFast)(str);
          chunks[i] = new require$_DOT__SLASH_pieceTreeBase_DOT_js.StringBuffer(str, newLineStart);
        }
      }
      defaultEOL = new require$_DOT__SLASH_pieceTreeTextBuffer_DOT_js.PieceTreeTextBuffer(chunks, this._bom, defaultEOL, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
      return {textBuffer:defaultEOL, disposable:defaultEOL};
    }
  }
  class PieceTreeTextBufferBuilder {
    constructor() {
      this.chunks = [];
      this.BOM = "";
      this._hasPreviousChar = !1;
      this._previousChar = 0;
      this._tmpLineStarts = [];
      this.crlf = this.lf = this.cr = 0;
      this.containsUnusualLineTerminators = this.containsRTL = !1;
      this.isBasicASCII = !0;
    }
    acceptChunk(chunk) {
      if (chunk.length !== 0) {
        this.chunks.length === 0 && strings.startsWithUTF8BOM(chunk) && (this.BOM = strings.UTF8_BOM_CHARACTER, chunk = chunk.substr(1));
        var lastChar = chunk.charCodeAt(chunk.length - 1);
        lastChar === 13 || lastChar >= 55296 && lastChar <= 56319 ? (this._acceptChunk1(chunk.substr(0, chunk.length - 1), !1), this._hasPreviousChar = !0) : (this._acceptChunk1(chunk, !1), this._hasPreviousChar = !1);
        this._previousChar = lastChar;
      }
    }
    _acceptChunk1(chunk, allowEmptyStrings) {
      if (allowEmptyStrings || chunk.length !== 0) {
        this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk) : this._acceptChunk2(chunk);
      }
    }
    _acceptChunk2(chunk) {
      const lineStarts = (0,require$_DOT__SLASH_pieceTreeBase_DOT_js.createLineStarts)(this._tmpLineStarts, chunk);
      this.chunks.push(new require$_DOT__SLASH_pieceTreeBase_DOT_js.StringBuffer(chunk, lineStarts.lineStarts));
      this.cr += lineStarts.cr;
      this.lf += lineStarts.lf;
      this.crlf += lineStarts.crlf;
      lineStarts.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = strings.containsRTL(chunk)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk)));
    }
    finish(normalizeEOL = !0) {
      this._finish();
      return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);
    }
    _finish() {
      this.chunks.length === 0 && this._acceptChunk1("", !0);
      if (this._hasPreviousChar) {
        this._hasPreviousChar = !1;
        const lastChunk = this.chunks[this.chunks.length - 1];
        lastChunk.buffer += String.fromCharCode(this._previousChar);
        const newLineStarts = (0,require$_DOT__SLASH_pieceTreeBase_DOT_js.createLineStartsFast)(lastChunk.buffer);
        lastChunk.lineStarts = newLineStarts;
        this._previousChar === 13 && this.cr++;
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBufferBuilder.js.map
