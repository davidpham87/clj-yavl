shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$view$domLineBreaksComputer = function(require, module, exports) {
  function createLineBreaks(targetWindow, requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, wordBreak, injectedTextsPerLine) {
    function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {
      var injectedTexts = injectedTextsPerLine[requestIdx];
      if (injectedTexts) {
        requestIdx = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_textModelEvents_DOT_js.LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);
        const injectionOptions = injectedTexts.map(t => t.options);
        injectedTexts = injectedTexts.map(text => text.column - 1);
        return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(injectedTexts, injectionOptions, [requestIdx.length], [], 0);
      }
      return null;
    }
    var _a;
    if (firstLineBreakColumn === -1) {
      targetWindow = [];
      for (let i = 0, len = requests.length; i < len; i++) {
        targetWindow[i] = createEmptyLineBreakWithPossiblyInjectedText(i);
      }
      return targetWindow;
    }
    var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);
    firstLineBreakColumn = Math.round(tabSize * (wrappingIndent === 3 ? 2 : wrappingIndent === 2 ? 1 : 0));
    var additionalIndentLength = Math.ceil(fontInfo.spaceWidth * firstLineBreakColumn);
    const containerDomNode = document.createElement("div");
    (0,require$_DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js.applyFontInfo)(containerDomNode, fontInfo);
    var sb = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_stringBuilder_DOT_js.StringBuilder(10000);
    const firstNonWhitespaceIndices = [], wrappedTextIndentLengths = [], renderLineContents = [], allCharOffsets = [], allVisibleColumns = [];
    for (var i = 0; i < requests.length; i++) {
      var lineContent = require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_textModelEvents_DOT_js.LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);
      let firstNonWhitespaceIndex = 0, wrappedTextIndentLength = 0;
      var width = overallWidth;
      if (wrappingIndent !== 0) {
        if (firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent), firstNonWhitespaceIndex === -1) {
          firstNonWhitespaceIndex = 0;
        } else {
          for (var i$jscomp$0 = 0; i$jscomp$0 < firstNonWhitespaceIndex; i$jscomp$0++) {
            const charWidth = lineContent.charCodeAt(i$jscomp$0) === 9 ? tabSize - wrappedTextIndentLength % tabSize : 1;
            wrappedTextIndentLength += charWidth;
          }
          i$jscomp$0 = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);
          i$jscomp$0 + fontInfo.typicalFullwidthCharacterWidth > overallWidth ? wrappedTextIndentLength = firstNonWhitespaceIndex = 0 : width = overallWidth - i$jscomp$0;
        }
      }
      lineContent = lineContent.substr(firstNonWhitespaceIndex);
      width = renderLine(lineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);
      firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;
      wrappedTextIndentLengths[i] = wrappedTextIndentLength;
      renderLineContents[i] = lineContent;
      allCharOffsets[i] = width[0];
      allVisibleColumns[i] = width[1];
    }
    fontInfo = sb.build();
    tabSize = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(fontInfo)) !== null && _a !== void 0 ? _a : fontInfo;
    containerDomNode.innerHTML = tabSize;
    containerDomNode.style.position = "absolute";
    containerDomNode.style.top = "10000";
    wordBreak === "keepAll" ? (containerDomNode.style.wordBreak = "keep-all", containerDomNode.style.overflowWrap = "anywhere") : (containerDomNode.style.wordBreak = "inherit", containerDomNode.style.overflowWrap = "break-word");
    targetWindow.document.body.appendChild(containerDomNode);
    wordBreak = document.createRange();
    _a = Array.prototype.slice.call(containerDomNode.children, 0);
    fontInfo = [];
    for (tabSize = 0; tabSize < requests.length; tabSize++) {
      if (wrappingIndent = readLineBreaks(wordBreak, _a[tabSize], renderLineContents[tabSize], allCharOffsets[tabSize]), wrappingIndent === null) {
        fontInfo[tabSize] = createEmptyLineBreakWithPossiblyInjectedText(tabSize);
      } else {
        sb = firstNonWhitespaceIndices[tabSize];
        overallWidth = wrappedTextIndentLengths[tabSize] + firstLineBreakColumn;
        i = allVisibleColumns[tabSize];
        additionalIndentLength = [];
        for (let j = 0, len = wrappingIndent.length; j < len; j++) {
          additionalIndentLength[j] = i[wrappingIndent[j]];
        }
        if (sb !== 0) {
          for (let j = 0, len = wrappingIndent.length; j < len; j++) {
            wrappingIndent[j] += sb;
          }
        }
        (i = injectedTextsPerLine[tabSize]) ? (sb = i.map(t => t.options), i = i.map(text => text.column - 1)) : i = sb = null;
        fontInfo[tabSize] = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_modelLineProjectionData_DOT_js.ModelLineProjectionData(i, sb, wrappingIndent, additionalIndentLength, overallWidth);
      }
    }
    targetWindow.document.body.removeChild(containerDomNode);
    return fontInfo;
  }
  function renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {
    wrappingIndentLength !== 0 ? (wrappingIndentLength = String(wrappingIndentLength), sb.appendString('\x3cdiv style\x3d"text-indent: -'), sb.appendString(wrappingIndentLength), sb.appendString("px; padding-left: "), sb.appendString(wrappingIndentLength), sb.appendString("px; box-sizing: border-box; width:")) : sb.appendString('\x3cdiv style\x3d"width:');
    sb.appendString(String(width));
    sb.appendString('px;"\x3e');
    width = lineContent.length;
    wrappingIndentLength = 0;
    const charOffsets = [], visibleColumns = [];
    let nextCharCode = 0 < width ? lineContent.charCodeAt(0) : 0;
    sb.appendString("\x3cspan\x3e");
    for (let charIndex = 0; charIndex < width; charIndex++) {
      charIndex !== 0 && charIndex % 16384 === 0 && sb.appendString("\x3c/span\x3e\x3cspan\x3e");
      charOffsets[charIndex] = wrappingIndentLength;
      visibleColumns[charIndex] = initialVisibleColumn;
      var charCode = nextCharCode;
      nextCharCode = charIndex + 1 < width ? lineContent.charCodeAt(charIndex + 1) : 0;
      let producedCharacters = 1, charWidth = 1;
      switch(charCode) {
        case 9:
          charWidth = producedCharacters = tabSize - initialVisibleColumn % tabSize;
          for (charCode = 1; charCode <= producedCharacters; charCode++) {
            charCode < producedCharacters ? sb.appendCharCode(160) : sb.appendASCIICharCode(32);
          }
          break;
        case 32:
          nextCharCode === 32 ? sb.appendCharCode(160) : sb.appendASCIICharCode(32);
          break;
        case 60:
          sb.appendString("\x26lt;");
          break;
        case 62:
          sb.appendString("\x26gt;");
          break;
        case 38:
          sb.appendString("\x26amp;");
          break;
        case 0:
          sb.appendString("\x26#00;");
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          sb.appendCharCode(65533);
          break;
        default:
          strings.isFullWidthCharacter(charCode) && charWidth++, charCode < 32 ? sb.appendCharCode(9216 + charCode) : sb.appendCharCode(charCode);
      }
      wrappingIndentLength += producedCharacters;
      initialVisibleColumn += charWidth;
    }
    sb.appendString("\x3c/span\x3e");
    charOffsets[lineContent.length] = wrappingIndentLength;
    visibleColumns[lineContent.length] = initialVisibleColumn;
    sb.appendString("\x3c/div\x3e");
    return [charOffsets, visibleColumns];
  }
  function readLineBreaks(range, lineDomNode, lineContent, charOffsets) {
    if (lineContent.length <= 1) {
      return null;
    }
    lineDomNode = Array.prototype.slice.call(lineDomNode.children, 0);
    const breakOffsets = [];
    try {
      discoverBreaks(range, lineDomNode, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);
    } catch (err) {
      return console.log(err), null;
    }
    if (breakOffsets.length === 0) {
      return null;
    }
    breakOffsets.push(lineContent.length);
    return breakOffsets;
  }
  function discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {
    if (low !== high && (lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]), highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]), !(Math.abs(lowRects[0].top - highRects[0].top) <= 0.1))) {
      if (low + 1 === high) {
        result.push(high);
      } else {
        var mid = low + (high - low) / 2 | 0, midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);
        discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);
        discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);
      }
    }
  }
  function readClientRect(range, spans, startOffset, endOffset) {
    range.setStart(spans[startOffset / 16384 | 0].firstChild, startOffset % 16384);
    range.setEnd(spans[endOffset / 16384 | 0].firstChild, endOffset % 16384);
    return range.getClientRects();
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DOMLineBreaksComputerFactory:{enumerable:!0, get:function() {
    return DOMLineBreaksComputerFactory;
  }}});
  module = require("module$node_modules$monaco_editor$esm$vs$base$browser$trustedTypes");
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types"), require$_DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$config$domFontInfo"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_stringBuilder_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_modelLineProjectionData_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$modelLineProjectionData"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_textModelEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents");
  const ttPolicy = (0,module.createTrustedTypesPolicy)("domLineBreaksComputer", {createHTML:value => value});
  class DOMLineBreaksComputerFactory {
    static create(targetWindow) {
      return new DOMLineBreaksComputerFactory(new WeakRef(targetWindow));
    }
    constructor(targetWindow) {
      this.targetWindow = targetWindow;
    }
    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {
      const requests = [], injectedTexts = [];
      return {addRequest:(lineText, injectedText, previousLineBreakData) => {
        requests.push(lineText);
        injectedTexts.push(injectedText);
      }, finalize:() => createLineBreaks((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_types_DOT_js.assertIsDefined)(this.targetWindow.deref()), requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak, injectedTexts)};
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$view$domLineBreaksComputer.js.map
