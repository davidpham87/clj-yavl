shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LineRange:{enumerable:!0, get:function() {
    return LineRange;
  }}, LineRangeSet:{enumerable:!0, get:function() {
    return LineRangeSet;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__SLASH_offsetRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange"), require$_DOT__SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$arraysFind");
  class LineRange {
    static fromRange(range) {
      return new LineRange(range.startLineNumber, range.endLineNumber);
    }
    static fromRangeInclusive(range) {
      return new LineRange(range.startLineNumber, range.endLineNumber + 1);
    }
    static joinMany(lineRanges) {
      if (lineRanges.length === 0) {
        return [];
      }
      let result = new LineRangeSet(lineRanges[0].slice());
      for (let i = 1; i < lineRanges.length; i++) {
        result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
      }
      return result.ranges;
    }
    static ofLength(startLineNumber, length) {
      return new LineRange(startLineNumber, startLineNumber + length);
    }
    static deserialize(lineRange) {
      return new LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
      if (startLineNumber > endLineNumberExclusive) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
      }
      this.startLineNumber = startLineNumber;
      this.endLineNumberExclusive = endLineNumberExclusive;
    }
    contains(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    get isEmpty() {
      return this.startLineNumber === this.endLineNumberExclusive;
    }
    delta(offset) {
      return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
    }
    deltaLength(offset) {
      return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
    }
    get length() {
      return this.endLineNumberExclusive - this.startLineNumber;
    }
    join(other) {
      return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
      return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    intersect(other) {
      const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
      other = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
      if (startLineNumber <= other) {
        return new LineRange(startLineNumber, other);
      }
    }
    intersectsStrict(other) {
      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b) {
      return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
    }
    toInclusiveRange() {
      return this.isEmpty ? null : new require$_DOT__SLASH_range_DOT_js.Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    toExclusiveRange() {
      return new require$_DOT__SLASH_range_DOT_js.Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f) {
      const result = [];
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        result.push(f(lineNumber));
      }
      return result;
    }
    forEach(f) {
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        f(lineNumber);
      }
    }
    serialize() {
      return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    toOffsetRange() {
      return new require$_DOT__SLASH_offsetRange_DOT_js.OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
    }
  }
  class LineRangeSet {
    constructor(_normalizedRanges = []) {
      this._normalizedRanges = _normalizedRanges;
    }
    get ranges() {
      return this._normalizedRanges;
    }
    addRange(range) {
      if (range.length !== 0) {
        var joinRangeStartIdx = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findFirstIdxMonotonousOrArrLen)(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber), joinRangeEndIdxExclusive = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastIdxMonotonous)(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
        } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
          this._normalizedRanges[joinRangeStartIdx] = this._normalizedRanges[joinRangeStartIdx].join(range);
        } else {
          const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
          this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
        }
      }
    }
    contains(lineNumber) {
      const rangeThatStartsBeforeEnd = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMonotonous)(this._normalizedRanges, r => r.startLineNumber <= lineNumber);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
    }
    intersects(range) {
      const rangeThatStartsBeforeEnd = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastMonotonous)(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
    }
    getUnion(other) {
      if (this._normalizedRanges.length === 0) {
        return other;
      }
      if (other._normalizedRanges.length === 0) {
        return this;
      }
      const result = [];
      let i1 = 0, i2 = 0, current = null;
      for (; i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length;) {
        var next = void 0;
        if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          next = this._normalizedRanges[i1];
          const lineRange2 = other._normalizedRanges[i2];
          next.startLineNumber < lineRange2.startLineNumber ? i1++ : (next = lineRange2, i2++);
        } else {
          i1 < this._normalizedRanges.length ? (next = this._normalizedRanges[i1], i1++) : (next = other._normalizedRanges[i2], i2++);
        }
        current === null ? current = next : current.endLineNumberExclusive >= next.startLineNumber ? current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive)) : (result.push(current), current = next);
      }
      current !== null && result.push(current);
      return new LineRangeSet(result);
    }
    subtractFrom(range) {
      var joinRangeStartIdx = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findFirstIdxMonotonousOrArrLen)(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arraysFind_DOT_js.findLastIdxMonotonous)(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        return new LineRangeSet([range]);
      }
      const result = [];
      let startLineNumber = range.startLineNumber;
      for (; joinRangeStartIdx < joinRangeEndIdxExclusive; joinRangeStartIdx++) {
        const r = this._normalizedRanges[joinRangeStartIdx];
        r.startLineNumber > startLineNumber && result.push(new LineRange(startLineNumber, r.startLineNumber));
        startLineNumber = r.endLineNumberExclusive;
      }
      startLineNumber < range.endLineNumberExclusive && result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
      return new LineRangeSet(result);
    }
    toString() {
      return this._normalizedRanges.map(r => r.toString()).join(", ");
    }
    getIntersection(other) {
      const result = [];
      let i1 = 0, i2 = 0;
      for (; i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length;) {
        const r1 = this._normalizedRanges[i1], r2 = other._normalizedRanges[i2], i = r1.intersect(r2);
        i && !i.isEmpty && result.push(i);
        r1.endLineNumberExclusive < r2.endLineNumberExclusive ? i1++ : i2++;
      }
      return new LineRangeSet(result);
    }
    getWithDelta(value) {
      return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange.js.map
