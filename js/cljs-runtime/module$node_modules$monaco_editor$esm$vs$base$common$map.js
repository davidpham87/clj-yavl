shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$map = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, BidirectionalMap:{enumerable:!0, get:function() {
    return BidirectionalMap;
  }}, LRUCache:{enumerable:!0, get:function() {
    return LRUCache;
  }}, LinkedMap:{enumerable:!0, get:function() {
    return LinkedMap;
  }}, ResourceMap:{enumerable:!0, get:function() {
    return ResourceMap;
  }}, SetMap:{enumerable:!0, get:function() {
    return SetMap;
  }}});
  var _a, _b;
  class ResourceMapEntry {
    constructor(uri, value) {
      this.uri = uri;
      this.value = value;
    }
  }
  class ResourceMap {
    constructor(arg, toKey) {
      this[_a] = "ResourceMap";
      if (arg instanceof ResourceMap) {
        this.map = new Map(arg.map), this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
      } else if (Array.isArray(arg)) {
        this.map = new Map();
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
        for (const [resource, value] of arg) {
          this.set(resource, value);
        }
      } else {
        this.map = new Map(), this.toKey = arg !== null && arg !== void 0 ? arg : ResourceMap.defaultToKey;
      }
    }
    set(resource, value) {
      this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
      return this;
    }
    get(resource) {
      var _c;
      return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(resource) {
      return this.map.has(this.toKey(resource));
    }
    get size() {
      return this.map.size;
    }
    clear() {
      this.map.clear();
    }
    delete(resource) {
      return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
      typeof thisArg !== "undefined" && (clb = clb.bind(thisArg));
      for (const [, entry] of this.map) {
        clb(entry.value, entry.uri, this);
      }
    }
    *values() {
      for (const entry of this.map.values()) {
        yield entry.value;
      }
    }
    *keys() {
      for (const entry of this.map.values()) {
        yield entry.uri;
      }
    }
    *entries() {
      for (const entry of this.map.values()) {
        yield [entry.uri, entry.value];
      }
    }
    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {
      for (const [, entry] of this.map) {
        yield [entry.uri, entry.value];
      }
    }
  }
  ResourceMap.defaultToKey = resource => resource.toString();
  class LinkedMap {
    constructor() {
      this[_b] = "LinkedMap";
      this._map = new Map();
      this._tail = this._head = void 0;
      this._state = this._size = 0;
    }
    clear() {
      this._map.clear();
      this._tail = this._head = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _c;
      return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
    }
    get last() {
      var _c;
      return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = 0) {
      if (key = this._map.get(key)) {
        return touch !== 0 && this.touch(key, touch), key.value;
      }
    }
    set(key, value, touch = 0) {
      let item = this._map.get(key);
      if (item) {
        item.value = value, touch !== 0 && this.touch(item, touch);
      } else {
        item = {key, value, next:void 0, previous:void 0};
        switch(touch) {
          case 0:
            this.addItemLast(item);
            break;
          case 1:
            this.addItemFirst(item);
            break;
          case 2:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (item) {
        return this._map.delete(key), this.removeItem(item), this._size--, item.value;
      }
    }
    shift() {
      if (this._head || this._tail) {
        if (!this._head || !this._tail) {
          throw Error("Invalid list");
        }
        var item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      for (; current;) {
        thisArg ? callbackfn.bind(thisArg)(current.value, current.key, this) : callbackfn(current.value, current.key, this);
        if (this._state !== state) {
          throw Error("LinkedMap got modified during iteration.");
        }
        current = current.next;
      }
    }
    keys() {
      const map = this, state = this._state;
      let current = this._head;
      const iterator = {[Symbol.iterator]() {
        return iterator;
      }, next() {
        if (map._state !== state) {
          throw Error("LinkedMap got modified during iteration.");
        }
        if (current) {
          const result = {value:current.key, done:!1};
          current = current.next;
          return result;
        }
        return {value:void 0, done:!0};
      }};
      return iterator;
    }
    values() {
      const map = this, state = this._state;
      let current = this._head;
      const iterator = {[Symbol.iterator]() {
        return iterator;
      }, next() {
        if (map._state !== state) {
          throw Error("LinkedMap got modified during iteration.");
        }
        if (current) {
          const result = {value:current.value, done:!1};
          current = current.next;
          return result;
        }
        return {value:void 0, done:!0};
      }};
      return iterator;
    }
    entries() {
      const map = this, state = this._state;
      let current = this._head;
      const iterator = {[Symbol.iterator]() {
        return iterator;
      }, next() {
        if (map._state !== state) {
          throw Error("LinkedMap got modified during iteration.");
        }
        if (current) {
          const result = {value:[current.key, current.value], done:!1};
          current = current.next;
          return result;
        }
        return {value:void 0, done:!0};
      }};
      return iterator;
    }
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (!(newSize >= this.size)) {
        if (newSize === 0) {
          this.clear();
        } else {
          for (var current = this._head, currentSize = this.size; current && currentSize > newSize;) {
            this._map.delete(current.key), current = current.next, currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          current && (current.previous = void 0);
          this._state++;
        }
      }
    }
    addItemFirst(item) {
      if (this._head || this._tail) {
        if (this._head) {
          item.next = this._head, this._head.previous = item;
        } else {
          throw Error("Invalid list");
        }
      } else {
        this._tail = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (this._head || this._tail) {
        if (this._tail) {
          item.previous = this._tail, this._tail.next = item;
        } else {
          throw Error("Invalid list");
        }
      } else {
        this._head = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._tail = this._head = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next, previous = item.previous;
        if (!next || !previous) {
          throw Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw Error("Invalid list");
      }
      if (touch === 1 || touch === 2) {
        if (touch === 1) {
          if (item !== this._head) {
            touch = item.next;
            var previous = item.previous;
            item === this._tail ? (previous.next = void 0, this._tail = previous) : (touch.previous = previous, previous.next = touch);
            item.previous = void 0;
            item.next = this._head;
            this._head = this._head.previous = item;
            this._state++;
          }
        } else {
          touch === 2 && item !== this._tail && (touch = item.next, previous = item.previous, item === this._head ? (touch.previous = void 0, this._head = touch) : (touch.previous = previous, previous.next = touch), item.next = void 0, item.previous = this._tail, this._tail = this._tail.next = item, this._state++);
        }
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value, key) => {
        data.push([key, value]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value] of data) {
        this.set(key, value);
      }
    }
  }
  class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get(key, touch = 2) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(key, 0);
    }
    set(key, value) {
      super.set(key, value, 2);
      this.checkTrim();
      return this;
    }
    checkTrim() {
      this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
    }
  }
  class BidirectionalMap {
    constructor(entries) {
      this._m1 = new Map();
      this._m2 = new Map();
      if (entries) {
        for (const [key, value] of entries) {
          this.set(key, value);
        }
      }
    }
    clear() {
      this._m1.clear();
      this._m2.clear();
    }
    set(key, value) {
      this._m1.set(key, value);
      this._m2.set(value, key);
    }
    get(key) {
      return this._m1.get(key);
    }
    getKey(value) {
      return this._m2.get(value);
    }
    delete(key) {
      const value = this._m1.get(key);
      if (value === void 0) {
        return !1;
      }
      this._m1.delete(key);
      this._m2.delete(value);
      return !0;
    }
    keys() {
      return this._m1.keys();
    }
    values() {
      return this._m1.values();
    }
  }
  class SetMap {
    constructor() {
      this.map = new Map();
    }
    add(key, value) {
      let values = this.map.get(key);
      values || (values = new Set(), this.map.set(key, values));
      values.add(value);
    }
    delete(key, value) {
      const values = this.map.get(key);
      values && (values.delete(value), values.size === 0 && this.map.delete(key));
    }
    forEach(key, fn) {
      (key = this.map.get(key)) && key.forEach(fn);
    }
    get(key) {
      return (key = this.map.get(key)) ? key : new Set();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$map.js.map
