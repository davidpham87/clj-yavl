shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$textModel = function(require, module, exports) {
  function createTextBufferFactory(text) {
    const builder = new require$_DOT__SLASH_pieceTreeTextBuffer_SLASH_pieceTreeTextBufferBuilder_DOT_js.PieceTreeTextBufferBuilder();
    builder.acceptChunk(text);
    return builder.finish();
  }
  function createTextBufferFactoryFromSnapshot(snapshot) {
    const builder = new require$_DOT__SLASH_pieceTreeTextBuffer_SLASH_pieceTreeTextBufferBuilder_DOT_js.PieceTreeTextBufferBuilder();
    let chunk;
    for (; typeof(chunk = snapshot.read()) === "string";) {
      builder.acceptChunk(chunk);
    }
    return builder.finish();
  }
  function createTextBuffer(value, defaultEOL) {
    return (typeof value === "string" ? createTextBufferFactory(value) : model.isITextSnapshot(value) ? createTextBufferFactoryFromSnapshot(value) : value).create(defaultEOL);
  }
  function isNodeInOverviewRuler(node) {
    return node.options.overviewRuler && node.options.overviewRuler.color ? !0 : !1;
  }
  function cleanClassName(className) {
    return className.replace(/[^a-z0-9\-_]/gi, " ");
  }
  function _normalizeOptions(options) {
    return options instanceof ModelDecorationOptions ? options : ModelDecorationOptions.createDynamic(options);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AttachedViews:{enumerable:!0, get:function() {
    return AttachedViews;
  }}, ModelDecorationGlyphMarginOptions:{enumerable:!0, get:function() {
    return ModelDecorationGlyphMarginOptions;
  }}, ModelDecorationInjectedTextOptions:{enumerable:!0, get:function() {
    return ModelDecorationInjectedTextOptions;
  }}, ModelDecorationMinimapOptions:{enumerable:!0, get:function() {
    return ModelDecorationMinimapOptions;
  }}, ModelDecorationOptions:{enumerable:!0, get:function() {
    return ModelDecorationOptions;
  }}, ModelDecorationOverviewRulerOptions:{enumerable:!0, get:function() {
    return ModelDecorationOverviewRulerOptions;
  }}, TextModel:{enumerable:!0, get:function() {
    return TextModel;
  }}, createTextBuffer:{enumerable:!0, get:function() {
    return createTextBuffer;
  }}, createTextBufferFactory:{enumerable:!0, get:function() {
    return createTextBufferFactory;
  }}, createTextBufferFactoryFromSnapshot:{enumerable:!0, get:function() {
    return createTextBufferFactoryFromSnapshot;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$color"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$uri"), require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$eolCounter"), require$_DOT__DOT__SLASH_core_SLASH_indentation_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$indentation"), require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$textModelDefaults");
  exports = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$language");
  var require$_DOT__DOT__SLASH_languages_SLASH_languageConfigurationRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfigurationRegistry"), model = require("module$node_modules$monaco_editor$esm$vs$editor$common$model"), require$_DOT__SLASH_bracketPairsTextModelPart_SLASH_bracketPairsImpl_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsImpl"), require$_DOT__SLASH_bracketPairsTextModelPart_SLASH_colorizedBracketPairsDecorationProvider_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$colorizedBracketPairsDecorationProvider"), require$_DOT__SLASH_editStack_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$editStack"), require$_DOT__SLASH_guidesTextModelPart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$guidesTextModelPart"), require$_DOT__SLASH_indentationGuesser_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$indentationGuesser"), 
  require$_DOT__SLASH_intervalTree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$intervalTree"), require$_DOT__SLASH_pieceTreeTextBuffer_SLASH_pieceTreeTextBuffer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBuffer"), require$_DOT__SLASH_pieceTreeTextBuffer_SLASH_pieceTreeTextBufferBuilder_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeTextBufferBuilder"), 
  require$_DOT__SLASH_textModelSearch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelSearch"), require$_DOT__SLASH_tokenizationTextModelPart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$tokenizationTextModelPart"), require$_DOT__DOT__SLASH_textModelEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents");
  require = require("module$node_modules$monaco_editor$esm$vs$platform$undoRedo$common$undoRedo");
  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }, TextModel_1;
  let MODEL_ID = 0;
  class TextModelSnapshot {
    constructor(source) {
      this._source = source;
      this._eos = !1;
    }
    read() {
      if (this._eos) {
        return null;
      }
      const result = [];
      let resultCnt = 0, resultLength = 0;
      do {
        const tmp = this._source.read();
        if (tmp === null) {
          return this._eos = !0, resultCnt === 0 ? null : result.join("");
        }
        tmp.length > 0 && (result[resultCnt++] = tmp, resultLength += tmp.length);
        if (resultLength >= 65536) {
          return result.join("");
        }
      } while (1);
    }
  }
  const invalidFunc = () => {
    throw Error("Invalid change accessor");
  };
  let TextModel = TextModel_1 = class extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    static resolveOptions(textBuffer, options) {
      return options.detectIndentation ? (textBuffer = (0,require$_DOT__SLASH_indentationGuesser_DOT_js.guessIndentation)(textBuffer, options.tabSize, options.insertSpaces), new model.TextModelResolvedOptions({tabSize:textBuffer.tabSize, indentSize:"tabSize", insertSpaces:textBuffer.insertSpaces, trimAutoWhitespace:options.trimAutoWhitespace, defaultEOL:options.defaultEOL, bracketPairColorizationOptions:options.bracketPairColorizationOptions})) : new model.TextModelResolvedOptions(options);
    }
    get onDidChangeLanguage() {
      return this._tokenizationTextModelPart.onDidChangeLanguage;
    }
    get onDidChangeLanguageConfiguration() {
      return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
    }
    get onDidChangeTokens() {
      return this._tokenizationTextModelPart.onDidChangeTokens;
    }
    onDidChangeContent(listener) {
      return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));
    }
    onDidChangeContentOrInjectedText(listener) {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.combinedDisposable)(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));
    }
    _isDisposing() {
      return this.__isDisposing;
    }
    get tokenization() {
      return this._tokenizationTextModelPart;
    }
    get bracketPairs() {
      return this._bracketPairs;
    }
    get guides() {
      return this._guidesTextModelPart;
    }
    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {
      super();
      this._undoRedoService = _undoRedoService;
      this._languageService = _languageService;
      this._languageConfigurationService = _languageConfigurationService;
      this._onWillDispose = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onWillDispose = this._onWillDispose.event;
      this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));
      this.onDidChangeDecorations = this._onDidChangeDecorations.event;
      this._onDidChangeOptions = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeOptions = this._onDidChangeOptions.event;
      this._onDidChangeAttached = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeAttached = this._onDidChangeAttached.event;
      this._onDidChangeInjectedText = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this._eventEmitter = this._register(new DidChangeContentEmitter());
      this._languageSelectionListener = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.MutableDisposable());
      this._deltaDecorationCallCnt = 0;
      this._attachedViews = new AttachedViews();
      MODEL_ID++;
      this.id = "$model" + MODEL_ID;
      this.isForSimpleWidget = creationOptions.isForSimpleWidget;
      this._associatedResource = typeof associatedResource === "undefined" || associatedResource === null ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_uri_DOT_js.URI.parse("inmemory://model/" + MODEL_ID) : associatedResource;
      this._attachedEditorCount = 0;
      const {textBuffer, disposable} = createTextBuffer(source, creationOptions.defaultEOL);
      this._buffer = textBuffer;
      this._bufferDisposable = disposable;
      this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);
      source = typeof languageIdOrSelection === "string" ? languageIdOrSelection : languageIdOrSelection.languageId;
      typeof languageIdOrSelection !== "string" && (this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId)));
      this._bracketPairs = this._register(new require$_DOT__SLASH_bracketPairsTextModelPart_SLASH_bracketPairsImpl_DOT_js.BracketPairsTextModelPart(this, this._languageConfigurationService));
      this._guidesTextModelPart = this._register(new require$_DOT__SLASH_guidesTextModelPart_DOT_js.GuidesTextModelPart(this, this._languageConfigurationService));
      this._decorationProvider = this._register(new require$_DOT__SLASH_bracketPairsTextModelPart_SLASH_colorizedBracketPairsDecorationProvider_DOT_js.ColorizedBracketPairsDecorationProvider(this));
      this._tokenizationTextModelPart = new require$_DOT__SLASH_tokenizationTextModelPart_DOT_js.TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, source, this._attachedViews);
      associatedResource = this._buffer.getLineCount();
      _undoRedoService = this._buffer.getValueLengthInRange(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, associatedResource, this._buffer.getLineLength(associatedResource) + 1), 0);
      creationOptions.largeFileOptimizations ? (this._isTooLargeForTokenization = _undoRedoService > TextModel_1.LARGE_FILE_SIZE_THRESHOLD || associatedResource > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD, this._isTooLargeForHeapOperation = _undoRedoService > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD) : this._isTooLargeForHeapOperation = this._isTooLargeForTokenization = !1;
      this._isTooLargeForSyncing = _undoRedoService > TextModel_1._MODEL_SYNC_LIMIT;
      this._alternativeVersionId = this._versionId = 1;
      this._initialUndoRedoSnapshot = null;
      this.__isDisposing = this._isDisposed = !1;
      this._instanceId = strings.singleLetterHash(MODEL_ID);
      this._lastDecorationId = 0;
      this._decorations = Object.create(null);
      this._decorationsTree = new DecorationsTrees();
      this._commandManager = new require$_DOT__SLASH_editStack_DOT_js.EditStack(this, this._undoRedoService);
      this._isRedoing = this._isUndoing = !1;
      this._trimAutoWhitespaceLines = null;
      this._register(this._decorationProvider.onDidChange(() => {
        this._onDidChangeDecorations.beginDeferredEmit();
        this._onDidChangeDecorations.fire();
        this._onDidChangeDecorations.endDeferredEmit();
      }));
      this._languageService.requestRichLanguageFeatures(source);
    }
    dispose() {
      this.__isDisposing = !0;
      this._onWillDispose.fire();
      this._tokenizationTextModelPart.dispose();
      this._isDisposed = !0;
      super.dispose();
      this._bufferDisposable.dispose();
      this.__isDisposing = !1;
      const emptyDisposedTextBuffer = new require$_DOT__SLASH_pieceTreeTextBuffer_SLASH_pieceTreeTextBuffer_DOT_js.PieceTreeTextBuffer([], "", "\n", !1, !1, !0, !0);
      emptyDisposedTextBuffer.dispose();
      this._buffer = emptyDisposedTextBuffer;
      this._bufferDisposable = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
    }
    _assertNotDisposed() {
      if (this._isDisposed) {
        throw Error("Model is disposed!");
      }
    }
    _emitContentChangedEvent(rawChange, change) {
      this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(change), this._bracketPairs.handleDidChangeContent(change), this._eventEmitter.fire(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.InternalModelContentChangeEvent(rawChange, change)));
    }
    setValue(value) {
      this._assertNotDisposed();
      if (value === null || value === void 0) {
        throw (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.illegalArgument)();
      }
      const {textBuffer, disposable} = createTextBuffer(value, this._options.defaultEOL);
      this._setValueFromTextBuffer(textBuffer, disposable);
    }
    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {
      return {changes:[{range, rangeOffset, rangeLength, text}], eol:this._buffer.getEOL(), isEolChange, versionId:this.getVersionId(), isUndoing, isRedoing, isFlush};
    }
    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {
      this._assertNotDisposed();
      var oldFullModelRange = this.getFullModelRange();
      oldFullModelRange = this.getValueLengthInRange(oldFullModelRange);
      const endLineNumber = this.getLineCount(), endColumn = this.getLineMaxColumn(endLineNumber);
      this._buffer = textBuffer;
      this._bufferDisposable.dispose();
      this._bufferDisposable = textBufferDisposable;
      this._increaseVersionId();
      this._decorations = Object.create(null);
      this._decorationsTree = new DecorationsTrees();
      this._commandManager.clear();
      this._trimAutoWhitespaceLines = null;
      this._emitContentChangedEvent(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawContentChangedEvent([new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawFlush()], this._versionId, !1, !1), this._createContentChanged2(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, endLineNumber, endColumn), 0, oldFullModelRange, this.getValue(), !1, !1, !0, !1));
    }
    setEOL(eol) {
      this._assertNotDisposed();
      eol = eol === 1 ? "\r\n" : "\n";
      if (this._buffer.getEOL() !== eol) {
        var oldFullModelRange = this.getFullModelRange();
        oldFullModelRange = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount(), endColumn = this.getLineMaxColumn(endLineNumber);
        this._onBeforeEOLChange();
        this._buffer.setEOL(eol);
        this._increaseVersionId();
        this._onAfterEOLChange();
        this._emitContentChangedEvent(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawContentChangedEvent([new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawEOLChanged()], this._versionId, !1, !1), this._createContentChanged2(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, endLineNumber, endColumn), 0, oldFullModelRange, this.getValue(), !1, !1, !1, !0));
      }
    }
    _onBeforeEOLChange() {
      this._decorationsTree.ensureAllNodesHaveRanges(this);
    }
    _onAfterEOLChange() {
      const versionId = this.getVersionId(), allDecorations = this._decorationsTree.collectNodesPostOrder();
      for (let i = 0, len = allDecorations.length; i < len; i++) {
        const node = allDecorations[i];
        var range = node.range;
        const delta = node.cachedAbsoluteStart - node.start, startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);
        range = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
        node.cachedAbsoluteStart = startOffset;
        node.cachedAbsoluteEnd = range;
        node.cachedVersionId = versionId;
        node.start = startOffset - delta;
        node.end = range - delta;
        (0,require$_DOT__SLASH_intervalTree_DOT_js.recomputeMaxEnd)(node);
      }
    }
    onBeforeAttached() {
      this._attachedEditorCount++;
      this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0));
      return this._attachedViews.attachView();
    }
    onBeforeDetached(view) {
      this._attachedEditorCount--;
      this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0));
      this._attachedViews.detachView(view);
    }
    isAttachedToEditor() {
      return this._attachedEditorCount > 0;
    }
    getAttachedEditorCount() {
      return this._attachedEditorCount;
    }
    isTooLargeForSyncing() {
      return this._isTooLargeForSyncing;
    }
    isTooLargeForTokenization() {
      return this._isTooLargeForTokenization;
    }
    isTooLargeForHeapOperation() {
      return this._isTooLargeForHeapOperation;
    }
    isDisposed() {
      return this._isDisposed;
    }
    isDominatedByLongLines() {
      this._assertNotDisposed();
      if (this.isTooLargeForTokenization()) {
        return !1;
      }
      let smallLineCharCount = 0, longLineCharCount = 0;
      const lineCount = this._buffer.getLineCount();
      for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
        const lineLength = this._buffer.getLineLength(lineNumber);
        lineLength >= 10000 ? longLineCharCount += lineLength : smallLineCharCount += lineLength;
      }
      return longLineCharCount > smallLineCharCount;
    }
    get uri() {
      return this._associatedResource;
    }
    getOptions() {
      this._assertNotDisposed();
      return this._options;
    }
    getFormattingOptions() {
      return {tabSize:this._options.indentSize, insertSpaces:this._options.insertSpaces};
    }
    updateOptions(_newOpts) {
      this._assertNotDisposed();
      _newOpts = new model.TextModelResolvedOptions({tabSize:typeof _newOpts.tabSize !== "undefined" ? _newOpts.tabSize : this._options.tabSize, indentSize:typeof _newOpts.indentSize !== "undefined" ? _newOpts.indentSize : this._options.originalIndentSize, insertSpaces:typeof _newOpts.insertSpaces !== "undefined" ? _newOpts.insertSpaces : this._options.insertSpaces, defaultEOL:this._options.defaultEOL, trimAutoWhitespace:typeof _newOpts.trimAutoWhitespace !== "undefined" ? _newOpts.trimAutoWhitespace : 
      this._options.trimAutoWhitespace, bracketPairColorizationOptions:typeof _newOpts.bracketColorizationOptions !== "undefined" ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions});
      if (!this._options.equals(_newOpts)) {
        var e = this._options.createChangeEvent(_newOpts);
        this._options = _newOpts;
        this._bracketPairs.handleDidChangeOptions(e);
        this._decorationProvider.handleDidChangeOptions(e);
        this._onDidChangeOptions.fire(e);
      }
    }
    detectIndentation(defaultInsertSpaces, defaultTabSize) {
      this._assertNotDisposed();
      defaultInsertSpaces = (0,require$_DOT__SLASH_indentationGuesser_DOT_js.guessIndentation)(this._buffer, defaultTabSize, defaultInsertSpaces);
      this.updateOptions({insertSpaces:defaultInsertSpaces.insertSpaces, tabSize:defaultInsertSpaces.tabSize, indentSize:defaultInsertSpaces.tabSize});
    }
    normalizeIndentation(str) {
      this._assertNotDisposed();
      return (0,require$_DOT__DOT__SLASH_core_SLASH_indentation_DOT_js.normalizeIndentation)(str, this._options.indentSize, this._options.insertSpaces);
    }
    getVersionId() {
      this._assertNotDisposed();
      return this._versionId;
    }
    mightContainRTL() {
      return this._buffer.mightContainRTL();
    }
    mightContainUnusualLineTerminators() {
      return this._buffer.mightContainUnusualLineTerminators();
    }
    removeUnusualLineTerminators(selections = null) {
      const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, !1, !0, !1, null, !1, 1073741824);
      this._buffer.resetMightContainUnusualLineTerminators();
      this.pushEditOperations(selections, matches.map(m => ({range:m.range, text:null})), () => null);
    }
    mightContainNonBasicASCII() {
      return this._buffer.mightContainNonBasicASCII();
    }
    getAlternativeVersionId() {
      this._assertNotDisposed();
      return this._alternativeVersionId;
    }
    getInitialUndoRedoSnapshot() {
      this._assertNotDisposed();
      return this._initialUndoRedoSnapshot;
    }
    getOffsetAt(rawPosition) {
      this._assertNotDisposed();
      rawPosition = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0);
      return this._buffer.getOffsetAt(rawPosition.lineNumber, rawPosition.column);
    }
    getPositionAt(rawOffset) {
      this._assertNotDisposed();
      rawOffset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));
      return this._buffer.getPositionAt(rawOffset);
    }
    _increaseVersionId() {
      this._alternativeVersionId = this._versionId += 1;
    }
    _overwriteVersionId(versionId) {
      this._versionId = versionId;
    }
    _overwriteAlternativeVersionId(newAlternativeVersionId) {
      this._alternativeVersionId = newAlternativeVersionId;
    }
    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {
      this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;
    }
    getValue(eol, preserveBOM = !1) {
      this._assertNotDisposed();
      if (this.isTooLargeForHeapOperation()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Operation would exceed heap memory limits");
      }
      const fullModelRange = this.getFullModelRange();
      eol = this.getValueInRange(fullModelRange, eol);
      return preserveBOM ? this._buffer.getBOM() + eol : eol;
    }
    createSnapshot(preserveBOM = !1) {
      return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
    }
    getValueLength(eol, preserveBOM = !1) {
      this._assertNotDisposed();
      const fullModelRange = this.getFullModelRange();
      eol = this.getValueLengthInRange(fullModelRange, eol);
      return preserveBOM ? this._buffer.getBOM().length + eol : eol;
    }
    getValueInRange(rawRange, eol = 0) {
      this._assertNotDisposed();
      return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
    }
    getValueLengthInRange(rawRange, eol = 0) {
      this._assertNotDisposed();
      return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
    }
    getCharacterCountInRange(rawRange, eol = 0) {
      this._assertNotDisposed();
      return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);
    }
    getLineCount() {
      this._assertNotDisposed();
      return this._buffer.getLineCount();
    }
    getLineContent(lineNumber) {
      this._assertNotDisposed();
      if (lineNumber < 1 || lineNumber > this.getLineCount()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      return this._buffer.getLineContent(lineNumber);
    }
    getLineLength(lineNumber) {
      this._assertNotDisposed();
      if (lineNumber < 1 || lineNumber > this.getLineCount()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      return this._buffer.getLineLength(lineNumber);
    }
    getLinesContent() {
      this._assertNotDisposed();
      if (this.isTooLargeForHeapOperation()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Operation would exceed heap memory limits");
      }
      return this._buffer.getLinesContent();
    }
    getEOL() {
      this._assertNotDisposed();
      return this._buffer.getEOL();
    }
    getEndOfLineSequence() {
      this._assertNotDisposed();
      return this._buffer.getEOL() === "\n" ? 0 : 1;
    }
    getLineMinColumn(lineNumber) {
      this._assertNotDisposed();
      return 1;
    }
    getLineMaxColumn(lineNumber) {
      this._assertNotDisposed();
      if (lineNumber < 1 || lineNumber > this.getLineCount()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      return this._buffer.getLineLength(lineNumber) + 1;
    }
    getLineFirstNonWhitespaceColumn(lineNumber) {
      this._assertNotDisposed();
      if (lineNumber < 1 || lineNumber > this.getLineCount()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
    }
    getLineLastNonWhitespaceColumn(lineNumber) {
      this._assertNotDisposed();
      if (lineNumber < 1 || lineNumber > this.getLineCount()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
      return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
    }
    _validateRangeRelaxedNoAllocations(range) {
      var linesCount = this._buffer.getLineCount();
      const initialStartLineNumber = range.startLineNumber, initialStartColumn = range.startColumn;
      let startLineNumber = Math.floor(typeof initialStartLineNumber !== "number" || isNaN(initialStartLineNumber) ? 1 : initialStartLineNumber), startColumn = Math.floor(typeof initialStartColumn !== "number" || isNaN(initialStartColumn) ? 1 : initialStartColumn);
      if (startLineNumber < 1) {
        startColumn = startLineNumber = 1;
      } else if (startLineNumber > linesCount) {
        startLineNumber = linesCount, startColumn = this.getLineMaxColumn(startLineNumber);
      } else {
        if (startColumn <= 1) {
          startColumn = 1;
        } else {
          var maxColumn = this.getLineMaxColumn(startLineNumber);
          startColumn >= maxColumn && (startColumn = maxColumn);
        }
      }
      maxColumn = range.endLineNumber;
      const initialEndColumn = range.endColumn;
      let endLineNumber = Math.floor(typeof maxColumn !== "number" || isNaN(maxColumn) ? 1 : maxColumn), endColumn = Math.floor(typeof initialEndColumn !== "number" || isNaN(initialEndColumn) ? 1 : initialEndColumn);
      endLineNumber < 1 ? endColumn = endLineNumber = 1 : endLineNumber > linesCount ? (endLineNumber = linesCount, endColumn = this.getLineMaxColumn(endLineNumber)) : endColumn <= 1 ? endColumn = 1 : (linesCount = this.getLineMaxColumn(endLineNumber), endColumn >= linesCount && (endColumn = linesCount));
      return initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && maxColumn === endLineNumber && initialEndColumn === endColumn && range instanceof require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range && !(range instanceof require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection) ? range : new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    _isValidPosition(lineNumber, column, validationType) {
      if (typeof lineNumber !== "number" || typeof column !== "number" || isNaN(lineNumber) || isNaN(column) || lineNumber < 1 || column < 1 || (lineNumber | 0) !== lineNumber || (column | 0) !== column) {
        return !1;
      }
      var lineCount = this._buffer.getLineCount();
      if (lineNumber > lineCount) {
        return !1;
      }
      if (column === 1) {
        return !0;
      }
      lineCount = this.getLineMaxColumn(lineNumber);
      return column > lineCount || validationType === 1 && (lineNumber = this._buffer.getLineCharCode(lineNumber, column - 2), strings.isHighSurrogate(lineNumber)) ? !1 : !0;
    }
    _validatePosition(_lineNumber, _column, validationType) {
      _lineNumber = Math.floor(typeof _lineNumber !== "number" || isNaN(_lineNumber) ? 1 : _lineNumber);
      _column = Math.floor(typeof _column !== "number" || isNaN(_column) ? 1 : _column);
      var lineCount = this._buffer.getLineCount();
      if (_lineNumber < 1) {
        return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(1, 1);
      }
      if (_lineNumber > lineCount) {
        return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineCount, this.getLineMaxColumn(lineCount));
      }
      if (_column <= 1) {
        return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_lineNumber, 1);
      }
      lineCount = this.getLineMaxColumn(_lineNumber);
      return _column >= lineCount ? new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_lineNumber, lineCount) : validationType === 1 && (validationType = this._buffer.getLineCharCode(_lineNumber, _column - 2), strings.isHighSurrogate(validationType)) ? new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_lineNumber, _column - 1) : new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(_lineNumber, _column);
    }
    validatePosition(position) {
      this._assertNotDisposed();
      return position instanceof require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position && this._isValidPosition(position.lineNumber, position.column, 1) ? position : this._validatePosition(position.lineNumber, position.column, 1);
    }
    _isValidRange(range, validationType) {
      const startLineNumber = range.startLineNumber, startColumn = range.startColumn;
      var endLineNumber = range.endLineNumber;
      range = range.endColumn;
      return this._isValidPosition(startLineNumber, startColumn, 0) && this._isValidPosition(endLineNumber, range, 0) ? validationType === 1 ? (validationType = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0, endLineNumber = range > 1 && range <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, range - 2) : 0, validationType = strings.isHighSurrogate(validationType), endLineNumber = strings.isHighSurrogate(endLineNumber), 
      validationType || endLineNumber ? !1 : !0) : !0 : !1;
    }
    validateRange(_range) {
      this._assertNotDisposed();
      if (_range instanceof require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range && !(_range instanceof require$_DOT__DOT__SLASH_core_SLASH_selection_DOT_js.Selection) && this._isValidRange(_range, 1)) {
        return _range;
      }
      var start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0), end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0);
      _range = start.lineNumber;
      start = start.column;
      const endLineNumber = end.lineNumber;
      end = end.column;
      var charCodeBeforeStart = start > 1 ? this._buffer.getLineCharCode(_range, start - 2) : 0, charCodeBeforeEnd = end > 1 && end <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, end - 2) : 0;
      charCodeBeforeStart = strings.isHighSurrogate(charCodeBeforeStart);
      charCodeBeforeEnd = strings.isHighSurrogate(charCodeBeforeEnd);
      return charCodeBeforeStart || charCodeBeforeEnd ? _range === endLineNumber && start === end ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_range, start - 1, endLineNumber, end - 1) : charCodeBeforeStart && charCodeBeforeEnd ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_range, start - 1, endLineNumber, end + 1) : charCodeBeforeStart ? new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_range, start - 1, endLineNumber, end) : new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_range, 
      start, endLineNumber, end + 1) : new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_range, start, endLineNumber, end);
    }
    modifyPosition(rawPosition, offset) {
      this._assertNotDisposed();
      rawPosition = this.getOffsetAt(rawPosition) + offset;
      return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, rawPosition)));
    }
    getFullModelRange() {
      this._assertNotDisposed();
      const lineCount = this.getLineCount();
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
    }
    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
      return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    }
    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = 999) {
      this._assertNotDisposed();
      let searchRanges = null;
      rawSearchScope !== null && (Array.isArray(rawSearchScope) || (rawSearchScope = [rawSearchScope]), rawSearchScope.every(searchScope => require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.isIRange(searchScope)) && (searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope))));
      searchRanges === null && (searchRanges = [this.getFullModelRange()]);
      searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);
      const uniqueSearchRanges = [];
      uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {
        if (require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.areIntersecting(prev, curr)) {
          return prev.plusRange(curr);
        }
        uniqueSearchRanges.push(prev);
        return curr;
      }));
      if (!isRegex && searchString.indexOf("\n") < 0) {
        const searchData = (new require$_DOT__SLASH_textModelSearch_DOT_js.SearchParams(searchString, isRegex, matchCase, wordSeparators)).parseSearchRequest();
        if (!searchData) {
          return [];
        }
        rawSearchScope = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
      } else {
        rawSearchScope = searchRange => require$_DOT__SLASH_textModelSearch_DOT_js.TextModelSearch.findMatches(this, new require$_DOT__SLASH_textModelSearch_DOT_js.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);
      }
      return uniqueSearchRanges.map(rawSearchScope).reduce((arr, matches) => arr.concat(matches), []);
    }
    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
      this._assertNotDisposed();
      rawSearchStart = this.validatePosition(rawSearchStart);
      if (!isRegex && searchString.indexOf("\n") < 0) {
        const searchData = (new require$_DOT__SLASH_textModelSearch_DOT_js.SearchParams(searchString, isRegex, matchCase, wordSeparators)).parseSearchRequest();
        if (!searchData) {
          return null;
        }
        var lineCount = this.getLineCount();
        lineCount = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(rawSearchStart.lineNumber, rawSearchStart.column, lineCount, this.getLineMaxColumn(lineCount));
        lineCount = this.findMatchesLineByLine(lineCount, searchData, captureMatches, 1);
        require$_DOT__SLASH_textModelSearch_DOT_js.TextModelSearch.findNextMatch(this, new require$_DOT__SLASH_textModelSearch_DOT_js.SearchParams(searchString, isRegex, matchCase, wordSeparators), rawSearchStart, captureMatches);
        if (lineCount.length > 0) {
          return lineCount[0];
        }
        lineCount = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, rawSearchStart.lineNumber, this.getLineMaxColumn(rawSearchStart.lineNumber));
        lineCount = this.findMatchesLineByLine(lineCount, searchData, captureMatches, 1);
        return lineCount.length > 0 ? lineCount[0] : null;
      }
      return require$_DOT__SLASH_textModelSearch_DOT_js.TextModelSearch.findNextMatch(this, new require$_DOT__SLASH_textModelSearch_DOT_js.SearchParams(searchString, isRegex, matchCase, wordSeparators), rawSearchStart, captureMatches);
    }
    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
      this._assertNotDisposed();
      rawSearchStart = this.validatePosition(rawSearchStart);
      return require$_DOT__SLASH_textModelSearch_DOT_js.TextModelSearch.findPreviousMatch(this, new require$_DOT__SLASH_textModelSearch_DOT_js.SearchParams(searchString, isRegex, matchCase, wordSeparators), rawSearchStart, captureMatches);
    }
    pushStackElement() {
      this._commandManager.pushStackElement();
    }
    popStackElement() {
      this._commandManager.popStackElement();
    }
    pushEOL(eol) {
      if ((this.getEOL() === "\n" ? 0 : 1) !== eol) {
        try {
          this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(eol);
        } finally {
          this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
        }
      }
    }
    _validateEditOperation(rawOperation) {
      return rawOperation instanceof model.ValidAnnotatedEditOperation ? rawOperation : new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || !1, rawOperation.isAutoWhitespaceEdit || !1, rawOperation._isTracked || !1);
    }
    _validateEditOperations(rawOperations) {
      const result = [];
      for (let i = 0, len = rawOperations.length; i < len; i++) {
        result[i] = this._validateEditOperation(rawOperations[i]);
      }
      return result;
    }
    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {
      try {
        return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {
      if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
        const incomingEdits = editOperations.map(op => ({range:this.validateRange(op.range), text:op.text}));
        var editsAreNearCursors = !0;
        if (beforeCursorState) {
          for (let i = 0, len = beforeCursorState.length; i < len; i++) {
            var sel = beforeCursorState[i], foundEditNearSel = !1;
            for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
              var editRange = incomingEdits[j].range, selIsBelow = sel.startLineNumber > editRange.endLineNumber;
              if (!(editRange.startLineNumber > sel.endLineNumber || selIsBelow)) {
                foundEditNearSel = !0;
                break;
              }
            }
            if (!foundEditNearSel) {
              editsAreNearCursors = !1;
              break;
            }
          }
        }
        if (editsAreNearCursors) {
          for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
            editsAreNearCursors = this._trimAutoWhitespaceLines[i];
            sel = this.getLineMaxColumn(editsAreNearCursors);
            foundEditNearSel = !0;
            for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
              if (editRange = incomingEdits[j].range, selIsBelow = incomingEdits[j].text, !(editsAreNearCursors < editRange.startLineNumber || editsAreNearCursors > editRange.endLineNumber || editsAreNearCursors === editRange.startLineNumber && editRange.startColumn === sel && editRange.isEmpty() && selIsBelow && selIsBelow.length > 0 && selIsBelow.charAt(0) === "\n" || editsAreNearCursors === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && selIsBelow && selIsBelow.length > 
              0 && selIsBelow.charAt(selIsBelow.length - 1) === "\n")) {
                foundEditNearSel = !1;
                break;
              }
            }
            foundEditNearSel && (editsAreNearCursors = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(editsAreNearCursors, 1, editsAreNearCursors, sel), editOperations.push(new model.ValidAnnotatedEditOperation(null, editsAreNearCursors, null, !1, !1, !1)));
          }
        }
        this._trimAutoWhitespaceLines = null;
      }
      this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri));
      return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);
    }
    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
      changes = changes.map(change => {
        const rangeStart = this.getPositionAt(change.newPosition), rangeEnd = this.getPositionAt(change.newEnd);
        return {range:new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column), text:change.oldText};
      });
      this._applyUndoRedoEdits(changes, eol, !0, !1, resultingAlternativeVersionId, resultingSelection);
    }
    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
      changes = changes.map(change => {
        const rangeStart = this.getPositionAt(change.oldPosition), rangeEnd = this.getPositionAt(change.oldEnd);
        return {range:new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column), text:change.newText};
      });
      this._applyUndoRedoEdits(changes, eol, !1, !0, resultingAlternativeVersionId, resultingSelection);
    }
    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = isUndoing, this._isRedoing = isRedoing, this.applyEdits(edits, !1), this.setEOL(eol), this._overwriteAlternativeVersionId(resultingAlternativeVersionId);
      } finally {
        this._isRedoing = this._isUndoing = !1, this._eventEmitter.endDeferredEmit(resultingSelection), this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    applyEdits(rawOperations, computeUndoEdits = !1) {
      try {
        this._onDidChangeDecorations.beginDeferredEmit();
        this._eventEmitter.beginDeferredEmit();
        const operations = this._validateEditOperations(rawOperations);
        return this._doApplyEdits(operations, computeUndoEdits);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _doApplyEdits(rawOperations, computeUndoEdits) {
      var oldLineCount = this._buffer.getLineCount();
      rawOperations = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);
      computeUndoEdits = this._buffer.getLineCount();
      const contentChanges = rawOperations.changes;
      this._trimAutoWhitespaceLines = rawOperations.trimAutoWhitespaceLineNumbers;
      if (contentChanges.length !== 0) {
        for (let i = 0, len = contentChanges.length; i < len; i++) {
          var change = contentChanges[i];
          this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
        }
        change = [];
        this._increaseVersionId();
        for (let i = 0, len = contentChanges.length; i < len; i++) {
          var change$jscomp$0 = contentChanges[i], [eolCount] = (0,require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(change$jscomp$0.text);
          this._onDidChangeDecorations.fire();
          const startLineNumber = change$jscomp$0.range.startLineNumber;
          var endLineNumber = change$jscomp$0.range.endLineNumber, deletingLinesCnt = endLineNumber - startLineNumber, editingLinesCnt = Math.min(deletingLinesCnt, eolCount);
          change$jscomp$0 = eolCount - deletingLinesCnt;
          var currentEditStartLineNumber = computeUndoEdits - oldLineCount - change$jscomp$0 + startLineNumber, lastInsertedLineNumber = currentEditStartLineNumber + eolCount;
          lastInsertedLineNumber = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(currentEditStartLineNumber, 1)), this.getOffsetAt(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);
          lastInsertedLineNumber = require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText.fromDecorations(lastInsertedLineNumber);
          var injectedTextInEditedRangeQueue = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.ArrayQueue(lastInsertedLineNumber);
          for (var j = editingLinesCnt; j >= 0; j--) {
            const editLineNumber = startLineNumber + j, currentEditLineNumber = currentEditStartLineNumber + j;
            injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);
            const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);
            change.push(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));
          }
          editingLinesCnt < deletingLinesCnt && change.push(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawLinesDeleted(startLineNumber + editingLinesCnt + 1, endLineNumber));
          if (editingLinesCnt < eolCount) {
            endLineNumber = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.ArrayQueue(lastInsertedLineNumber);
            deletingLinesCnt = startLineNumber + editingLinesCnt;
            editingLinesCnt = eolCount - editingLinesCnt;
            currentEditStartLineNumber = computeUndoEdits - oldLineCount - editingLinesCnt + deletingLinesCnt + 1;
            lastInsertedLineNumber = [];
            injectedTextInEditedRangeQueue = [];
            for (j = 0; j < editingLinesCnt; j++) {
              const lineNumber = currentEditStartLineNumber + j;
              injectedTextInEditedRangeQueue[j] = this.getLineContent(lineNumber);
              endLineNumber.takeWhile(r => r.lineNumber < lineNumber);
              lastInsertedLineNumber[j] = endLineNumber.takeWhile(r => r.lineNumber === lineNumber);
            }
            change.push(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawLinesInserted(deletingLinesCnt + 1, startLineNumber + eolCount, injectedTextInEditedRangeQueue, lastInsertedLineNumber));
          }
          oldLineCount += change$jscomp$0;
        }
        this._emitContentChangedEvent(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawContentChangedEvent(change, this.getVersionId(), this._isUndoing, this._isRedoing), {changes:contentChanges, eol:this._buffer.getEOL(), isEolChange:!1, versionId:this.getVersionId(), isUndoing:this._isUndoing, isRedoing:this._isRedoing, isFlush:!1});
      }
      return rawOperations.reverseEdits === null ? void 0 : rawOperations.reverseEdits;
    }
    undo() {
      return this._undoRedoService.undo(this.uri);
    }
    canUndo() {
      return this._undoRedoService.canUndo(this.uri);
    }
    redo() {
      return this._undoRedoService.redo(this.uri);
    }
    canRedo() {
      return this._undoRedoService.canRedo(this.uri);
    }
    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {
      affectedInjectedTextLines !== null && affectedInjectedTextLines.size !== 0 && (affectedInjectedTextLines = Array.from(affectedInjectedTextLines).map(lineNumber => new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber))), this._onDidChangeInjectedText.fire(new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.ModelInjectedTextChangedEvent(affectedInjectedTextLines)));
    }
    changeDecorations(callback, ownerId = 0) {
      this._assertNotDisposed();
      try {
        return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(ownerId, callback);
      } finally {
        this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _changeDecorations(ownerId, callback) {
      const changeAccessor = {addDecoration:(range, options) => this._deltaDecorationsImpl(ownerId, [], [{range, options}])[0], changeDecoration:(id, newRange) => {
        this._changeDecorationImpl(id, newRange);
      }, changeDecorationOptions:(id, options) => {
        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));
      }, removeDecoration:id => {
        this._deltaDecorationsImpl(ownerId, [id], []);
      }, deltaDecorations:(oldDecorations, newDecorations) => oldDecorations.length === 0 && newDecorations.length === 0 ? [] : this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations)};
      let result = null;
      try {
        result = callback(changeAccessor);
      } catch (e) {
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e);
      }
      changeAccessor.addDecoration = invalidFunc;
      changeAccessor.changeDecoration = invalidFunc;
      changeAccessor.changeDecorationOptions = invalidFunc;
      changeAccessor.removeDecoration = invalidFunc;
      changeAccessor.deltaDecorations = invalidFunc;
      return result;
    }
    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {
      this._assertNotDisposed();
      oldDecorations ||= [];
      if (oldDecorations.length === 0 && newDecorations.length === 0) {
        return [];
      }
      try {
        return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
      } finally {
        this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
      }
    }
    _getTrackedRange(id) {
      return this.getDecorationRange(id);
    }
    _setTrackedRange(id, newRange, newStickiness) {
      id = id ? this._decorations[id] : null;
      if (!id) {
        return newRange ? this._deltaDecorationsImpl(0, [], [{range:newRange, options:TRACKED_RANGE_OPTIONS[newStickiness]}], !0)[0] : null;
      }
      if (!newRange) {
        return this._decorationsTree.delete(id), delete this._decorations[id.id], null;
      }
      newRange = this._validateRangeRelaxedNoAllocations(newRange);
      const startOffset = this._buffer.getOffsetAt(newRange.startLineNumber, newRange.startColumn), endOffset = this._buffer.getOffsetAt(newRange.endLineNumber, newRange.endColumn);
      this._decorationsTree.delete(id);
      id.reset(this.getVersionId(), startOffset, endOffset, newRange);
      id.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
      this._decorationsTree.insert(id);
      return id.id;
    }
    removeAllDecorationsWithOwnerId(ownerId) {
      if (!this._isDisposed) {
        ownerId = this._decorationsTree.collectNodesFromOwner(ownerId);
        for (let i = 0, len = ownerId.length; i < len; i++) {
          const node = ownerId[i];
          this._decorationsTree.delete(node);
          delete this._decorations[node.id];
        }
      }
    }
    getDecorationOptions(decorationId) {
      return (decorationId = this._decorations[decorationId]) ? decorationId.options : null;
    }
    getDecorationRange(decorationId) {
      return (decorationId = this._decorations[decorationId]) ? this._decorationsTree.getNodeRange(this, decorationId) : null;
    }
    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = !1) {
      return lineNumber < 1 || lineNumber > this.getLineCount() ? [] : this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
    }
    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = !1, onlyMarginDecorations = !1) {
      var lineCount = this.getLineCount();
      _startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
      _endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
      lineCount = this.getLineMaxColumn(_endLineNumber);
      _startLineNumber = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(_startLineNumber, 1, _endLineNumber, lineCount);
      onlyMarginDecorations = this._getDecorationsInRange(_startLineNumber, ownerId, filterOutValidation, onlyMarginDecorations);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.pushMany)(onlyMarginDecorations, this._decorationProvider.getDecorationsInRange(_startLineNumber, ownerId, filterOutValidation));
      return onlyMarginDecorations;
    }
    getDecorationsInRange(range, ownerId = 0, filterOutValidation = !1, onlyMinimapDecorations = !1, onlyMarginDecorations = !1) {
      range = this.validateRange(range);
      onlyMarginDecorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.pushMany)(onlyMarginDecorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations));
      return onlyMarginDecorations;
    }
    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = !1) {
      return this._decorationsTree.getAll(this, ownerId, filterOutValidation, !0, !1);
    }
    getInjectedTextDecorations(ownerId = 0) {
      return this._decorationsTree.getAllInjectedText(this, ownerId);
    }
    _getInjectedTextInLine(lineNumber) {
      var startOffset = this._buffer.getOffsetAt(lineNumber, 1);
      const endOffset = startOffset + this._buffer.getLineLength(lineNumber);
      startOffset = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);
      return require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText.fromDecorations(startOffset).filter(t => t.lineNumber === lineNumber);
    }
    getAllDecorations(ownerId = 0, filterOutValidation = !1) {
      let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, !1, !1);
      return result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));
    }
    getAllMarginDecorations(ownerId = 0) {
      return this._decorationsTree.getAll(this, ownerId, !1, !1, !0);
    }
    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {
      const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
      filterRange = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
      return this._decorationsTree.getAllInInterval(this, startOffset, filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations);
    }
    getRangeAt(start, end) {
      return this._buffer.getRangeAt(start, end - start);
    }
    _changeDecorationImpl(decorationId, _range) {
      const node = this._decorations[decorationId];
      if (node) {
        if (node.options.after) {
          var oldRange = this.getDecorationRange(decorationId);
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);
        }
        node.options.before && (decorationId = this.getDecorationRange(decorationId), this._onDidChangeDecorations.recordLineAffectedByInjectedText(decorationId.startLineNumber));
        _range = this._validateRangeRelaxedNoAllocations(_range);
        decorationId = this._buffer.getOffsetAt(_range.startLineNumber, _range.startColumn);
        oldRange = this._buffer.getOffsetAt(_range.endLineNumber, _range.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), decorationId, oldRange, _range);
        this._decorationsTree.insert(node);
        this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        node.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(_range.endLineNumber);
        node.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(_range.startLineNumber);
      }
    }
    _changeDecorationOptionsImpl(decorationId, options) {
      if (decorationId = this._decorations[decorationId]) {
        var nodeWasInOverviewRuler = decorationId.options.overviewRuler && decorationId.options.overviewRuler.color ? !0 : !1, nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? !0 : !1;
        this._onDidChangeDecorations.checkAffectedAndFire(decorationId.options);
        this._onDidChangeDecorations.checkAffectedAndFire(options);
        if (decorationId.options.after || options.after) {
          var nodeRange = this._decorationsTree.getNodeRange(this, decorationId);
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
        }
        if (decorationId.options.before || options.before) {
          nodeRange = this._decorationsTree.getNodeRange(this, decorationId), this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
        }
        nodeWasInOverviewRuler !== nodeIsInOverviewRuler ? (this._decorationsTree.delete(decorationId), decorationId.setOptions(options), this._decorationsTree.insert(decorationId)) : decorationId.setOptions(options);
      }
    }
    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = !1) {
      const versionId = this.getVersionId(), oldDecorationsLen = oldDecorationsIds.length;
      let oldDecorationIndex = 0;
      const newDecorationsLen = newDecorations.length;
      let newDecorationIndex = 0;
      this._onDidChangeDecorations.beginDeferredEmit();
      try {
        const result = Array(newDecorationsLen);
        for (; oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen;) {
          let node = null;
          if (oldDecorationIndex < oldDecorationsLen) {
            do {
              node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
            } while (!node && oldDecorationIndex < oldDecorationsLen);
            if (node) {
              if (node.options.after) {
                const nodeRange = this._decorationsTree.getNodeRange(this, node);
                this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
              }
              if (node.options.before) {
                const nodeRange = this._decorationsTree.getNodeRange(this, node);
                this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
              }
              this._decorationsTree.delete(node);
              suppressEvents || this._onDidChangeDecorations.checkAffectedAndFire(node.options);
            }
          }
          if (newDecorationIndex < newDecorationsLen) {
            if (!node) {
              const internalDecorationId = ++this._lastDecorationId, decorationId = `${this._instanceId};${internalDecorationId}`;
              node = new require$_DOT__SLASH_intervalTree_DOT_js.IntervalNode(decorationId, 0, 0);
              this._decorations[decorationId] = node;
            }
            const newDecoration = newDecorations[newDecorationIndex], range = this._validateRangeRelaxedNoAllocations(newDecoration.range), options = _normalizeOptions(newDecoration.options), startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn), endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);
            node.ownerId = ownerId;
            node.reset(versionId, startOffset, endOffset, range);
            node.setOptions(options);
            node.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);
            node.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);
            suppressEvents || this._onDidChangeDecorations.checkAffectedAndFire(options);
            this._decorationsTree.insert(node);
            result[newDecorationIndex] = node.id;
            newDecorationIndex++;
          } else {
            node && delete this._decorations[node.id];
          }
        }
        return result;
      } finally {
        this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    getLanguageId() {
      return this.tokenization.getLanguageId();
    }
    setLanguage(languageIdOrSelection, source) {
      typeof languageIdOrSelection === "string" ? (this._languageSelectionListener.clear(), this._setLanguage(languageIdOrSelection, source)) : (this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source)), this._setLanguage(languageIdOrSelection.languageId, source));
    }
    _setLanguage(languageId, source) {
      this.tokenization.setLanguageId(languageId, source);
      this._languageService.requestRichLanguageFeatures(languageId);
    }
    getLanguageIdAtPosition(lineNumber, column) {
      return this.tokenization.getLanguageIdAtPosition(lineNumber, column);
    }
    getWordAtPosition(position) {
      return this._tokenizationTextModelPart.getWordAtPosition(position);
    }
    getWordUntilPosition(position) {
      return this._tokenizationTextModelPart.getWordUntilPosition(position);
    }
    normalizePosition(position, affinity) {
      return position;
    }
    getLineIndentColumn(lineNumber) {
      lineNumber = this.getLineContent(lineNumber);
      let indent = 0;
      for (const c of lineNumber) {
        if (c === " " || c === "\t") {
          indent++;
        } else {
          break;
        }
      }
      return indent + 1;
    }
  };
  TextModel._MODEL_SYNC_LIMIT = 52428800;
  TextModel.LARGE_FILE_SIZE_THRESHOLD = 20971520;
  TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 3E5;
  TextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 268435456;
  TextModel.DEFAULT_CREATION_OPTIONS = {isForSimpleWidget:!1, tabSize:module.EDITOR_MODEL_DEFAULTS.tabSize, indentSize:module.EDITOR_MODEL_DEFAULTS.indentSize, insertSpaces:module.EDITOR_MODEL_DEFAULTS.insertSpaces, detectIndentation:!1, defaultEOL:1, trimAutoWhitespace:module.EDITOR_MODEL_DEFAULTS.trimAutoWhitespace, largeFileOptimizations:module.EDITOR_MODEL_DEFAULTS.largeFileOptimizations, bracketPairColorizationOptions:module.EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions};
  TextModel = TextModel_1 = __decorate([__param(4, require.IUndoRedoService), __param(5, exports.ILanguageService), __param(6, require$_DOT__DOT__SLASH_languages_SLASH_languageConfigurationRegistry_DOT_js.ILanguageConfigurationService)], TextModel);
  class DecorationsTrees {
    constructor() {
      this._decorationsTree0 = new require$_DOT__SLASH_intervalTree_DOT_js.IntervalTree();
      this._decorationsTree1 = new require$_DOT__SLASH_intervalTree_DOT_js.IntervalTree();
      this._injectedTextDecorationsTree = new require$_DOT__SLASH_intervalTree_DOT_js.IntervalTree();
    }
    ensureAllNodesHaveRanges(host) {
      this.getAll(host, 0, !1, !1, !1);
    }
    _ensureNodesHaveRanges(host, nodes) {
      for (const node of nodes) {
        node.range === null && (node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd));
      }
      return nodes;
    }
    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {
      const versionId = host.getVersionId();
      start = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);
      return this._ensureNodesHaveRanges(host, start);
    }
    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
      const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations), r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      start = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      return r0.concat(r1).concat(start);
    }
    getInjectedTextInInterval(host, start, end, filterOwnerId) {
      const versionId = host.getVersionId();
      start = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, !1, versionId, !1);
      return this._ensureNodesHaveRanges(host, start).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());
    }
    getAllInjectedText(host, filterOwnerId) {
      const versionId = host.getVersionId();
      filterOwnerId = this._injectedTextDecorationsTree.search(filterOwnerId, !1, versionId, !1);
      return this._ensureNodesHaveRanges(host, filterOwnerId).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());
    }
    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {
      const versionId = host.getVersionId();
      filterOwnerId = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);
      return this._ensureNodesHaveRanges(host, filterOwnerId);
    }
    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {
      if (overviewRulerOnly) {
        return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      }
      overviewRulerOnly = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      filterOwnerId = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      return overviewRulerOnly.concat(r1).concat(filterOwnerId);
    }
    collectNodesFromOwner(ownerId) {
      const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId), r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
      ownerId = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);
      return r0.concat(r1).concat(ownerId);
    }
    collectNodesPostOrder() {
      const r0 = this._decorationsTree0.collectNodesPostOrder(), r1 = this._decorationsTree1.collectNodesPostOrder(), r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();
      return r0.concat(r1).concat(r2);
    }
    insert(node) {
      node.options.after || node.options.before ? this._injectedTextDecorationsTree.insert(node) : isNodeInOverviewRuler(node) ? this._decorationsTree1.insert(node) : this._decorationsTree0.insert(node);
    }
    delete(node) {
      node.options.after || node.options.before ? this._injectedTextDecorationsTree.delete(node) : isNodeInOverviewRuler(node) ? this._decorationsTree1.delete(node) : this._decorationsTree0.delete(node);
    }
    getNodeRange(host, node) {
      const versionId = host.getVersionId();
      node.cachedVersionId !== versionId && this._resolveNode(node, versionId);
      node.range === null && (node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd));
      return node.range;
    }
    _resolveNode(node, cachedVersionId) {
      node.options.after || node.options.before ? this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId) : isNodeInOverviewRuler(node) ? this._decorationsTree1.resolveNode(node, cachedVersionId) : this._decorationsTree0.resolveNode(node, cachedVersionId);
    }
    acceptReplace(offset, length, textLength, forceMoveMarkers) {
      this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
      this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
      this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);
    }
  }
  class DecorationOptions {
    constructor(options) {
      this.color = options.color || "";
      this.darkColor = options.darkColor || "";
    }
  }
  class ModelDecorationOverviewRulerOptions extends DecorationOptions {
    constructor(options) {
      super(options);
      this._resolvedColor = null;
      this.position = typeof options.position === "number" ? options.position : model.OverviewRulerLane.Center;
    }
    getColor(theme) {
      this._resolvedColor || (this._resolvedColor = theme.type !== "light" && this.darkColor ? this._resolveColor(this.darkColor, theme) : this._resolveColor(this.color, theme));
      return this._resolvedColor;
    }
    invalidateCachedColor() {
      this._resolvedColor = null;
    }
    _resolveColor(color, theme) {
      return typeof color === "string" ? color : (color = color ? theme.getColor(color.id) : null) ? color.toString() : "";
    }
  }
  class ModelDecorationGlyphMarginOptions {
    constructor(options) {
      var _a;
      this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Left;
    }
  }
  class ModelDecorationMinimapOptions extends DecorationOptions {
    constructor(options) {
      super(options);
      this.position = options.position;
    }
    getColor(theme) {
      this._resolvedColor || (this._resolvedColor = theme.type !== "light" && this.darkColor ? this._resolveColor(this.darkColor, theme) : this._resolveColor(this.color, theme));
      return this._resolvedColor;
    }
    invalidateCachedColor() {
      this._resolvedColor = void 0;
    }
    _resolveColor(color, theme) {
      return typeof color === "string" ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.fromHex(color) : theme.getColor(color.id);
    }
  }
  class ModelDecorationInjectedTextOptions {
    static from(options) {
      return options instanceof ModelDecorationInjectedTextOptions ? options : new ModelDecorationInjectedTextOptions(options);
    }
    constructor(options) {
      this.content = options.content || "";
      this.inlineClassName = options.inlineClassName || null;
      this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || !1;
      this.attachedData = options.attachedData || null;
      this.cursorStops = options.cursorStops || null;
    }
  }
  class ModelDecorationOptions {
    static register(options) {
      return new ModelDecorationOptions(options);
    }
    static createDynamic(options) {
      return new ModelDecorationOptions(options);
    }
    constructor(options) {
      var _a, _b, _c, _d, _e, _f;
      this.description = options.description;
      this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;
      this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;
      this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;
      this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;
      this.stickiness = options.stickiness || 0;
      this.zIndex = options.zIndex || 0;
      this.className = options.className ? cleanClassName(options.className) : null;
      this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;
      this.hoverMessage = options.hoverMessage || null;
      this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;
      this.isWholeLine = options.isWholeLine || !1;
      this.showIfCollapsed = options.showIfCollapsed || !1;
      this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || !1;
      this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;
      this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;
      this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;
      this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;
      this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;
      this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;
      this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;
      this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;
      this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || !1;
      this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;
      this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;
      this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;
      this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;
      this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : !1;
      this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : !1;
    }
  }
  ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({description:"empty"});
  const TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({description:"tracked-range-always-grows-when-typing-at-edges", stickiness:0}), ModelDecorationOptions.register({description:"tracked-range-never-grows-when-typing-at-edges", stickiness:1}), ModelDecorationOptions.register({description:"tracked-range-grows-only-when-typing-before", stickiness:2}), ModelDecorationOptions.register({description:"tracked-range-grows-only-when-typing-after", stickiness:3})];
  class DidChangeDecorationsEmitter extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor(handleBeforeFire) {
      super();
      this.handleBeforeFire = handleBeforeFire;
      this._actual = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.event = this._actual.event;
      this._affectedInjectedTextLines = null;
      this._deferredCnt = 0;
      this._affectsGlyphMargin = this._affectsOverviewRuler = this._affectsMinimap = this._shouldFireDeferred = !1;
    }
    beginDeferredEmit() {
      this._deferredCnt++;
    }
    endDeferredEmit() {
      var _a;
      this._deferredCnt--;
      this._deferredCnt === 0 && (this._shouldFireDeferred && this.doFire(), (_a = this._affectedInjectedTextLines) === null || _a === void 0 || _a.clear(), this._affectedInjectedTextLines = null);
    }
    recordLineAffectedByInjectedText(lineNumber) {
      this._affectedInjectedTextLines || (this._affectedInjectedTextLines = new Set());
      this._affectedInjectedTextLines.add(lineNumber);
    }
    checkAffectedAndFire(options) {
      this._affectsMinimap || (this._affectsMinimap = options.minimap && options.minimap.position ? !0 : !1);
      this._affectsOverviewRuler || (this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? !0 : !1);
      this._affectsGlyphMargin || (this._affectsGlyphMargin = options.glyphMarginClassName ? !0 : !1);
      this.tryFire();
    }
    fire() {
      this._affectsGlyphMargin = this._affectsOverviewRuler = this._affectsMinimap = !0;
      this.tryFire();
    }
    tryFire() {
      this._deferredCnt === 0 ? this.doFire() : this._shouldFireDeferred = !0;
    }
    doFire() {
      this.handleBeforeFire(this._affectedInjectedTextLines);
      const event = {affectsMinimap:this._affectsMinimap, affectsOverviewRuler:this._affectsOverviewRuler, affectsGlyphMargin:this._affectsGlyphMargin};
      this._affectsGlyphMargin = this._affectsOverviewRuler = this._affectsMinimap = this._shouldFireDeferred = !1;
      this._actual.fire(event);
    }
  }
  class DidChangeContentEmitter extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    constructor() {
      super();
      this._fastEmitter = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.fastEvent = this._fastEmitter.event;
      this._slowEmitter = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.slowEvent = this._slowEmitter.event;
      this._deferredCnt = 0;
      this._deferredEvent = null;
    }
    beginDeferredEmit() {
      this._deferredCnt++;
    }
    endDeferredEmit(resultingSelection = null) {
      this._deferredCnt--;
      this._deferredCnt === 0 && this._deferredEvent !== null && (this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection, resultingSelection = this._deferredEvent, this._deferredEvent = null, this._fastEmitter.fire(resultingSelection), this._slowEmitter.fire(resultingSelection));
    }
    fire(e) {
      this._deferredCnt > 0 ? this._deferredEvent = this._deferredEvent ? this._deferredEvent.merge(e) : e : (this._fastEmitter.fire(e), this._slowEmitter.fire(e));
    }
  }
  class AttachedViews {
    constructor() {
      this._onDidChangeVisibleRanges = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;
      this._views = new Set();
    }
    attachView() {
      const view = new AttachedViewImpl(state => {
        this._onDidChangeVisibleRanges.fire({view, state});
      });
      this._views.add(view);
      return view;
    }
    detachView(view) {
      this._views.delete(view);
      this._onDidChangeVisibleRanges.fire({view, state:void 0});
    }
  }
  class AttachedViewImpl {
    constructor(handleStateChange) {
      this.handleStateChange = handleStateChange;
    }
    setVisibleLines(visibleLines, stabilized) {
      visibleLines = visibleLines.map(line => new require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange(line.startLineNumber, line.endLineNumber + 1));
      this.handleStateChange({visibleLineRanges:visibleLines, stabilized});
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$textModel.js.map
