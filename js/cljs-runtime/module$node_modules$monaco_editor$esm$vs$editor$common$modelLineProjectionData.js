shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$modelLineProjectionData = function(require, module, exports) {
  function hasRightCursorStop(cursorStop) {
    return cursorStop === null || cursorStop === void 0 ? !0 : cursorStop === require$_DOT__SLASH_model_DOT_js.InjectedTextCursorStops.Right || cursorStop === require$_DOT__SLASH_model_DOT_js.InjectedTextCursorStops.Both;
  }
  function hasLeftCursorStop(cursorStop) {
    return cursorStop === null || cursorStop === void 0 ? !0 : cursorStop === require$_DOT__SLASH_model_DOT_js.InjectedTextCursorStops.Left || cursorStop === require$_DOT__SLASH_model_DOT_js.InjectedTextCursorStops.Both;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, InjectedText:{enumerable:!0, get:function() {
    return InjectedText;
  }}, ModelLineProjectionData:{enumerable:!0, get:function() {
    return ModelLineProjectionData;
  }}, OutputPosition:{enumerable:!0, get:function() {
    return OutputPosition;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$assert"), require$_DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__SLASH_model_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model");
  class ModelLineProjectionData {
    constructor(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength) {
      this.injectionOffsets = injectionOffsets;
      this.injectionOptions = injectionOptions;
      this.breakOffsets = breakOffsets;
      this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;
      this.wrappedTextIndentLength = wrappedTextIndentLength;
    }
    getOutputLineCount() {
      return this.breakOffsets.length;
    }
    getMinOutputOffset(outputLineIndex) {
      return outputLineIndex > 0 ? this.wrappedTextIndentLength : 0;
    }
    getLineLength(outputLineIndex) {
      let lineLength = this.breakOffsets[outputLineIndex] - (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0);
      outputLineIndex > 0 && (lineLength += this.wrappedTextIndentLength);
      return lineLength;
    }
    getMaxOutputOffset(outputLineIndex) {
      return this.getLineLength(outputLineIndex);
    }
    translateToInputOffset(outputLineIndex, outputOffset) {
      outputLineIndex > 0 && (outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength));
      outputLineIndex = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;
      if (this.injectionOffsets !== null) {
        for (outputOffset = 0; outputOffset < this.injectionOffsets.length; outputOffset++) {
          if (outputLineIndex > this.injectionOffsets[outputOffset]) {
            outputLineIndex = outputLineIndex < this.injectionOffsets[outputOffset] + this.injectionOptions[outputOffset].content.length ? this.injectionOffsets[outputOffset] : outputLineIndex - this.injectionOptions[outputOffset].content.length;
          } else {
            break;
          }
        }
      }
      return outputLineIndex;
    }
    translateToOutputPosition(inputOffset, affinity = 2) {
      let inputOffsetInInputWithInjection = inputOffset;
      if (this.injectionOffsets !== null) {
        for (let i = 0; i < this.injectionOffsets.length && !(inputOffset < this.injectionOffsets[i]) && (affinity === 1 || inputOffset !== this.injectionOffsets[i]); i++) {
          inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;
        }
      }
      return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);
    }
    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2) {
      let low = 0, high = this.breakOffsets.length - 1, mid = 0, midStart = 0;
      for (; low <= high;) {
        mid = low + (high - low) / 2 | 0;
        const midStop = this.breakOffsets[mid];
        midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;
        if (affinity === 0) {
          if (offsetInInputWithInjections <= midStart) {
            high = mid - 1;
          } else if (offsetInInputWithInjections > midStop) {
            low = mid + 1;
          } else {
            break;
          }
        } else {
          if (offsetInInputWithInjections < midStart) {
            high = mid - 1;
          } else if (offsetInInputWithInjections >= midStop) {
            low = mid + 1;
          } else {
            break;
          }
        }
      }
      offsetInInputWithInjections -= midStart;
      mid > 0 && (offsetInInputWithInjections += this.wrappedTextIndentLength);
      return new OutputPosition(mid, offsetInInputWithInjections);
    }
    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {
      if (this.injectionOffsets !== null) {
        const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset), normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);
        if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {
          return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);
        }
      }
      if (affinity === 0) {
        if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {
          return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));
        }
      } else if (affinity === 1 && (affinity = this.getOutputLineCount() - 1, outputLineIndex < affinity && outputOffset === this.getMaxOutputOffset(outputLineIndex))) {
        return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));
      }
      return new OutputPosition(outputLineIndex, outputOffset);
    }
    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {
      outputLineIndex > 0 && (outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength));
      return (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;
    }
    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {
      var injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);
      if (!injectedText) {
        return offsetInInputWithInjections;
      }
      if (affinity === 2) {
        if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {
          return injectedText.offsetInInputWithInjections + injectedText.length;
        }
        offsetInInputWithInjections = injectedText.offsetInInputWithInjections;
        if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {
          return offsetInInputWithInjections;
        }
        for (affinity = injectedText.injectedTextIndex - 1; affinity >= 0 && this.injectionOffsets[affinity] === this.injectionOffsets[injectedText.injectedTextIndex] && !hasRightCursorStop(this.injectionOptions[affinity].cursorStops);) {
          offsetInInputWithInjections -= this.injectionOptions[affinity].content.length;
          if (hasLeftCursorStop(this.injectionOptions[affinity].cursorStops)) {
            break;
          }
          affinity--;
        }
        return offsetInInputWithInjections;
      }
      if (affinity === 1 || affinity === 4) {
        offsetInInputWithInjections = injectedText.offsetInInputWithInjections + injectedText.length;
        for (injectedText = injectedText.injectedTextIndex; injectedText + 1 < this.injectionOffsets.length && this.injectionOffsets[injectedText + 1] === this.injectionOffsets[injectedText];) {
          offsetInInputWithInjections += this.injectionOptions[injectedText + 1].content.length, injectedText++;
        }
        return offsetInInputWithInjections;
      }
      if (affinity === 0 || affinity === 3) {
        offsetInInputWithInjections = injectedText.offsetInInputWithInjections;
        for (injectedText = injectedText.injectedTextIndex; injectedText - 1 >= 0 && this.injectionOffsets[injectedText - 1] === this.injectionOffsets[injectedText];) {
          offsetInInputWithInjections -= this.injectionOptions[injectedText - 1].content.length, injectedText--;
        }
        return offsetInInputWithInjections;
      }
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_assert_DOT_js.assertNever)(affinity);
    }
    getInjectedText(outputLineIndex, outputOffset) {
      outputLineIndex = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);
      return (outputLineIndex = this.getInjectedTextAtOffset(outputLineIndex)) ? {options:this.injectionOptions[outputLineIndex.injectedTextIndex]} : null;
    }
    getInjectedTextAtOffset(offsetInInputWithInjections) {
      const injectionOffsets = this.injectionOffsets, injectionOptions = this.injectionOptions;
      if (injectionOffsets !== null) {
        let totalInjectedTextLengthBefore = 0;
        for (let i = 0; i < injectionOffsets.length; i++) {
          const length = injectionOptions[i].content.length, injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;
          if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {
            break;
          }
          if (offsetInInputWithInjections <= injectionOffsets[i] + totalInjectedTextLengthBefore + length) {
            return {injectedTextIndex:i, offsetInInputWithInjections:injectedTextStartOffsetInInputWithInjections, length};
          }
          totalInjectedTextLengthBefore += length;
        }
      }
    }
  }
  class InjectedText {
    constructor(options) {
      this.options = options;
    }
  }
  class OutputPosition {
    constructor(outputLineIndex, outputOffset) {
      this.outputLineIndex = outputLineIndex;
      this.outputOffset = outputOffset;
    }
    toString() {
      return `${this.outputLineIndex}:${this.outputOffset}`;
    }
    toPosition(baseLineNumber) {
      return new require$_DOT__SLASH_core_SLASH_position_DOT_js.Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$modelLineProjectionData.js.map
