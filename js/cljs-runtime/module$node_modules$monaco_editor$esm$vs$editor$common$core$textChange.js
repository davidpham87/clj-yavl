shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$core$textChange = function(require, module, exports) {
  function escapeNewLine(str) {
    return str.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  }
  function compressConsecutiveTextChanges(prevEdits, currEdits) {
    return prevEdits === null || prevEdits.length === 0 ? currEdits : (new TextChangeCompressor(prevEdits, currEdits)).compress();
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, TextChange:{enumerable:!0, get:function() {
    return TextChange;
  }}, compressConsecutiveTextChanges:{enumerable:!0, get:function() {
    return compressConsecutiveTextChanges;
  }}});
  var buffer = require("module$node_modules$monaco_editor$esm$vs$base$common$buffer"), require$_DOT__SLASH_stringBuilder_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$stringBuilder");
  class TextChange {
    get oldLength() {
      return this.oldText.length;
    }
    get oldEnd() {
      return this.oldPosition + this.oldText.length;
    }
    get newLength() {
      return this.newText.length;
    }
    get newEnd() {
      return this.newPosition + this.newText.length;
    }
    constructor(oldPosition, oldText, newPosition, newText) {
      this.oldPosition = oldPosition;
      this.oldText = oldText;
      this.newPosition = newPosition;
      this.newText = newText;
    }
    toString() {
      return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${escapeNewLine(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${escapeNewLine(this.oldText)}")` : `(replace@${this.oldPosition} "${escapeNewLine(this.oldText)}" with "${escapeNewLine(this.newText)}")`;
    }
    static _writeStringSize(str) {
      return 4 + 2 * str.length;
    }
    static _writeString(b, str, offset) {
      const len = str.length;
      buffer.writeUInt32BE(b, len, offset);
      offset += 4;
      for (let i = 0; i < len; i++) {
        buffer.writeUInt16LE(b, str.charCodeAt(i), offset), offset += 2;
      }
      return offset;
    }
    static _readString(b, offset) {
      const len = buffer.readUInt32BE(b, offset);
      return (0,require$_DOT__SLASH_stringBuilder_DOT_js.decodeUTF16LE)(b, offset + 4, len);
    }
    writeSize() {
      return 8 + TextChange._writeStringSize(this.oldText) + TextChange._writeStringSize(this.newText);
    }
    write(b, offset) {
      buffer.writeUInt32BE(b, this.oldPosition, offset);
      offset += 4;
      buffer.writeUInt32BE(b, this.newPosition, offset);
      offset = TextChange._writeString(b, this.oldText, offset + 4);
      return offset = TextChange._writeString(b, this.newText, offset);
    }
    static read(b, offset, dest) {
      const oldPosition = buffer.readUInt32BE(b, offset);
      offset += 4;
      const newPosition = buffer.readUInt32BE(b, offset);
      offset += 4;
      const oldText = TextChange._readString(b, offset);
      offset += TextChange._writeStringSize(oldText);
      b = TextChange._readString(b, offset);
      offset += TextChange._writeStringSize(b);
      dest.push(new TextChange(oldPosition, oldText, newPosition, b));
      return offset;
    }
  }
  class TextChangeCompressor {
    constructor(prevEdits, currEdits) {
      this._prevEdits = prevEdits;
      this._currEdits = currEdits;
      this._result = [];
      this._resultLen = 0;
      this._prevLen = this._prevEdits.length;
      this._prevDeltaOffset = 0;
      this._currLen = this._currEdits.length;
      this._currDeltaOffset = 0;
    }
    compress() {
      var prevIndex = 0;
      let currIndex = 0, prevEdit = this._getPrev(prevIndex), currEdit = this._getCurr(currIndex);
      for (; prevIndex < this._prevLen || currIndex < this._currLen;) {
        if (prevEdit === null) {
          this._acceptCurr(currEdit);
          currEdit = this._getCurr(++currIndex);
          continue;
        }
        if (currEdit === null) {
          this._acceptPrev(prevEdit);
          prevEdit = this._getPrev(++prevIndex);
          continue;
        }
        if (currEdit.oldEnd <= prevEdit.newPosition) {
          this._acceptCurr(currEdit);
          currEdit = this._getCurr(++currIndex);
          continue;
        }
        if (prevEdit.newEnd <= currEdit.oldPosition) {
          this._acceptPrev(prevEdit);
          prevEdit = this._getPrev(++prevIndex);
          continue;
        }
        if (currEdit.oldPosition < prevEdit.newPosition) {
          const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);
          this._acceptCurr(e1);
          currEdit = e2;
          continue;
        }
        if (prevEdit.newPosition < currEdit.oldPosition) {
          const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);
          this._acceptPrev(e1);
          prevEdit = e2;
          continue;
        }
        let mergePrev, mergeCurr;
        if (currEdit.oldEnd === prevEdit.newEnd) {
          mergePrev = prevEdit, mergeCurr = currEdit, prevEdit = this._getPrev(++prevIndex), currEdit = this._getCurr(++currIndex);
        } else if (currEdit.oldEnd < prevEdit.newEnd) {
          const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);
          mergePrev = e1;
          mergeCurr = currEdit;
          prevEdit = e2;
          currEdit = this._getCurr(++currIndex);
        } else {
          const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);
          mergePrev = prevEdit;
          mergeCurr = e1;
          prevEdit = this._getPrev(++prevIndex);
          currEdit = e2;
        }
        this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);
        this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;
        this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;
      }
      prevIndex = TextChangeCompressor._merge(this._result);
      return TextChangeCompressor._removeNoOps(prevIndex);
    }
    _acceptCurr(currEdit) {
      this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);
      this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;
    }
    _getCurr(currIndex) {
      return currIndex < this._currLen ? this._currEdits[currIndex] : null;
    }
    _acceptPrev(prevEdit) {
      this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);
      this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;
    }
    _getPrev(prevIndex) {
      return prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null;
    }
    static _rebaseCurr(prevDeltaOffset, currEdit) {
      return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);
    }
    static _rebasePrev(currDeltaOffset, prevEdit) {
      return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);
    }
    static _splitPrev(edit, offset) {
      const preText = edit.newText.substr(0, offset), postText = edit.newText.substr(offset);
      return [new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText), new TextChange(edit.oldEnd, "", edit.newPosition + offset, postText)];
    }
    static _splitCurr(edit, offset) {
      const preText = edit.oldText.substr(0, offset), postText = edit.oldText.substr(offset);
      return [new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText), new TextChange(edit.oldPosition + offset, postText, edit.newEnd, "")];
    }
    static _merge(edits) {
      if (edits.length === 0) {
        return edits;
      }
      const result = [];
      let resultLen = 0, prev = edits[0];
      for (let i = 1; i < edits.length; i++) {
        const curr = edits[i];
        prev.oldEnd === curr.oldPosition ? prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText) : (result[resultLen++] = prev, prev = curr);
      }
      result[resultLen++] = prev;
      return result;
    }
    static _removeNoOps(edits) {
      if (edits.length === 0) {
        return edits;
      }
      const result = [];
      let resultLen = 0;
      for (let i = 0; i < edits.length; i++) {
        const edit = edits[i];
        edit.oldText !== edit.newText && (result[resultLen++] = edit);
      }
      return result;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$core$textChange.js.map
