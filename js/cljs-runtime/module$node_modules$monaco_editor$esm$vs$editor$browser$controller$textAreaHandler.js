shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaHandler = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, TextAreaHandler:{enumerable:!0, get:function() {
    return TextAreaHandler;
  }}});
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaHandler_css");
  var nls = require("module$node_modules$monaco_editor$esm$vs$nls"), browser = require("module$node_modules$monaco_editor$esm$vs$base$browser$browser"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$fastDomNode"), platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), 
  require$_DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$config$domFontInfo"), require$_DOT__SLASH_textAreaInput_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaInput"), require$_DOT__SLASH_textAreaState_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaState"), require$_DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart"), 
  require$_DOT__DOT__SLASH_viewParts_SLASH_lineNumbers_SLASH_lineNumbers_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lineNumbers$lineNumbers"), require$_DOT__DOT__SLASH_viewParts_SLASH_margin_SLASH_margin_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$margin$margin"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$config$editorOptions"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_wordCharacterClassifier_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordCharacterClassifier"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$selection"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_mouseCursor_SLASH_mouseCursor_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$mouseCursor$mouseCursor"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$color"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$ime");
  module = require("module$node_modules$monaco_editor$esm$vs$platform$keybinding$common$keybinding");
  require = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$instantiation");
  exports = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  class VisibleTextAreaData {
    constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {
      this._context = _context;
      this.modelLineNumber = modelLineNumber;
      this.distanceToModelLineStart = distanceToModelLineStart;
      this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;
      this.distanceToModelLineEnd = distanceToModelLineEnd;
      this._visibleTextAreaBrand = void 0;
      this._previousPresentation = this.visibleTextareaEnd = this.visibleTextareaStart = this.endPosition = this.startPosition = null;
    }
    prepareRender(visibleRangeProvider) {
      const startModelPosition = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(this.modelLineNumber, this.distanceToModelLineStart + 1), endModelPosition = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
      this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);
      this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);
      this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition)) : this.visibleTextareaEnd = this.visibleTextareaStart = null;
    }
    definePresentation(tokenPresentation) {
      this._previousPresentation || (this._previousPresentation = tokenPresentation ? tokenPresentation : {foreground:1, italic:!1, bold:!1, underline:!1, strikethrough:!1});
      return this._previousPresentation;
    }
  }
  const canUseZeroSizeTextarea = browser.isFirefox;
  let TextAreaHandler = class extends require$_DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.ViewPart {
    constructor(context, viewController, visibleRangeProvider, _keybindingService, _instantiationService) {
      super(context);
      this._keybindingService = _keybindingService;
      this._instantiationService = _instantiationService;
      this._primaryCursorPosition = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(1, 1);
      this._primaryCursorVisibleRange = null;
      this._viewController = viewController;
      this._visibleRangeProvider = visibleRangeProvider;
      this._scrollTop = this._scrollLeft = 0;
      context = this._context.configuration.options;
      viewController = context.get(143);
      this._setAccessibilityOptions(context);
      this._contentLeft = viewController.contentLeft;
      this._contentWidth = viewController.contentWidth;
      this._contentHeight = viewController.height;
      this._fontInfo = context.get(50);
      this._lineHeight = context.get(66);
      this._emptySelectionClipboard = context.get(37);
      this._copyWithSyntaxHighlighting = context.get(25);
      this._visibleTextArea = null;
      this._selections = [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(1, 1, 1, 1)];
      this._modelSelections = [new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_selection_DOT_js.Selection(1, 1, 1, 1)];
      this._lastRenderPosition = null;
      this.textArea = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("textarea"));
      require$_DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.write(this.textArea, 6);
      this.textArea.setClassName(`inputarea ${require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_mouseCursor_SLASH_mouseCursor_DOT_js.MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
      this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
      ({tabSize:viewController} = this._context.viewModel.model.getOptions());
      this.textArea.domNode.style.tabSize = `${viewController * this._fontInfo.spaceWidth}px`;
      this.textArea.setAttribute("autocorrect", "off");
      this.textArea.setAttribute("autocapitalize", "off");
      this.textArea.setAttribute("autocomplete", "off");
      this.textArea.setAttribute("spellcheck", "false");
      this.textArea.setAttribute("aria-label", this._getAriaLabel(context));
      this.textArea.setAttribute("aria-required", context.get(5) ? "true" : "false");
      this.textArea.setAttribute("tabindex", String(context.get(123)));
      this.textArea.setAttribute("role", "textbox");
      this.textArea.setAttribute("aria-roledescription", nls.localize("editor", "editor"));
      this.textArea.setAttribute("aria-multiline", "true");
      this.textArea.setAttribute("aria-autocomplete", context.get(90) ? "none" : "both");
      this._ensureReadOnlyAttribute();
      this.textAreaCover = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_fastDomNode_DOT_js.createFastDomNode)(document.createElement("div"));
      this.textAreaCover.setPosition("absolute");
      const simpleModel = {getLineCount:() => this._context.viewModel.getLineCount(), getLineMaxColumn:lineNumber => this._context.viewModel.getLineMaxColumn(lineNumber), getValueInRange:(range, eol) => this._context.viewModel.getValueInRange(range, eol), getValueLengthInRange:(range, eol) => this._context.viewModel.getValueLengthInRange(range, eol), modifyPosition:(position, offset) => this._context.viewModel.modifyPosition(position, offset)};
      context = this._register(new require$_DOT__SLASH_textAreaInput_DOT_js.TextAreaWrapper(this.textArea.domNode));
      this._textAreaInput = this._register(this._instantiationService.createInstance(require$_DOT__SLASH_textAreaInput_DOT_js.TextAreaInput, {getDataToCopy:() => {
        var rawTextToCopy = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows), newLineCharacter = this._context.viewModel.model.getEOL();
        const isFromEmptySelection = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), multicursorText = Array.isArray(rawTextToCopy) ? rawTextToCopy : null;
        rawTextToCopy = Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy;
        newLineCharacter = void 0;
        let mode = null;
        if (require$_DOT__SLASH_textAreaInput_DOT_js.CopyOptions.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && rawTextToCopy.length < 65536) {
          const richText = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          richText && (newLineCharacter = richText.html, mode = richText.mode);
        }
        return {isFromEmptySelection, multicursorText, text:rawTextToCopy, html:newLineCharacter, mode};
      }, getScreenReaderContent:() => {
        if (this._accessibilitySupport === 1) {
          var selection = this._selections[0];
          if (platform.isMacintosh && selection.isEmpty()) {
            var position = selection.getStartPosition();
            let textBefore = this._getWordBeforePosition(position);
            textBefore.length === 0 && (textBefore = this._getCharacterBeforePosition(position));
            if (textBefore.length > 0) {
              return new require$_DOT__SLASH_textAreaState_DOT_js.TextAreaState(textBefore, textBefore.length, textBefore.length, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(position), 0);
            }
          }
          return platform.isMacintosh && !selection.isEmpty() && simpleModel.getValueLengthInRange(selection, 0) < 500 ? (position = simpleModel.getValueInRange(selection, 0), new require$_DOT__SLASH_textAreaState_DOT_js.TextAreaState(position, 0, position.length, selection, 0)) : browser.isSafari && !selection.isEmpty() ? new require$_DOT__SLASH_textAreaState_DOT_js.TextAreaState("vscode-placeholder", 0, 18, null, void 0) : require$_DOT__SLASH_textAreaState_DOT_js.TextAreaState.EMPTY;
        }
        if (browser.isAndroid) {
          selection = this._selections[0];
          if (selection.isEmpty()) {
            selection = selection.getStartPosition();
            const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(selection);
            if (wordAtPosition.length > 0) {
              return new require$_DOT__SLASH_textAreaState_DOT_js.TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(selection), 0);
            }
          }
          return require$_DOT__SLASH_textAreaState_DOT_js.TextAreaState.EMPTY;
        }
        return require$_DOT__SLASH_textAreaState_DOT_js.PagedScreenReaderStrategy.fromEditorSelection(simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0);
      }, deduceModelPosition:(viewAnchorPosition, deltaOffset, lineFeedCnt) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt)}, context, platform.OS, {isAndroid:browser.isAndroid, isChrome:browser.isChrome, isFirefox:browser.isFirefox, isSafari:browser.isSafari}));
      this._register(this._textAreaInput.onKeyDown(e => {
        this._viewController.emitKeyDown(e);
      }));
      this._register(this._textAreaInput.onKeyUp(e => {
        this._viewController.emitKeyUp(e);
      }));
      this._register(this._textAreaInput.onPaste(e => {
        let pasteOnNewLine = !1, multicursorText = null, mode = null;
        e.metadata && (pasteOnNewLine = this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection, multicursorText = typeof e.metadata.multicursorText !== "undefined" ? e.metadata.multicursorText : null, mode = e.metadata.mode);
        this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);
      }));
      this._register(this._textAreaInput.onCut(() => {
        this._viewController.cut();
      }));
      this._register(this._textAreaInput.onType(e => {
        e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta ? (require$_DOT__SLASH_textAreaState_DOT_js._debugComposition && console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`), this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta)) : (require$_DOT__SLASH_textAreaState_DOT_js._debugComposition && console.log(` => type: <<${e.text}>>`), this._viewController.type(e.text));
      }));
      this._register(this._textAreaInput.onSelectionChangeRequest(modelSelection => {
        this._viewController.setSelection(modelSelection);
      }));
      this._register(this._textAreaInput.onCompositionStart(e => {
        const ta = this.textArea.domNode, modelSelection = this._modelSelections[0], {distanceToModelLineStart, widthOfHiddenTextBefore} = (() => {
          var textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd)), lineFeedOffset1 = textBeforeSelection.lastIndexOf("\n");
          lineFeedOffset1 = textBeforeSelection.substring(lineFeedOffset1 + 1);
          textBeforeSelection = lineFeedOffset1.lastIndexOf("\t");
          var desiredVisibleBeforeCharCount = lineFeedOffset1.length - textBeforeSelection - 1;
          textBeforeSelection = modelSelection.getStartPosition();
          desiredVisibleBeforeCharCount = Math.min(textBeforeSelection.column - 1, desiredVisibleBeforeCharCount);
          textBeforeSelection = textBeforeSelection.column - 1 - desiredVisibleBeforeCharCount;
          var hiddenLineTextBefore = lineFeedOffset1.substring(0, lineFeedOffset1.length - desiredVisibleBeforeCharCount);
          const {tabSize} = this._context.viewModel.model.getOptions();
          lineFeedOffset1 = this.textArea.domNode.ownerDocument;
          var fontInfo = this._fontInfo;
          if (hiddenLineTextBefore.length === 0) {
            lineFeedOffset1 = 0;
          } else {
            desiredVisibleBeforeCharCount = lineFeedOffset1.createElement("div");
            desiredVisibleBeforeCharCount.style.position = "absolute";
            desiredVisibleBeforeCharCount.style.top = "-50000px";
            desiredVisibleBeforeCharCount.style.width = "50000px";
            var regularDomNode = lineFeedOffset1.createElement("span");
            (0,require$_DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js.applyFontInfo)(regularDomNode, fontInfo);
            regularDomNode.style.whiteSpace = "pre";
            regularDomNode.style.tabSize = `${tabSize * fontInfo.spaceWidth}px`;
            regularDomNode.append(hiddenLineTextBefore);
            desiredVisibleBeforeCharCount.appendChild(regularDomNode);
            lineFeedOffset1.body.appendChild(desiredVisibleBeforeCharCount);
            hiddenLineTextBefore = regularDomNode.offsetWidth;
            lineFeedOffset1.body.removeChild(desiredVisibleBeforeCharCount);
            lineFeedOffset1 = hiddenLineTextBefore;
          }
          return {distanceToModelLineStart:textBeforeSelection, widthOfHiddenTextBefore:lineFeedOffset1};
        })();
        ({distanceToModelLineEnd:e} = (() => {
          var textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd)), lineFeedOffset2 = textAfterSelection.indexOf("\n");
          textAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);
          lineFeedOffset2 = textAfterSelection.indexOf("\t");
          lineFeedOffset2 = lineFeedOffset2 === -1 ? textAfterSelection.length : textAfterSelection.length - lineFeedOffset2 - 1;
          textAfterSelection = modelSelection.getEndPosition();
          lineFeedOffset2 = Math.min(this._context.viewModel.model.getLineMaxColumn(textAfterSelection.lineNumber) - textAfterSelection.column, lineFeedOffset2);
          return {distanceToModelLineEnd:this._context.viewModel.model.getLineMaxColumn(textAfterSelection.lineNumber) - textAfterSelection.column - lineFeedOffset2};
        })());
        this._context.viewModel.revealRange("keyboard", !0, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.fromPositions(this._selections[0].getStartPosition()), 0, 1);
        this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, e);
        this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
        this._visibleTextArea.prepareRender(this._visibleRangeProvider);
        this._render();
        this.textArea.setClassName(`inputarea ${require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_mouseCursor_SLASH_mouseCursor_DOT_js.MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);
        this._viewController.compositionStart();
        this._context.viewModel.onCompositionStart();
      }));
      this._register(this._textAreaInput.onCompositionUpdate(e => {
        this._visibleTextArea && (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
      }));
      this._register(this._textAreaInput.onCompositionEnd(() => {
        this._visibleTextArea = null;
        this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
        this._render();
        this.textArea.setClassName(`inputarea ${require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_mouseCursor_SLASH_mouseCursor_DOT_js.MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
        this._viewController.compositionEnd();
        this._context.viewModel.onCompositionEnd();
      }));
      this._register(this._textAreaInput.onFocus(() => {
        this._context.viewModel.setHasFocus(!0);
      }));
      this._register(this._textAreaInput.onBlur(() => {
        this._context.viewModel.setHasFocus(!1);
      }));
      this._register(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js.IME.onDidChange(() => {
        this._ensureReadOnlyAttribute();
      }));
    }
    writeScreenReaderContent(reason) {
      this._textAreaInput.writeNativeTextAreaContent(reason);
    }
    dispose() {
      super.dispose();
    }
    _getAndroidWordAtPosition(position) {
      const lineContent = this._context.viewModel.getLineContent(position.lineNumber), wordSeparators = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_wordCharacterClassifier_DOT_js.getMapForWordSeparators)('`~!@#$%^\x26*()-\x3d+[{]}\\|;:",.\x3c\x3e/?');
      let goingLeft = !0, startColumn = position.column, goingRight = !0, endColumn = position.column, distance = 0;
      for (; distance < 50 && (goingLeft || goingRight);) {
        goingLeft && startColumn <= 1 && (goingLeft = !1);
        if (goingLeft) {
          var charCode = lineContent.charCodeAt(startColumn - 2);
          wordSeparators.get(charCode) !== 0 ? goingLeft = !1 : startColumn--;
        }
        goingRight && endColumn > lineContent.length && (goingRight = !1);
        goingRight && (charCode = lineContent.charCodeAt(endColumn - 1), wordSeparators.get(charCode) !== 0 ? goingRight = !1 : endColumn++);
        distance++;
      }
      return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];
    }
    _getWordBeforePosition(position) {
      const lineContent = this._context.viewModel.getLineContent(position.lineNumber), wordSeparators = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_wordCharacterClassifier_DOT_js.getMapForWordSeparators)(this._context.configuration.options.get(129));
      let column = position.column, distance = 0;
      for (; column > 1;) {
        const charCode = lineContent.charCodeAt(column - 2);
        if (wordSeparators.get(charCode) !== 0 || distance > 50) {
          return lineContent.substring(column - 1, position.column - 1);
        }
        distance++;
        column--;
      }
      return lineContent.substring(0, position.column - 1);
    }
    _getCharacterBeforePosition(position) {
      return position.column > 1 && (position = this._context.viewModel.getLineContent(position.lineNumber).charAt(position.column - 2), !strings.isHighSurrogate(position.charCodeAt(0))) ? position : "";
    }
    _getAriaLabel(options) {
      var _a, _b, _c;
      return options.get(2) === 1 ? (options = (_a = this._keybindingService.lookupKeybinding("editor.action.toggleScreenReaderAccessibilityMode")) === null || _a === void 0 ? void 0 : _a.getAriaLabel(), _a = (_b = this._keybindingService.lookupKeybinding("workbench.action.showCommands")) === null || _b === void 0 ? void 0 : _b.getAriaLabel(), _b = (_c = this._keybindingService.lookupKeybinding("workbench.action.openGlobalKeybindings")) === null || _c === void 0 ? void 0 : _c.getAriaLabel(), _c = 
      nls.localize("accessibilityModeOff", "The editor is not accessible at this time."), options ? nls.localize("accessibilityOffAriaLabel", "{0} To enable screen reader optimized mode, use {1}", _c, options) : _a ? nls.localize("accessibilityOffAriaLabelNoKb", "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", _c, _a) : _b ? nls.localize("accessibilityOffAriaLabelNoKbs", 
      "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", _c, _b) : _c) : options.get(4);
    }
    _setAccessibilityOptions(options) {
      this._accessibilitySupport = options.get(2);
      var accessibilityPageSize = options.get(3);
      this._accessibilityPageSize = this._accessibilitySupport === 2 && accessibilityPageSize === require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_config_SLASH_editorOptions_DOT_js.EditorOptions.accessibilityPageSize.defaultValue ? 500 : accessibilityPageSize;
      accessibilityPageSize = options.get(143).wrappingColumn;
      accessibilityPageSize !== -1 && this._accessibilitySupport !== 1 ? (options = options.get(50), this._textAreaWrapping = !0, this._textAreaWidth = Math.round(accessibilityPageSize * options.typicalHalfwidthCharacterWidth)) : (this._textAreaWrapping = !1, this._textAreaWidth = canUseZeroSizeTextarea ? 0 : 1);
    }
    onConfigurationChanged(e) {
      const options = this._context.configuration.options;
      var layoutInfo = options.get(143);
      this._setAccessibilityOptions(options);
      this._contentLeft = layoutInfo.contentLeft;
      this._contentWidth = layoutInfo.contentWidth;
      this._contentHeight = layoutInfo.height;
      this._fontInfo = options.get(50);
      this._lineHeight = options.get(66);
      this._emptySelectionClipboard = options.get(37);
      this._copyWithSyntaxHighlighting = options.get(25);
      this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
      ({tabSize:layoutInfo} = this._context.viewModel.model.getOptions());
      this.textArea.domNode.style.tabSize = `${layoutInfo * this._fontInfo.spaceWidth}px`;
      this.textArea.setAttribute("aria-label", this._getAriaLabel(options));
      this.textArea.setAttribute("aria-required", options.get(5) ? "true" : "false");
      this.textArea.setAttribute("tabindex", String(options.get(123)));
      (e.hasChanged(34) || e.hasChanged(90)) && this._ensureReadOnlyAttribute();
      e.hasChanged(2) && this._textAreaInput.writeNativeTextAreaContent("strategy changed");
      return !0;
    }
    onCursorStateChanged(e) {
      this._selections = e.selections.slice(0);
      this._modelSelections = e.modelSelections.slice(0);
      this._textAreaInput.writeNativeTextAreaContent("selection changed");
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      this._scrollLeft = e.scrollLeft;
      this._scrollTop = e.scrollTop;
      return !0;
    }
    onZonesChanged(e) {
      return !0;
    }
    isFocused() {
      return this._textAreaInput.isFocused();
    }
    focusTextArea() {
      this._textAreaInput.focusTextArea();
    }
    getLastRenderData() {
      return this._lastRenderPosition;
    }
    setAriaOptions(options) {
      options.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", options.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant"));
      options.role && this.textArea.setAttribute("role", options.role);
    }
    _ensureReadOnlyAttribute() {
      const options = this._context.configuration.options;
      !require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js.IME.enabled || options.get(34) && options.get(90) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly");
    }
    prepareRender(ctx) {
      var _a;
      this._primaryCursorPosition = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);
      this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);
      (_a = this._visibleTextArea) === null || _a === void 0 || _a.prepareRender(ctx);
    }
    render(ctx) {
      this._textAreaInput.writeNativeTextAreaContent("render");
      this._render();
    }
    _render() {
      if (this._visibleTextArea) {
        var visibleStart = this._visibleTextArea.visibleTextareaStart, visibleEnd = this._visibleTextArea.visibleTextareaEnd, startPosition = this._visibleTextArea.startPosition, endPosition = this._visibleTextArea.endPosition;
        if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {
          var _a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop;
          var lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart)), scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;
          let left = this._contentLeft + visibleStart.left - this._scrollLeft;
          visibleStart = visibleEnd.left - visibleStart.left + 1;
          left < this._contentLeft && (visibleEnd = this._contentLeft - left, left += visibleEnd, scrollLeft += visibleEnd, visibleStart -= visibleEnd);
          visibleStart > this._contentWidth && (visibleStart = this._contentWidth);
          visibleEnd = this._context.viewModel.getViewLineData(startPosition.lineNumber);
          startPosition = visibleEnd.tokens.findTokenIndexAtOffset(startPosition.column - 1);
          endPosition = visibleEnd.tokens.findTokenIndexAtOffset(endPosition.column - 1);
          endPosition = this._visibleTextArea.definePresentation(startPosition === endPosition ? visibleEnd.tokens.getPresentation(startPosition) : null);
          this.textArea.domNode.scrollTop = lineCount * this._lineHeight;
          this.textArea.domNode.scrollLeft = scrollLeft;
          this._doRender({lastRenderPosition:null, top:_a, left, width:visibleStart, height:this._lineHeight, useCover:!1, color:(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_languages_DOT_js.TokenizationRegistry.getColorMap() || [])[endPosition.foreground], italic:endPosition.italic, bold:endPosition.bold, underline:endPosition.underline, strikethrough:endPosition.strikethrough});
        }
      } else {
        this._primaryCursorVisibleRange ? (lineCount = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft, lineCount < this._contentLeft || lineCount > this._contentLeft + this._contentWidth ? this._renderAtTopLeft() : (scrollLeft = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop, scrollLeft < 0 || scrollLeft > this._contentHeight ? this._renderAtTopLeft() : platform.isMacintosh || this._accessibilitySupport === 
        2 ? (this._doRender({lastRenderPosition:this._primaryCursorPosition, top:scrollLeft, left:this._textAreaWrapping ? this._contentLeft : lineCount, width:this._textAreaWidth, height:this._lineHeight, useCover:!1}), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left, lineCount = (_a = this._textAreaInput.textAreaState.newlineCountBeforeSelection) !== null && _a !== void 0 ? _a : this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart)), 
        this.textArea.domNode.scrollTop = lineCount * this._lineHeight) : this._doRender({lastRenderPosition:this._primaryCursorPosition, top:scrollLeft, left:this._textAreaWrapping ? this._contentLeft : lineCount, width:this._textAreaWidth, height:canUseZeroSizeTextarea ? 0 : 1, useCover:!1}))) : this._renderAtTopLeft();
      }
    }
    _newlinecount(text) {
      let result = 0, startIndex = -1;
      do {
        startIndex = text.indexOf("\n", startIndex + 1);
        if (startIndex === -1) {
          break;
        }
        result++;
      } while (1);
      return result;
    }
    _renderAtTopLeft() {
      this._doRender({lastRenderPosition:null, top:0, left:0, width:this._textAreaWidth, height:canUseZeroSizeTextarea ? 0 : 1, useCover:!0});
    }
    _doRender(renderData) {
      this._lastRenderPosition = renderData.lastRenderPosition;
      const ta = this.textArea, tac = this.textAreaCover;
      (0,require$_DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js.applyFontInfo)(ta, this._fontInfo);
      ta.setTop(renderData.top);
      ta.setLeft(renderData.left);
      ta.setWidth(renderData.width);
      ta.setHeight(renderData.height);
      ta.setColor(renderData.color ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_color_DOT_js.Color.Format.CSS.formatHex(renderData.color) : "");
      ta.setFontStyle(renderData.italic ? "italic" : "");
      renderData.bold && ta.setFontWeight("bold");
      ta.setTextDecoration(`${renderData.underline ? " underline" : ""}${renderData.strikethrough ? " line-through" : ""}`);
      tac.setTop(renderData.useCover ? renderData.top : 0);
      tac.setLeft(renderData.useCover ? renderData.left : 0);
      tac.setWidth(renderData.useCover ? renderData.width : 0);
      tac.setHeight(renderData.useCover ? renderData.height : 0);
      renderData = this._context.configuration.options;
      renderData.get(57) ? tac.setClassName("monaco-editor-background textAreaCover " + require$_DOT__DOT__SLASH_viewParts_SLASH_margin_SLASH_margin_DOT_js.Margin.OUTER_CLASS_NAME) : renderData.get(67).renderType !== 0 ? tac.setClassName("monaco-editor-background textAreaCover " + require$_DOT__DOT__SLASH_viewParts_SLASH_lineNumbers_SLASH_lineNumbers_DOT_js.LineNumbersOverlay.CLASS_NAME) : tac.setClassName("monaco-editor-background textAreaCover");
    }
  };
  TextAreaHandler = (this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  })([exports(3, module.IKeybindingService), exports(4, require.IInstantiationService)], TextAreaHandler);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$controller$textAreaHandler.js.map
