shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorAtomicMoveOperations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AtomicTabMoveOperations:{enumerable:!0, get:function() {
    return AtomicTabMoveOperations;
  }}});
  var require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$cursorColumns");
  class AtomicTabMoveOperations {
    static whitespaceVisibleColumn(lineContent, position, tabSize) {
      const lineLength = lineContent.length;
      let visibleColumn = 0, prevTabStopPosition = -1, prevTabStopVisibleColumn = -1;
      for (let i = 0; i < lineLength; i++) {
        if (i === position) {
          return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];
        }
        visibleColumn % tabSize === 0 && (prevTabStopPosition = i, prevTabStopVisibleColumn = visibleColumn);
        switch(lineContent.charCodeAt(i)) {
          case 32:
            visibleColumn += 1;
            break;
          case 9:
            visibleColumn = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.nextRenderTabStop(visibleColumn, tabSize);
            break;
          default:
            return [-1, -1, -1];
        }
      }
      return position === lineLength ? [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] : [-1, -1, -1];
    }
    static atomicPosition(lineContent, position, tabSize, direction) {
      const lineLength = lineContent.length, [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);
      if (visibleColumn === -1) {
        return -1;
      }
      switch(direction) {
        case 0:
          var left = !0;
          break;
        case 1:
          left = !1;
          break;
        case 2:
          if (visibleColumn % tabSize === 0) {
            return position;
          }
          left = visibleColumn % tabSize <= tabSize / 2;
      }
      if (left) {
        if (prevTabStopPosition === -1) {
          return -1;
        }
        position = prevTabStopVisibleColumn;
        for (direction = prevTabStopPosition; direction < lineLength; ++direction) {
          if (position === prevTabStopVisibleColumn + tabSize) {
            return prevTabStopPosition;
          }
          switch(lineContent.charCodeAt(direction)) {
            case 32:
              position += 1;
              break;
            case 9:
              position = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.nextRenderTabStop(position, tabSize);
              break;
            default:
              return -1;
          }
        }
        return position === prevTabStopVisibleColumn + tabSize ? prevTabStopPosition : -1;
      }
      direction = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.nextRenderTabStop(visibleColumn, tabSize);
      for (left = visibleColumn; position < lineLength; position++) {
        if (left === direction) {
          return position;
        }
        switch(lineContent.charCodeAt(position)) {
          case 32:
            left += 1;
            break;
          case 9:
            left = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.nextRenderTabStop(left, tabSize);
            break;
          default:
            return -1;
        }
      }
      return left === direction ? lineLength : -1;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorAtomicMoveOperations.js.map
