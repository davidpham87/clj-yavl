shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LineTokens:{enumerable:!0, get:function() {
    return LineTokens;
  }}});
  var require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$encodedTokenAttributes");
  class LineTokens {
    static createEmpty(lineContent, decoder) {
      const defaultMetadata = LineTokens.defaultTokenMetadata, tokens = new Uint32Array(2);
      tokens[0] = lineContent.length;
      tokens[1] = defaultMetadata;
      return new LineTokens(tokens, lineContent, decoder);
    }
    constructor(tokens, text, decoder) {
      this._lineTokensBrand = void 0;
      this._tokens = tokens;
      this._tokensCount = this._tokens.length >>> 1;
      this._text = text;
      this._languageIdCodec = decoder;
    }
    equals(other) {
      return other instanceof LineTokens ? this.slicedEquals(other, 0, this._tokensCount) : !1;
    }
    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {
      if (this._text !== other._text || this._tokensCount !== other._tokensCount) {
        return !1;
      }
      sliceFromTokenIndex <<= 1;
      for (sliceTokenCount = sliceFromTokenIndex + (sliceTokenCount << 1); sliceFromTokenIndex < sliceTokenCount; sliceFromTokenIndex++) {
        if (this._tokens[sliceFromTokenIndex] !== other._tokens[sliceFromTokenIndex]) {
          return !1;
        }
      }
      return !0;
    }
    getLineContent() {
      return this._text;
    }
    getCount() {
      return this._tokensCount;
    }
    getStartOffset(tokenIndex) {
      return tokenIndex > 0 ? this._tokens[tokenIndex - 1 << 1] : 0;
    }
    getMetadata(tokenIndex) {
      return this._tokens[(tokenIndex << 1) + 1];
    }
    getLanguageId(tokenIndex) {
      tokenIndex = require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getLanguageId(this._tokens[(tokenIndex << 1) + 1]);
      return this._languageIdCodec.decodeLanguageId(tokenIndex);
    }
    getStandardTokenType(tokenIndex) {
      return require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getTokenType(this._tokens[(tokenIndex << 1) + 1]);
    }
    getForeground(tokenIndex) {
      return require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getForeground(this._tokens[(tokenIndex << 1) + 1]);
    }
    getClassName(tokenIndex) {
      return require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getClassNameFromMetadata(this._tokens[(tokenIndex << 1) + 1]);
    }
    getInlineStyle(tokenIndex, colorMap) {
      return require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getInlineStyleFromMetadata(this._tokens[(tokenIndex << 1) + 1], colorMap);
    }
    getPresentation(tokenIndex) {
      return require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getPresentationFromMetadata(this._tokens[(tokenIndex << 1) + 1]);
    }
    getEndOffset(tokenIndex) {
      return this._tokens[tokenIndex << 1];
    }
    findTokenIndexAtOffset(offset) {
      return LineTokens.findIndexInTokensArray(this._tokens, offset);
    }
    inflate() {
      return this;
    }
    sliceAndInflate(startOffset, endOffset, deltaOffset) {
      return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);
    }
    static convertToEndOffset(tokens, lineTextLength) {
      const lastTokenIndex = (tokens.length >>> 1) - 1;
      for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
        tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];
      }
      tokens[lastTokenIndex << 1] = lineTextLength;
    }
    static findIndexInTokensArray(tokens, desiredIndex) {
      if (tokens.length <= 2) {
        return 0;
      }
      let low = 0, high = (tokens.length >>> 1) - 1;
      for (; low < high;) {
        const mid = low + Math.floor((high - low) / 2), endOffset = tokens[mid << 1];
        if (endOffset === desiredIndex) {
          return mid + 1;
        }
        endOffset < desiredIndex ? low = mid + 1 : endOffset > desiredIndex && (high = mid);
      }
      return low;
    }
    withInserted(insertTokens) {
      if (insertTokens.length === 0) {
        return this;
      }
      let nextOriginalTokenIdx = 0, nextInsertTokenIdx = 0, text = "";
      const newTokens = [];
      let originalEndOffset = 0;
      for (;;) {
        const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1, nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;
        if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {
          text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset), newTokens.push(text.length, this._tokens[(nextOriginalTokenIdx << 1) + 1]), nextOriginalTokenIdx++, originalEndOffset = nextOriginalTokenEndOffset;
        } else if (nextInsertToken) {
          nextInsertToken.offset > originalEndOffset && (text += this._text.substring(originalEndOffset, nextInsertToken.offset), newTokens.push(text.length, this._tokens[(nextOriginalTokenIdx << 1) + 1]), originalEndOffset = nextInsertToken.offset), text += nextInsertToken.text, newTokens.push(text.length, nextInsertToken.tokenMetadata), nextInsertTokenIdx++;
        } else {
          break;
        }
      }
      return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);
    }
  }
  LineTokens.defaultTokenMetadata = 33587200;
  class SliceLineTokens {
    constructor(source, startOffset, endOffset, deltaOffset) {
      this._source = source;
      this._startOffset = startOffset;
      this._endOffset = endOffset;
      this._deltaOffset = deltaOffset;
      this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
      this._tokensCount = 0;
      for (let i = this._firstTokenIndex, len = source.getCount(); i < len && !(source.getStartOffset(i) >= endOffset); i++) {
        this._tokensCount++;
      }
    }
    getMetadata(tokenIndex) {
      return this._source.getMetadata(this._firstTokenIndex + tokenIndex);
    }
    getLanguageId(tokenIndex) {
      return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);
    }
    getLineContent() {
      return this._source.getLineContent().substring(this._startOffset, this._endOffset);
    }
    equals(other) {
      return other instanceof SliceLineTokens ? this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount) : !1;
    }
    getCount() {
      return this._tokensCount;
    }
    getForeground(tokenIndex) {
      return this._source.getForeground(this._firstTokenIndex + tokenIndex);
    }
    getEndOffset(tokenIndex) {
      tokenIndex = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
      return Math.min(this._endOffset, tokenIndex) - this._startOffset + this._deltaOffset;
    }
    getClassName(tokenIndex) {
      return this._source.getClassName(this._firstTokenIndex + tokenIndex);
    }
    getInlineStyle(tokenIndex, colorMap) {
      return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
    }
    getPresentation(tokenIndex) {
      return this._source.getPresentation(this._firstTokenIndex + tokenIndex);
    }
    findTokenIndexAtOffset(offset) {
      return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens.js.map
