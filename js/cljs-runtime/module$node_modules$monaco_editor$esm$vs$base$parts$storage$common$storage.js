shadow$provide.module$node_modules$monaco_editor$esm$vs$base$parts$storage$common$storage = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, InMemoryStorageDatabase:{enumerable:!0, get:function() {
    return InMemoryStorageDatabase;
  }}, Storage:{enumerable:!0, get:function() {
    return Storage;
  }}, StorageHint:{enumerable:!0, get:function() {
    return StorageHint;
  }}, StorageState:{enumerable:!0, get:function() {
    return StorageState;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_marshalling_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$marshalling"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types"), StorageHint;
  (function(StorageHint) {
    StorageHint[StorageHint.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST";
    StorageHint[StorageHint.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
  })(StorageHint ||= {});
  var StorageState;
  (function(StorageState) {
    StorageState[StorageState.None = 0] = "None";
    StorageState[StorageState.Initialized = 1] = "Initialized";
    StorageState[StorageState.Closed = 2] = "Closed";
  })(StorageState ||= {});
  class Storage extends module.Disposable {
    constructor(database, options = Object.create(null)) {
      super();
      this.database = database;
      this.options = options;
      this._onDidChangeStorage = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.PauseableEmitter());
      this.onDidChangeStorage = this._onDidChangeStorage.event;
      this.state = StorageState.None;
      this.cache = new Map();
      this.flushDelayer = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));
      this.pendingDeletes = new Set();
      this.pendingInserts = new Map();
      this.whenFlushedCallbacks = [];
      this.registerListeners();
    }
    registerListeners() {
      this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));
    }
    onDidChangeItemsExternal(e) {
      var _a, _b;
      this._onDidChangeStorage.pause();
      try {
        (_a = e.changed) === null || _a === void 0 || _a.forEach((value, key) => this.acceptExternal(key, value)), (_b = e.deleted) === null || _b === void 0 || _b.forEach(key => this.acceptExternal(key, void 0));
      } finally {
        this._onDidChangeStorage.resume();
      }
    }
    acceptExternal(key, value) {
      if (this.state !== StorageState.Closed) {
        var changed = !1;
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isUndefinedOrNull)(value) ? changed = this.cache.delete(key) : this.cache.get(key) !== value && (this.cache.set(key, value), changed = !0);
        changed && this._onDidChangeStorage.fire({key, external:!0});
      }
    }
    get(key, fallbackValue) {
      key = this.cache.get(key);
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isUndefinedOrNull)(key) ? fallbackValue : key;
    }
    getBoolean(key, fallbackValue) {
      key = this.get(key);
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isUndefinedOrNull)(key) ? fallbackValue : key === "true";
    }
    getNumber(key, fallbackValue) {
      key = this.get(key);
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isUndefinedOrNull)(key) ? fallbackValue : parseInt(key, 10);
    }
    async set(key, value, external = !1) {
      if (this.state !== StorageState.Closed) {
        if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isUndefinedOrNull)(value)) {
          return this.delete(key, external);
        }
        value = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isObject)(value) || Array.isArray(value) ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_marshalling_DOT_js.stringify)(value) : String(value);
        if (this.cache.get(key) !== value) {
          return this.cache.set(key, value), this.pendingInserts.set(key, value), this.pendingDeletes.delete(key), this._onDidChangeStorage.fire({key, external}), this.doFlush();
        }
      }
    }
    async delete(key, external = !1) {
      if (this.state !== StorageState.Closed && this.cache.delete(key)) {
        return this.pendingDeletes.has(key) || this.pendingDeletes.add(key), this.pendingInserts.delete(key), this._onDidChangeStorage.fire({key, external}), this.doFlush();
      }
    }
    get hasPending() {
      return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
    }
    async flushPending() {
      if (this.hasPending) {
        var updateRequest = {insert:this.pendingInserts, delete:this.pendingDeletes};
        this.pendingDeletes = new Set();
        this.pendingInserts = new Map();
        return this.database.updateItems(updateRequest).finally(() => {
          var _a;
          if (!this.hasPending) {
            for (; this.whenFlushedCallbacks.length;) {
              (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 || _a();
            }
          }
        });
      }
    }
    async doFlush(delay) {
      return this.options.hint === StorageHint.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), delay);
    }
  }
  Storage.DEFAULT_FLUSH_DELAY = 100;
  class InMemoryStorageDatabase {
    constructor() {
      this.onDidChangeItemsExternal = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.None;
      this.items = new Map();
    }
    async updateItems(request) {
      var _a, _b;
      (_a = request.insert) === null || _a === void 0 || _a.forEach((value, key) => this.items.set(key, value));
      (_b = request.delete) === null || _b === void 0 || _b.forEach(key => this.items.delete(key));
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$parts$storage$common$storage.js.map
