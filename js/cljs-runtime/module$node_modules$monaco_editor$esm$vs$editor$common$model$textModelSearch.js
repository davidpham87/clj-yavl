shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelSearch = function(require, module, exports) {
  function isMultilineRegexSource(searchString) {
    if (!searchString || searchString.length === 0) {
      return !1;
    }
    for (let i = 0, len = searchString.length; i < len; i++) {
      var chCode = searchString.charCodeAt(i);
      if (chCode === 10) {
        return !0;
      }
      if (chCode === 92) {
        i++;
        if (i >= len) {
          break;
        }
        chCode = searchString.charCodeAt(i);
        if (chCode === 110 || chCode === 114 || chCode === 87) {
          return !0;
        }
      }
    }
    return !1;
  }
  function createFindMatch(range, rawMatches, captureMatches) {
    if (!captureMatches) {
      return new require$_DOT__DOT__SLASH_model_DOT_js.FindMatch(range, null);
    }
    captureMatches = [];
    for (let i = 0, len = rawMatches.length; i < len; i++) {
      captureMatches[i] = rawMatches[i];
    }
    return new require$_DOT__DOT__SLASH_model_DOT_js.FindMatch(range, captureMatches);
  }
  function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    a: {
      if (matchStartIndex === 0) {
        var JSCompiler_inline_result = !0;
      } else {
        if (JSCompiler_inline_result = text.charCodeAt(matchStartIndex - 1), wordSeparators.get(JSCompiler_inline_result) !== 0) {
          JSCompiler_inline_result = !0;
        } else {
          if (JSCompiler_inline_result === 13 || JSCompiler_inline_result === 10) {
            JSCompiler_inline_result = !0;
          } else {
            if (matchLength > 0 && (JSCompiler_inline_result = text.charCodeAt(matchStartIndex), wordSeparators.get(JSCompiler_inline_result) !== 0)) {
              JSCompiler_inline_result = !0;
              break a;
            }
            JSCompiler_inline_result = !1;
          }
        }
      }
    }
    if (JSCompiler_inline_result) {
      a: {
        if (matchStartIndex + matchLength === textLength) {
          JSCompiler_inline_result = !0;
        } else {
          if (textLength = text.charCodeAt(matchStartIndex + matchLength), wordSeparators.get(textLength) !== 0) {
            JSCompiler_inline_result = !0;
          } else {
            if (textLength === 13 || textLength === 10) {
              JSCompiler_inline_result = !0;
            } else {
              if (matchLength > 0 && (text = text.charCodeAt(matchStartIndex + matchLength - 1), wordSeparators.get(text) !== 0)) {
                JSCompiler_inline_result = !0;
                break a;
              }
              JSCompiler_inline_result = !1;
            }
          }
        }
      }
    }
    return JSCompiler_inline_result;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SearchParams:{enumerable:!0, get:function() {
    return SearchParams;
  }}, Searcher:{enumerable:!0, get:function() {
    return Searcher;
  }}, TextModelSearch:{enumerable:!0, get:function() {
    return TextModelSearch;
  }}, createFindMatch:{enumerable:!0, get:function() {
    return createFindMatch;
  }}, isMultilineRegexSource:{enumerable:!0, get:function() {
    return isMultilineRegexSource;
  }}, isValidMatch:{enumerable:!0, get:function() {
    return isValidMatch;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordCharacterClassifier"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), 
  require$_DOT__DOT__SLASH_model_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model");
  class SearchParams {
    constructor(searchString, isRegex, matchCase, wordSeparators) {
      this.searchString = searchString;
      this.isRegex = isRegex;
      this.matchCase = matchCase;
      this.wordSeparators = wordSeparators;
    }
    parseSearchRequest() {
      if (this.searchString === "") {
        return null;
      }
      var multiline = this.isRegex ? isMultilineRegexSource(this.searchString) : this.searchString.indexOf("\n") >= 0;
      let regex = null;
      try {
        regex = strings.createRegExp(this.searchString, this.isRegex, {matchCase:this.matchCase, wholeWord:!1, multiline, global:!0, unicode:!0});
      } catch (err) {
        return null;
      }
      if (!regex) {
        return null;
      }
      (multiline = !this.isRegex && !multiline) && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (multiline = this.matchCase);
      return new require$_DOT__DOT__SLASH_model_DOT_js.SearchData(regex, this.wordSeparators ? (0,require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js.getMapForWordSeparators)(this.wordSeparators) : null, multiline ? this.searchString : null);
    }
  }
  class LineFeedCounter {
    constructor(text) {
      const lineFeedsOffsets = [];
      let lineFeedsOffsetsLen = 0;
      for (let i = 0, textLen = text.length; i < textLen; i++) {
        text.charCodeAt(i) === 10 && (lineFeedsOffsets[lineFeedsOffsetsLen++] = i);
      }
      this._lineFeedsOffsets = lineFeedsOffsets;
    }
    findLineFeedCountBeforeOffset(offset) {
      const lineFeedsOffsets = this._lineFeedsOffsets;
      let min = 0, max = lineFeedsOffsets.length - 1;
      if (max === -1 || offset <= lineFeedsOffsets[0]) {
        return 0;
      }
      for (; min < max;) {
        const mid = min + ((max - min) / 2 >> 0);
        lineFeedsOffsets[mid] >= offset ? max = mid - 1 : lineFeedsOffsets[mid + 1] >= offset ? max = min = mid : min = mid + 1;
      }
      return min + 1;
    }
  }
  class TextModelSearch {
    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {
      return (searchParams = searchParams.parseSearchRequest()) ? searchParams.regex.multiline ? this._doFindMatchesMultiline(model, searchRange, new Searcher(searchParams.wordSeparators, searchParams.regex), captureMatches, limitResultCount) : this._doFindMatchesLineByLine(model, searchRange, searchParams, captureMatches, limitResultCount) : [];
    }
    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {
      text = 0;
      lfCounter ? (text = lfCounter.findLineFeedCountBeforeOffset(matchIndex), deltaOffset = deltaOffset + matchIndex + text) : deltaOffset += matchIndex;
      lfCounter ? (lfCounter = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length), match0 = deltaOffset + match0.length + (lfCounter - text)) : match0 = deltaOffset + match0.length;
      lfCounter = model.getPositionAt(deltaOffset);
      model = model.getPositionAt(match0);
      return new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lfCounter.lineNumber, lfCounter.column, model.lineNumber, model.column);
    }
    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {
      const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
      searchRange = model.getValueInRange(searchRange, 1);
      const lfCounter = model.getEOL() === "\r\n" ? new LineFeedCounter(searchRange) : null, result = [];
      let counter = 0, m;
      for (searcher.reset(0); (m = searcher.next(searchRange)) && !(result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, searchRange, lfCounter, m.index, m[0]), m, captureMatches), counter >= limitResultCount);) {
      }
      return result;
    }
    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {
      const result = [];
      let resultLen = 0;
      if (searchRange.startLineNumber === searchRange.endLineNumber) {
        return model = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1), this._findMatchesInLine(searchData, model, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount), result;
      }
      var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
      resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
      for (text = searchRange.startLineNumber + 1; text < searchRange.endLineNumber && resultLen < limitResultCount; text++) {
        resultLen = this._findMatchesInLine(searchData, model.getLineContent(text), text, 0, resultLen, result, captureMatches, limitResultCount);
      }
      resultLen < limitResultCount && (model = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1), this._findMatchesInLine(searchData, model, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount));
      return result;
    }
    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
      var wordSeparators = searchData.wordSeparators;
      if (!captureMatches && searchData.simpleSearch) {
        captureMatches = searchData.simpleSearch;
        searchData = captureMatches.length;
        const textLength = text.length;
        let lastMatchIndex = -searchData;
        for (; (lastMatchIndex = text.indexOf(captureMatches, lastMatchIndex + searchData)) !== -1;) {
          if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchData)) {
            if (result[resultLen++] = new require$_DOT__DOT__SLASH_model_DOT_js.FindMatch(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchData + deltaOffset), null), resultLen >= limitResultCount) {
              break;
            }
          }
        }
        return resultLen;
      }
      wordSeparators = new Searcher(searchData.wordSeparators, searchData.regex);
      wordSeparators.reset(0);
      do {
        if (searchData = wordSeparators.next(text)) {
          if (result[resultLen++] = createFindMatch(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, searchData.index + 1 + deltaOffset, lineNumber, searchData.index + 1 + searchData[0].length + deltaOffset), searchData, captureMatches), resultLen >= limitResultCount) {
            break;
          }
        }
      } while (searchData);
      return resultLen;
    }
    static findNextMatch(model, searchParams, searchStart, captureMatches) {
      searchParams = searchParams.parseSearchRequest();
      if (!searchParams) {
        return null;
      }
      const searcher = new Searcher(searchParams.wordSeparators, searchParams.regex);
      return searchParams.regex.multiline ? this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) : this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
    }
    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {
      var searchTextStart = new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(searchStart.lineNumber, 1);
      const deltaOffset = model.getOffsetAt(searchTextStart);
      var lineCount = model.getLineCount();
      searchTextStart = model.getValueInRange(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1);
      lineCount = model.getEOL() === "\r\n" ? new LineFeedCounter(searchTextStart) : null;
      searcher.reset(searchStart.column - 1);
      const m = searcher.next(searchTextStart);
      return m ? createFindMatch(this._getMultilineMatchRange(model, deltaOffset, searchTextStart, lineCount, m.index, m[0]), m, captureMatches) : searchStart.lineNumber !== 1 || searchStart.column !== 1 ? this._doFindNextMatchMultiline(model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(1, 1), searcher, captureMatches) : null;
    }
    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {
      const lineCount = model.getLineCount(), startLineNumber = searchStart.lineNumber;
      var text$jscomp$0 = model.getLineContent(startLineNumber);
      if (searchStart = this._findFirstMatchInLine(searcher, text$jscomp$0, startLineNumber, searchStart.column, captureMatches)) {
        return searchStart;
      }
      for (searchStart = 1; searchStart <= lineCount; searchStart++) {
        text$jscomp$0 = (startLineNumber + searchStart - 1) % lineCount;
        const text = model.getLineContent(text$jscomp$0 + 1);
        if (text$jscomp$0 = this._findFirstMatchInLine(searcher, text, text$jscomp$0 + 1, 1, captureMatches)) {
          return text$jscomp$0;
        }
      }
      return null;
    }
    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {
      searcher.reset(fromColumn - 1);
      return (searcher = searcher.next(text)) ? createFindMatch(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, searcher.index + 1, lineNumber, searcher.index + 1 + searcher[0].length), searcher, captureMatches) : null;
    }
    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {
      searchParams = searchParams.parseSearchRequest();
      if (!searchParams) {
        return null;
      }
      const searcher = new Searcher(searchParams.wordSeparators, searchParams.regex);
      return searchParams.regex.multiline ? this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) : this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
    }
    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {
      var matches = this._doFindMatchesMultiline(model, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 9990);
      if (matches.length > 0) {
        return matches[matches.length - 1];
      }
      matches = model.getLineCount();
      return searchStart.lineNumber !== matches || searchStart.column !== model.getLineMaxColumn(matches) ? this._doFindPreviousMatchMultiline(model, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(matches, model.getLineMaxColumn(matches)), searcher, captureMatches) : null;
    }
    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {
      const lineCount = model.getLineCount(), startLineNumber = searchStart.lineNumber;
      searchStart = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
      if (searchStart = this._findLastMatchInLine(searcher, searchStart, startLineNumber, captureMatches)) {
        return searchStart;
      }
      for (searchStart = 1; searchStart <= lineCount; searchStart++) {
        var lineIndex = (lineCount + startLineNumber - searchStart - 1) % lineCount;
        const text = model.getLineContent(lineIndex + 1);
        if (lineIndex = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches)) {
          return lineIndex;
        }
      }
      return null;
    }
    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {
      let bestResult = null, m;
      for (searcher.reset(0); m = searcher.next(text);) {
        bestResult = createFindMatch(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
      }
      return bestResult;
    }
  }
  class Searcher {
    constructor(wordSeparators, searchRegex) {
      this._wordSeparators = wordSeparators;
      this._searchRegex = searchRegex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    reset(lastIndex) {
      this._searchRegex.lastIndex = lastIndex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    next(text) {
      const textLength = text.length;
      let m;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
          break;
        }
        m = this._searchRegex.exec(text);
        if (!m) {
          break;
        }
        const matchStartIndex = m.index, matchLength = m[0].length;
        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
          if (matchLength === 0) {
            strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
            continue;
          }
          break;
        }
        this._prevMatchStartIndex = matchStartIndex;
        this._prevMatchLength = matchLength;
        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
          return m;
        }
      } while (m);
      return null;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelSearch.js.map
