shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeBase = function(require, module, exports) {
  function createUintArray(arr) {
    let r;
    r = arr[arr.length - 1] < 65536 ? new Uint16Array(arr.length) : new Uint32Array(arr.length);
    r.set(arr, 0);
    return r;
  }
  function createLineStartsFast(str, readonly = !0) {
    const r = [0];
    let rLength = 1;
    for (let i = 0, len = str.length; i < len; i++) {
      const chr = str.charCodeAt(i);
      chr === 13 ? i + 1 < len && str.charCodeAt(i + 1) === 10 ? (r[rLength++] = i + 2, i++) : r[rLength++] = i + 1 : chr === 10 && (r[rLength++] = i + 1);
    }
    return readonly ? createUintArray(r) : r;
  }
  function createLineStarts(r, str) {
    r.length = 0;
    r[0] = 0;
    let rLength = 1, cr = 0, lf = 0, crlf = 0, isBasicASCII = !0;
    for (let i = 0, len = str.length; i < len; i++) {
      const chr = str.charCodeAt(i);
      chr === 13 ? i + 1 < len && str.charCodeAt(i + 1) === 10 ? (crlf++, r[rLength++] = i + 2, i++) : (cr++, r[rLength++] = i + 1) : chr === 10 ? (lf++, r[rLength++] = i + 1) : isBasicASCII && chr !== 9 && (chr < 32 || chr > 126) && (isBasicASCII = !1);
    }
    str = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);
    r.length = 0;
    return str;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, Piece:{enumerable:!0, get:function() {
    return Piece;
  }}, PieceTreeBase:{enumerable:!0, get:function() {
    return PieceTreeBase;
  }}, StringBuffer:{enumerable:!0, get:function() {
    return StringBuffer;
  }}, createLineStarts:{enumerable:!0, get:function() {
    return createLineStarts;
  }}, createLineStartsFast:{enumerable:!0, get:function() {
    return createLineStartsFast;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_model_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model"), require$_DOT__SLASH_rbTreeBase_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$rbTreeBase"), 
  require$_DOT__DOT__SLASH_textModelSearch_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelSearch");
  class LineStarts {
    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {
      this.lineStarts = lineStarts;
      this.cr = cr;
      this.lf = lf;
      this.crlf = crlf;
      this.isBasicASCII = isBasicASCII;
    }
  }
  class Piece {
    constructor(bufferIndex, start, end, lineFeedCnt, length) {
      this.bufferIndex = bufferIndex;
      this.start = start;
      this.end = end;
      this.lineFeedCnt = lineFeedCnt;
      this.length = length;
    }
  }
  class StringBuffer {
    constructor(buffer, lineStarts) {
      this.buffer = buffer;
      this.lineStarts = lineStarts;
    }
  }
  class PieceTreeSnapshot {
    constructor(tree, BOM) {
      this._pieces = [];
      this._tree = tree;
      this._BOM = BOM;
      this._index = 0;
      tree.root !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL && tree.iterate(tree.root, node => {
        node !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL && this._pieces.push(node.piece);
        return !0;
      });
    }
    read() {
      return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
    }
  }
  class PieceTreeSearchCache {
    constructor(limit) {
      this._limit = limit;
      this._cache = [];
    }
    get(offset) {
      for (let i = this._cache.length - 1; i >= 0; i--) {
        const nodePos = this._cache[i];
        if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
          return nodePos;
        }
      }
      return null;
    }
    get2(lineNumber) {
      for (let i = this._cache.length - 1; i >= 0; i--) {
        const nodePos = this._cache[i];
        if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
          return nodePos;
        }
      }
      return null;
    }
    set(nodePosition) {
      this._cache.length >= this._limit && this._cache.shift();
      this._cache.push(nodePosition);
    }
    validate(offset) {
      let hasInvalidVal = !1;
      const tmp = this._cache;
      for (let i = 0; i < tmp.length; i++) {
        const nodePos = tmp[i];
        if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
          tmp[i] = null, hasInvalidVal = !0;
        }
      }
      if (hasInvalidVal) {
        offset = [];
        for (const entry of tmp) {
          entry !== null && offset.push(entry);
        }
        this._cache = offset;
      }
    }
  }
  class PieceTreeBase {
    constructor(chunks, eol, eolNormalized) {
      this.create(chunks, eol, eolNormalized);
    }
    create(chunks, eol, eolNormalized) {
      this._buffers = [new StringBuffer("", [0])];
      this._lastChangeBufferPos = {line:0, column:0};
      this.root = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      this._lineCnt = 1;
      this._length = 0;
      this._EOL = eol;
      this._EOLLength = eol.length;
      this._EOLNormalized = eolNormalized;
      eol = null;
      for (let i = 0, len = chunks.length; i < len; i++) {
        chunks[i].buffer.length > 0 && (chunks[i].lineStarts || (chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer)), eolNormalized = new Piece(i + 1, {line:0, column:0}, {line:chunks[i].lineStarts.length - 1, column:chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]}, chunks[i].lineStarts.length - 1, chunks[i].buffer.length), this._buffers.push(chunks[i]), eol = this.rbInsertRight(eol, eolNormalized));
      }
      this._searchCache = new PieceTreeSearchCache(1);
      this._lastVisitedLine = {lineNumber:0, value:""};
      this.computeBufferMetadata();
    }
    normalizeEOL(eol) {
      let tempChunk = "", tempChunkLen = 0;
      const chunks = [];
      this.iterate(this.root, node => {
        node = this.getNodeContent(node);
        const len = node.length;
        if (tempChunkLen <= 43690 || tempChunkLen + len < 87380) {
          return tempChunk += node, tempChunkLen += len, !0;
        }
        const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
        chunks.push(new StringBuffer(text, createLineStartsFast(text)));
        tempChunk = node;
        tempChunkLen = len;
        return !0;
      });
      if (tempChunkLen > 0) {
        const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
        chunks.push(new StringBuffer(text, createLineStartsFast(text)));
      }
      this.create(chunks, eol, !0);
    }
    getEOL() {
      return this._EOL;
    }
    setEOL(newEOL) {
      this._EOL = newEOL;
      this._EOLLength = this._EOL.length;
      this.normalizeEOL(newEOL);
    }
    createSnapshot(BOM) {
      return new PieceTreeSnapshot(this, BOM);
    }
    getOffsetAt(lineNumber, column) {
      let leftLen = 0, x = this.root;
      for (; x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        if (x.left !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL && x.lf_left + 1 >= lineNumber) {
          x = x.left;
        } else {
          if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
            return leftLen += x.size_left, lineNumber = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2), leftLen + (lineNumber + column - 1);
          }
          lineNumber -= x.lf_left + x.piece.lineFeedCnt;
          leftLen += x.size_left + x.piece.length;
          x = x.right;
        }
      }
      return leftLen;
    }
    getPositionAt(offset) {
      offset = Math.floor(offset);
      offset = Math.max(0, offset);
      var x = this.root;
      let lfCnt = 0;
      const originalOffset = offset;
      for (; x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        if (x.size_left !== 0 && x.size_left >= offset) {
          x = x.left;
        } else {
          if (x.size_left + x.piece.length >= offset) {
            return offset = this.getIndexOf(x, offset - x.size_left), lfCnt += x.lf_left + offset.index, offset.index === 0 ? (offset = this.getOffsetAt(lfCnt + 1, 1), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lfCnt + 1, originalOffset - offset + 1)) : new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lfCnt + 1, offset.remainder + 1);
          }
          offset -= x.size_left + x.piece.length;
          lfCnt += x.lf_left + x.piece.lineFeedCnt;
          if (x.right === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL) {
            return x = this.getOffsetAt(lfCnt + 1, 1), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lfCnt + 1, originalOffset - offset - x + 1);
          }
          x = x.right;
        }
      }
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(1, 1);
    }
    getValueInRange(range, eol) {
      if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
        return "";
      }
      var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);
      range = this.nodeAt2(range.endLineNumber, range.endColumn);
      startPosition = this.getValueInRange2(startPosition, range);
      return eol ? eol === this._EOL && this._EOLNormalized ? eol === this.getEOL() && this._EOLNormalized ? startPosition : startPosition.replace(/\r\n|\r|\n/g, eol) : startPosition.replace(/\r\n|\r|\n/g, eol) : startPosition;
    }
    getValueInRange2(startPosition, endPosition) {
      if (startPosition.node === endPosition.node) {
        var node = startPosition.node, buffer = this._buffers[node.piece.bufferIndex].buffer;
        node = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
        return buffer.substring(node + startPosition.remainder, node + endPosition.remainder);
      }
      buffer = startPosition.node;
      node = this._buffers[buffer.piece.bufferIndex].buffer;
      var startOffset = this.offsetInBuffer(buffer.piece.bufferIndex, buffer.piece.start);
      startPosition = node.substring(startOffset + startPosition.remainder, startOffset + buffer.piece.length);
      for (buffer = buffer.next(); buffer !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        node = this._buffers[buffer.piece.bufferIndex].buffer;
        startOffset = this.offsetInBuffer(buffer.piece.bufferIndex, buffer.piece.start);
        if (buffer === endPosition.node) {
          startPosition += node.substring(startOffset, startOffset + endPosition.remainder);
          break;
        } else {
          startPosition += node.substr(startOffset, buffer.piece.length);
        }
        buffer = buffer.next();
      }
      return startPosition;
    }
    getLinesContent() {
      const lines = [];
      let linesLength = 0, currentLine = "", danglingCR = !1;
      this.iterate(this.root, node => {
        if (node === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL) {
          return !0;
        }
        node = node.piece;
        var pieceLength = node.length;
        if (pieceLength === 0) {
          return !0;
        }
        const buffer = this._buffers[node.bufferIndex].buffer, lineStarts = this._buffers[node.bufferIndex].lineStarts, pieceStartLine = node.start.line, pieceEndLine = node.end.line;
        let pieceStartOffset = lineStarts[pieceStartLine] + node.start.column;
        if (danglingCR && (buffer.charCodeAt(pieceStartOffset) === 10 && (pieceStartOffset++, pieceLength--), lines[linesLength++] = currentLine, currentLine = "", danglingCR = !1, pieceLength === 0)) {
          return !0;
        }
        if (pieceStartLine === pieceEndLine) {
          return this._EOLNormalized || buffer.charCodeAt(pieceStartOffset + pieceLength - 1) !== 13 ? currentLine += buffer.substr(pieceStartOffset, pieceLength) : (danglingCR = !0, currentLine += buffer.substr(pieceStartOffset, pieceLength - 1)), !0;
        }
        currentLine += this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, "");
        lines[linesLength++] = currentLine;
        for (pieceLength = pieceStartLine + 1; pieceLength < pieceEndLine; pieceLength++) {
          currentLine = this._EOLNormalized ? buffer.substring(lineStarts[pieceLength], lineStarts[pieceLength + 1] - this._EOLLength) : buffer.substring(lineStarts[pieceLength], lineStarts[pieceLength + 1]).replace(/(\r\n|\r|\n)$/, ""), lines[linesLength++] = currentLine;
        }
        this._EOLNormalized || buffer.charCodeAt(lineStarts[pieceEndLine] + node.end.column - 1) !== 13 ? currentLine = buffer.substr(lineStarts[pieceEndLine], node.end.column) : (danglingCR = !0, node.end.column === 0 ? linesLength-- : currentLine = buffer.substr(lineStarts[pieceEndLine], node.end.column - 1));
        return !0;
      });
      danglingCR && (lines[linesLength++] = currentLine, currentLine = "");
      lines[linesLength++] = currentLine;
      return lines;
    }
    getLength() {
      return this._length;
    }
    getLineCount() {
      return this._lineCnt;
    }
    getLineContent(lineNumber) {
      if (this._lastVisitedLine.lineNumber === lineNumber) {
        return this._lastVisitedLine.value;
      }
      this._lastVisitedLine.lineNumber = lineNumber;
      this._lastVisitedLine.value = lineNumber === this._lineCnt ? this.getLineRawContent(lineNumber) : this._EOLNormalized ? this.getLineRawContent(lineNumber, this._EOLLength) : this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, "");
      return this._lastVisitedLine.value;
    }
    _getCharCode(nodePos) {
      if (nodePos.remainder === nodePos.node.piece.length) {
        nodePos = nodePos.node.next();
        if (!nodePos) {
          return 0;
        }
        var buffer = this._buffers[nodePos.piece.bufferIndex];
        nodePos = this.offsetInBuffer(nodePos.piece.bufferIndex, nodePos.piece.start);
        return buffer.buffer.charCodeAt(nodePos);
      }
      buffer = this._buffers[nodePos.node.piece.bufferIndex];
      nodePos = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start) + nodePos.remainder;
      return buffer.buffer.charCodeAt(nodePos);
    }
    getLineCharCode(lineNumber, index) {
      lineNumber = this.nodeAt2(lineNumber, index + 1);
      return this._getCharCode(lineNumber);
    }
    getLineLength(lineNumber) {
      return lineNumber === this.getLineCount() ? (lineNumber = this.getOffsetAt(lineNumber, 1), this.getLength() - lineNumber) : this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
    }
    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
      var buffer = this._buffers[node.piece.bufferIndex];
      searchData = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
      const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
      endCursor = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
      const ret = {line:0, column:0};
      let searchText, offsetInBuffer;
      searcher._wordSeparators ? (searchText = buffer.buffer.substring(start, endCursor), offsetInBuffer = offset => offset + start, searcher.reset(0)) : (searchText = buffer.buffer, offsetInBuffer = offset => offset, searcher.reset(start));
      do {
        if (buffer = searcher.next(searchText)) {
          if (offsetInBuffer(buffer.index) >= endCursor) {
            break;
          }
          this.positionInBuffer(node, offsetInBuffer(buffer.index) - searchData, ret);
          const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret), retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1, retEndColumn = retStartColumn + buffer[0].length;
          result[resultLen++] = (0,require$_DOT__DOT__SLASH_textModelSearch_DOT_js.createFindMatch)(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), buffer, captureMatches);
          if (offsetInBuffer(buffer.index) + buffer[0].length >= endCursor) {
            break;
          }
          if (resultLen >= limitResultCount) {
            break;
          }
        }
      } while (buffer);
      return resultLen;
    }
    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
      const result = [];
      let resultLen = 0;
      const searcher = new require$_DOT__DOT__SLASH_textModelSearch_DOT_js.Searcher(searchData.wordSeparators, searchData.regex);
      var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
      if (startPosition === null) {
        return [];
      }
      var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
      if (endPosition === null) {
        return [];
      }
      var start = this.positionInBuffer(startPosition.node, startPosition.remainder);
      const end = this.positionInBuffer(endPosition.node, endPosition.remainder);
      if (startPosition.node === endPosition.node) {
        return this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result), result;
      }
      var startLineNumber = searchRange.startLineNumber;
      let currentNode = startPosition.node;
      for (; currentNode !== endPosition.node;) {
        startPosition = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
        if (startPosition >= 1) {
          const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts, startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
          resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1, start, this.positionInBuffer(currentNode, lineStarts[start.line + startPosition] - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
          if (resultLen >= limitResultCount) {
            return result;
          }
          startLineNumber += startPosition;
        }
        start = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
        if (startLineNumber === searchRange.endLineNumber) {
          return startLineNumber = this.getLineContent(startLineNumber).substring(start, searchRange.endColumn - 1), this._findMatchesInLine(searchData, searcher, startLineNumber, searchRange.endLineNumber, start, resultLen, result, captureMatches, limitResultCount), result;
        }
        resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(start), startLineNumber, start, resultLen, result, captureMatches, limitResultCount);
        if (resultLen >= limitResultCount) {
          return result;
        }
        startLineNumber++;
        startPosition = this.nodeAt2(startLineNumber, 1);
        currentNode = startPosition.node;
        start = this.positionInBuffer(startPosition.node, startPosition.remainder);
      }
      if (startLineNumber === searchRange.endLineNumber) {
        return endPosition = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0, startLineNumber = this.getLineContent(startLineNumber).substring(endPosition, searchRange.endColumn - 1), this._findMatchesInLine(searchData, searcher, startLineNumber, searchRange.endLineNumber, endPosition, resultLen, result, captureMatches, limitResultCount), result;
      }
      this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
      return result;
    }
    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
      var wordSeparators = searchData.wordSeparators;
      if (!captureMatches && searchData.simpleSearch) {
        searcher = searchData.simpleSearch;
        captureMatches = searcher.length;
        searchData = text.length;
        let lastMatchIndex = -captureMatches;
        for (; (lastMatchIndex = text.indexOf(searcher, lastMatchIndex + captureMatches)) !== -1;) {
          if (!wordSeparators || (0,require$_DOT__DOT__SLASH_textModelSearch_DOT_js.isValidMatch)(wordSeparators, text, searchData, lastMatchIndex, captureMatches)) {
            if (result[resultLen++] = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_model_DOT_js.FindMatch(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + captureMatches + deltaOffset), null), resultLen >= limitResultCount) {
              break;
            }
          }
        }
        return resultLen;
      }
      searcher.reset(0);
      do {
        if (wordSeparators = searcher.next(text)) {
          if (result[resultLen++] = (0,require$_DOT__DOT__SLASH_textModelSearch_DOT_js.createFindMatch)(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, wordSeparators.index + 1 + deltaOffset, lineNumber, wordSeparators.index + 1 + wordSeparators[0].length + deltaOffset), wordSeparators, captureMatches), resultLen >= limitResultCount) {
            break;
          }
        }
      } while (wordSeparators);
      return resultLen;
    }
    insert(offset, value, eolNormalized = !1) {
      this._EOLNormalized = this._EOLNormalized && eolNormalized;
      this._lastVisitedLine.lineNumber = 0;
      this._lastVisitedLine.value = "";
      if (this.root !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL) {
        const {node, remainder, nodeStartOffset} = this.nodeAt(offset);
        var piece = node.piece, bufferIndex = piece.bufferIndex;
        eolNormalized = this.positionInBuffer(node, remainder);
        if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < 65535) {
          this.appendToNode(node, value);
          this.computeBufferMetadata();
          return;
        }
        if (nodeStartOffset === offset) {
          this.insertContentToNodeLeft(value, node), this._searchCache.validate(offset);
        } else if (nodeStartOffset + node.piece.length > offset) {
          offset = [];
          piece = new Piece(piece.bufferIndex, eolNormalized, piece.end, this.getLineFeedCnt(piece.bufferIndex, eolNormalized, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, eolNormalized));
          this.shouldCheckCRLF() && this.endWithCR(value) && this.nodeCharCodeAt(node, remainder) === 10 && (bufferIndex = {line:piece.start.line + 1, column:0}, piece = new Piece(piece.bufferIndex, bufferIndex, piece.end, this.getLineFeedCnt(piece.bufferIndex, bufferIndex, piece.end), piece.length - 1), value += "\n");
          this.shouldCheckCRLF() && this.startWithLF(value) ? this.nodeCharCodeAt(node, remainder - 1) === 13 ? (eolNormalized = this.positionInBuffer(node, remainder - 1), this.deleteNodeTail(node, eolNormalized), value = "\r" + value, node.piece.length === 0 && offset.push(node)) : this.deleteNodeTail(node, eolNormalized) : this.deleteNodeTail(node, eolNormalized);
          value = this.createNewPieces(value);
          piece.length > 0 && this.rbInsertRight(node, piece);
          eolNormalized = node;
          for (piece = 0; piece < value.length; piece++) {
            eolNormalized = this.rbInsertRight(eolNormalized, value[piece]);
          }
          this.deleteNodes(offset);
        } else {
          this.insertContentToNodeRight(value, node);
        }
      } else {
        for (offset = this.createNewPieces(value), value = this.rbInsertLeft(null, offset[0]), eolNormalized = 1; eolNormalized < offset.length; eolNormalized++) {
          value = this.rbInsertRight(value, offset[eolNormalized]);
        }
      }
      this.computeBufferMetadata();
    }
    delete(offset, cnt) {
      this._lastVisitedLine.lineNumber = 0;
      this._lastVisitedLine.value = "";
      if (!(cnt <= 0 || this.root === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL)) {
        var startPosition = this.nodeAt(offset), endPosition = this.nodeAt(offset + cnt), startNode = startPosition.node, endNode = endPosition.node;
        if (startNode === endNode) {
          endNode = this.positionInBuffer(startNode, startPosition.remainder), endPosition = this.positionInBuffer(startNode, endPosition.remainder), startPosition.nodeStartOffset === offset ? cnt === startNode.piece.length ? (endNode = startNode.next(), (0,require$_DOT__SLASH_rbTreeBase_DOT_js.rbDelete)(this, startNode), this.validateCRLFWithPrevNode(endNode)) : (this.deleteNodeHead(startNode, endPosition), this._searchCache.validate(offset), this.validateCRLFWithPrevNode(startNode)) : startPosition.nodeStartOffset + 
          startNode.piece.length === offset + cnt ? (this.deleteNodeTail(startNode, endNode), this.validateCRLFWithNextNode(startNode)) : this.shrinkNode(startNode, endNode, endPosition);
        } else {
          cnt = [];
          startPosition = this.positionInBuffer(startNode, startPosition.remainder);
          this.deleteNodeTail(startNode, startPosition);
          this._searchCache.validate(offset);
          startNode.piece.length === 0 && cnt.push(startNode);
          offset = this.positionInBuffer(endNode, endPosition.remainder);
          this.deleteNodeHead(endNode, offset);
          endNode.piece.length === 0 && cnt.push(endNode);
          for (offset = startNode.next(); offset !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL && offset !== endNode; offset = offset.next()) {
            cnt.push(offset);
          }
          startNode = startNode.piece.length === 0 ? startNode.prev() : startNode;
          this.deleteNodes(cnt);
          this.validateCRLFWithNextNode(startNode);
        }
        this.computeBufferMetadata();
      }
    }
    insertContentToNodeLeft(value, node) {
      const nodesToDel = [];
      if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
        var piece = node.piece;
        const newStart = {line:piece.start.line + 1, column:0};
        piece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
        node.piece = piece;
        value += "\n";
        (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, node, -1, -1);
        node.piece.length === 0 && nodesToDel.push(node);
      }
      value = this.createNewPieces(value);
      node = this.rbInsertLeft(node, value[value.length - 1]);
      for (piece = value.length - 2; piece >= 0; piece--) {
        node = this.rbInsertLeft(node, value[piece]);
      }
      this.validateCRLFWithPrevNode(node);
      this.deleteNodes(nodesToDel);
    }
    insertContentToNodeRight(value, node) {
      this.adjustCarriageReturnFromNext(value, node) && (value += "\n");
      value = this.createNewPieces(value);
      let tmpNode = node = this.rbInsertRight(node, value[0]);
      for (let k = 1; k < value.length; k++) {
        tmpNode = this.rbInsertRight(tmpNode, value[k]);
      }
      this.validateCRLFWithPrevNode(node);
    }
    positionInBuffer(node, remainder, ret) {
      var piece = node.piece;
      node = this._buffers[node.piece.bufferIndex].lineStarts;
      remainder = node[piece.start.line] + piece.start.column + remainder;
      let low = piece.start.line;
      piece = piece.end.line;
      let mid = 0, midStop, midStart = 0;
      for (; low <= piece;) {
        mid = low + (piece - low) / 2 | 0;
        midStart = node[mid];
        if (mid === piece) {
          break;
        }
        midStop = node[mid + 1];
        if (remainder < midStart) {
          piece = mid - 1;
        } else if (remainder >= midStop) {
          low = mid + 1;
        } else {
          break;
        }
      }
      return ret ? (ret.line = mid, ret.column = remainder - midStart, null) : {line:mid, column:remainder - midStart};
    }
    getLineFeedCnt(bufferIndex, start, end) {
      if (end.column === 0) {
        return end.line - start.line;
      }
      const lineStarts = this._buffers[bufferIndex].lineStarts;
      if (end.line === lineStarts.length - 1) {
        return end.line - start.line;
      }
      const endOffset = lineStarts[end.line] + end.column;
      return lineStarts[end.line + 1] > endOffset + 1 ? end.line - start.line : this._buffers[bufferIndex].buffer.charCodeAt(endOffset - 1) === 13 ? end.line - start.line + 1 : end.line - start.line;
    }
    offsetInBuffer(bufferIndex, cursor) {
      return this._buffers[bufferIndex].lineStarts[cursor.line] + cursor.column;
    }
    deleteNodes(nodes) {
      for (let i = 0; i < nodes.length; i++) {
        (0,require$_DOT__SLASH_rbTreeBase_DOT_js.rbDelete)(this, nodes[i]);
      }
    }
    createNewPieces(text) {
      if (text.length > 65535) {
        for (var newPieces = []; text.length > 65535;) {
          var lastChar = text.charCodeAt(65534);
          lastChar === 13 || lastChar >= 55296 && lastChar <= 56319 ? (lastChar = text.substring(0, 65534), text = text.substring(65534)) : (lastChar = text.substring(0, 65535), text = text.substring(65535));
          var lineStarts = createLineStartsFast(lastChar);
          newPieces.push(new Piece(this._buffers.length, {line:0, column:0}, {line:lineStarts.length - 1, column:lastChar.length - lineStarts[lineStarts.length - 1]}, lineStarts.length - 1, lastChar.length));
          this._buffers.push(new StringBuffer(lastChar, lineStarts));
        }
        lastChar = createLineStartsFast(text);
        newPieces.push(new Piece(this._buffers.length, {line:0, column:0}, {line:lastChar.length - 1, column:text.length - lastChar[lastChar.length - 1]}, lastChar.length - 1, text.length));
        this._buffers.push(new StringBuffer(text, lastChar));
        return newPieces;
      }
      newPieces = this._buffers[0].buffer.length;
      lineStarts = createLineStartsFast(text, !1);
      lastChar = this._lastChangeBufferPos;
      if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === newPieces && newPieces !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer)) {
        lastChar = this._lastChangeBufferPos = {line:this._lastChangeBufferPos.line, column:this._lastChangeBufferPos.column + 1};
        for (var i = 0; i < lineStarts.length; i++) {
          lineStarts[i] += newPieces + 1;
        }
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
        this._buffers[0].buffer += "_" + text;
        newPieces += 1;
      } else {
        if (newPieces !== 0) {
          for (i = 0; i < lineStarts.length; i++) {
            lineStarts[i] += newPieces;
          }
        }
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
        this._buffers[0].buffer += text;
      }
      text = this._buffers[0].buffer.length;
      lineStarts = this._buffers[0].lineStarts.length - 1;
      lineStarts = {line:lineStarts, column:text - this._buffers[0].lineStarts[lineStarts]};
      text = new Piece(0, lastChar, lineStarts, this.getLineFeedCnt(0, lastChar, lineStarts), text - newPieces);
      this._lastChangeBufferPos = lineStarts;
      return [text];
    }
    getLineRawContent(lineNumber, endOffset = 0) {
      var x = this.root, ret = "", cache = this._searchCache.get2(lineNumber);
      if (cache) {
        x = cache.node;
        ret = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
        var buffer$jscomp$0 = this._buffers[x.piece.bufferIndex].buffer, startOffset$jscomp$0 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
          ret = buffer$jscomp$0.substring(startOffset$jscomp$0 + ret, startOffset$jscomp$0 + x.piece.length);
        } else {
          return x = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber), buffer$jscomp$0.substring(startOffset$jscomp$0 + ret, startOffset$jscomp$0 + x - endOffset);
        }
      } else {
        for (cache = 0, buffer$jscomp$0 = lineNumber; x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
          if (x.left !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL && x.lf_left >= lineNumber - 1) {
            x = x.left;
          } else {
            if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
              ret = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
              startOffset$jscomp$0 = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
              const buffer = this._buffers[x.piece.bufferIndex].buffer, startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
              cache += x.size_left;
              this._searchCache.set({node:x, nodeStartOffset:cache, nodeStartLineNumber:buffer$jscomp$0 - (lineNumber - 1 - x.lf_left)});
              return buffer.substring(startOffset + ret, startOffset + startOffset$jscomp$0 - endOffset);
            }
            if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
              lineNumber = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
              ret = this._buffers[x.piece.bufferIndex].buffer;
              cache = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
              ret = ret.substring(cache + lineNumber, cache + x.piece.length);
              break;
            } else {
              lineNumber -= x.lf_left + x.piece.lineFeedCnt, cache += x.size_left + x.piece.length, x = x.right;
            }
          }
        }
      }
      for (x = x.next(); x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        lineNumber = this._buffers[x.piece.bufferIndex].buffer;
        if (x.piece.lineFeedCnt > 0) {
          cache = this.getAccumulatedValue(x, 0);
          x = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          ret += lineNumber.substring(x, x + cache - endOffset);
          break;
        } else {
          cache = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start), ret += lineNumber.substr(cache, x.piece.length);
        }
        x = x.next();
      }
      return ret;
    }
    computeBufferMetadata() {
      let x = this.root, lfCnt = 1, len = 0;
      for (; x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        lfCnt += x.lf_left + x.piece.lineFeedCnt, len += x.size_left + x.piece.length, x = x.right;
      }
      this._lineCnt = lfCnt;
      this._length = len;
      this._searchCache.validate(this._length);
    }
    getIndexOf(node, accumulatedValue) {
      const piece = node.piece, pos = this.positionInBuffer(node, accumulatedValue), lineCnt = pos.line - piece.start.line;
      return this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue && (node = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos), node !== lineCnt) ? {index:node, remainder:0} : {index:lineCnt, remainder:pos.column};
    }
    getAccumulatedValue(node, index) {
      if (index < 0) {
        return 0;
      }
      node = node.piece;
      const lineStarts = this._buffers[node.bufferIndex].lineStarts;
      index = node.start.line + index + 1;
      return index > node.end.line ? lineStarts[node.end.line] + node.end.column - lineStarts[node.start.line] - node.start.column : lineStarts[index] - lineStarts[node.start.line] - node.start.column;
    }
    deleteNodeTail(node, pos) {
      const piece = node.piece;
      var originalLFCnt = piece.lineFeedCnt, originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
      const newEndOffset = this.offsetInBuffer(piece.bufferIndex, pos), newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, pos);
      originalLFCnt = newLineFeedCnt - originalLFCnt;
      originalEndOffset = newEndOffset - originalEndOffset;
      node.piece = new Piece(piece.bufferIndex, piece.start, pos, newLineFeedCnt, piece.length + originalEndOffset);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, node, originalEndOffset, originalLFCnt);
    }
    deleteNodeHead(node, pos) {
      const piece = node.piece;
      var originalLFCnt = piece.lineFeedCnt, originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
      const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, pos, piece.end), newStartOffset = this.offsetInBuffer(piece.bufferIndex, pos);
      originalLFCnt = newLineFeedCnt - originalLFCnt;
      originalStartOffset -= newStartOffset;
      node.piece = new Piece(piece.bufferIndex, pos, piece.end, newLineFeedCnt, piece.length + originalStartOffset);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, node, originalStartOffset, originalLFCnt);
    }
    shrinkNode(node, start, end) {
      const piece = node.piece;
      var originalStartPos = piece.start;
      const originalEndPos = piece.end, oldLength = piece.length, oldLFCnt = piece.lineFeedCnt, newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, start);
      originalStartPos = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
      node.piece = new Piece(piece.bufferIndex, piece.start, start, newLineFeedCnt, originalStartPos);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, node, originalStartPos - oldLength, newLineFeedCnt - oldLFCnt);
      start = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
      node = this.rbInsertRight(node, start);
      this.validateCRLFWithPrevNode(node);
    }
    appendToNode(node, value) {
      this.adjustCarriageReturnFromNext(value, node) && (value += "\n");
      var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node), startOffset = this._buffers[0].buffer.length;
      this._buffers[0].buffer += value;
      var lineStarts = createLineStartsFast(value, !1);
      for (var i = 0; i < lineStarts.length; i++) {
        lineStarts[i] += startOffset;
      }
      hitCRLF && (hitCRLF = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2], this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = {line:this._lastChangeBufferPos.line - 1, column:startOffset - hitCRLF});
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      startOffset = this._buffers[0].lineStarts.length - 1;
      startOffset = {line:startOffset, column:this._buffers[0].buffer.length - this._buffers[0].lineStarts[startOffset]};
      lineStarts = node.piece.length + value.length;
      i = node.piece.lineFeedCnt;
      hitCRLF = this.getLineFeedCnt(0, node.piece.start, startOffset);
      i = hitCRLF - i;
      node.piece = new Piece(node.piece.bufferIndex, node.piece.start, startOffset, hitCRLF, lineStarts);
      this._lastChangeBufferPos = startOffset;
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, node, value.length, i);
    }
    nodeAt(offset) {
      let x = this.root;
      var cache = this._searchCache.get(offset);
      if (cache) {
        return {node:cache.node, nodeStartOffset:cache.nodeStartOffset, remainder:offset - cache.nodeStartOffset};
      }
      for (cache = 0; x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        if (x.size_left > offset) {
          x = x.left;
        } else {
          if (x.size_left + x.piece.length >= offset) {
            return cache += x.size_left, offset = {node:x, remainder:offset - x.size_left, nodeStartOffset:cache}, this._searchCache.set(offset), offset;
          }
          offset -= x.size_left + x.piece.length;
          cache += x.size_left + x.piece.length;
          x = x.right;
        }
      }
      return null;
    }
    nodeAt2(lineNumber, column) {
      let x = this.root;
      for (var nodeStartOffset = 0; x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        if (x.left !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL && x.lf_left >= lineNumber - 1) {
          x = x.left;
        } else {
          if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
            var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
            lineNumber = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
            nodeStartOffset += x.size_left;
            return {node:x, remainder:Math.min(prevAccumualtedValue + column - 1, lineNumber), nodeStartOffset};
          }
          if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
            prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
            if (prevAccumualtedValue + column - 1 <= x.piece.length) {
              return {node:x, remainder:prevAccumualtedValue + column - 1, nodeStartOffset};
            }
            column -= x.piece.length - prevAccumualtedValue;
            break;
          } else {
            lineNumber -= x.lf_left + x.piece.lineFeedCnt, nodeStartOffset += x.size_left + x.piece.length, x = x.right;
          }
        }
      }
      for (x = x.next(); x !== require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;) {
        if (x.piece.lineFeedCnt > 0) {
          return nodeStartOffset = this.getAccumulatedValue(x, 0), prevAccumualtedValue = this.offsetOfNode(x), {node:x, remainder:Math.min(column - 1, nodeStartOffset), nodeStartOffset:prevAccumualtedValue};
        }
        if (x.piece.length >= column - 1) {
          return nodeStartOffset = this.offsetOfNode(x), {node:x, remainder:column - 1, nodeStartOffset};
        }
        column -= x.piece.length;
        x = x.next();
      }
      return null;
    }
    nodeCharCodeAt(node, offset) {
      if (node.piece.lineFeedCnt < 1) {
        return -1;
      }
      const buffer = this._buffers[node.piece.bufferIndex];
      node = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
      return buffer.buffer.charCodeAt(node);
    }
    offsetOfNode(node) {
      if (!node) {
        return 0;
      }
      let pos = node.size_left;
      for (; node !== this.root;) {
        node.parent.right === node && (pos += node.parent.size_left + node.parent.piece.length), node = node.parent;
      }
      return pos;
    }
    shouldCheckCRLF() {
      return !(this._EOLNormalized && this._EOL === "\n");
    }
    startWithLF(val) {
      if (typeof val === "string") {
        return val.charCodeAt(0) === 10;
      }
      if (val === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL || val.piece.lineFeedCnt === 0) {
        return !1;
      }
      val = val.piece;
      const lineStarts = this._buffers[val.bufferIndex].lineStarts, line = val.start.line, startOffset = lineStarts[line] + val.start.column;
      return line === lineStarts.length - 1 || lineStarts[line + 1] > startOffset + 1 ? !1 : this._buffers[val.bufferIndex].buffer.charCodeAt(startOffset) === 10;
    }
    endWithCR(val) {
      return typeof val === "string" ? val.charCodeAt(val.length - 1) === 13 : val === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL || val.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
    }
    validateCRLFWithPrevNode(nextNode) {
      if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
        const node = nextNode.prev();
        this.endWithCR(node) && this.fixCRLF(node, nextNode);
      }
    }
    validateCRLFWithNextNode(node) {
      if (this.shouldCheckCRLF() && this.endWithCR(node)) {
        const nextNode = node.next();
        this.startWithLF(nextNode) && this.fixCRLF(node, nextNode);
      }
    }
    fixCRLF(prev, next) {
      const nodesToDel = [];
      var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
      prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, prev.piece.end.column === 0 ? {line:prev.piece.end.line - 1, column:lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1} : {line:prev.piece.end.line, column:prev.piece.end.column - 1}, prev.piece.lineFeedCnt - 1, prev.piece.length - 1);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, prev, -1, -1);
      prev.piece.length === 0 && nodesToDel.push(prev);
      lineStarts = {line:next.piece.start.line + 1, column:0};
      const newLength = next.piece.length - 1, newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, lineStarts, next.piece.end);
      next.piece = new Piece(next.piece.bufferIndex, lineStarts, next.piece.end, newLineFeedCnt, newLength);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, next, -1, -1);
      next.piece.length === 0 && nodesToDel.push(next);
      next = this.createNewPieces("\r\n");
      this.rbInsertRight(prev, next[0]);
      for (prev = 0; prev < nodesToDel.length; prev++) {
        (0,require$_DOT__SLASH_rbTreeBase_DOT_js.rbDelete)(this, nodesToDel[prev]);
      }
    }
    adjustCarriageReturnFromNext(value, node) {
      if (this.shouldCheckCRLF() && this.endWithCR(value) && (value = node.next(), this.startWithLF(value))) {
        if (value.piece.length === 1) {
          (0,require$_DOT__SLASH_rbTreeBase_DOT_js.rbDelete)(this, value);
        } else {
          node = value.piece;
          const newStart = {line:node.start.line + 1, column:0}, newLength = node.length - 1, newLineFeedCnt = this.getLineFeedCnt(node.bufferIndex, newStart, node.end);
          value.piece = new Piece(node.bufferIndex, newStart, node.end, newLineFeedCnt, newLength);
          (0,require$_DOT__SLASH_rbTreeBase_DOT_js.updateTreeMetadata)(this, value, -1, -1);
        }
        return !0;
      }
      return !1;
    }
    iterate(node, callback) {
      if (node === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL) {
        return callback(require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL);
      }
      const leftRet = this.iterate(node.left, callback);
      return leftRet ? callback(node) && this.iterate(node.right, callback) : leftRet;
    }
    getNodeContent(node) {
      if (node === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL) {
        return "";
      }
      const buffer = this._buffers[node.piece.bufferIndex];
      var piece = node.piece;
      node = this.offsetInBuffer(piece.bufferIndex, piece.start);
      piece = this.offsetInBuffer(piece.bufferIndex, piece.end);
      return buffer.buffer.substring(node, piece);
    }
    getPieceContent(piece) {
      const buffer = this._buffers[piece.bufferIndex], startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
      piece = this.offsetInBuffer(piece.bufferIndex, piece.end);
      return buffer.buffer.substring(startOffset, piece);
    }
    rbInsertRight(node, p) {
      p = new require$_DOT__SLASH_rbTreeBase_DOT_js.TreeNode(p, 1);
      p.left = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      p.right = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      p.parent = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      p.size_left = 0;
      p.lf_left = 0;
      this.root === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL ? (this.root = p, p.color = 0) : node.right === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL ? (node.right = p, p.parent = node) : (node = (0,require$_DOT__SLASH_rbTreeBase_DOT_js.leftest)(node.right), node.left = p, p.parent = node);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.fixInsert)(this, p);
      return p;
    }
    rbInsertLeft(node, p) {
      p = new require$_DOT__SLASH_rbTreeBase_DOT_js.TreeNode(p, 1);
      p.left = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      p.right = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      p.parent = require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL;
      p.size_left = 0;
      p.lf_left = 0;
      this.root === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL ? (this.root = p, p.color = 0) : node.left === require$_DOT__SLASH_rbTreeBase_DOT_js.SENTINEL ? (node.left = p, p.parent = node) : (node = (0,require$_DOT__SLASH_rbTreeBase_DOT_js.righttest)(node.left), node.right = p, p.parent = node);
      (0,require$_DOT__SLASH_rbTreeBase_DOT_js.fixInsert)(this, p);
      return p;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$pieceTreeTextBuffer$pieceTreeBase.js.map
