shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$modelLineProjection = function(require, module, exports) {
  function createModelLineProjection(lineBreakData, isVisible) {
    return lineBreakData === null ? isVisible ? IdentityModelLineProjection.INSTANCE : HiddenModelLineProjection.INSTANCE : new ModelLineProjection(lineBreakData, isVisible);
  }
  function spaces(count) {
    if (count >= _spaces.length) {
      for (let i = 1; i <= count; i++) {
        _spaces[i] = Array(i + 1).join(" ");
      }
    }
    return _spaces[count];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, createModelLineProjection:{enumerable:!0, get:function() {
    return createModelLineProjection;
  }}});
  var require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_textModelEvents_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$textModelEvents"), require$_DOT__DOT__SLASH_viewModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$viewModel");
  class ModelLineProjection {
    constructor(lineBreakData, isVisible) {
      this._projectionData = lineBreakData;
      this._isVisible = isVisible;
    }
    isVisible() {
      return this._isVisible;
    }
    setVisible(isVisible) {
      this._isVisible = isVisible;
      return this;
    }
    getProjectionData() {
      return this._projectionData;
    }
    getViewLineCount() {
      return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
    }
    getViewLineContent(model, modelLineNumber, outputLineIndex) {
      this._assertVisible();
      const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0, endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];
      if (this._projectionData.injectionOffsets !== null) {
        const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));
        model = require$_DOT__DOT__SLASH_textModelEvents_DOT_js.LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts).substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);
      } else {
        model = model.getValueInRange({startLineNumber:modelLineNumber, startColumn:startOffsetInInputWithInjections + 1, endLineNumber:modelLineNumber, endColumn:endOffsetInInputWithInjections + 1});
      }
      outputLineIndex > 0 && (model = spaces(this._projectionData.wrappedTextIndentLength) + model);
      return model;
    }
    getViewLineLength(model, modelLineNumber, outputLineIndex) {
      this._assertVisible();
      return this._projectionData.getLineLength(outputLineIndex);
    }
    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {
      this._assertVisible();
      return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;
    }
    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {
      this._assertVisible();
      return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;
    }
    getViewLineData(model, modelLineNumber, outputLineIndex) {
      const arr = [];
      this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [!0], arr);
      return arr[0];
    }
    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {
      this._assertVisible();
      var lineBreakData = this._projectionData;
      const injectionOffsets = lineBreakData.injectionOffsets, injectionOptions = lineBreakData.injectionOptions;
      let inlineDecorationsPerOutputLine = null;
      if (injectionOffsets) {
        inlineDecorationsPerOutputLine = [];
        let totalInjectedTextLengthBefore = 0, currentInjectedOffset = 0;
        for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {
          const inlineDecorations = [];
          inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;
          const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0, lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];
          for (; currentInjectedOffset < injectionOffsets.length;) {
            const length = injectionOptions[currentInjectedOffset].content.length;
            var injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;
            const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;
            if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {
              break;
            }
            if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {
              const options = injectionOptions[currentInjectedOffset];
              if (options.inlineClassName) {
                var offset = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;
                injectedTextStartOffsetInInputWithInjections = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);
                offset += Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);
                injectedTextStartOffsetInInputWithInjections !== offset && inlineDecorations.push(new require$_DOT__DOT__SLASH_viewModel_DOT_js.SingleLineInlineDecoration(injectedTextStartOffsetInInputWithInjections, offset, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));
              }
            }
            if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {
              totalInjectedTextLengthBefore += length, currentInjectedOffset++;
            } else {
              break;
            }
          }
        }
      }
      model = injectionOffsets ? model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({offset, text:injectionOptions[idx].content, tokenMetadata:require$_DOT__DOT__SLASH_tokens_SLASH_lineTokens_DOT_js.LineTokens.defaultTokenMetadata}))) : model.tokenization.getLineTokens(modelLineNumber);
      for (modelLineNumber = outputLineIdx; modelLineNumber < outputLineIdx + lineCount; modelLineNumber++) {
        lineBreakData = globalStartIndex + modelLineNumber - outputLineIdx, result[lineBreakData] = needed[lineBreakData] ? this._getViewLineData(model, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[modelLineNumber] : null, modelLineNumber) : null;
      }
    }
    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {
      this._assertVisible();
      const lineBreakData = this._projectionData;
      lineWithInjections = lineWithInjections.sliceAndInflate(outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0, lineBreakData.breakOffsets[outputLineIndex], outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);
      let lineContent = lineWithInjections.getLineContent();
      outputLineIndex > 0 && (lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent);
      const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1, maxColumn = lineContent.length + 1, continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();
      return new require$_DOT__DOT__SLASH_viewModel_DOT_js.ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1], lineWithInjections, inlineDecorations);
    }
    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {
      this._assertVisible();
      return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;
    }
    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2) {
      this._assertVisible();
      return this._projectionData.translateToOutputPosition(inputColumn - 1, affinity).toPosition(deltaLineNumber);
    }
    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {
      this._assertVisible();
      inputColumn = this._projectionData.translateToOutputPosition(inputColumn - 1);
      return deltaLineNumber + inputColumn.outputLineIndex;
    }
    normalizePosition(outputLineIndex, outputPosition, affinity) {
      const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;
      return this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity).toPosition(baseViewLineNumber);
    }
    getInjectedTextAt(outputLineIndex, outputColumn) {
      return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);
    }
    _assertVisible() {
      if (!this._isVisible) {
        throw Error("Not supported");
      }
    }
  }
  class IdentityModelLineProjection {
    constructor() {
    }
    isVisible() {
      return !0;
    }
    setVisible(isVisible) {
      return isVisible ? this : HiddenModelLineProjection.INSTANCE;
    }
    getProjectionData() {
      return null;
    }
    getViewLineCount() {
      return 1;
    }
    getViewLineContent(model, modelLineNumber, _outputLineIndex) {
      return model.getLineContent(modelLineNumber);
    }
    getViewLineLength(model, modelLineNumber, _outputLineIndex) {
      return model.getLineLength(modelLineNumber);
    }
    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {
      return model.getLineMinColumn(modelLineNumber);
    }
    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {
      return model.getLineMaxColumn(modelLineNumber);
    }
    getViewLineData(model, modelLineNumber, _outputLineIndex) {
      model = model.tokenization.getLineTokens(modelLineNumber);
      modelLineNumber = model.getLineContent();
      return new require$_DOT__DOT__SLASH_viewModel_DOT_js.ViewLineData(modelLineNumber, !1, 1, modelLineNumber.length + 1, 0, model.inflate(), null);
    }
    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {
      result[globalStartIndex] = needed[globalStartIndex] ? this.getViewLineData(model, modelLineNumber, 0) : null;
    }
    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {
      return outputColumn;
    }
    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {
      return new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(deltaLineNumber, inputColumn);
    }
    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {
      return deltaLineNumber;
    }
    normalizePosition(outputLineIndex, outputPosition, affinity) {
      return outputPosition;
    }
    getInjectedTextAt(_outputLineIndex, _outputColumn) {
      return null;
    }
  }
  IdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();
  class HiddenModelLineProjection {
    constructor() {
    }
    isVisible() {
      return !1;
    }
    setVisible(isVisible) {
      return isVisible ? IdentityModelLineProjection.INSTANCE : this;
    }
    getProjectionData() {
      return null;
    }
    getViewLineCount() {
      return 0;
    }
    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {
      throw Error("Not supported");
    }
    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {
      throw Error("Not supported");
    }
    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {
      throw Error("Not supported");
    }
    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {
      throw Error("Not supported");
    }
    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {
      throw Error("Not supported");
    }
    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {
      throw Error("Not supported");
    }
    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {
      throw Error("Not supported");
    }
    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {
      throw Error("Not supported");
    }
    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {
      throw Error("Not supported");
    }
    normalizePosition(outputLineIndex, outputPosition, affinity) {
      throw Error("Not supported");
    }
    getInjectedTextAt(_outputLineIndex, _outputColumn) {
      throw Error("Not supported");
    }
  }
  HiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();
  const _spaces = [""];
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewModel$modelLineProjection.js.map
