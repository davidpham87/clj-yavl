shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$lineDecorations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DecorationSegment:{enumerable:!0, get:function() {
    return DecorationSegment;
  }}, LineDecoration:{enumerable:!0, get:function() {
    return LineDecoration;
  }}, LineDecorationsNormalizer:{enumerable:!0, get:function() {
    return LineDecorationsNormalizer;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  class LineDecoration {
    constructor(startColumn, endColumn, className, type) {
      this.startColumn = startColumn;
      this.endColumn = endColumn;
      this.className = className;
      this.type = type;
      this._lineDecorationBrand = void 0;
    }
    static _equals(a, b) {
      return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;
    }
    static equalsArr(a, b) {
      const aLen = a.length;
      if (aLen !== b.length) {
        return !1;
      }
      for (let i = 0; i < aLen; i++) {
        if (!LineDecoration._equals(a[i], b[i])) {
          return !1;
        }
      }
      return !0;
    }
    static extractWrapped(arr, startOffset, endOffset) {
      if (arr.length === 0) {
        return arr;
      }
      const startColumn = startOffset + 1, endColumn = endOffset + 1;
      startOffset = endOffset - startOffset;
      endOffset = [];
      let rLength = 0;
      for (const dec of arr) {
        dec.endColumn <= startColumn || dec.startColumn >= endColumn || (endOffset[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(startOffset + 1, dec.endColumn - startColumn + 1), dec.className, dec.type));
      }
      return endOffset;
    }
    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {
      if (lineDecorations.length === 0) {
        return [];
      }
      const result = [];
      let resultLen = 0;
      for (let i = 0, len = lineDecorations.length; i < len; i++) {
        const d = lineDecorations[i];
        var range = d.range;
        if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {
          continue;
        }
        if (range.isEmpty() && (d.type === 0 || d.type === 3)) {
          continue;
        }
        const startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;
        range = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;
        result[resultLen++] = new LineDecoration(startColumn, range, d.inlineClassName, d.type);
      }
      return result;
    }
    static _typeCompare(a, b) {
      const ORDER = [2, 0, 1, 3];
      return ORDER[a] - ORDER[b];
    }
    static compare(a, b) {
      if (a.startColumn !== b.startColumn) {
        return a.startColumn - b.startColumn;
      }
      if (a.endColumn !== b.endColumn) {
        return a.endColumn - b.endColumn;
      }
      const typeCmp = LineDecoration._typeCompare(a.type, b.type);
      return typeCmp !== 0 ? typeCmp : a.className !== b.className ? a.className < b.className ? -1 : 1 : 0;
    }
  }
  class DecorationSegment {
    constructor(startOffset, endOffset, className, metadata) {
      this.startOffset = startOffset;
      this.endOffset = endOffset;
      this.className = className;
      this.metadata = metadata;
    }
  }
  class Stack {
    constructor() {
      this.stopOffsets = [];
      this.classNames = [];
      this.metadata = [];
      this.count = 0;
    }
    static _metadata(metadata) {
      let result = 0;
      for (let i = 0, len = metadata.length; i < len; i++) {
        result |= metadata[i];
      }
      return result;
    }
    consumeLowerThan(maxStopOffset, nextStartOffset, result) {
      for (; this.count > 0 && this.stopOffsets[0] < maxStopOffset;) {
        let i = 0;
        for (; i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1];) {
          i++;
        }
        result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(" "), Stack._metadata(this.metadata)));
        nextStartOffset = this.stopOffsets[i] + 1;
        this.stopOffsets.splice(0, i + 1);
        this.classNames.splice(0, i + 1);
        this.metadata.splice(0, i + 1);
        this.count -= i + 1;
      }
      this.count > 0 && nextStartOffset < maxStopOffset && (result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(" "), Stack._metadata(this.metadata))), nextStartOffset = maxStopOffset);
      return nextStartOffset;
    }
    insert(stopOffset, className, metadata) {
      if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {
        this.stopOffsets.push(stopOffset), this.classNames.push(className), this.metadata.push(metadata);
      } else {
        for (let i = 0; i < this.count; i++) {
          if (this.stopOffsets[i] >= stopOffset) {
            this.stopOffsets.splice(i, 0, stopOffset);
            this.classNames.splice(i, 0, className);
            this.metadata.splice(i, 0, metadata);
            break;
          }
        }
      }
      this.count++;
    }
  }
  class LineDecorationsNormalizer {
    static normalize(lineContent, lineDecorations) {
      if (lineDecorations.length === 0) {
        return [];
      }
      const result = [], stack = new Stack();
      let nextStartOffset = 0;
      for (let i = 0, len = lineDecorations.length; i < len; i++) {
        var d = lineDecorations[i], startColumn = d.startColumn, endColumn = d.endColumn;
        const className = d.className;
        d = d.type === 1 ? 2 : d.type === 2 ? 4 : 0;
        if (startColumn > 1) {
          var charCodeBefore = lineContent.charCodeAt(startColumn - 2);
          strings.isHighSurrogate(charCodeBefore) && startColumn--;
        }
        endColumn > 1 && (charCodeBefore = lineContent.charCodeAt(endColumn - 2), strings.isHighSurrogate(charCodeBefore) && endColumn--);
        --startColumn;
        endColumn -= 2;
        nextStartOffset = stack.consumeLowerThan(startColumn, nextStartOffset, result);
        stack.count === 0 && (nextStartOffset = startColumn);
        stack.insert(endColumn, className, d);
      }
      stack.consumeLowerThan(1073741824, nextStartOffset, result);
      return result;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$viewLayout$lineDecorations.js.map
