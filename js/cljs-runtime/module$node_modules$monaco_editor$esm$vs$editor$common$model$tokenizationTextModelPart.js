shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$tokenizationTextModelPart = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, TokenizationTextModelPart:{enumerable:!0, get:function() {
    return TokenizationTextModelPart;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$eolCounter"), require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$lineRange"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordHelper"), require$_DOT__DOT__SLASH_languages_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages");
  module = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelPart");
  var require$_DOT__SLASH_textModelTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$textModelTokens"), require$_DOT__DOT__SLASH_tokens_SLASH_contiguousMultilineTokensBuilder_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousMultilineTokensBuilder"), require$_DOT__DOT__SLASH_tokens_SLASH_contiguousTokensStore_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousTokensStore"), require$_DOT__DOT__SLASH_tokens_SLASH_sparseTokensStore_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseTokensStore");
  class TokenizationTextModelPart extends module.TextModelPart {
    constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {
      super();
      this._languageService = _languageService;
      this._languageConfigurationService = _languageConfigurationService;
      this._textModel = _textModel;
      this._bracketPairsTextModelPart = _bracketPairsTextModelPart;
      this._languageId = _languageId;
      this._attachedViews = _attachedViews;
      this._semanticTokens = new require$_DOT__DOT__SLASH_tokens_SLASH_sparseTokensStore_DOT_js.SparseTokensStore(this._languageService.languageIdCodec);
      this._onDidChangeLanguage = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeLanguage = this._onDidChangeLanguage.event;
      this._onDidChangeLanguageConfiguration = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;
      this._onDidChangeTokens = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeTokens = this._onDidChangeTokens.event;
      this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
      this._register(this._languageConfigurationService.onDidChange(e => {
        e.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
      }));
      this._register(this.grammarTokens.onDidChangeTokens(e => {
        this._emitModelTokensChangedEvent(e);
      }));
      this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState(e => {
        this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
      }));
    }
    handleDidChangeContent(e) {
      if (e.isFlush) {
        this._semanticTokens.flush();
      } else if (!e.isEolChange) {
        for (const c of e.changes) {
          const [eolCount, firstLineLength, lastLineLength] = (0,require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(c.text);
          this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0);
        }
      }
      this.grammarTokens.handleDidChangeContent(e);
    }
    handleDidChangeAttached() {
      this.grammarTokens.handleDidChangeAttached();
    }
    getLineTokens(lineNumber) {
      this.validateLineNumber(lineNumber);
      const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);
      return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);
    }
    _emitModelTokensChangedEvent(e) {
      this._textModel._isDisposing() || (this._bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
    }
    validateLineNumber(lineNumber) {
      if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {
        throw new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.BugIndicatingError("Illegal value for lineNumber");
      }
    }
    get hasTokens() {
      return this.grammarTokens.hasTokens;
    }
    resetTokenization() {
      this.grammarTokens.resetTokenization();
    }
    get backgroundTokenizationState() {
      return this.grammarTokens.backgroundTokenizationState;
    }
    forceTokenization(lineNumber) {
      this.validateLineNumber(lineNumber);
      this.grammarTokens.forceTokenization(lineNumber);
    }
    isCheapToTokenize(lineNumber) {
      this.validateLineNumber(lineNumber);
      return this.grammarTokens.isCheapToTokenize(lineNumber);
    }
    tokenizeIfCheap(lineNumber) {
      this.validateLineNumber(lineNumber);
      this.grammarTokens.tokenizeIfCheap(lineNumber);
    }
    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
      return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);
    }
    tokenizeLineWithEdit(position, length, newText) {
      return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);
    }
    setSemanticTokens(tokens, isComplete) {
      this._semanticTokens.set(tokens, isComplete);
      this._emitModelTokensChangedEvent({semanticTokensApplied:tokens !== null, ranges:[{fromLineNumber:1, toLineNumber:this._textModel.getLineCount()}]});
    }
    hasCompleteSemanticTokens() {
      return this._semanticTokens.isComplete();
    }
    hasSomeSemanticTokens() {
      return !this._semanticTokens.isEmpty();
    }
    setPartialSemanticTokens(range, tokens) {
      this.hasCompleteSemanticTokens() || (range = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens)), this._emitModelTokensChangedEvent({semanticTokensApplied:!0, ranges:[{fromLineNumber:range.startLineNumber, toLineNumber:range.endLineNumber}]}));
    }
    getWordAtPosition(_position) {
      this.assertNotDisposed();
      var position = this._textModel.validatePosition(_position);
      const lineContent = this._textModel.getLineContent(position.lineNumber), lineTokens = this.getLineTokens(position.lineNumber), tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1), [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex), rightBiasedWord = (0,require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js.getWordAtText)(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), 
      lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
      if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {
        return rightBiasedWord;
      }
      if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
        const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);
        if ((position = (0,require$_DOT__DOT__SLASH_core_SLASH_wordHelper_DOT_js.getWordAtText)(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset)) && position.startColumn <= _position.column && _position.column <= position.endColumn) {
          return position;
        }
      }
      return null;
    }
    getLanguageConfiguration(languageId) {
      return this._languageConfigurationService.getLanguageConfiguration(languageId);
    }
    static _findLanguageBoundaries(lineTokens, tokenIndex) {
      const languageId = lineTokens.getLanguageId(tokenIndex);
      let startOffset = 0;
      for (var i$jscomp$0 = tokenIndex; i$jscomp$0 >= 0 && lineTokens.getLanguageId(i$jscomp$0) === languageId; i$jscomp$0--) {
        startOffset = lineTokens.getStartOffset(i$jscomp$0);
      }
      i$jscomp$0 = lineTokens.getLineContent().length;
      for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
        i$jscomp$0 = lineTokens.getEndOffset(i);
      }
      return [startOffset, i$jscomp$0];
    }
    getWordUntilPosition(position) {
      const wordAtPosition = this.getWordAtPosition(position);
      return wordAtPosition ? {word:wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn), startColumn:wordAtPosition.startColumn, endColumn:position.column} : {word:"", startColumn:position.column, endColumn:position.column};
    }
    getLanguageId() {
      return this._languageId;
    }
    getLanguageIdAtPosition(lineNumber, column) {
      lineNumber = this._textModel.validatePosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, column));
      column = this.getLineTokens(lineNumber.lineNumber);
      return column.getLanguageId(column.findTokenIndexAtOffset(lineNumber.column - 1));
    }
    setLanguageId(languageId, source = "api") {
      this._languageId !== languageId && (source = {oldLanguage:this._languageId, newLanguage:languageId, source}, this._languageId = languageId, this._bracketPairsTextModelPart.handleDidChangeLanguage(source), this.grammarTokens.resetTokenization(), this._onDidChangeLanguage.fire(source), this._onDidChangeLanguageConfiguration.fire({}));
    }
  }
  class GrammarTokens extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    get backgroundTokenizationState() {
      return this._backgroundTokenizationState;
    }
    constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {
      super();
      this._languageIdCodec = _languageIdCodec;
      this._textModel = _textModel;
      this.getLanguageId = getLanguageId;
      this._defaultBackgroundTokenizer = this._tokenizer = null;
      this._backgroundTokenizer = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.MutableDisposable());
      this._tokens = new require$_DOT__DOT__SLASH_tokens_SLASH_contiguousTokensStore_DOT_js.ContiguousTokensStore(this._languageIdCodec);
      this._debugBackgroundTokenizer = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.MutableDisposable());
      this._backgroundTokenizationState = 1;
      this._onDidChangeBackgroundTokenizationState = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;
      this._onDidChangeTokens = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this.onDidChangeTokens = this._onDidChangeTokens.event;
      this._attachedViewStates = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.DisposableMap());
      this._register(require$_DOT__DOT__SLASH_languages_DOT_js.TokenizationRegistry.onDidChange(e => {
        const languageId = this.getLanguageId();
        e.changedLanguages.indexOf(languageId) !== -1 && this.resetTokenization();
      }));
      this.resetTokenization();
      this._register(attachedViews.onDidChangeVisibleRanges(({view, state}) => {
        if (state) {
          let existing = this._attachedViewStates.get(view);
          existing || (existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges)), this._attachedViewStates.set(view, existing));
          existing.handleStateChange(state);
        } else {
          this._attachedViewStates.deleteAndDispose(view);
        }
      }));
    }
    resetTokenization(fireTokenChangeEvent = !0) {
      var _a;
      this._tokens.flush();
      (_a = this._debugBackgroundTokens) === null || _a === void 0 || _a.flush();
      this._debugBackgroundStates && (this._debugBackgroundStates = new require$_DOT__SLASH_textModelTokens_DOT_js.TrackingTokenizationStateStore(this._textModel.getLineCount()));
      fireTokenChangeEvent && this._onDidChangeTokens.fire({semanticTokensApplied:!1, ranges:[{fromLineNumber:1, toLineNumber:this._textModel.getLineCount()}]});
      const [tokenizationSupport, initialState] = (() => {
        if (this._textModel.isTooLargeForTokenization()) {
          return [null, null];
        }
        const tokenizationSupport = require$_DOT__DOT__SLASH_languages_DOT_js.TokenizationRegistry.get(this.getLanguageId());
        if (!tokenizationSupport) {
          return [null, null];
        }
        let initialState;
        try {
          initialState = tokenizationSupport.getInitialState();
        } catch (e) {
          return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e), [null, null];
        }
        return [tokenizationSupport, initialState];
      })();
      this._tokenizer = tokenizationSupport && initialState ? new require$_DOT__SLASH_textModelTokens_DOT_js.TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec) : null;
      this._backgroundTokenizer.clear();
      this._defaultBackgroundTokenizer = null;
      this._tokenizer && (fireTokenChangeEvent = {setTokens:tokens => {
        this.setTokens(tokens);
      }, backgroundTokenizationFinished:() => {
        this._backgroundTokenizationState !== 2 && (this._backgroundTokenizationState = 2, this._onDidChangeBackgroundTokenizationState.fire());
      }, setEndState:(lineNumber, state) => {
        var _a;
        if (this._tokenizer) {
          var firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
          firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber && ((_a = this._tokenizer) === null || _a === void 0 || _a.store.setEndState(lineNumber, state));
        }
      }}, tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens && (this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, fireTokenChangeEvent)), this._backgroundTokenizer.value || (this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new require$_DOT__SLASH_textModelTokens_DOT_js.DefaultBackgroundTokenizer(this._tokenizer, fireTokenChangeEvent), this._defaultBackgroundTokenizer.handleChanges()), 
      (tokenizationSupport === null || tokenizationSupport === void 0 ? 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer ? (this._debugBackgroundTokens = new require$_DOT__DOT__SLASH_tokens_SLASH_contiguousTokensStore_DOT_js.ContiguousTokensStore(this._languageIdCodec), this._debugBackgroundStates = new require$_DOT__SLASH_textModelTokens_DOT_js.TrackingTokenizationStateStore(this._textModel.getLineCount()), this._debugBackgroundTokenizer.clear(), 
      this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {setTokens:tokens => {
        var _a;
        (_a = this._debugBackgroundTokens) === null || _a === void 0 || _a.setMultilineTokens(tokens, this._textModel);
      }, backgroundTokenizationFinished() {
      }, setEndState:(lineNumber, state) => {
        var _a;
        (_a = this._debugBackgroundStates) === null || _a === void 0 || _a.setEndState(lineNumber, state);
      }})) : (this._debugBackgroundStates = this._debugBackgroundTokens = void 0, this._debugBackgroundTokenizer.value = void 0));
      this.refreshAllVisibleLineTokens();
    }
    handleDidChangeAttached() {
      var _a;
      (_a = this._defaultBackgroundTokenizer) === null || _a === void 0 || _a.handleChanges();
    }
    handleDidChangeContent(e) {
      var _a, _b, _c;
      if (e.isFlush) {
        this.resetTokenization(!1);
      } else if (!e.isEolChange) {
        for (const c of e.changes) {
          const [eolCount, firstLineLength] = (0,require$_DOT__DOT__SLASH_core_SLASH_eolCounter_DOT_js.countEOL)(c.text);
          this._tokens.acceptEdit(c.range, eolCount, firstLineLength);
          (_a = this._debugBackgroundTokens) === null || _a === void 0 || _a.acceptEdit(c.range, eolCount, firstLineLength);
        }
        (_b = this._debugBackgroundStates) === null || _b === void 0 || _b.acceptChanges(e.changes);
        this._tokenizer && this._tokenizer.store.acceptChanges(e.changes);
        (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 || _c.handleChanges();
      }
    }
    setTokens(tokens) {
      ({changes:tokens} = this._tokens.setMultilineTokens(tokens, this._textModel));
      tokens.length > 0 && this._onDidChangeTokens.fire({semanticTokensApplied:!1, ranges:tokens});
      return {changes:tokens};
    }
    refreshAllVisibleLineTokens() {
      const ranges = require$_DOT__DOT__SLASH_core_SLASH_lineRange_DOT_js.LineRange.joinMany([...this._attachedViewStates].map(([, s]) => s.lineRanges));
      this.refreshRanges(ranges);
    }
    refreshRanges(ranges) {
      for (const range of ranges) {
        this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);
      }
    }
    refreshRange(startLineNumber, endLineNumber) {
      var _a, _b;
      if (this._tokenizer) {
        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));
        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);
        var builder = new require$_DOT__DOT__SLASH_tokens_SLASH_contiguousMultilineTokensBuilder_DOT_js.ContiguousMultilineTokensBuilder();
        ({heuristicTokens:startLineNumber} = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber));
        builder = this.setTokens(builder.finalize());
        if (startLineNumber) {
          for (const c of builder.changes) {
            (_a = this._backgroundTokenizer.value) === null || _a === void 0 || _a.requestTokens(c.fromLineNumber, c.toLineNumber + 1);
          }
        }
        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 || _b.checkFinished();
      }
    }
    forceTokenization(lineNumber) {
      var _a, _b;
      const builder = new require$_DOT__DOT__SLASH_tokens_SLASH_contiguousMultilineTokensBuilder_DOT_js.ContiguousMultilineTokensBuilder();
      (_a = this._tokenizer) === null || _a === void 0 || _a.updateTokensUntilLine(builder, lineNumber);
      this.setTokens(builder.finalize());
      (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 || _b.checkFinished();
    }
    isCheapToTokenize(lineNumber) {
      return this._tokenizer ? this._tokenizer.isCheapToTokenize(lineNumber) : !0;
    }
    tokenizeIfCheap(lineNumber) {
      this.isCheapToTokenize(lineNumber) && this.forceTokenization(lineNumber);
    }
    getLineTokens(lineNumber) {
      var _a, lineText = this._textModel.getLineContent(lineNumber);
      const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
      this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer && this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && (lineText = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText), !result.equals(lineText) && ((_a = this._debugBackgroundTokenizer.value) === null || _a === void 0 ? 0 : _a.reportMismatchingTokens) && this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber));
      return result;
    }
    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
      if (!this._tokenizer) {
        return 0;
      }
      lineNumber = this._textModel.validatePosition(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(lineNumber, column));
      this.forceTokenization(lineNumber.lineNumber);
      return this._tokenizer.getTokenTypeIfInsertingCharacter(lineNumber, character);
    }
    tokenizeLineWithEdit(position, length, newText) {
      if (!this._tokenizer) {
        return null;
      }
      position = this._textModel.validatePosition(position);
      this.forceTokenization(position.lineNumber);
      return this._tokenizer.tokenizeLineWithEdit(position, length, newText);
    }
    get hasTokens() {
      return this._tokens.hasTokens;
    }
  }
  class AttachedViewHandler extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable {
    get lineRanges() {
      return this._lineRanges;
    }
    constructor(_refreshTokens) {
      super();
      this._refreshTokens = _refreshTokens;
      this.runner = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.RunOnceScheduler(() => this.update(), 50));
      this._computedLineRanges = [];
      this._lineRanges = [];
    }
    update() {
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.equals)(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b)) || (this._computedLineRanges = this._lineRanges, this._refreshTokens());
    }
    handleStateChange(state) {
      this._lineRanges = state.visibleLineRanges;
      state.stabilized ? (this.runner.cancel(), this.update()) : this.runner.schedule();
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$tokenizationTextModelPart.js.map
