shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$linkedList = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, LinkedList:{enumerable:!0, get:function() {
    return LinkedList;
  }}});
  class Node {
    constructor(element) {
      this.element = element;
      this.prev = this.next = Node.Undefined;
    }
  }
  Node.Undefined = new Node(void 0);
  class LinkedList {
    constructor() {
      this._last = this._first = Node.Undefined;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === Node.Undefined;
    }
    clear() {
      let node = this._first;
      for (; node !== Node.Undefined;) {
        const next = node.next;
        node.prev = Node.Undefined;
        node.next = Node.Undefined;
        node = next;
      }
      this._last = this._first = Node.Undefined;
      this._size = 0;
    }
    unshift(element) {
      return this._insert(element, !1);
    }
    push(element) {
      return this._insert(element, !0);
    }
    _insert(element, atTheEnd) {
      const newNode = new Node(element);
      this._first === Node.Undefined ? this._last = this._first = newNode : atTheEnd ? (element = this._last, this._last = newNode, newNode.prev = element, element.next = newNode) : (element = this._first, this._first = newNode, newNode.next = element, element.prev = newNode);
      this._size += 1;
      let didRemove = !1;
      return () => {
        didRemove || (didRemove = !0, this._remove(newNode));
      };
    }
    shift() {
      if (this._first !== Node.Undefined) {
        const res = this._first.element;
        this._remove(this._first);
        return res;
      }
    }
    pop() {
      if (this._last !== Node.Undefined) {
        const res = this._last.element;
        this._remove(this._last);
        return res;
      }
    }
    _remove(node) {
      if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
        const anchor = node.prev;
        anchor.next = node.next;
        node.next.prev = anchor;
      } else {
        node.prev === Node.Undefined && node.next === Node.Undefined ? this._last = this._first = Node.Undefined : node.next === Node.Undefined ? (this._last = this._last.prev, this._last.next = Node.Undefined) : node.prev === Node.Undefined && (this._first = this._first.next, this._first.prev = Node.Undefined);
      }
      --this._size;
    }
    *[Symbol.iterator]() {
      let node = this._first;
      for (; node !== Node.Undefined;) {
        yield node.element, node = node.next;
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$linkedList.js.map
