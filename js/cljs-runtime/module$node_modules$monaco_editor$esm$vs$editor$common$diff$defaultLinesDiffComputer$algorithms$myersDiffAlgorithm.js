shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$myersDiffAlgorithm = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MyersDiffAlgorithm:{enumerable:!0, get:function() {
    return MyersDiffAlgorithm;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$offsetRange"), require$_DOT__SLASH_diffAlgorithm_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$diffAlgorithm");
  class MyersDiffAlgorithm {
    compute(seq1, seq2, timeout = require$_DOT__SLASH_diffAlgorithm_DOT_js.InfiniteTimeout.instance) {
      function getXAfterSnake(x, y) {
        for (; x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y);) {
          x++, y++;
        }
        return x;
      }
      if (seq1.length === 0 || seq2.length === 0) {
        return require$_DOT__SLASH_diffAlgorithm_DOT_js.DiffAlgorithmResult.trivial(seq1, seq2);
      }
      const seqX = seq1, seqY = seq2;
      seq1 = 0;
      seq2 = new FastInt32Array();
      seq2.set(0, getXAfterSnake(0, 0));
      var paths = new FastArrayNegativeIndices();
      paths.set(0, seq2.get(0) === 0 ? null : new SnakePath(null, 0, 0, seq2.get(0)));
      var k = 0;
      a: for (;;) {
        seq1++;
        if (!timeout.isValid()) {
          return require$_DOT__SLASH_diffAlgorithm_DOT_js.DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
        }
        var lowerBound = -Math.min(seq1, seqY.length + seq1 % 2);
        const upperBound = Math.min(seq1, seqX.length + seq1 % 2);
        for (k = lowerBound; k <= upperBound; k += 2) {
          var step = 0, maxXofDLineTop = k === upperBound ? -1 : seq2.get(k + 1), maxXofDLineLeft = k === lowerBound ? -1 : seq2.get(k - 1) + 1;
          step++;
          maxXofDLineLeft = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
          const y = maxXofDLineLeft - k;
          step++;
          if (!(maxXofDLineLeft > seqX.length || y > seqY.length) && (step = getXAfterSnake(maxXofDLineLeft, y), seq2.set(k, step), maxXofDLineTop = maxXofDLineLeft === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1), paths.set(k, step !== maxXofDLineLeft ? new SnakePath(maxXofDLineTop, maxXofDLineLeft, y, step - maxXofDLineLeft) : maxXofDLineTop), seq2.get(k) === seqX.length && seq2.get(k) - k === seqY.length)) {
            break a;
          }
        }
      }
      timeout = paths.get(k);
      seq1 = [];
      seq2 = seqX.length;
      for (paths = seqY.length;;) {
        k = timeout ? timeout.x + timeout.length : 0;
        lowerBound = timeout ? timeout.y + timeout.length : 0;
        k === seq2 && lowerBound === paths || seq1.push(new require$_DOT__SLASH_diffAlgorithm_DOT_js.SequenceDiff(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(k, seq2), new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_core_SLASH_offsetRange_DOT_js.OffsetRange(lowerBound, paths)));
        if (!timeout) {
          break;
        }
        seq2 = timeout.x;
        paths = timeout.y;
        timeout = timeout.prev;
      }
      seq1.reverse();
      return new require$_DOT__SLASH_diffAlgorithm_DOT_js.DiffAlgorithmResult(seq1, !1);
    }
  }
  class SnakePath {
    constructor(prev, x, y, length) {
      this.prev = prev;
      this.x = x;
      this.y = y;
      this.length = length;
    }
  }
  class FastInt32Array {
    constructor() {
      this.positiveArr = new Int32Array(10);
      this.negativeArr = new Int32Array(10);
    }
    get(idx) {
      return idx < 0 ? this.negativeArr[-idx - 1] : this.positiveArr[idx];
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        if (idx >= this.negativeArr.length) {
          var arr = this.negativeArr;
          this.negativeArr = new Int32Array(arr.length * 2);
          this.negativeArr.set(arr);
        }
        this.negativeArr[idx] = value;
      } else {
        idx >= this.positiveArr.length && (arr = this.positiveArr, this.positiveArr = new Int32Array(arr.length * 2), this.positiveArr.set(arr)), this.positiveArr[idx] = value;
      }
    }
  }
  class FastArrayNegativeIndices {
    constructor() {
      this.positiveArr = [];
      this.negativeArr = [];
    }
    get(idx) {
      return idx < 0 ? this.negativeArr[-idx - 1] : this.positiveArr[idx];
    }
    set(idx, value) {
      idx < 0 ? this.negativeArr[-idx - 1] = value : this.positiveArr[idx] = value;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$diff$defaultLinesDiffComputer$algorithms$myersDiffAlgorithm.js.map
