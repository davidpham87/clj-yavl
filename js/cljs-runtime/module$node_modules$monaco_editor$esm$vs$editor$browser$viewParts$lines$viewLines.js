shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLines = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ViewLines:{enumerable:!0, get:function() {
    return ViewLines;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_mouseCursor_SLASH_mouseCursor_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$mouseCursor$mouseCursor"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), platform = require("module$node_modules$monaco_editor$esm$vs$base$common$platform");
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLines_css");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$config$domFontInfo"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$renderingContext"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewLayer_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewLayer"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$browser$view$viewPart"), require$_DOT__SLASH_domReadingContext_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$domReadingContext"), require$_DOT__SLASH_viewLine_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLine"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range");
  class LastRenderedData {
    constructor() {
      this._currentVisibleRange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range(1, 1, 1, 1);
    }
    getCurrentVisibleRange() {
      return this._currentVisibleRange;
    }
    setCurrentVisibleRange(currentVisibleRange) {
      this._currentVisibleRange = currentVisibleRange;
    }
  }
  class HorizontalRevealRangeRequest {
    constructor(minimalReveal, lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {
      this.minimalReveal = minimalReveal;
      this.lineNumber = lineNumber;
      this.startColumn = startColumn;
      this.endColumn = endColumn;
      this.startScrollTop = startScrollTop;
      this.stopScrollTop = stopScrollTop;
      this.scrollType = scrollType;
      this.type = "range";
      this.maxLineNumber = this.minLineNumber = lineNumber;
    }
  }
  class HorizontalRevealSelectionsRequest {
    constructor(minimalReveal, selections, startScrollTop, stopScrollTop, scrollType) {
      this.minimalReveal = minimalReveal;
      this.selections = selections;
      this.startScrollTop = startScrollTop;
      this.stopScrollTop = stopScrollTop;
      this.scrollType = scrollType;
      this.type = "selections";
      minimalReveal = selections[0].startLineNumber;
      startScrollTop = selections[0].endLineNumber;
      for (let i = 1, len = selections.length; i < len; i++) {
        stopScrollTop = selections[i], minimalReveal = Math.min(minimalReveal, stopScrollTop.startLineNumber), startScrollTop = Math.max(startScrollTop, stopScrollTop.endLineNumber);
      }
      this.minLineNumber = minimalReveal;
      this.maxLineNumber = startScrollTop;
    }
  }
  class ViewLines extends require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.ViewPart {
    constructor(context, linesContent) {
      super(context);
      this._linesContent = linesContent;
      this._textRangeRestingSpot = document.createElement("div");
      this._visibleLines = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewLayer_DOT_js.VisibleLinesCollection(this);
      this.domNode = this._visibleLines.domNode;
      context = this._context.configuration;
      linesContent = this._context.configuration.options;
      const fontInfo = linesContent.get(50), wrappingInfo = linesContent.get(144);
      this._lineHeight = linesContent.get(66);
      this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
      this._isViewportWrapping = wrappingInfo.isViewportWrapping;
      this._revealHorizontalRightPadding = linesContent.get(99);
      this._cursorSurroundingLines = linesContent.get(29);
      this._cursorSurroundingLinesStyle = linesContent.get(30);
      this._canUseLayerHinting = !linesContent.get(32);
      this._viewLineOptions = new require$_DOT__SLASH_viewLine_DOT_js.ViewLineOptions(context, this._context.theme.type);
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_viewPart_DOT_js.PartFingerprints.write(this.domNode, 7);
      this.domNode.setClassName(`view-lines ${require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_browser_SLASH_ui_SLASH_mouseCursor_SLASH_mouseCursor_DOT_js.MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js.applyFontInfo)(this.domNode, fontInfo);
      this._maxLineWidth = 0;
      this._asyncUpdateLineWidths = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.RunOnceScheduler(() => {
        this._updateLineWidthsSlow();
      }, 200);
      this._asyncCheckMonospaceFontAssumptions = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.RunOnceScheduler(() => {
        this._checkMonospaceFontAssumptions();
      }, 2000);
      this._lastRenderedData = new LastRenderedData();
      this._horizontalRevealRequest = null;
      this._stickyScrollEnabled = linesContent.get(114).enabled;
      this._maxNumberStickyLines = linesContent.get(114).maxLineCount;
    }
    dispose() {
      this._asyncUpdateLineWidths.dispose();
      this._asyncCheckMonospaceFontAssumptions.dispose();
      super.dispose();
    }
    getDomNode() {
      return this.domNode;
    }
    createVisibleLine() {
      return new require$_DOT__SLASH_viewLine_DOT_js.ViewLine(this._viewLineOptions);
    }
    onConfigurationChanged(e) {
      this._visibleLines.onConfigurationChanged(e);
      e.hasChanged(144) && (this._maxLineWidth = 0);
      const options = this._context.configuration.options, fontInfo = options.get(50), wrappingInfo = options.get(144);
      this._lineHeight = options.get(66);
      this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;
      this._isViewportWrapping = wrappingInfo.isViewportWrapping;
      this._revealHorizontalRightPadding = options.get(99);
      this._cursorSurroundingLines = options.get(29);
      this._cursorSurroundingLinesStyle = options.get(30);
      this._canUseLayerHinting = !options.get(32);
      this._stickyScrollEnabled = options.get(114).enabled;
      this._maxNumberStickyLines = options.get(114).maxLineCount;
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_config_SLASH_domFontInfo_DOT_js.applyFontInfo)(this.domNode, fontInfo);
      this._onOptionsMaybeChanged();
      e.hasChanged(143) && (this._maxLineWidth = 0);
      return !0;
    }
    _onOptionsMaybeChanged() {
      var newViewLineOptions = new require$_DOT__SLASH_viewLine_DOT_js.ViewLineOptions(this._context.configuration, this._context.theme.type);
      if (!this._viewLineOptions.equals(newViewLineOptions)) {
        this._viewLineOptions = newViewLineOptions;
        var startLineNumber = this._visibleLines.getStartLineNumber();
        for (newViewLineOptions = this._visibleLines.getEndLineNumber(); startLineNumber <= newViewLineOptions; startLineNumber++) {
          this._visibleLines.getVisibleLine(startLineNumber).onOptionsChanged(this._viewLineOptions);
        }
        return !0;
      }
      return !1;
    }
    onCursorStateChanged(e) {
      var rendStartLineNumber = this._visibleLines.getStartLineNumber();
      e = this._visibleLines.getEndLineNumber();
      let r = !1;
      for (; rendStartLineNumber <= e; rendStartLineNumber++) {
        r = this._visibleLines.getVisibleLine(rendStartLineNumber).onSelectionChanged() || r;
      }
      return r;
    }
    onDecorationsChanged(e) {
      var rendStartLineNumber = this._visibleLines.getStartLineNumber();
      for (e = this._visibleLines.getEndLineNumber(); rendStartLineNumber <= e; rendStartLineNumber++) {
        this._visibleLines.getVisibleLine(rendStartLineNumber).onDecorationsChanged();
      }
      return !0;
    }
    onFlushed(e) {
      e = this._visibleLines.onFlushed(e);
      this._maxLineWidth = 0;
      return e;
    }
    onLinesChanged(e) {
      return this._visibleLines.onLinesChanged(e);
    }
    onLinesDeleted(e) {
      return this._visibleLines.onLinesDeleted(e);
    }
    onLinesInserted(e) {
      return this._visibleLines.onLinesInserted(e);
    }
    onRevealRangeRequest(e) {
      var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
      if (desiredScrollTop === -1) {
        return !1;
      }
      desiredScrollTop = this._context.viewLayout.validateScrollPosition({scrollTop:desiredScrollTop});
      e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? desiredScrollTop = {scrollTop:desiredScrollTop.scrollTop, scrollLeft:0} : e.range ? this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), desiredScrollTop.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.minimalReveal, 
      e.selections, this._context.viewLayout.getCurrentScrollTop(), desiredScrollTop.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
      e = Math.abs(this._context.viewLayout.getCurrentScrollTop() - desiredScrollTop.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
      this._context.viewModel.viewLayout.setScrollPosition(desiredScrollTop, e);
      return !0;
    }
    onScrollChanged(e) {
      this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null);
      if (this._horizontalRevealRequest && e.scrollTopChanged) {
        const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
        if (e.scrollTop < Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop) || e.scrollTop > max) {
          this._horizontalRevealRequest = null;
        }
      }
      this.domNode.setWidth(e.scrollWidth);
      return this._visibleLines.onScrollChanged(e) || !0;
    }
    onTokensChanged(e) {
      return this._visibleLines.onTokensChanged(e);
    }
    onZonesChanged(e) {
      this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth);
      return this._visibleLines.onZonesChanged(e);
    }
    onThemeChanged(e) {
      return this._onOptionsMaybeChanged();
    }
    getPositionFromDOMInfo(spanNode, offset) {
      var viewLineDomNode = this._getViewLineDomNode(spanNode);
      if (viewLineDomNode === null) {
        return null;
      }
      viewLineDomNode = this._getLineNumberFor(viewLineDomNode);
      if (viewLineDomNode === -1 || viewLineDomNode < 1 || viewLineDomNode > this._context.viewModel.getLineCount()) {
        return null;
      }
      if (this._context.viewModel.getLineMaxColumn(viewLineDomNode) === 1) {
        return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewLineDomNode, 1);
      }
      const rendStartLineNumber = this._visibleLines.getStartLineNumber(), rendEndLineNumber = this._visibleLines.getEndLineNumber();
      if (viewLineDomNode < rendStartLineNumber || viewLineDomNode > rendEndLineNumber) {
        return null;
      }
      spanNode = this._visibleLines.getVisibleLine(viewLineDomNode).getColumnOfNodeOffset(spanNode, offset);
      offset = this._context.viewModel.getLineMinColumn(viewLineDomNode);
      spanNode < offset && (spanNode = offset);
      return new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(viewLineDomNode, spanNode);
    }
    _getViewLineDomNode(node) {
      for (; node && node.nodeType === 1;) {
        if (node.className === require$_DOT__SLASH_viewLine_DOT_js.ViewLine.CLASS_NAME) {
          return node;
        }
        node = node.parentElement;
      }
      return null;
    }
    _getLineNumberFor(domNode) {
      var startLineNumber = this._visibleLines.getStartLineNumber();
      const endLineNumber = this._visibleLines.getEndLineNumber();
      for (; startLineNumber <= endLineNumber; startLineNumber++) {
        const line = this._visibleLines.getVisibleLine(startLineNumber);
        if (domNode === line.getDomNode()) {
          return startLineNumber;
        }
      }
      return -1;
    }
    getLineWidth(lineNumber) {
      var rendStartLineNumber = this._visibleLines.getStartLineNumber();
      const rendEndLineNumber = this._visibleLines.getEndLineNumber();
      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
        return -1;
      }
      rendStartLineNumber = new require$_DOT__SLASH_domReadingContext_DOT_js.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
      lineNumber = this._visibleLines.getVisibleLine(lineNumber).getWidth(rendStartLineNumber);
      this._updateLineWidthsSlowIfDomDidLayout(rendStartLineNumber);
      return lineNumber;
    }
    linesVisibleRangesForRange(_range, includeNewLines) {
      if (this.shouldRender()) {
        return null;
      }
      const originalEndLineNumber = _range.endLineNumber;
      _range = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_range_DOT_js.Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());
      if (!_range) {
        return null;
      }
      const visibleRanges = [];
      let visibleRangesLen = 0;
      const domReadingContext = new require$_DOT__SLASH_domReadingContext_DOT_js.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
      let nextLineModelLineNumber = 0;
      includeNewLines && (nextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(_range.startLineNumber, 1)).lineNumber);
      const rendStartLineNumber = this._visibleLines.getStartLineNumber(), rendEndLineNumber = this._visibleLines.getEndLineNumber();
      for (let lineNumber = _range.startLineNumber; lineNumber <= _range.endLineNumber; lineNumber++) {
        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
          continue;
        }
        var startColumn = lineNumber === _range.startLineNumber ? _range.startColumn : 1;
        const continuesInNextLine = lineNumber !== _range.endLineNumber;
        var endColumn = continuesInNextLine ? this._context.viewModel.getLineMaxColumn(lineNumber) : _range.endColumn;
        if (startColumn = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext)) {
          includeNewLines && lineNumber < originalEndLineNumber && (endColumn = nextLineModelLineNumber, nextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_core_SLASH_position_DOT_js.Position(lineNumber + 1, 1)).lineNumber, endColumn !== nextLineModelLineNumber && (startColumn.ranges[startColumn.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth)), visibleRanges[visibleRangesLen++] = 
          new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.LineVisibleRanges(startColumn.outsideRenderedLine, lineNumber, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.HorizontalRange.from(startColumn.ranges), continuesInNextLine);
        }
      }
      this._updateLineWidthsSlowIfDomDidLayout(domReadingContext);
      return visibleRangesLen === 0 ? null : visibleRanges;
    }
    _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {
      if (this.shouldRender() || lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {
        return null;
      }
      const domReadingContext = new require$_DOT__SLASH_domReadingContext_DOT_js.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
      lineNumber = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);
      this._updateLineWidthsSlowIfDomDidLayout(domReadingContext);
      return lineNumber;
    }
    visibleRangeForPosition(position) {
      return (position = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column)) ? new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_view_SLASH_renderingContext_DOT_js.HorizontalPosition(position.outsideRenderedLine, position.ranges[0].left) : null;
    }
    _updateLineWidthsFast() {
      return this._updateLineWidths(!0);
    }
    _updateLineWidthsSlow() {
      this._updateLineWidths(!1);
    }
    _updateLineWidthsSlowIfDomDidLayout(domReadingContext) {
      domReadingContext.didDomLayout && !this._asyncUpdateLineWidths.isScheduled() && (this._asyncUpdateLineWidths.cancel(), this._updateLineWidthsSlow());
    }
    _updateLineWidths(fast) {
      const rendStartLineNumber = this._visibleLines.getStartLineNumber(), rendEndLineNumber = this._visibleLines.getEndLineNumber();
      let localMaxLineWidth = 1, allWidthsComputed = !0;
      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);
        fast && !visibleLine.getWidthIsFast() ? allWidthsComputed = !1 : localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth(null));
      }
      allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0);
      this._ensureMaxLineWidth(localMaxLineWidth);
      return allWidthsComputed;
    }
    _checkMonospaceFontAssumptions() {
      var longestLineNumber = -1;
      let longestWidth = -1;
      const rendStartLineNumber = this._visibleLines.getStartLineNumber(), rendEndLineNumber = this._visibleLines.getEndLineNumber();
      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
        var visibleLine = this._visibleLines.getVisibleLine(lineNumber);
        visibleLine.needsMonospaceFontCheck() && (visibleLine = visibleLine.getWidth(null), visibleLine > longestWidth && (longestWidth = visibleLine, longestLineNumber = lineNumber));
      }
      if (longestLineNumber !== -1 && !this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {
        for (longestLineNumber = rendStartLineNumber; longestLineNumber <= rendEndLineNumber; longestLineNumber++) {
          this._visibleLines.getVisibleLine(longestLineNumber).onMonospaceAssumptionsInvalidated();
        }
      }
    }
    prepareRender() {
      throw Error("Not supported");
    }
    render() {
      throw Error("Not supported");
    }
    renderText(viewportData) {
      this._visibleLines.renderLines(viewportData);
      this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);
      this.domNode.setWidth(this._context.viewLayout.getScrollWidth());
      this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));
      if (this._horizontalRevealRequest) {
        var horizontalRevealRequest = this._horizontalRevealRequest;
        if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {
          this._horizontalRevealRequest = null;
          this.onDidRender();
          var newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);
          newScrollLeft && (this._isViewportWrapping || this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({scrollLeft:newScrollLeft.scrollLeft}, horizontalRevealRequest.scrollType));
        }
      }
      this._updateLineWidthsFast() ? this._asyncUpdateLineWidths.cancel() : this._asyncUpdateLineWidths.schedule();
      if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
        for (newScrollLeft = this._visibleLines.getStartLineNumber(), horizontalRevealRequest = this._visibleLines.getEndLineNumber(); newScrollLeft <= horizontalRevealRequest; newScrollLeft++) {
          if (this._visibleLines.getVisibleLine(newScrollLeft).needsMonospaceFontCheck()) {
            this._asyncCheckMonospaceFontAssumptions.schedule();
            break;
          }
        }
      }
      this._linesContent.setLayerHinting(this._canUseLayerHinting);
      this._linesContent.setContain("strict");
      viewportData = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;
      this._linesContent.setTop(-viewportData);
      this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
    }
    _ensureMaxLineWidth(lineWidth) {
      lineWidth = Math.ceil(lineWidth);
      this._maxLineWidth < lineWidth && (this._maxLineWidth = lineWidth, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
    }
    _computeScrollTopToRevealRange(viewport, source, minimalReveal, range, selections, verticalType) {
      const viewportStartY = viewport.top;
      viewport = viewport.height;
      const viewportEndY = viewportStartY + viewport;
      if (selections && selections.length > 0) {
        var boxStartY = selections[0].startLineNumber;
        range = selections[0].endLineNumber;
        for (let i = 1, len = selections.length; i < len; i++) {
          var selection = selections[i];
          boxStartY = Math.min(boxStartY, selection.startLineNumber);
          range = Math.max(range, selection.endLineNumber);
        }
        selections = !1;
        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(boxStartY);
        range = this._context.viewLayout.getVerticalOffsetForLineNumber(range) + this._lineHeight;
      } else if (range) {
        selections = !0, boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber), range = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;
      } else {
        return -1;
      }
      let paddingBottom = selection = 0;
      source !== "mouse" && !minimalReveal || this._cursorSurroundingLinesStyle !== "default" ? (source = Math.min(viewport / this._lineHeight / 2, this._cursorSurroundingLines), selection = this._stickyScrollEnabled ? Math.max(source, this._maxNumberStickyLines) * this._lineHeight : source * this._lineHeight, paddingBottom = Math.max(0, source - 1) * this._lineHeight) : minimalReveal || (selection = this._lineHeight);
      minimalReveal || verticalType !== 0 && verticalType !== 4 || (paddingBottom += this._lineHeight);
      boxStartY -= selection;
      range += paddingBottom;
      if (range - boxStartY > viewport) {
        if (!selections) {
          return -1;
        }
        minimalReveal = boxStartY;
      } else {
        minimalReveal = verticalType === 5 || verticalType === 6 ? verticalType === 6 && viewportStartY <= boxStartY && range <= viewportEndY ? viewportStartY : Math.max(range - viewport, boxStartY - Math.max(5 * this._lineHeight, viewport * 0.2)) : verticalType === 1 || verticalType === 2 ? verticalType === 2 && viewportStartY <= boxStartY && range <= viewportEndY ? viewportStartY : Math.max(0, (boxStartY + range) / 2 - viewport / 2) : this._computeMinimumScrolling(viewportStartY, viewportEndY, 
        boxStartY, range, verticalType === 3, verticalType === 4);
      }
      return minimalReveal;
    }
    _computeScrollLeftToReveal(horizontalRevealRequest) {
      const viewport = this._context.viewLayout.getCurrentViewport();
      var layoutInfo = this._context.configuration.options.get(143);
      const viewportStartX = viewport.left;
      layoutInfo = viewportStartX + viewport.width - layoutInfo.verticalScrollbarWidth;
      let boxStartX = 1073741824, boxEndX = 0;
      if (horizontalRevealRequest.type === "range") {
        var visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);
        if (!visibleRanges) {
          return null;
        }
        for (var visibleRange$jscomp$0 of visibleRanges.ranges) {
          boxStartX = Math.min(boxStartX, Math.round(visibleRange$jscomp$0.left)), boxEndX = Math.max(boxEndX, Math.round(visibleRange$jscomp$0.left + visibleRange$jscomp$0.width));
        }
      } else {
        for (visibleRanges of horizontalRevealRequest.selections) {
          if (visibleRanges.startLineNumber !== visibleRanges.endLineNumber) {
            return null;
          }
          visibleRange$jscomp$0 = this._visibleRangesForLineRange(visibleRanges.startLineNumber, visibleRanges.startColumn, visibleRanges.endColumn);
          if (!visibleRange$jscomp$0) {
            return null;
          }
          for (const visibleRange of visibleRange$jscomp$0.ranges) {
            boxStartX = Math.min(boxStartX, Math.round(visibleRange.left)), boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));
          }
        }
      }
      horizontalRevealRequest.minimalReveal || (boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX), boxEndX += this._revealHorizontalRightPadding);
      return horizontalRevealRequest.type === "selections" && boxEndX - boxStartX > viewport.width ? null : {scrollLeft:this._computeMinimumScrolling(viewportStartX, layoutInfo, boxStartX, boxEndX), maxHorizontalOffset:boxEndX};
    }
    _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {
      viewportStart |= 0;
      viewportEnd |= 0;
      boxStart |= 0;
      boxEnd |= 0;
      const viewportLength = viewportEnd - viewportStart;
      if (boxEnd - boxStart < viewportLength) {
        if (revealAtStart) {
          return boxStart;
        }
        if (revealAtEnd) {
          return Math.max(0, boxEnd - viewportLength);
        }
        if (boxStart < viewportStart) {
          return boxStart;
        }
        if (boxEnd > viewportEnd) {
          return Math.max(0, boxEnd - viewportLength);
        }
      } else {
        return boxStart;
      }
      return viewportStart;
    }
  }
  ViewLines.HORIZONTAL_EXTRA_PX = 30;
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$browser$viewParts$lines$viewLines.js.map
