shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$actions$common$menuService = function(require, module, exports) {
  function createMenuHide(menu, command, states) {
    const id = (0,require$_DOT__SLASH_actions_DOT_js.isISubmenuItem)(command) ? command.submenu.id : command.id;
    command = typeof command.title === "string" ? command.title : command.title.value;
    const hide = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_actions_DOT_js.toAction)({id:`hide/${menu.id}/${id}`, label:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js.localize)("hide.label", "Hide '{0}'", command), run() {
      states.updateHidden(menu, id, !0);
    }}), toggle = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_actions_DOT_js.toAction)({id:`toggle/${menu.id}/${id}`, label:command, get checked() {
      return !states.isHidden(menu, id);
    }, run() {
      states.updateHidden(menu, id, !!this.checked);
    }});
    return {hide, toggle, get isHidden() {
      return !toggle.checked;
    }};
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, MenuService:{enumerable:!0, get:function() {
    return MenuService;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), 
  require$_DOT__SLASH_actions_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$actions$common$actions");
  module = require("module$node_modules$monaco_editor$esm$vs$platform$commands$common$commands");
  exports = require("module$node_modules$monaco_editor$esm$vs$platform$contextkey$common$contextkey");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_actions_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$actions"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_storage_SLASH_common_SLASH_storage_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$storage$common$storage"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_nls_DOT_js = require("module$node_modules$monaco_editor$esm$vs$nls");
  require = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }, PersistedMenuHideState_1, MenuInfo_1;
  let MenuService = class {
    constructor(_commandService, storageService) {
      this._commandService = _commandService;
      this._hiddenStates = new PersistedMenuHideState(storageService);
    }
    createMenu(id, contextKeyService, options) {
      return new MenuImpl(id, this._hiddenStates, {emitEventsForSubmenuChanges:!1, eventDebounceDelay:50, ...options}, this._commandService, contextKeyService);
    }
    resetHiddenStates(ids) {
      this._hiddenStates.reset(ids);
    }
  };
  MenuService = require([__param(0, module.ICommandService), __param(1, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_storage_SLASH_common_SLASH_storage_DOT_js.IStorageService)], MenuService);
  let PersistedMenuHideState = PersistedMenuHideState_1 = class {
    constructor(_storageService) {
      this._storageService = _storageService;
      this._disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._onDidChange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter();
      this.onDidChange = this._onDidChange.event;
      this._ignoreChangeEvent = !1;
      this._hiddenByDefaultCache = new Map();
      try {
        const raw = _storageService.get(PersistedMenuHideState_1._key, 0, "{}");
        this._data = JSON.parse(raw);
      } catch (err) {
        this._data = Object.create(null);
      }
      this._disposables.add(_storageService.onDidChangeValue(0, PersistedMenuHideState_1._key, this._disposables)(() => {
        if (!this._ignoreChangeEvent) {
          try {
            const raw = _storageService.get(PersistedMenuHideState_1._key, 0, "{}");
            this._data = JSON.parse(raw);
          } catch (err) {
            console.log("FAILED to read storage after UPDATE", err);
          }
        }
        this._onDidChange.fire();
      }));
    }
    dispose() {
      this._onDidChange.dispose();
      this._disposables.dispose();
    }
    _isHiddenByDefault(menu, commandId) {
      var _a;
      return (_a = this._hiddenByDefaultCache.get(`${menu.id}/${commandId}`)) !== null && _a !== void 0 ? _a : !1;
    }
    setDefaultState(menu, commandId, hidden) {
      this._hiddenByDefaultCache.set(`${menu.id}/${commandId}`, hidden);
    }
    isHidden(menu, commandId) {
      var _a, _b;
      const hiddenByDefault = this._isHiddenByDefault(menu, commandId);
      menu = (_b = (_a = this._data[menu.id]) === null || _a === void 0 ? void 0 : _a.includes(commandId)) !== null && _b !== void 0 ? _b : !1;
      return hiddenByDefault ? !menu : menu;
    }
    updateHidden(menu, commandId, hidden) {
      this._isHiddenByDefault(menu, commandId) && (hidden = !hidden);
      const entries = this._data[menu.id];
      hidden ? entries ? entries.indexOf(commandId) < 0 && entries.push(commandId) : this._data[menu.id] = [commandId] : entries && (commandId = entries.indexOf(commandId), commandId >= 0 && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_arrays_DOT_js.removeFastWithoutKeepingOrder)(entries, commandId), entries.length === 0 && delete this._data[menu.id]);
      this._persist();
    }
    reset(menus) {
      if (menus === void 0) {
        this._data = Object.create(null);
      } else {
        for (const {id} of menus) {
          this._data[id] && delete this._data[id];
        }
      }
      this._persist();
    }
    _persist() {
      try {
        this._ignoreChangeEvent = !0;
        const raw = JSON.stringify(this._data);
        this._storageService.store(PersistedMenuHideState_1._key, raw, 0, 0);
      } finally {
        this._ignoreChangeEvent = !1;
      }
    }
  };
  PersistedMenuHideState._key = "menu.hiddenCommands";
  PersistedMenuHideState = PersistedMenuHideState_1 = require([__param(0, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_storage_SLASH_common_SLASH_storage_DOT_js.IStorageService)], PersistedMenuHideState);
  let MenuInfo = MenuInfo_1 = class {
    constructor(_id, _hiddenStates, _collectContextKeysForSubmenus, _commandService, _contextKeyService) {
      this._id = _id;
      this._hiddenStates = _hiddenStates;
      this._collectContextKeysForSubmenus = _collectContextKeysForSubmenus;
      this._commandService = _commandService;
      this._contextKeyService = _contextKeyService;
      this._menuGroups = [];
      this._structureContextKeys = new Set();
      this._preconditionContextKeys = new Set();
      this._toggledContextKeys = new Set();
      this.refresh();
    }
    get structureContextKeys() {
      return this._structureContextKeys;
    }
    get preconditionContextKeys() {
      return this._preconditionContextKeys;
    }
    get toggledContextKeys() {
      return this._toggledContextKeys;
    }
    refresh() {
      this._menuGroups.length = 0;
      this._structureContextKeys.clear();
      this._preconditionContextKeys.clear();
      this._toggledContextKeys.clear();
      var menuItems = require$_DOT__SLASH_actions_DOT_js.MenuRegistry.getMenuItems(this._id);
      let group;
      menuItems.sort(MenuInfo_1._compareMenuItems);
      for (const item of menuItems) {
        menuItems = item.group || "", group && group[0] === menuItems || (group = [menuItems, []], this._menuGroups.push(group)), group[1].push(item), this._collectContextKeys(item);
      }
    }
    _collectContextKeys(item) {
      MenuInfo_1._fillInKbExprKeys(item.when, this._structureContextKeys);
      (0,require$_DOT__SLASH_actions_DOT_js.isIMenuItem)(item) ? (item.command.precondition && MenuInfo_1._fillInKbExprKeys(item.command.precondition, this._preconditionContextKeys), item.command.toggled && MenuInfo_1._fillInKbExprKeys(item.command.toggled.condition || item.command.toggled, this._toggledContextKeys)) : this._collectContextKeysForSubmenus && require$_DOT__SLASH_actions_DOT_js.MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);
    }
    createActionGroups(options) {
      const result = [];
      for (const group of this._menuGroups) {
        const [id, items] = group, activeActions = [];
        for (const item of items) {
          if (this._contextKeyService.contextMatchesRules(item.when)) {
            var isMenuItem = (0,require$_DOT__SLASH_actions_DOT_js.isIMenuItem)(item);
            isMenuItem && this._hiddenStates.setDefaultState(this._id, item.command.id, !!item.isHiddenByDefault);
            const menuHide = createMenuHide(this._id, isMenuItem ? item.command : item, this._hiddenStates);
            isMenuItem ? activeActions.push(new require$_DOT__SLASH_actions_DOT_js.MenuItemAction(item.command, item.alt, options, menuHide, this._contextKeyService, this._commandService)) : (isMenuItem = (new MenuInfo_1(item.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._contextKeyService)).createActionGroups(options), isMenuItem = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_actions_DOT_js.Separator.join(...isMenuItem.map(g => 
            g[1])), isMenuItem.length > 0 && activeActions.push(new require$_DOT__SLASH_actions_DOT_js.SubmenuItemAction(item, menuHide, isMenuItem)));
          }
        }
        activeActions.length > 0 && result.push([id, activeActions]);
      }
      return result;
    }
    static _fillInKbExprKeys(exp, set) {
      if (exp) {
        for (const key of exp.keys()) {
          set.add(key);
        }
      }
    }
    static _compareMenuItems(a, b) {
      var aGroup = a.group, bGroup = b.group;
      if (aGroup !== bGroup) {
        if (!aGroup) {
          return 1;
        }
        if (!bGroup || aGroup === "navigation") {
          return -1;
        }
        if (bGroup === "navigation") {
          return 1;
        }
        aGroup = aGroup.localeCompare(bGroup);
        if (aGroup !== 0) {
          return aGroup;
        }
      }
      aGroup = a.order || 0;
      bGroup = b.order || 0;
      return aGroup < bGroup ? -1 : aGroup > bGroup ? 1 : MenuInfo_1._compareTitles((0,require$_DOT__SLASH_actions_DOT_js.isIMenuItem)(a) ? a.command.title : a.title, (0,require$_DOT__SLASH_actions_DOT_js.isIMenuItem)(b) ? b.command.title : b.title);
    }
    static _compareTitles(a, b) {
      return (typeof a === "string" ? a : a.original).localeCompare(typeof b === "string" ? b : b.original);
    }
  };
  MenuInfo = MenuInfo_1 = require([__param(3, module.ICommandService), __param(4, exports.IContextKeyService)], MenuInfo);
  let MenuImpl = class {
    constructor(id, hiddenStates, options, commandService, contextKeyService) {
      this._disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this._menuInfo = new MenuInfo(id, hiddenStates, options.emitEventsForSubmenuChanges, commandService, contextKeyService);
      const rebuildMenuSoon = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.RunOnceScheduler(() => {
        this._menuInfo.refresh();
        this._onDidChange.fire({menu:this, isStructuralChange:!0, isEnablementChange:!0, isToggleChange:!0});
      }, options.eventDebounceDelay);
      this._disposables.add(rebuildMenuSoon);
      this._disposables.add(require$_DOT__SLASH_actions_DOT_js.MenuRegistry.onDidChangeMenu(e => {
        e.has(id) && rebuildMenuSoon.schedule();
      }));
      const lazyListener = this._disposables.add(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore());
      this._onDidChange = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.DebounceEmitter({onWillAddFirstListener:() => {
        lazyListener.add(contextKeyService.onDidChangeContext(e => {
          const isStructuralChange = e.affectsSome(this._menuInfo.structureContextKeys), isEnablementChange = e.affectsSome(this._menuInfo.preconditionContextKeys);
          e = e.affectsSome(this._menuInfo.toggledContextKeys);
          (isStructuralChange || isEnablementChange || e) && this._onDidChange.fire({menu:this, isStructuralChange, isEnablementChange, isToggleChange:e});
        }));
        lazyListener.add(hiddenStates.onDidChange(e => {
          this._onDidChange.fire({menu:this, isStructuralChange:!0, isEnablementChange:!1, isToggleChange:!1});
        }));
      }, onDidRemoveLastListener:lazyListener.clear.bind(lazyListener), delay:options.eventDebounceDelay, merge:events => {
        let isStructuralChange = !1, isEnablementChange = !1, isToggleChange = !1;
        for (const item of events) {
          if (isStructuralChange = isStructuralChange || item.isStructuralChange, isEnablementChange = isEnablementChange || item.isEnablementChange, isToggleChange = isToggleChange || item.isToggleChange, isStructuralChange && isEnablementChange && isToggleChange) {
            break;
          }
        }
        return {menu:this, isStructuralChange, isEnablementChange, isToggleChange};
      }});
      this.onDidChange = this._onDidChange.event;
    }
    getActions(options) {
      return this._menuInfo.createActionGroups(options);
    }
    dispose() {
      this._disposables.dispose();
      this._onDidChange.dispose();
    }
  };
  MenuImpl = require([__param(3, module.ICommandService), __param(4, exports.IContextKeyService)], MenuImpl);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$actions$common$menuService.js.map
