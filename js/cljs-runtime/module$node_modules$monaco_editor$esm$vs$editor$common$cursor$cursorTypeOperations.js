shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorTypeOperations = function(require, module, exports) {
  function getTypingOperation(typedText, previousTypingOperation) {
    return typedText === " " ? previousTypingOperation === 5 || previousTypingOperation === 6 ? 6 : 5 : 4;
  }
  function shouldPushStackElementBetween(previousTypingOperation, typingOperation) {
    return previousTypingOperation !== 4 && previousTypingOperation !== 5 && previousTypingOperation !== 6 || typingOperation === 4 || typingOperation === 5 || typingOperation === 6 ? previousTypingOperation === 5 ? !1 : (previousTypingOperation === 6 || previousTypingOperation === 5 ? "space" : previousTypingOperation) !== (typingOperation === 6 || typingOperation === 5 ? "space" : typingOperation) : !0;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CompositionOutcome:{enumerable:!0, get:function() {
    return CompositionOutcome;
  }}, TypeOperations:{enumerable:!0, get:function() {
    return TypeOperations;
  }}, TypeWithAutoClosingCommand:{enumerable:!0, get:function() {
    return TypeWithAutoClosingCommand;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$commands$replaceCommand"), require$_DOT__DOT__SLASH_commands_SLASH_shiftCommand_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$commands$shiftCommand"), 
  require$_DOT__DOT__SLASH_commands_SLASH_surroundSelectionCommand_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$commands$surroundSelectionCommand"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$wordCharacterClassifier"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfiguration"), require$_DOT__DOT__SLASH_languages_SLASH_languageConfigurationRegistry_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$languageConfigurationRegistry"), 
  require$_DOT__DOT__SLASH_languages_SLASH_supports_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$supports"), require$_DOT__DOT__SLASH_languages_SLASH_autoIndent_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$autoIndent"), require$_DOT__DOT__SLASH_languages_SLASH_enterAction_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$enterAction");
  class TypeOperations {
    static indent(config, model, selections) {
      if (model === null || selections === null) {
        return [];
      }
      model = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        model[i] = new require$_DOT__DOT__SLASH_commands_SLASH_shiftCommand_DOT_js.ShiftCommand(selections[i], {isUnshift:!1, tabSize:config.tabSize, indentSize:config.indentSize, insertSpaces:config.insertSpaces, useTabStops:config.useTabStops, autoIndent:config.autoIndent}, config.languageConfigurationService);
      }
      return model;
    }
    static outdent(config, model, selections) {
      model = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        model[i] = new require$_DOT__DOT__SLASH_commands_SLASH_shiftCommand_DOT_js.ShiftCommand(selections[i], {isUnshift:!0, tabSize:config.tabSize, indentSize:config.indentSize, insertSpaces:config.insertSpaces, useTabStops:config.useTabStops, autoIndent:config.autoIndent}, config.languageConfigurationService);
      }
      return model;
    }
    static shiftIndent(config, indentation, count) {
      return require$_DOT__DOT__SLASH_commands_SLASH_shiftCommand_DOT_js.ShiftCommand.shiftIndent(indentation, indentation.length + (count || 1), config.tabSize, config.indentSize, config.insertSpaces);
    }
    static unshiftIndent(config, indentation, count) {
      return require$_DOT__DOT__SLASH_commands_SLASH_shiftCommand_DOT_js.ShiftCommand.unshiftIndent(indentation, indentation.length + (count || 1), config.tabSize, config.indentSize, config.insertSpaces);
    }
    static _distributedPaste(config, model, selections, text) {
      config = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selections[i], text[i]);
      }
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(0, config, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!0});
    }
    static _simplePaste(config, model, selections, text, pasteOnNewLine) {
      config = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        model = selections[i];
        var position = model.getPosition();
        pasteOnNewLine && !model.isEmpty() && (pasteOnNewLine = !1);
        pasteOnNewLine && text.indexOf("\n") !== text.length - 1 && (pasteOnNewLine = !1);
        pasteOnNewLine ? (position = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, 1, position.lineNumber, 1), config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandThatPreservesSelection(position, text, model, !0)) : config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(model, text);
      }
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(0, config, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!0});
    }
    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {
      return pasteOnNewLine || selections.length === 1 ? null : multicursorText && multicursorText.length === selections.length ? multicursorText : config.multiCursorPaste === "spread" && (text.charCodeAt(text.length - 1) === 10 && (text = text.substr(0, text.length - 1)), text.charCodeAt(text.length - 1) === 13 && (text = text.substr(0, text.length - 1)), config = strings.splitLines(text), config.length === selections.length) ? config : null;
    }
    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {
      return (multicursorText = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText)) ? (selections = selections.sort(require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.compareRangesUsingStarts), this._distributedPaste(config, model, selections, multicursorText)) : this._simplePaste(config, model, selections, text, pasteOnNewLine);
    }
    static _goodIndentForLine(config, model, lineNumber) {
      let action = null, indentation = "";
      var expectedIndentAction = (0,require$_DOT__DOT__SLASH_languages_SLASH_autoIndent_DOT_js.getInheritIndentForLine)(config.autoIndent, model, lineNumber, !1, config.languageConfigurationService);
      if (expectedIndentAction) {
        action = expectedIndentAction.action, indentation = expectedIndentAction.indentation;
      } else if (lineNumber > 1) {
        for (--lineNumber; lineNumber >= 1 && !(expectedIndentAction = model.getLineContent(lineNumber), strings.lastNonWhitespaceIndex(expectedIndentAction) >= 0); lineNumber--) {
        }
        if (lineNumber < 1) {
          return null;
        }
        expectedIndentAction = model.getLineMaxColumn(lineNumber);
        (model = (0,require$_DOT__DOT__SLASH_languages_SLASH_enterAction_DOT_js.getEnterAction)(config.autoIndent, model, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, expectedIndentAction, lineNumber, expectedIndentAction), config.languageConfigurationService)) && (indentation = model.indentation + model.appendText);
      }
      action && (action === require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js.IndentAction.Indent && (indentation = TypeOperations.shiftIndent(config, indentation)), action === require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js.IndentAction.Outdent && (indentation = TypeOperations.unshiftIndent(config, indentation)), indentation = config.normalizeIndentation(indentation));
      return indentation ? indentation : null;
    }
    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {
      let typeText = "";
      const position = selection.getStartPosition();
      if (config.insertSpaces) {
        for (model = config.visibleColumnFromColumn(model, position), config = config.indentSize, config -= model % config, model = 0; model < config; model++) {
          typeText += " ";
        }
      } else {
        typeText = "\t";
      }
      return new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selection, typeText, insertsAutoWhitespace);
    }
    static tab(config, model, selections) {
      const commands = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        const selection = selections[i];
        if (selection.isEmpty()) {
          var lineText = model.getLineContent(selection.startLineNumber);
          if (/^\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {
            var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);
            goodIndent = goodIndent || "\t";
            goodIndent = config.normalizeIndentation(goodIndent);
            if (!lineText.startsWith(goodIndent)) {
              commands[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), goodIndent, !0);
              continue;
            }
          }
          commands[i] = this._replaceJumpToNextIndent(config, model, selection, !0);
        } else {
          if (selection.startLineNumber === selection.endLineNumber && (lineText = model.getLineMaxColumn(selection.startLineNumber), selection.startColumn !== 1 || selection.endColumn !== lineText)) {
            commands[i] = this._replaceJumpToNextIndent(config, model, selection, !1);
            continue;
          }
          commands[i] = new require$_DOT__DOT__SLASH_commands_SLASH_shiftCommand_DOT_js.ShiftCommand(selection, {isUnshift:!1, tabSize:config.tabSize, indentSize:config.indentSize, insertSpaces:config.insertSpaces, useTabStops:config.useTabStops, autoIndent:config.autoIndent}, config.languageConfigurationService);
        }
      }
      return commands;
    }
    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {
      config = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, config, {shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType, 4), shouldPushStackElementAfter:!1});
    }
    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {
      if (!selection.isEmpty()) {
        return null;
      }
      selection = selection.getPosition();
      replacePrevCharCnt = Math.max(1, selection.column - replacePrevCharCnt);
      replaceNextCharCnt = Math.min(model.getLineMaxColumn(selection.lineNumber), selection.column + replaceNextCharCnt);
      replaceNextCharCnt = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection.lineNumber, replacePrevCharCnt, selection.lineNumber, replaceNextCharCnt);
      return model.getValueInRange(replaceNextCharCnt) === text && positionDelta === 0 ? null : new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithOffsetCursorState(replaceNextCharCnt, text, 0, positionDelta);
    }
    static _typeCommand(range, text, keepPosition) {
      return keepPosition ? new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithoutChangingPosition(range, text, !0) : new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(range, text, !0);
    }
    static _enter(config, model, keepPosition, range) {
      if (config.autoIndent === 0) {
        return TypeOperations._typeCommand(range, "\n", keepPosition);
      }
      if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1) {
        return model = model.getLineContent(range.startLineNumber), model = strings.getLeadingWhitespace(model).substring(0, range.startColumn - 1), TypeOperations._typeCommand(range, "\n" + config.normalizeIndentation(model), keepPosition);
      }
      var r = (0,require$_DOT__DOT__SLASH_languages_SLASH_enterAction_DOT_js.getEnterAction)(config.autoIndent, model, range, config.languageConfigurationService);
      if (r) {
        if (r.indentAction === require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js.IndentAction.None || r.indentAction === require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js.IndentAction.Indent) {
          return TypeOperations._typeCommand(range, "\n" + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);
        }
        if (r.indentAction === require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js.IndentAction.IndentOutdent) {
          model = config.normalizeIndentation(r.indentation);
          r = config.normalizeIndentation(r.indentation + r.appendText);
          var typeText = "\n" + r + "\n" + model;
          return keepPosition ? new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithoutChangingPosition(range, typeText, !0) : new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithOffsetCursorState(range, typeText, -1, r.length - model.length, !0);
        }
        if (r.indentAction === require$_DOT__DOT__SLASH_languages_SLASH_languageConfiguration_DOT_js.IndentAction.Outdent) {
          return model = TypeOperations.unshiftIndent(config, r.indentation), TypeOperations._typeCommand(range, "\n" + config.normalizeIndentation(model + r.appendText), keepPosition);
        }
      }
      r = model.getLineContent(range.startLineNumber);
      typeText = strings.getLeadingWhitespace(r).substring(0, range.startColumn - 1);
      if (config.autoIndent >= 4 && (r = (0,require$_DOT__DOT__SLASH_languages_SLASH_autoIndent_DOT_js.getIndentForEnter)(config.autoIndent, model, range, {unshiftIndent:indent => TypeOperations.unshiftIndent(config, indent), shiftIndent:indent => TypeOperations.shiftIndent(config, indent), normalizeIndentation:indent => config.normalizeIndentation(indent)}, config.languageConfigurationService))) {
        typeText = config.visibleColumnFromColumn(model, range.getEndPosition());
        const oldEndColumn = range.endColumn;
        var newLineContent = model.getLineContent(range.endLineNumber);
        newLineContent = strings.firstNonWhitespaceIndex(newLineContent);
        range = newLineContent >= 0 ? range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, newLineContent + 1)) : range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));
        if (keepPosition) {
          return new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithoutChangingPosition(range, "\n" + config.normalizeIndentation(r.afterEnter), !0);
        }
        keepPosition = 0;
        oldEndColumn <= newLineContent + 1 && (config.insertSpaces || (typeText = Math.ceil(typeText / config.indentSize)), keepPosition = Math.min(typeText + 1 - config.normalizeIndentation(r.afterEnter).length - 1, 0));
        return new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithOffsetCursorState(range, "\n" + config.normalizeIndentation(r.afterEnter), 0, keepPosition, !0);
      }
      return TypeOperations._typeCommand(range, "\n" + config.normalizeIndentation(typeText), keepPosition);
    }
    static _isAutoIndentType(config, model, selections) {
      if (config.autoIndent < 4) {
        return !1;
      }
      for (let i = 0, len = selections.length; i < len; i++) {
        if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {
          return !1;
        }
      }
      return !0;
    }
    static _runAutoIndentType(config, model, range, ch) {
      var currentIndentation = (0,require$_DOT__DOT__SLASH_languages_SLASH_languageConfigurationRegistry_DOT_js.getIndentationAtPosition)(model, range.startLineNumber, range.startColumn);
      const actualIndentation = (0,require$_DOT__DOT__SLASH_languages_SLASH_autoIndent_DOT_js.getIndentActionForType)(config.autoIndent, model, range, ch, {shiftIndent:indentation => TypeOperations.shiftIndent(config, indentation), unshiftIndent:indentation => TypeOperations.unshiftIndent(config, indentation)}, config.languageConfigurationService);
      return actualIndentation === null ? null : actualIndentation !== config.normalizeIndentation(currentIndentation) ? (currentIndentation = model.getLineFirstNonWhitespaceColumn(range.startLineNumber), currentIndentation === 0 ? TypeOperations._typeCommand(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, !1) : TypeOperations._typeCommand(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(range.startLineNumber, 
      1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(currentIndentation - 1, range.startColumn - 1) + ch, !1)) : null;
    }
    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {
      if (config.autoClosingOvertype === "never" || !config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {
        return !1;
      }
      for (let i = 0, len = selections.length; i < len; i++) {
        var selection = selections[i];
        if (!selection.isEmpty()) {
          return !1;
        }
        selection = selection.getPosition();
        var lineText = model.getLineContent(selection.lineNumber);
        if (lineText.charAt(selection.column - 1) !== ch) {
          return !1;
        }
        var chIsQuote = (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(ch);
        if ((selection.column > 2 ? lineText.charCodeAt(selection.column - 2) : 0) === 92 && chIsQuote) {
          return !1;
        }
        if (config.autoClosingOvertype === "auto") {
          lineText = !1;
          for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {
            if (chIsQuote = autoClosedCharacters[j], selection.lineNumber === chIsQuote.startLineNumber && selection.column === chIsQuote.startColumn) {
              lineText = !0;
              break;
            }
          }
          if (!lineText) {
            return !1;
          }
        }
      }
      return !0;
    }
    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {
      config = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        model = selections[i].getPosition(), model = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(model.lineNumber, model.column, model.lineNumber, model.column + 1), config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(model, ch);
      }
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, config, {shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType, 4), shouldPushStackElementAfter:!1});
    }
    static _isBeforeClosingBrace(config, lineAfter) {
      const nextChar = lineAfter.charAt(0);
      var potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];
      config = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];
      potentialStartingBraces = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));
      config = config.some(x => lineAfter.startsWith(x.close));
      return !potentialStartingBraces && config;
    }
    static _findAutoClosingPairOpen(config, model, positions, ch) {
      var candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);
      if (!candidates) {
        return null;
      }
      config = null;
      for (const candidate of candidates) {
        if (config === null || candidate.open.length > config.open.length) {
          candidates = !0;
          for (const position of positions) {
            if (model.getValueInRange(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column)) + ch !== candidate.open) {
              candidates = !1;
              break;
            }
          }
          candidates && (config = candidate);
        }
      }
      return config;
    }
    static _findContainedAutoClosingPair(config, pair) {
      if (pair.open.length <= 1) {
        return null;
      }
      var lastChar = pair.close.charAt(pair.close.length - 1);
      config = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];
      lastChar = null;
      for (const candidate of config) {
        candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close) && (!lastChar || candidate.open.length > lastChar.open.length) && (lastChar = candidate);
      }
      return lastChar;
    }
    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {
      for (var selection of selections) {
        if (!selection.isEmpty()) {
          return null;
        }
      }
      var positions = selections.map(s => {
        s = s.getPosition();
        return chIsAlreadyTyped ? {lineNumber:s.lineNumber, beforeColumn:s.column - ch.length, afterColumn:s.column} : {lineNumber:s.lineNumber, beforeColumn:s.column, afterColumn:s.column};
      });
      selections = this._findAutoClosingPairOpen(config, model, positions.map(p => new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(p.lineNumber, p.beforeColumn)), ch);
      if (!selections) {
        return null;
      }
      let shouldAutoCloseBefore;
      (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(ch) ? (selection = config.autoClosingQuotes, shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote) : config.blockCommentStartToken && selections.open.includes(config.blockCommentStartToken) ? (selection = config.autoClosingComments, shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment) : (selection = config.autoClosingBrackets, shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket);
      if (selection === "never") {
        return null;
      }
      var containedPair = this._findContainedAutoClosingPair(config, selections);
      containedPair = containedPair ? containedPair.close : "";
      let isContainedPairPresent = !0;
      for (const position of positions) {
        const {lineNumber, beforeColumn, afterColumn} = position;
        var lineText = model.getLineContent(lineNumber);
        positions = lineText.substring(0, beforeColumn - 1);
        lineText = lineText.substring(afterColumn - 1);
        lineText.startsWith(containedPair) || (isContainedPairPresent = !1);
        if (lineText.length > 0) {
          const characterAfter = lineText.charAt(0);
          if (!TypeOperations._isBeforeClosingBrace(config, lineText) && !shouldAutoCloseBefore(characterAfter)) {
            return null;
          }
        }
        if (selections.open.length === 1 && (ch === "'" || ch === '"') && selection !== "always" && (lineText = (0,require$_DOT__DOT__SLASH_core_SLASH_wordCharacterClassifier_DOT_js.getMapForWordSeparators)(config.wordSeparators), positions.length > 0 && (positions = positions.charCodeAt(positions.length - 1), lineText.get(positions) === 0)) || !model.tokenization.isCheapToTokenize(lineNumber)) {
          return null;
        }
        model.tokenization.forceTokenization(lineNumber);
        positions = model.tokenization.getLineTokens(lineNumber);
        positions = (0,require$_DOT__DOT__SLASH_languages_SLASH_supports_DOT_js.createScopedLineTokens)(positions, beforeColumn - 1);
        if (!selections.shouldAutoClose(positions, beforeColumn - positions.firstCharOffset)) {
          return null;
        }
        if (positions = selections.findNeutralCharacter()) {
          if (positions = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, positions), !selections.isOK(positions)) {
            return null;
          }
        }
      }
      return isContainedPairPresent ? selections.close.substring(0, selections.close.length - containedPair.length) : selections.close;
    }
    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {
      prevEditOperationType = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        prevEditOperationType[i] = new TypeWithAutoClosingCommand(selections[i], ch, !chIsAlreadyTyped, autoClosingPairClose);
      }
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, prevEditOperationType, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!1});
    }
    static _shouldSurroundChar(config, ch) {
      return (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(ch) ? config.autoSurround === "quotes" || config.autoSurround === "languageDefined" : config.autoSurround === "brackets" || config.autoSurround === "languageDefined";
    }
    static _isSurroundSelectionType(config, model, selections, ch) {
      if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {
        return !1;
      }
      config = (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(ch);
      for (const selection of selections) {
        if (selection.isEmpty()) {
          return !1;
        }
        selections = !0;
        for (ch = selection.startLineNumber; ch <= selection.endLineNumber; ch++) {
          var lineText = model.getLineContent(ch);
          lineText = lineText.substring(ch === selection.startLineNumber ? selection.startColumn - 1 : 0, ch === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);
          if (/[^ \t]/.test(lineText)) {
            selections = !1;
            break;
          }
        }
        if (selections || config && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn && (selections = model.getValueInRange(selection), (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(selections))) {
          return !1;
        }
      }
      return !0;
    }
    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {
      prevEditOperationType = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        prevEditOperationType[i] = new require$_DOT__DOT__SLASH_commands_SLASH_surroundSelectionCommand_DOT_js.SurroundSelectionCommand(selections[i], ch, config.surroundingPairs[ch]);
      }
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(0, prevEditOperationType, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!0});
    }
    static _isTypeInterceptorElectricChar(config, model, selections) {
      return selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber) ? !0 : !1;
    }
    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {
      if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {
        return null;
      }
      selection = selection.getPosition();
      model.tokenization.forceTokenization(selection.lineNumber);
      var lineTokens = model.tokenization.getLineTokens(selection.lineNumber);
      try {
        var electricAction = config.onElectricCharacter(ch, lineTokens, selection.column);
      } catch (e) {
        return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(e), null;
      }
      if (!electricAction) {
        return null;
      }
      if (electricAction.matchOpenBracket && (lineTokens = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1, electricAction = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {lineNumber:selection.lineNumber, column:lineTokens}, 500))) {
        if (electricAction.startLineNumber === selection.lineNumber) {
          return null;
        }
        electricAction = model.getLineContent(electricAction.startLineNumber);
        electricAction = strings.getLeadingWhitespace(electricAction);
        config = config.normalizeIndentation(electricAction);
        electricAction = model.getLineContent(selection.lineNumber);
        model = model.getLineFirstNonWhitespaceColumn(selection.lineNumber) || selection.column;
        model = electricAction.substring(model - 1, selection.column - 1);
        ch = config + model + ch;
        selection = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection.lineNumber, 1, selection.lineNumber, selection.column);
        selection = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selection, ch);
        return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(getTypingOperation(ch, prevEditOperationType), [selection], {shouldPushStackElementBefore:!1, shouldPushStackElementAfter:!0});
      }
      return null;
    }
    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {
      if (!compositions) {
        return null;
      }
      var insertedText = null;
      for (var composition of compositions) {
        if (insertedText === null) {
          insertedText = composition.insertedText;
        } else if (insertedText !== composition.insertedText) {
          return null;
        }
      }
      if (!insertedText || insertedText.length !== 1) {
        return null;
      }
      composition = !1;
      for (const composition$jscomp$0 of compositions) {
        if (composition$jscomp$0.deletedText.length !== 0) {
          composition = !0;
          break;
        }
      }
      if (composition) {
        if (!TypeOperations._shouldSurroundChar(config, insertedText) || !config.surroundingPairs.hasOwnProperty(insertedText)) {
          return null;
        }
        prevEditOperationType = (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(insertedText);
        for (const composition of compositions) {
          if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length || /^[ \t]+$/.test(composition.deletedText) || prevEditOperationType && (0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(composition.deletedText)) {
            return null;
          }
        }
        prevEditOperationType = [];
        for (const selection of selections) {
          if (!selection.isEmpty()) {
            return null;
          }
          prevEditOperationType.push(selection.getPosition());
        }
        if (prevEditOperationType.length !== compositions.length) {
          return null;
        }
        selections = [];
        for (let i = 0, len = prevEditOperationType.length; i < len; i++) {
          selections.push(new require$_DOT__DOT__SLASH_commands_SLASH_surroundSelectionCommand_DOT_js.CompositionSurroundSelectionCommand(prevEditOperationType[i], compositions[i].deletedText, config.surroundingPairs[insertedText]));
        }
        return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, selections, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!1});
      }
      if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, insertedText)) {
        return config = selections.map(s => new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), "", !1)), new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, config, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!1});
      }
      compositions = this._getAutoClosingPairClose(config, model, selections, insertedText, !0);
      return compositions !== null ? this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, insertedText, !0, compositions) : null;
    }
    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {
      if (!isDoingComposition && ch === "\n") {
        prevEditOperationType = [];
        for (let i = 0, len = selections.length; i < len; i++) {
          prevEditOperationType[i] = TypeOperations._enter(config, model, !1, selections[i]);
        }
        return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, prevEditOperationType, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!1});
      }
      if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {
        const commands = [];
        let autoIndentFails = !1;
        for (let i = 0, len = selections.length; i < len; i++) {
          if (commands[i] = this._runAutoIndentType(config, model, selections[i], ch), !commands[i]) {
            autoIndentFails = !0;
            break;
          }
        }
        if (!autoIndentFails) {
          return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(4, commands, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!1});
        }
      }
      if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {
        return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);
      }
      if (!isDoingComposition && (autoClosedCharacters = this._getAutoClosingPairClose(config, model, selections, ch, !1))) {
        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, !1, autoClosedCharacters);
      }
      if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {
        return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);
      }
      if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections) && (config = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch))) {
        return config;
      }
      config = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selections[i], ch);
      }
      selections = getTypingOperation(ch, prevEditOperationType);
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(selections, config, {shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType, selections), shouldPushStackElementAfter:!1});
    }
    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {
      config = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selections[i], str);
      }
      selections = getTypingOperation(str, prevEditOperationType);
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(selections, config, {shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType, selections), shouldPushStackElementAfter:!1});
    }
    static lineInsertBefore(config, model, selections) {
      if (model === null || selections === null) {
        return [];
      }
      const commands = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        let lineNumber = selections[i].positionLineNumber;
        if (lineNumber === 1) {
          commands[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithoutChangingPosition(new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(1, 1, 1, 1), "\n");
        } else {
          lineNumber--;
          const column = model.getLineMaxColumn(lineNumber);
          commands[i] = this._enter(config, model, !1, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, column, lineNumber, column));
        }
      }
      return commands;
    }
    static lineInsertAfter(config, model, selections) {
      if (model === null || selections === null) {
        return [];
      }
      const commands = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        const lineNumber = selections[i].positionLineNumber, column = model.getLineMaxColumn(lineNumber);
        commands[i] = this._enter(config, model, !1, new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lineNumber, column, lineNumber, column));
      }
      return commands;
    }
    static lineBreakInsert(config, model, selections) {
      const commands = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        commands[i] = this._enter(config, model, !0, selections[i]);
      }
      return commands;
    }
  }
  class TypeWithAutoClosingCommand extends require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommandWithOffsetCursorState {
    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {
      super(selection, (insertOpenCharacter ? openCharacter : "") + closeCharacter, 0, -closeCharacter.length);
      this._openCharacter = openCharacter;
      this._closeCharacter = closeCharacter;
      this.enclosingRange = this.closeCharacterRange = null;
    }
    computeCursorState(model, helper) {
      const range = helper.getInverseEditOperations()[0].range;
      this.closeCharacterRange = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);
      this.enclosingRange = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);
      return super.computeCursorState(model, helper);
    }
  }
  class CompositionOutcome {
    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {
      this.deletedText = deletedText;
      this.deletedSelectionStart = deletedSelectionStart;
      this.deletedSelectionEnd = deletedSelectionEnd;
      this.insertedText = insertedText;
      this.insertedSelectionStart = insertedSelectionStart;
      this.insertedSelectionEnd = insertedSelectionEnd;
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorTypeOperations.js.map
