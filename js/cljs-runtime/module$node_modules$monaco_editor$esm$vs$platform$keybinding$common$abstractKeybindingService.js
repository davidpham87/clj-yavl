shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$keybinding$common$abstractKeybindingService = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AbstractKeybindingService:{enumerable:!0, get:function() {
    return AbstractKeybindingService;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$ime");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var nls = require("module$node_modules$monaco_editor$esm$vs$nls"), require$_DOT__SLASH_keybindingResolver_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$keybinding$common$keybindingResolver");
  const HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
  class AbstractKeybindingService extends module.Disposable {
    get onDidUpdateKeybindings() {
      return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Event.None;
    }
    get inChordMode() {
      return this._currentChords.length > 0;
    }
    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {
      super();
      this._contextKeyService = _contextKeyService;
      this._commandService = _commandService;
      this._telemetryService = _telemetryService;
      this._notificationService = _notificationService;
      this._logService = _logService;
      this._onDidUpdateKeybindings = this._register(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_event_DOT_js.Emitter());
      this._currentChords = [];
      this._currentChordChecker = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.IntervalTimer();
      this._currentChordStatusMessage = null;
      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
      this._currentSingleModifier = null;
      this._currentSingleModifierClearTimeout = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_async_DOT_js.TimeoutTimer();
      this._logging = !1;
    }
    dispose() {
      super.dispose();
    }
    _log(str) {
      this._logging && this._logService.info(`[KeybindingService]: ${str}`);
    }
    getKeybindings() {
      return this._getResolver().getKeybindings();
    }
    lookupKeybinding(commandId, context) {
      if (commandId = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService)) {
        return commandId.resolvedKeybinding;
      }
    }
    dispatchEvent(e, target) {
      return this._dispatch(e, target);
    }
    softDispatch(e, target) {
      this._log("/ Soft dispatching keyboard event");
      e = this.resolveKeyboardEvent(e);
      if (e.hasMultipleChords()) {
        return console.warn("keyboard event should not be mapped to multiple chords"), require$_DOT__SLASH_keybindingResolver_DOT_js.NoMatchingKb;
      }
      [e] = e.getDispatchChords();
      if (e === null) {
        return this._log("\\ Keyboard event cannot be dispatched"), require$_DOT__SLASH_keybindingResolver_DOT_js.NoMatchingKb;
      }
      target = this._contextKeyService.getContext(target);
      const currentChords = this._currentChords.map(({keypress}) => keypress);
      return this._getResolver().resolve(target, currentChords, e);
    }
    _scheduleLeaveChordMode() {
      const chordLastInteractedTime = Date.now();
      this._currentChordChecker.cancelAndSet(() => {
        this._documentHasFocus() ? Date.now() - chordLastInteractedTime > 5000 && this._leaveChordMode() : this._leaveChordMode();
      }, 500);
    }
    _expectAnotherChord(firstChord, keypressLabel) {
      this._currentChords.push({keypress:firstChord, label:keypressLabel});
      switch(this._currentChords.length) {
        case 0:
          throw (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.illegalState)("impossible");
        case 1:
          this._currentChordStatusMessage = this._notificationService.status(nls.localize("first.chord", "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
          break;
        default:
          firstChord = this._currentChords.map(({label}) => label).join(", "), this._currentChordStatusMessage = this._notificationService.status(nls.localize("next.chord", "({0}) was pressed. Waiting for next key of chord...", firstChord));
      }
      this._scheduleLeaveChordMode();
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js.IME.enabled && require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js.IME.disable();
    }
    _leaveChordMode() {
      this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null);
      this._currentChordChecker.cancel();
      this._currentChords = [];
      require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_ime_DOT_js.IME.enable();
    }
    _dispatch(e, target) {
      return this._doDispatch(this.resolveKeyboardEvent(e), target, !1);
    }
    _singleModifierDispatch(e, target) {
      e = this.resolveKeyboardEvent(e);
      const [singleModifier] = e.getSingleModifierDispatchChords();
      if (singleModifier) {
        if (this._ignoreSingleModifiers.has(singleModifier)) {
          return this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
        }
        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
        if (this._currentSingleModifier === null) {
          return this._log(`+ Storing single modifier for possible chord ${singleModifier}.`), this._currentSingleModifier = singleModifier, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
            this._log("+ Clearing single modifier due to 300ms elapsed.");
            this._currentSingleModifier = null;
          }, 300), !1;
        }
        if (singleModifier === this._currentSingleModifier) {
          return this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(e, target, !0);
        }
        this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);
        this._currentSingleModifierClearTimeout.cancel();
        this._currentSingleModifier = null;
        return !1;
      }
      [target] = e.getChords();
      this._ignoreSingleModifiers = new KeybindingModifierSet(target);
      this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up.");
      this._currentSingleModifierClearTimeout.cancel();
      this._currentSingleModifier = null;
      return !1;
    }
    _doDispatch(userKeypress, target, isSingleModiferChord = !1) {
      var _a;
      let shouldPreventDefault = !1;
      if (userKeypress.hasMultipleChords()) {
        return console.warn("Unexpected keyboard event mapped to multiple chords"), !1;
      }
      let userPressedChord = null;
      var currentChords = null;
      isSingleModiferChord ? ([currentChords] = userKeypress.getSingleModifierDispatchChords(), currentChords = (userPressedChord = currentChords) ? [currentChords] : []) : ([userPressedChord] = userKeypress.getDispatchChords(), currentChords = this._currentChords.map(({keypress}) => keypress));
      if (userPressedChord === null) {
        return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), shouldPreventDefault;
      }
      isSingleModiferChord = this._contextKeyService.getContext(target);
      target = userKeypress.getLabel();
      currentChords = this._getResolver().resolve(isSingleModiferChord, currentChords, userPressedChord);
      switch(currentChords.kind) {
        case 0:
          return this._logService.trace("KeybindingService#dispatch", target, "[ No matching keybinding ]"), this.inChordMode && (userKeypress = this._currentChords.map(({label}) => label).join(", "), this._log(`+ Leaving multi-chord mode: Nothing bound to "${userKeypress}, ${target}".`), this._notificationService.status(nls.localize("missing.chord", "The key combination ({0}, {1}) is not a command.", userKeypress, target), {hideAfter:1E4}), this._leaveChordMode(), shouldPreventDefault = !0), shouldPreventDefault;
        case 1:
          return this._logService.trace("KeybindingService#dispatch", target, "[ Several keybindings match - more chords needed ]"), shouldPreventDefault = !0, this._expectAnotherChord(userPressedChord, target), this._log(this._currentChords.length === 1 ? "+ Entering multi-chord mode..." : "+ Continuing multi-chord mode..."), shouldPreventDefault;
        case 2:
          return this._logService.trace("KeybindingService#dispatch", target, `[ Will dispatch command ${currentChords.commandId} ]`), currentChords.commandId === null || currentChords.commandId === "" ? this.inChordMode && (userKeypress = this._currentChords.map(({label}) => label).join(", "), this._log(`+ Leaving chord mode: Nothing bound to "${userKeypress}, ${target}".`), this._notificationService.status(nls.localize("missing.chord", "The key combination ({0}, {1}) is not a command.", userKeypress, 
          target), {hideAfter:1E4}), this._leaveChordMode(), shouldPreventDefault = !0) : (this.inChordMode && this._leaveChordMode(), currentChords.isBubble || (shouldPreventDefault = !0), this._log(`+ Invoking command ${currentChords.commandId}.`), typeof currentChords.commandArgs === "undefined" ? this._commandService.executeCommand(currentChords.commandId).then(void 0, err => this._notificationService.warn(err)) : this._commandService.executeCommand(currentChords.commandId, currentChords.commandArgs).then(void 0, 
          err => this._notificationService.warn(err)), HIGH_FREQ_COMMANDS.test(currentChords.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", {id:currentChords.commandId, from:"keybinding", detail:(_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : void 0})), shouldPreventDefault;
      }
    }
    mightProducePrintableCharacter(event) {
      return event.ctrlKey || event.metaKey ? !1 : event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30 ? !0 : !1;
    }
  }
  class KeybindingModifierSet {
    constructor(source) {
      this._ctrlKey = source ? source.ctrlKey : !1;
      this._shiftKey = source ? source.shiftKey : !1;
      this._altKey = source ? source.altKey : !1;
      this._metaKey = source ? source.metaKey : !1;
    }
    has(modifier) {
      switch(modifier) {
        case "ctrl":
          return this._ctrlKey;
        case "shift":
          return this._shiftKey;
        case "alt":
          return this._altKey;
        case "meta":
          return this._metaKey;
      }
    }
  }
  KeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$keybinding$common$abstractKeybindingService.js.map
