shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$parser = function(require, module, exports) {
  function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {
    return (new Parser(tokenizer, edits, oldNode, createImmutableLists)).parseDocument();
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, parseDocument:{enumerable:!0, get:function() {
    return parseDocument;
  }}});
  var require$_DOT__SLASH_ast_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$ast"), require$_DOT__SLASH_beforeEditPositionMapper_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$beforeEditPositionMapper"), require$_DOT__SLASH_smallImmutableSet_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$smallImmutableSet"), 
  require$_DOT__SLASH_length_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$length"), require$_DOT__SLASH_concat23Trees_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$concat23Trees"), require$_DOT__SLASH_nodeReader_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$nodeReader");
  class Parser {
    constructor(tokenizer, edits, oldNode, createImmutableLists) {
      this.tokenizer = tokenizer;
      this.createImmutableLists = createImmutableLists;
      this._itemsFromCache = this._itemsConstructed = 0;
      if (oldNode && createImmutableLists) {
        throw Error("Not supported");
      }
      this.oldNodeReader = oldNode ? new require$_DOT__SLASH_nodeReader_DOT_js.NodeReader(oldNode) : void 0;
      this.positionMapper = new require$_DOT__SLASH_beforeEditPositionMapper_DOT_js.BeforeEditPositionMapper(edits);
    }
    parseDocument() {
      this._itemsFromCache = this._itemsConstructed = 0;
      let result = this.parseList(require$_DOT__SLASH_smallImmutableSet_DOT_js.SmallImmutableSet.getEmpty(), 0);
      result ||= require$_DOT__SLASH_ast_DOT_js.ListAstNode.getEmpty();
      return result;
    }
    parseList(openedBracketIds, level) {
      const items = [];
      for (;;) {
        var child = this.tryReadChildFromCache(openedBracketIds);
        if (!child) {
          child = this.tokenizer.peek();
          if (!child || child.kind === 2 && child.bracketIds.intersects(openedBracketIds)) {
            break;
          }
          child = this.parseChild(openedBracketIds, level + 1);
        }
        child.kind === 4 && child.childrenLength === 0 || items.push(child);
      }
      return this.oldNodeReader ? (0,require$_DOT__SLASH_concat23Trees_DOT_js.concat23Trees)(items) : (0,require$_DOT__SLASH_concat23Trees_DOT_js.concat23TreesOfSameHeight)(items, this.createImmutableLists);
    }
    tryReadChildFromCache(openedBracketIds) {
      if (this.oldNodeReader) {
        const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
        if (maxCacheableLength === null || !(0,require$_DOT__SLASH_length_DOT_js.lengthIsZero)(maxCacheableLength)) {
          const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => maxCacheableLength === null || (0,require$_DOT__SLASH_length_DOT_js.lengthLessThan)(curNode.length, maxCacheableLength) ? curNode.canBeReused(openedBracketIds) : !1);
          if (cachedNode) {
            return this._itemsFromCache++, this.tokenizer.skip(cachedNode.length), cachedNode;
          }
        }
      }
    }
    parseChild(openedBracketIds, level) {
      this._itemsConstructed++;
      const token = this.tokenizer.read();
      switch(token.kind) {
        case 2:
          return new require$_DOT__SLASH_ast_DOT_js.InvalidBracketAstNode(token.bracketIds, token.length);
        case 0:
          return token.astNode;
        case 1:
          if (level > 300) {
            return new require$_DOT__SLASH_ast_DOT_js.TextAstNode(token.length);
          }
          openedBracketIds = openedBracketIds.merge(token.bracketIds);
          level = this.parseList(openedBracketIds, level + 1);
          return (openedBracketIds = this.tokenizer.peek()) && openedBracketIds.kind === 2 && (openedBracketIds.bracketId === token.bracketId || openedBracketIds.bracketIds.intersects(token.bracketIds)) ? (this.tokenizer.read(), require$_DOT__SLASH_ast_DOT_js.PairAstNode.create(token.astNode, level, openedBracketIds.astNode)) : require$_DOT__SLASH_ast_DOT_js.PairAstNode.create(token.astNode, level, null);
        default:
          throw Error("unexpected");
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$bracketPairsTextModelPart$bracketPairsTree$parser.js.map
