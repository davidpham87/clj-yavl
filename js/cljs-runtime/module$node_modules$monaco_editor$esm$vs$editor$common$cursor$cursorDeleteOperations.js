shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorDeleteOperations = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DeleteOperations:{enumerable:!0, get:function() {
    return DeleteOperations;
  }}});
  var strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings"), require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$commands$replaceCommand"), require$_DOT__DOT__SLASH_cursorCommon_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursorCommon"), require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$cursorColumns"), 
  require$_DOT__SLASH_cursorMoveOperations_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorMoveOperations"), require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$range"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position");
  class DeleteOperations {
    static deleteRight(prevEditOperationType, config, model, selections) {
      const commands = [];
      prevEditOperationType = prevEditOperationType !== 3;
      for (let i = 0, len = selections.length; i < len; i++) {
        var selection = selections[i], deleteSelection = selection;
        deleteSelection.isEmpty() && (selection = selection.getPosition(), deleteSelection = require$_DOT__SLASH_cursorMoveOperations_DOT_js.MoveOperations.right(config, model, selection), deleteSelection = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(deleteSelection.lineNumber, deleteSelection.column, selection.lineNumber, selection.column));
        deleteSelection.isEmpty() ? commands[i] = null : (deleteSelection.startLineNumber !== deleteSelection.endLineNumber && (prevEditOperationType = !0), commands[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(deleteSelection, ""));
      }
      return [prevEditOperationType, commands];
    }
    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {
      if (autoClosingBrackets === "never" && autoClosingQuotes === "never" || autoClosingDelete === "never") {
        return !1;
      }
      for (let i = 0, len = selections.length; i < len; i++) {
        var selection = selections[i];
        const position = selection.getPosition();
        if (!selection.isEmpty()) {
          return !1;
        }
        var lineText = model.getLineContent(position.lineNumber);
        if (position.column < 2 || position.column >= lineText.length + 1) {
          return !1;
        }
        selection = lineText.charAt(position.column - 2);
        var autoClosingPairCandidates = autoClosingPairsOpen.get(selection);
        if (!autoClosingPairCandidates) {
          return !1;
        }
        if ((0,require$_DOT__DOT__SLASH_cursorCommon_DOT_js.isQuote)(selection)) {
          if (autoClosingQuotes === "never") {
            return !1;
          }
        } else {
          if (autoClosingBrackets === "never") {
            return !1;
          }
        }
        lineText = lineText.charAt(position.column - 1);
        let foundAutoClosingPair = !1;
        for (const autoClosingPairCandidate of autoClosingPairCandidates) {
          autoClosingPairCandidate.open === selection && autoClosingPairCandidate.close === lineText && (foundAutoClosingPair = !0);
        }
        if (!foundAutoClosingPair) {
          return !1;
        }
        if (autoClosingDelete === "auto") {
          selection = !1;
          for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {
            if (autoClosingPairCandidates = autoClosedCharacters[j], position.lineNumber === autoClosingPairCandidates.startLineNumber && position.column === autoClosingPairCandidates.startColumn) {
              selection = !0;
              break;
            }
          }
          if (!selection) {
            return !1;
          }
        }
      }
      return !0;
    }
    static _runAutoClosingPairDelete(config, model, selections) {
      config = [];
      for (let i = 0, len = selections.length; i < len; i++) {
        model = selections[i].getPosition(), model = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(model.lineNumber, model.column - 1, model.lineNumber, model.column + 1), config[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(model, "");
      }
      return [!0, config];
    }
    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {
      if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {
        return this._runAutoClosingPairDelete(config, model, selections);
      }
      autoClosedCharacters = [];
      prevEditOperationType = prevEditOperationType !== 2;
      for (let i = 0, len = selections.length; i < len; i++) {
        const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);
        deleteRange.isEmpty() ? autoClosedCharacters[i] = null : (deleteRange.startLineNumber !== deleteRange.endLineNumber && (prevEditOperationType = !0), autoClosedCharacters[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(deleteRange, ""));
      }
      return [prevEditOperationType, autoClosedCharacters];
    }
    static getDeleteRange(selection, model, config) {
      if (!selection.isEmpty()) {
        return selection;
      }
      selection = selection.getPosition();
      if (config.useTabStops && selection.column > 1) {
        var lineContent = model.getLineContent(selection.lineNumber);
        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
        if (selection.column <= (firstNonWhitespaceIndex === -1 ? lineContent.length + 1 : firstNonWhitespaceIndex + 1)) {
          return lineContent = config.visibleColumnFromColumn(model, selection), lineContent = require$_DOT__DOT__SLASH_core_SLASH_cursorColumns_DOT_js.CursorColumns.prevIndentTabStop(lineContent, config.indentSize), model = config.columnFromVisibleColumn(model, selection.lineNumber, lineContent), new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(selection.lineNumber, model, selection.lineNumber, selection.column);
        }
      }
      return require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(selection, model), selection);
    }
    static getPositionAfterDeleteLeft(position, model) {
      return position.column > 1 ? (model = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber)), position.with(void 0, model + 1)) : position.lineNumber > 1 ? (position = position.lineNumber - 1, new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(position, model.getLineMaxColumn(position))) : position;
    }
    static cut(config, model, selections) {
      const commands = [];
      var lastCutRange = null;
      selections.sort((a, b) => require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position.compare(a.getStartPosition(), b.getEndPosition()));
      for (let i = 0, len = selections.length; i < len; i++) {
        var selection = selections[i];
        if (selection.isEmpty()) {
          if (config.emptySelectionClipboard) {
            selection = selection.getPosition();
            let startColumn, endLineNumber;
            selection.lineNumber < model.getLineCount() ? (lastCutRange = selection.lineNumber, startColumn = 1, endLineNumber = selection.lineNumber + 1, selection = 1) : (selection.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== selection.lineNumber ? (lastCutRange = selection.lineNumber - 1, startColumn = model.getLineMaxColumn(selection.lineNumber - 1)) : (lastCutRange = selection.lineNumber, startColumn = 1), endLineNumber = selection.lineNumber, 
            selection = model.getLineMaxColumn(selection.lineNumber));
            lastCutRange = selection = new require$_DOT__DOT__SLASH_core_SLASH_range_DOT_js.Range(lastCutRange, startColumn, endLineNumber, selection);
            selection.isEmpty() ? commands[i] = null : commands[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selection, "");
          } else {
            commands[i] = null;
          }
        } else {
          commands[i] = new require$_DOT__DOT__SLASH_commands_SLASH_replaceCommand_DOT_js.ReplaceCommand(selection, "");
        }
      }
      return new require$_DOT__DOT__SLASH_cursorCommon_DOT_js.EditOperationResult(0, commands, {shouldPushStackElementBefore:!0, shouldPushStackElementAfter:!0});
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$cursor$cursorDeleteOperations.js.map
