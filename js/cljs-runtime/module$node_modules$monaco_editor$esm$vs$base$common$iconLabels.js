shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$iconLabels = function(require, module, exports) {
  function escapeIcons(text) {
    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\${match}`);
  }
  function markdownEscapeEscapedIcons(text) {
    return text.replace(markdownEscapedIconsRegex, match => `\\${match}`);
  }
  function stripIcons(text) {
    return text.indexOf("$(") === -1 ? text : text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || "");
  }
  function getCodiconAriaLabel(text) {
    return text ? text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim() : "";
  }
  function parseLabelWithIcons(input) {
    _parseIconsRegex.lastIndex = 0;
    let text = "";
    const iconOffsets = [];
    let iconsOffset = 0;
    for (;;) {
      var pos = _parseIconsRegex.lastIndex;
      const match = _parseIconsRegex.exec(input);
      pos = input.substring(pos, match === null || match === void 0 ? void 0 : match.index);
      if (pos.length > 0) {
        text += pos;
        for (let i = 0; i < pos.length; i++) {
          iconOffsets.push(iconsOffset);
        }
      }
      if (!match) {
        break;
      }
      iconsOffset += match[0].length;
    }
    return {text, iconOffsets};
  }
  function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = !1) {
    const {text, iconOffsets} = target;
    if (!iconOffsets || iconOffsets.length === 0) {
      return (0,require$_DOT__SLASH_filters_DOT_js.matchesFuzzy)(query, text, enableSeparateSubstringMatching);
    }
    const wordToMatchAgainstWithoutIconsTrimmed = (0,require$_DOT__SLASH_strings_DOT_js.ltrim)(text, " ");
    target = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
    if (query = (0,require$_DOT__SLASH_filters_DOT_js.matchesFuzzy)(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching)) {
      for (const match of query) {
        enableSeparateSubstringMatching = iconOffsets[match.start + target] + target, match.start += enableSeparateSubstringMatching, match.end += enableSeparateSubstringMatching;
      }
    }
    return query;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, escapeIcons:{enumerable:!0, get:function() {
    return escapeIcons;
  }}, getCodiconAriaLabel:{enumerable:!0, get:function() {
    return getCodiconAriaLabel;
  }}, markdownEscapeEscapedIcons:{enumerable:!0, get:function() {
    return markdownEscapeEscapedIcons;
  }}, matchesFuzzyIconAware:{enumerable:!0, get:function() {
    return matchesFuzzyIconAware;
  }}, parseLabelWithIcons:{enumerable:!0, get:function() {
    return parseLabelWithIcons;
  }}, stripIcons:{enumerable:!0, get:function() {
    return stripIcons;
  }}});
  var require$_DOT__SLASH_filters_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$filters"), require$_DOT__SLASH_strings_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  require = require("module$node_modules$monaco_editor$esm$vs$base$common$themables");
  module = new RegExp(`\\$\\(${require.ThemeIcon.iconNameExpression}(?:${require.ThemeIcon.iconModifierExpression})?\\)`, "g");
  const escapeIconsRegex = new RegExp(`(\\\\)?${module.source}`, "g"), markdownEscapedIconsRegex = new RegExp(`\\\\${module.source}`, "g"), stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${module.source}(\\s)?`, "g"), _parseIconsRegex = new RegExp(`\\$\\(${require.ThemeIcon.iconNameCharacter}+\\)`, "g");
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$iconLabels.js.map
