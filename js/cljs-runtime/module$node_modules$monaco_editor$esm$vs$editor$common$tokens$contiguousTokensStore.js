shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousTokensStore = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ContiguousTokensStore:{enumerable:!0, get:function() {
    return ContiguousTokensStore;
  }}});
  var arrays = require("module$node_modules$monaco_editor$esm$vs$base$common$arrays"), require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$core$position"), require$_DOT__SLASH_contiguousTokensEditing_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousTokensEditing"), require$_DOT__SLASH_lineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$lineTokens"), require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$editor$common$encodedTokenAttributes");
  class ContiguousTokensStore {
    constructor(languageIdCodec) {
      this._lineTokens = [];
      this._len = 0;
      this._languageIdCodec = languageIdCodec;
    }
    flush() {
      this._lineTokens = [];
      this._len = 0;
    }
    get hasTokens() {
      return this._lineTokens.length > 0;
    }
    getTokens(topLevelLanguageId, lineIndex, lineText) {
      let rawLineTokens = null;
      lineIndex < this._len && (rawLineTokens = this._lineTokens[lineIndex]);
      if (rawLineTokens !== null && rawLineTokens !== require$_DOT__SLASH_contiguousTokensEditing_DOT_js.EMPTY_LINE_TOKENS) {
        return new require$_DOT__SLASH_lineTokens_DOT_js.LineTokens((0,require$_DOT__SLASH_contiguousTokensEditing_DOT_js.toUint32Array)(rawLineTokens), lineText, this._languageIdCodec);
      }
      lineIndex = new Uint32Array(2);
      lineIndex[0] = lineText.length;
      topLevelLanguageId = (this._languageIdCodec.encodeLanguageId(topLevelLanguageId) << 0 | 33588224) >>> 0;
      lineIndex[1] = topLevelLanguageId;
      return new require$_DOT__SLASH_lineTokens_DOT_js.LineTokens(lineIndex, lineText, this._languageIdCodec);
    }
    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {
      _tokens = _tokens ? (0,require$_DOT__SLASH_contiguousTokensEditing_DOT_js.toUint32Array)(_tokens) : null;
      if (lineTextLength === 0) {
        let hasDifferentLanguageId = !1;
        _tokens && _tokens.length > 1 && (hasDifferentLanguageId = require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getLanguageId(_tokens[1]) !== topLevelLanguageId);
        if (!hasDifferentLanguageId) {
          return require$_DOT__SLASH_contiguousTokensEditing_DOT_js.EMPTY_LINE_TOKENS;
        }
      }
      if (!_tokens || _tokens.length === 0) {
        return _tokens = new Uint32Array(2), _tokens[0] = lineTextLength, _tokens[1] = (topLevelLanguageId << 0 | 33588224) >>> 0, _tokens.buffer;
      }
      _tokens[_tokens.length - 2] = lineTextLength;
      return _tokens.byteOffset === 0 && _tokens.byteLength === _tokens.buffer.byteLength ? _tokens.buffer : _tokens;
    }
    _ensureLine(lineIndex) {
      for (; lineIndex >= this._len;) {
        this._lineTokens[this._len] = null, this._len++;
      }
    }
    _deleteLines(start, deleteCount) {
      deleteCount !== 0 && (start + deleteCount > this._len && (deleteCount = this._len - start), this._lineTokens.splice(start, deleteCount), this._len -= deleteCount);
    }
    _insertLines(insertIndex, insertCount) {
      if (insertCount !== 0) {
        var lineTokens = [];
        for (let i = 0; i < insertCount; i++) {
          lineTokens[i] = null;
        }
        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);
        this._len += insertCount;
      }
    }
    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {
      topLevelLanguageId = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);
      this._ensureLine(lineIndex);
      lineTextLength = this._lineTokens[lineIndex];
      this._lineTokens[lineIndex] = topLevelLanguageId;
      return checkEquality ? !ContiguousTokensStore._equals(lineTextLength, topLevelLanguageId) : !1;
    }
    static _equals(_a, _b) {
      if (!_a || !_b) {
        return !_a && !_b;
      }
      _a = (0,require$_DOT__SLASH_contiguousTokensEditing_DOT_js.toUint32Array)(_a);
      _b = (0,require$_DOT__SLASH_contiguousTokensEditing_DOT_js.toUint32Array)(_b);
      if (_a.length !== _b.length) {
        return !1;
      }
      for (let i = 0, len = _a.length; i < len; i++) {
        if (_a[i] !== _b[i]) {
          return !1;
        }
      }
      return !0;
    }
    acceptEdit(range, eolCount, firstLineLength) {
      this._acceptDeleteRange(range);
      this._acceptInsertText(new require$_DOT__DOT__SLASH_core_SLASH_position_DOT_js.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);
    }
    _acceptDeleteRange(range) {
      const firstLineIndex = range.startLineNumber - 1;
      if (!(firstLineIndex >= this._len)) {
        if (range.startLineNumber === range.endLineNumber) {
          range.startColumn !== range.endColumn && (this._lineTokens[firstLineIndex] = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1));
        } else {
          this._lineTokens[firstLineIndex] = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);
          var lastLineIndex = range.endLineNumber - 1, lastLineTokens = null;
          lastLineIndex < this._len && (lastLineTokens = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1));
          this._lineTokens[firstLineIndex] = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);
          this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        }
      }
    }
    _acceptInsertText(position, eolCount, firstLineLength) {
      if (eolCount !== 0 || firstLineLength !== 0) {
        var lineIndex = position.lineNumber - 1;
        lineIndex >= this._len || (eolCount === 0 ? this._lineTokens[lineIndex] = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength) : (this._lineTokens[lineIndex] = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1), this._lineTokens[lineIndex] = require$_DOT__SLASH_contiguousTokensEditing_DOT_js.ContiguousTokensEditing.insert(this._lineTokens[lineIndex], 
        position.column - 1, firstLineLength), this._insertLines(position.lineNumber, eolCount)));
      }
    }
    setMultilineTokens(tokens, textModel) {
      if (tokens.length === 0) {
        return {changes:[]};
      }
      const ranges = [];
      for (let i = 0, len = tokens.length; i < len; i++) {
        const element = tokens[i];
        let minChangedLineNumber = 0, maxChangedLineNumber = 0, hasChange = !1;
        for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {
          hasChange ? (this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), !1), maxChangedLineNumber = lineNumber) : this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), !0) && (hasChange = !0, maxChangedLineNumber = minChangedLineNumber = lineNumber);
        }
        hasChange && ranges.push({fromLineNumber:minChangedLineNumber, toLineNumber:maxChangedLineNumber});
      }
      return {changes:ranges};
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$tokens$contiguousTokensStore.js.map
