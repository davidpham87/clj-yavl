shadow$provide.module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$asyncDataTree = function(require, module, exports) {
  function createAsyncDataTreeNode(props) {
    return {...props, children:[], refreshPromise:void 0, stale:!0, slow:!1, forceExpanded:!1};
  }
  function isAncestor(ancestor, descendant) {
    return descendant.parent ? descendant.parent === ancestor ? !0 : isAncestor(ancestor, descendant.parent) : !1;
  }
  function intersects(node, other) {
    return node === other || isAncestor(node, other) || isAncestor(other, node);
  }
  function asTreeEvent(e) {
    return {browserEvent:e.browserEvent, elements:e.elements.map(e => e.element)};
  }
  function asTreeMouseEvent(e) {
    return {browserEvent:e.browserEvent, element:e.element && e.element.element, target:e.target};
  }
  function asAsyncDataTreeDragAndDropData(data) {
    return data instanceof require$_DOT__DOT__SLASH_list_SLASH_listView_DOT_js.ElementsDragAndDropData ? new AsyncDataTreeElementsDragAndDropData(data) : data;
  }
  function asObjectTreeOptions(options) {
    return options && {...options, collapseByDefault:!0, identityProvider:options.identityProvider && {getId(el) {
      return options.identityProvider.getId(el.element);
    }}, dnd:options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController:options.multipleSelectionController && {isSelectionSingleChangeEvent(e) {
      return options.multipleSelectionController.isSelectionSingleChangeEvent({...e, element:e.element});
    }, isSelectionRangeChangeEvent(e) {
      return options.multipleSelectionController.isSelectionRangeChangeEvent({...e, element:e.element});
    }}, accessibilityProvider:options.accessibilityProvider && {...options.accessibilityProvider, getPosInSet:void 0, getSetSize:void 0, getRole:options.accessibilityProvider.getRole ? el => options.accessibilityProvider.getRole(el.element) : () => "treeitem", isChecked:options.accessibilityProvider.isChecked ? e => {
      var _a;
      return !((_a = options.accessibilityProvider) === null || _a === void 0 || !_a.isChecked(e.element));
    } : void 0, getAriaLabel(e) {
      return options.accessibilityProvider.getAriaLabel(e.element);
    }, getWidgetAriaLabel() {
      return options.accessibilityProvider.getWidgetAriaLabel();
    }, getWidgetRole:options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => "tree", getAriaLevel:options.accessibilityProvider.getAriaLevel && (node => options.accessibilityProvider.getAriaLevel(node.element)), getActiveDescendantId:options.accessibilityProvider.getActiveDescendantId && (node => options.accessibilityProvider.getActiveDescendantId(node.element))}, filter:options.filter && {filter(e, parentVisibility) {
      return options.filter.filter(e.element, parentVisibility);
    }}, keyboardNavigationLabelProvider:options.keyboardNavigationLabelProvider && {...options.keyboardNavigationLabelProvider, getKeyboardNavigationLabel(e) {
      return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
    }}, sorter:void 0, expandOnlyOnTwistieClick:typeof options.expandOnlyOnTwistieClick === "undefined" ? void 0 : typeof options.expandOnlyOnTwistieClick !== "function" ? options.expandOnlyOnTwistieClick : e => options.expandOnlyOnTwistieClick(e.element), defaultFindVisibility:e => e.hasChildren && e.stale ? 1 : typeof options.defaultFindVisibility === "number" ? options.defaultFindVisibility : typeof options.defaultFindVisibility === "undefined" ? 2 : options.defaultFindVisibility(e.element)};
  }
  function dfs(node, fn) {
    fn(node);
    node.children.forEach(child => dfs(child, fn));
  }
  function asCompressibleObjectTreeOptions(options) {
    const objectTreeOptions = options && asObjectTreeOptions(options);
    return objectTreeOptions && {...objectTreeOptions, keyboardNavigationLabelProvider:objectTreeOptions.keyboardNavigationLabelProvider && {...objectTreeOptions.keyboardNavigationLabelProvider, getCompressedNodeKeyboardNavigationLabel(els) {
      return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));
    }}};
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AsyncDataTree:{enumerable:!0, get:function() {
    return AsyncDataTree;
  }}, CompressibleAsyncDataTree:{enumerable:!0, get:function() {
    return CompressibleAsyncDataTree;
  }}});
  var require$_DOT__DOT__SLASH_list_SLASH_listView_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$list$listView"), require$_DOT__SLASH_abstractTree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$abstractTree"), require$_DOT__SLASH_indexTreeModel_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$indexTreeModel"), require$_DOT__SLASH_objectTree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$objectTree"), 
  require$_DOT__SLASH_tree_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$tree"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$async"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$codicons"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js = 
  require("module$node_modules$monaco_editor$esm$vs$base$common$themables"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$iterator"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$types");
  class AsyncDataTreeNodeWrapper {
    get element() {
      return this.node.element.element;
    }
    get children() {
      return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node));
    }
    get depth() {
      return this.node.depth;
    }
    get visibleChildrenCount() {
      return this.node.visibleChildrenCount;
    }
    get visibleChildIndex() {
      return this.node.visibleChildIndex;
    }
    get collapsible() {
      return this.node.collapsible;
    }
    get collapsed() {
      return this.node.collapsed;
    }
    get visible() {
      return this.node.visible;
    }
    get filterData() {
      return this.node.filterData;
    }
    constructor(node) {
      this.node = node;
    }
  }
  class AsyncDataTreeRenderer {
    constructor(renderer, nodeMapper, onDidChangeTwistieState) {
      this.renderer = renderer;
      this.nodeMapper = nodeMapper;
      this.onDidChangeTwistieState = onDidChangeTwistieState;
      this.renderedNodes = new Map();
      this.templateId = renderer.templateId;
    }
    renderTemplate(container) {
      return {templateData:this.renderer.renderTemplate(container)};
    }
    renderElement(node, index, templateData, height) {
      this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
    }
    renderTwistie(element, twistieElement) {
      if (element.slow) {
        return twistieElement.classList.add(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js.ThemeIcon.asClassNameArray(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.treeItemLoading)), !0;
      }
      twistieElement.classList.remove(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js.ThemeIcon.asClassNameArray(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.treeItemLoading));
      return !1;
    }
    disposeElement(node, index, templateData, height) {
      var _a, _b;
      (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 || _b.call(_a, this.nodeMapper.map(node), index, templateData.templateData, height);
    }
    disposeTemplate(templateData) {
      this.renderer.disposeTemplate(templateData.templateData);
    }
    dispose() {
      this.renderedNodes.clear();
    }
  }
  class AsyncDataTreeElementsDragAndDropData extends require$_DOT__DOT__SLASH_list_SLASH_listView_DOT_js.ElementsDragAndDropData {
    constructor(data) {
      super(data.elements.map(node => node.element));
      this.data = data;
    }
  }
  class AsyncDataTreeNodeListDragAndDrop {
    constructor(dnd) {
      this.dnd = dnd;
    }
    getDragURI(node) {
      return this.dnd.getDragURI(node.element);
    }
    getDragLabel(nodes, originalEvent) {
      if (this.dnd.getDragLabel) {
        return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);
      }
    }
    onDragStart(data, originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragStart) === null || _b === void 0 || _b.call(_a, asAsyncDataTreeDragAndDropData(data), originalEvent);
    }
    onDragOver(data, targetNode, targetIndex, originalEvent, raw) {
      return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
    }
    drop(data, targetNode, targetIndex, originalEvent) {
      this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
    }
    onDragEnd(originalEvent) {
      var _a, _b;
      (_b = (_a = this.dnd).onDragEnd) === null || _b === void 0 || _b.call(_a, originalEvent);
    }
    dispose() {
      this.dnd.dispose();
    }
  }
  class AsyncDataTree {
    get onDidScroll() {
      return this.tree.onDidScroll;
    }
    get onDidChangeFocus() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.tree.onDidChangeFocus, asTreeEvent);
    }
    get onDidChangeSelection() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.tree.onDidChangeSelection, asTreeEvent);
    }
    get onMouseDblClick() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.tree.onMouseDblClick, asTreeMouseEvent);
    }
    get onPointer() {
      return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.map(this.tree.onPointer, asTreeMouseEvent);
    }
    get onDidFocus() {
      return this.tree.onDidFocus;
    }
    get onDidChangeModel() {
      return this.tree.onDidChangeModel;
    }
    get onDidChangeCollapseState() {
      return this.tree.onDidChangeCollapseState;
    }
    get onDidChangeFindOpenState() {
      return this.tree.onDidChangeFindOpenState;
    }
    get onDidDispose() {
      return this.tree.onDidDispose;
    }
    constructor(user, container, delegate, renderers, dataSource, options = {}) {
      this.user = user;
      this.dataSource = dataSource;
      this.nodes = new Map();
      this.subTreeRefreshPromises = new Map();
      this.refreshPromises = new Map();
      this._onDidRender = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this._onDidChangeNodeSlowState = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Emitter();
      this.nodeMapper = new require$_DOT__SLASH_tree_DOT_js.WeakMapper(node => new AsyncDataTreeNodeWrapper(node));
      this.disposables = new require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.DisposableStore();
      this.identityProvider = options.identityProvider;
      this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === "undefined" ? !1 : options.autoExpandSingleChildren;
      this.sorter = options.sorter;
      this.getDefaultCollapseState = e => options.collapseByDefault ? options.collapseByDefault(e) ? require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrCollapsed : require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrExpanded : void 0;
      this.tree = this.createTree(user, container, delegate, renderers, options);
      this.onDidChangeFindMode = this.tree.onDidChangeFindMode;
      this.root = createAsyncDataTreeNode({element:void 0, parent:null, hasChildren:!0, defaultCollapseState:void 0});
      this.identityProvider && (this.root = {...this.root, id:null});
      this.nodes.set(null, this.root);
      this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
    }
    createTree(user, container, delegate, renderers, options) {
      delegate = new require$_DOT__SLASH_abstractTree_DOT_js.ComposedTreeDelegate(delegate);
      renderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));
      options = asObjectTreeOptions(options) || {};
      return new require$_DOT__SLASH_objectTree_DOT_js.ObjectTree(user, container, delegate, renderers, options);
    }
    updateOptions(options = {}) {
      this.tree.updateOptions(options);
    }
    getHTMLElement() {
      return this.tree.getHTMLElement();
    }
    get scrollTop() {
      return this.tree.scrollTop;
    }
    set scrollTop(scrollTop) {
      this.tree.scrollTop = scrollTop;
    }
    get scrollHeight() {
      return this.tree.scrollHeight;
    }
    get renderHeight() {
      return this.tree.renderHeight;
    }
    domFocus() {
      this.tree.domFocus();
    }
    layout(height, width) {
      this.tree.layout(height, width);
    }
    style(styles) {
      this.tree.style(styles);
    }
    getInput() {
      return this.root.element;
    }
    async setInput(input, viewState) {
      this.refreshPromises.forEach(promise => promise.cancel());
      this.refreshPromises.clear();
      this.root.element = input;
      const viewStateContext = viewState && {viewState, focus:[], selection:[]};
      await this._updateChildren(input, !0, !1, viewStateContext);
      viewStateContext && (this.tree.setFocus(viewStateContext.focus), this.tree.setSelection(viewStateContext.selection));
      viewState && typeof viewState.scrollTop === "number" && (this.scrollTop = viewState.scrollTop);
    }
    async _updateChildren(element = this.root.element, recursive = !0, rerender = !1, viewStateContext, options) {
      if (typeof this.root.element === "undefined") {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Tree input not set");
      }
      this.root.refreshPromise && (await this.root.refreshPromise, await require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.toPromise(this._onDidRender.event));
      element = this.getDataNode(element);
      await this.refreshAndRenderNode(element, recursive, viewStateContext, options);
      if (rerender) {
        try {
          this.tree.rerender(element);
        } catch (_a) {
        }
      }
    }
    rerender(element) {
      element === void 0 || element === this.root.element ? this.tree.rerender() : (element = this.getDataNode(element), this.tree.rerender(element));
    }
    getNode(element = this.root.element) {
      element = this.getDataNode(element);
      element = this.tree.getNode(element === this.root ? null : element);
      return this.nodeMapper.map(element);
    }
    collapse(element, recursive = !1) {
      element = this.getDataNode(element);
      return this.tree.collapse(element === this.root ? null : element, recursive);
    }
    async expand(element, recursive = !1) {
      if (typeof this.root.element === "undefined") {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, "Tree input not set");
      }
      this.root.refreshPromise && (await this.root.refreshPromise, await require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.toPromise(this._onDidRender.event));
      element = this.getDataNode(element);
      if (this.tree.hasElement(element) && !this.tree.isCollapsible(element)) {
        return !1;
      }
      element.refreshPromise && (await this.root.refreshPromise, await require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.toPromise(this._onDidRender.event));
      if (element !== this.root && !element.refreshPromise && !this.tree.isCollapsed(element)) {
        return !1;
      }
      recursive = this.tree.expand(element === this.root ? null : element, recursive);
      element.refreshPromise && (await this.root.refreshPromise, await require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_event_DOT_js.Event.toPromise(this._onDidRender.event));
      return recursive;
    }
    setSelection(elements, browserEvent) {
      elements = elements.map(e => this.getDataNode(e));
      this.tree.setSelection(elements, browserEvent);
    }
    getSelection() {
      return this.tree.getSelection().map(n => n.element);
    }
    setFocus(elements, browserEvent) {
      elements = elements.map(e => this.getDataNode(e));
      this.tree.setFocus(elements, browserEvent);
    }
    getFocus() {
      return this.tree.getFocus().map(n => n.element);
    }
    reveal(element, relativeTop) {
      this.tree.reveal(this.getDataNode(element), relativeTop);
    }
    getParentElement(element) {
      return (element = this.tree.getParentElement(this.getDataNode(element))) && element.element;
    }
    getFirstElementChild(element = this.root.element) {
      element = this.getDataNode(element);
      return (element = this.tree.getFirstElementChild(element === this.root ? null : element)) && element.element;
    }
    getDataNode(element) {
      const node = this.nodes.get(element === this.root.element ? null : element);
      if (!node) {
        throw new require$_DOT__SLASH_tree_DOT_js.TreeError(this.user, `Data tree node not found: ${element}`);
      }
      return node;
    }
    async refreshAndRenderNode(node, recursive, viewStateContext, options) {
      await this.refreshNode(node, recursive, viewStateContext);
      this.render(node, viewStateContext, options);
    }
    async refreshNode(node, recursive, viewStateContext) {
      let result;
      this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {
        !result && intersects(refreshNode, node) && (result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext)));
      });
      if (result) {
        return result;
      }
      if (node !== this.root && this.tree.getNode(node).collapsed) {
        node.hasChildren = !!this.dataSource.hasChildren(node.element), node.stale = !0;
      } else {
        return this.doRefreshSubTree(node, recursive, viewStateContext);
      }
    }
    async doRefreshSubTree(node, recursive, viewStateContext) {
      let done;
      node.refreshPromise = new Promise(c => done = c);
      this.subTreeRefreshPromises.set(node, node.refreshPromise);
      node.refreshPromise.finally(() => {
        node.refreshPromise = void 0;
        this.subTreeRefreshPromises.delete(node);
      });
      try {
        const childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);
        node.stale = !1;
        await require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));
      } finally {
        done();
      }
    }
    async doRefreshNode(node, recursive, viewStateContext) {
      node.hasChildren = !!this.dataSource.hasChildren(node.element);
      if (node.hasChildren) {
        var childrenPromise = this.doGetChildren(node);
        if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isIterable)(childrenPromise)) {
          childrenPromise = Promise.resolve(childrenPromise);
        } else {
          const slowTimeout = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.timeout)(800);
          slowTimeout.then(() => {
            node.slow = !0;
            this._onDidChangeNodeSlowState.fire(node);
          }, _ => null);
          childrenPromise = childrenPromise.finally(() => slowTimeout.cancel());
        }
      } else {
        childrenPromise = Promise.resolve(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.empty());
      }
      try {
        const children = await childrenPromise;
        return this.setChildren(node, children, recursive, viewStateContext);
      } catch (err) {
        node !== this.root && this.tree.hasElement(node) && this.tree.collapse(node);
        if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_errors_DOT_js.isCancellationError)(err)) {
          return [];
        }
        throw err;
      } finally {
        node.slow && (node.slow = !1, this._onDidChangeNodeSlowState.fire(node));
      }
    }
    doGetChildren(node) {
      let result = this.refreshPromises.get(node);
      if (result) {
        return result;
      }
      const children = this.dataSource.getChildren(node.element);
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_types_DOT_js.isIterable)(children)) {
        return this.processChildren(children);
      }
      result = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_async_DOT_js.createCancelablePromise)(async() => this.processChildren(await children));
      this.refreshPromises.set(node, result);
      return result.finally(() => {
        this.refreshPromises.delete(node);
      });
    }
    _onDidChangeCollapseState({node, deep}) {
      node.element !== null && !node.collapsed && node.element.stale && (deep ? this.collapse(node.element.element) : this.refreshAndRenderNode(node.element, !1).catch(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_errors_DOT_js.onUnexpectedError));
    }
    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {
      childrenElementsIterable = [...childrenElementsIterable];
      if (node.children.length === 0 && childrenElementsIterable.length === 0) {
        return [];
      }
      const nodesToForget = new Map(), childrenTreeNodesById = new Map();
      for (var child$jscomp$0 of node.children) {
        nodesToForget.set(child$jscomp$0.element, child$jscomp$0), this.identityProvider && childrenTreeNodesById.set(child$jscomp$0.id, {node:child$jscomp$0, collapsed:this.tree.hasElement(child$jscomp$0) && this.tree.isCollapsed(child$jscomp$0)});
      }
      const childrenToRefresh = [];
      child$jscomp$0 = childrenElementsIterable.map(element => {
        const hasChildren = !!this.dataSource.hasChildren(element);
        if (!this.identityProvider) {
          return element = createAsyncDataTreeNode({element, parent:node, hasChildren, defaultCollapseState:this.getDefaultCollapseState(element)}), hasChildren && element.defaultCollapseState === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrExpanded && childrenToRefresh.push(element), element;
        }
        var id = this.identityProvider.getId(element).toString();
        const result = childrenTreeNodesById.get(id);
        if (result) {
          return id = result.node, nodesToForget.delete(id.element), this.nodes.delete(id.element), this.nodes.set(element, id), id.element = element, id.hasChildren = hasChildren, recursive ? result.collapsed ? (id.children.forEach(node => dfs(node, node => this.nodes.delete(node.element))), id.children.splice(0, id.children.length), id.stale = !0) : childrenToRefresh.push(id) : hasChildren && !result.collapsed && childrenToRefresh.push(id), id;
        }
        element = createAsyncDataTreeNode({element, parent:node, id, hasChildren, defaultCollapseState:this.getDefaultCollapseState(element)});
        viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1 && viewStateContext.focus.push(element);
        viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1 && viewStateContext.selection.push(element);
        viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1 ? childrenToRefresh.push(element) : hasChildren && element.defaultCollapseState === require$_DOT__SLASH_tree_DOT_js.ObjectTreeElementCollapseState.PreserveOrExpanded && childrenToRefresh.push(element);
        return element;
      });
      for (const node of nodesToForget.values()) {
        dfs(node, node => this.nodes.delete(node.element));
      }
      for (const child of child$jscomp$0) {
        this.nodes.set(child.element, child);
      }
      node.children.splice(0, node.children.length, ...child$jscomp$0);
      node !== this.root && this.autoExpandSingleChildren && child$jscomp$0.length === 1 && childrenToRefresh.length === 0 && (child$jscomp$0[0].forceExpanded = !0, childrenToRefresh.push(child$jscomp$0[0]));
      return childrenToRefresh;
    }
    render(node, viewStateContext, options) {
      const children = node.children.map(node => this.asTreeElement(node, viewStateContext));
      this.tree.setChildren(node === this.root ? null : node, children, options && {...options, diffIdentityProvider:options.diffIdentityProvider && {getId(node) {
        return options.diffIdentityProvider.getId(node.element);
      }}});
      node !== this.root && this.tree.setCollapsible(node, node.hasChildren);
      this._onDidRender.fire();
    }
    asTreeElement(node, viewStateContext) {
      if (node.stale) {
        return {element:node, collapsible:node.hasChildren, collapsed:!0};
      }
      let collapsed;
      viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1 ? collapsed = !1 : node.forceExpanded ? (collapsed = !1, node.forceExpanded = !1) : collapsed = node.defaultCollapseState;
      return {element:node, children:node.hasChildren ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [], collapsible:node.hasChildren, collapsed};
    }
    processChildren(children) {
      this.sorter && (children = [...children].sort(this.sorter.compare.bind(this.sorter)));
      return children;
    }
    dispose() {
      this.disposables.dispose();
      this.tree.dispose();
    }
  }
  class CompressibleAsyncDataTreeNodeWrapper {
    get element() {
      return {elements:this.node.element.elements.map(e => e.element), incompressible:this.node.element.incompressible};
    }
    get children() {
      return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node));
    }
    get depth() {
      return this.node.depth;
    }
    get visibleChildrenCount() {
      return this.node.visibleChildrenCount;
    }
    get visibleChildIndex() {
      return this.node.visibleChildIndex;
    }
    get collapsible() {
      return this.node.collapsible;
    }
    get collapsed() {
      return this.node.collapsed;
    }
    get visible() {
      return this.node.visible;
    }
    get filterData() {
      return this.node.filterData;
    }
    constructor(node) {
      this.node = node;
    }
  }
  class CompressibleAsyncDataTreeRenderer {
    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {
      this.renderer = renderer;
      this.nodeMapper = nodeMapper;
      this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;
      this.onDidChangeTwistieState = onDidChangeTwistieState;
      this.renderedNodes = new Map();
      this.disposables = [];
      this.templateId = renderer.templateId;
    }
    renderTemplate(container) {
      return {templateData:this.renderer.renderTemplate(container)};
    }
    renderElement(node, index, templateData, height) {
      this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
    }
    renderCompressedElements(node, index, templateData, height) {
      this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
    }
    renderTwistie(element, twistieElement) {
      if (element.slow) {
        return twistieElement.classList.add(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js.ThemeIcon.asClassNameArray(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.treeItemLoading)), !0;
      }
      twistieElement.classList.remove(...require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_themables_DOT_js.ThemeIcon.asClassNameArray(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_codicons_DOT_js.Codicon.treeItemLoading));
      return !1;
    }
    disposeElement(node, index, templateData, height) {
      var _a, _b;
      (_b = (_a = this.renderer).disposeElement) === null || _b === void 0 || _b.call(_a, this.nodeMapper.map(node), index, templateData.templateData, height);
    }
    disposeCompressedElements(node, index, templateData, height) {
      var _a, _b;
      (_b = (_a = this.renderer).disposeCompressedElements) === null || _b === void 0 || _b.call(_a, this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
    }
    disposeTemplate(templateData) {
      this.renderer.disposeTemplate(templateData.templateData);
    }
    dispose() {
      this.renderedNodes.clear();
      this.disposables = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_lifecycle_DOT_js.dispose)(this.disposables);
    }
  }
  class CompressibleAsyncDataTree extends AsyncDataTree {
    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {
      super(user, container, virtualDelegate, renderers, dataSource, options);
      this.compressionDelegate = compressionDelegate;
      this.compressibleNodeMapper = new require$_DOT__SLASH_tree_DOT_js.WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));
      this.filter = options.filter;
    }
    createTree(user, container, delegate, renderers, options) {
      delegate = new require$_DOT__SLASH_abstractTree_DOT_js.ComposedTreeDelegate(delegate);
      renderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));
      options = asCompressibleObjectTreeOptions(options) || {};
      return new require$_DOT__SLASH_objectTree_DOT_js.CompressibleObjectTree(user, container, delegate, renderers, options);
    }
    asTreeElement(node, viewStateContext) {
      return {incompressible:this.compressionDelegate.isIncompressible(node.element), ...super.asTreeElement(node, viewStateContext)};
    }
    updateOptions(options = {}) {
      this.tree.updateOptions(options);
    }
    render(node, viewStateContext) {
      if (!this.identityProvider) {
        return super.render(node, viewStateContext);
      }
      const getId = element => this.identityProvider.getId(element).toString(), getUncompressedIds = nodes => {
        const result = new Set();
        for (const node of nodes) {
          if (nodes = this.tree.getCompressedTreeNode(node === this.root ? null : node), nodes.element) {
            for (const node of nodes.element.elements) {
              result.add(getId(node.element));
            }
          }
        }
        return result;
      }, oldSelection = getUncompressedIds(this.tree.getSelection()), oldFocus = getUncompressedIds(this.tree.getFocus());
      super.render(node, viewStateContext);
      const selection = this.getSelection();
      let didChangeSelection = !1;
      const focus = this.getFocus();
      let didChangeFocus = !1;
      const visit = node => {
        const compressedNode = node.element;
        if (compressedNode) {
          for (let i = 0; i < compressedNode.elements.length; i++) {
            const id = getId(compressedNode.elements[i].element), element = compressedNode.elements[compressedNode.elements.length - 1].element;
            oldSelection.has(id) && selection.indexOf(element) === -1 && (selection.push(element), didChangeSelection = !0);
            oldFocus.has(id) && focus.indexOf(element) === -1 && (focus.push(element), didChangeFocus = !0);
          }
        }
        node.children.forEach(visit);
      };
      visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));
      didChangeSelection && this.setSelection(selection);
      didChangeFocus && this.setFocus(focus);
    }
    processChildren(children) {
      this.filter && (children = require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_common_SLASH_iterator_DOT_js.Iterable.filter(children, e => {
        e = this.filter.filter(e, 1);
        e = typeof e === "boolean" ? e ? 1 : 0 : (0,require$_DOT__SLASH_indexTreeModel_DOT_js.isFilterResult)(e) ? (0,require$_DOT__SLASH_indexTreeModel_DOT_js.getVisibleState)(e.visibility) : (0,require$_DOT__SLASH_indexTreeModel_DOT_js.getVisibleState)(e);
        if (e === 2) {
          throw Error("Recursive tree visibility not supported in async data compressed trees");
        }
        return e === 1;
      }));
      return super.processChildren(children);
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$browser$ui$tree$asyncDataTree.js.map
