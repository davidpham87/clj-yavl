shadow$provide.module$node_modules$monaco_editor$esm$vs$platform$undoRedo$common$undoRedoService = function(require, module, exports) {
  function getResourceLabel(resource) {
    return resource.scheme === require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_network_DOT_js.Schemas.file ? resource.fsPath : resource.path;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, UndoRedoService:{enumerable:!0, get:function() {
    return UndoRedoService;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_network_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$network"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$severity"), nls = require("module$node_modules$monaco_editor$esm$vs$nls");
  module = require("module$node_modules$monaco_editor$esm$vs$platform$dialogs$common$dialogs");
  exports = require("module$node_modules$monaco_editor$esm$vs$platform$instantiation$common$extensions");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_notification_SLASH_common_SLASH_notification_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$notification$common$notification"), require$_DOT__SLASH_undoRedo_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$undoRedo$common$undoRedo"), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js);
  require = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  let stackElementCounter = 0;
  class ResourceStackElement {
    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {
      this.id = ++stackElementCounter;
      this.type = 0;
      this.actual = actual;
      this.label = actual.label;
      this.confirmBeforeUndo = actual.confirmBeforeUndo || !1;
      this.resourceLabel = resourceLabel;
      this.strResource = strResource;
      this.resourceLabels = [this.resourceLabel];
      this.strResources = [this.strResource];
      this.groupId = groupId;
      this.groupOrder = groupOrder;
      this.sourceId = sourceId;
      this.sourceOrder = sourceOrder;
      this.isValid = !0;
    }
    setValid(isValid) {
      this.isValid = isValid;
    }
    toString() {
      return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
    }
  }
  class ResourceReasonPair {
    constructor(resourceLabel, reason) {
      this.resourceLabel = resourceLabel;
      this.reason = reason;
    }
  }
  class RemovedResources {
    constructor() {
      this.elements = new Map();
    }
    createMessage() {
      const externalRemoval = [], noParallelUniverses = [];
      for (var [, element] of this.elements) {
        (element.reason === 0 ? externalRemoval : noParallelUniverses).push(element.resourceLabel);
      }
      element = [];
      externalRemoval.length > 0 && element.push(nls.localize({key:"externalRemoval", comment:["{0} is a list of filenames"]}, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(", ")));
      noParallelUniverses.length > 0 && element.push(nls.localize({key:"noParallelUniverses", comment:["{0} is a list of filenames"]}, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(", ")));
      return element.join("\n");
    }
    get size() {
      return this.elements.size;
    }
    has(strResource) {
      return this.elements.has(strResource);
    }
    set(strResource, value) {
      this.elements.set(strResource, value);
    }
    delete(strResource) {
      return this.elements.delete(strResource);
    }
  }
  class WorkspaceStackElement {
    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {
      this.id = ++stackElementCounter;
      this.type = 1;
      this.actual = actual;
      this.label = actual.label;
      this.confirmBeforeUndo = actual.confirmBeforeUndo || !1;
      this.resourceLabels = resourceLabels;
      this.strResources = strResources;
      this.groupId = groupId;
      this.groupOrder = groupOrder;
      this.sourceId = sourceId;
      this.sourceOrder = sourceOrder;
      this.invalidatedResources = this.removedResources = null;
    }
    canSplit() {
      return typeof this.actual.split === "function";
    }
    removeResource(resourceLabel, strResource, reason) {
      this.removedResources || (this.removedResources = new RemovedResources());
      this.removedResources.has(strResource) || this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));
    }
    setValid(resourceLabel, strResource, isValid) {
      isValid ? this.invalidatedResources && (this.invalidatedResources.delete(strResource), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new RemovedResources()), this.invalidatedResources.has(strResource) || this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0)));
    }
    toString() {
      return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
    }
  }
  class ResourceEditStack {
    constructor(resourceLabel, strResource) {
      this.resourceLabel = resourceLabel;
      this.strResource = strResource;
      this._past = [];
      this._future = [];
      this.locked = !1;
      this.versionId = 1;
    }
    dispose() {
      for (const element of this._past) {
        element.type === 1 && element.removeResource(this.resourceLabel, this.strResource, 0);
      }
      for (const element of this._future) {
        element.type === 1 && element.removeResource(this.resourceLabel, this.strResource, 0);
      }
      this.versionId++;
    }
    toString() {
      const result = [];
      result.push(`* ${this.strResource}:`);
      for (var i = 0; i < this._past.length; i++) {
        result.push(`   * [UNDO] ${this._past[i]}`);
      }
      for (i = this._future.length - 1; i >= 0; i--) {
        result.push(`   * [REDO] ${this._future[i]}`);
      }
      return result.join("\n");
    }
    flushAllElements() {
      this._past = [];
      this._future = [];
      this.versionId++;
    }
    _setElementValidFlag(element, isValid) {
      element.type === 1 ? element.setValid(this.resourceLabel, this.strResource, isValid) : element.setValid(isValid);
    }
    setElementsValidFlag(isValid, filter) {
      for (const element of this._past) {
        filter(element.actual) && this._setElementValidFlag(element, isValid);
      }
      for (const element of this._future) {
        filter(element.actual) && this._setElementValidFlag(element, isValid);
      }
    }
    pushElement(element) {
      for (const futureElement of this._future) {
        futureElement.type === 1 && futureElement.removeResource(this.resourceLabel, this.strResource, 1);
      }
      this._future = [];
      this._past.push(element);
      this.versionId++;
    }
    createSnapshot(resource) {
      const elements = [];
      for (let i = 0, len = this._past.length; i < len; i++) {
        elements.push(this._past[i].id);
      }
      for (let i = this._future.length - 1; i >= 0; i--) {
        elements.push(this._future[i].id);
      }
      return new require$_DOT__SLASH_undoRedo_DOT_js.ResourceEditStackSnapshot(resource, elements);
    }
    restoreSnapshot(snapshot) {
      const snapshotLength = snapshot.elements.length;
      let isOK = !0, snapshotIndex = 0, removePastAfter = -1;
      for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {
        var element$jscomp$0 = this._past[i];
        isOK && (snapshotIndex >= snapshotLength || element$jscomp$0.id !== snapshot.elements[snapshotIndex]) && (isOK = !1, removePastAfter = 0);
        isOK || element$jscomp$0.type !== 1 || element$jscomp$0.removeResource(this.resourceLabel, this.strResource, 0);
      }
      element$jscomp$0 = -1;
      for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {
        const element = this._future[i];
        isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex]) && (isOK = !1, element$jscomp$0 = i);
        isOK || element.type !== 1 || element.removeResource(this.resourceLabel, this.strResource, 0);
      }
      removePastAfter !== -1 && (this._past = this._past.slice(0, removePastAfter));
      element$jscomp$0 !== -1 && (this._future = this._future.slice(element$jscomp$0 + 1));
      this.versionId++;
    }
    getElements() {
      const past = [], future = [];
      for (const element of this._past) {
        past.push(element.actual);
      }
      for (const element of this._future) {
        future.push(element.actual);
      }
      return {past, future};
    }
    getClosestPastElement() {
      return this._past.length === 0 ? null : this._past[this._past.length - 1];
    }
    getSecondClosestPastElement() {
      return this._past.length < 2 ? null : this._past[this._past.length - 2];
    }
    getClosestFutureElement() {
      return this._future.length === 0 ? null : this._future[this._future.length - 1];
    }
    hasPastElements() {
      return this._past.length > 0;
    }
    hasFutureElements() {
      return this._future.length > 0;
    }
    splitPastWorkspaceElement(toRemove, individualMap) {
      for (let j = this._past.length - 1; j >= 0; j--) {
        if (this._past[j] === toRemove) {
          individualMap.has(this.strResource) ? this._past[j] = individualMap.get(this.strResource) : this._past.splice(j, 1);
          break;
        }
      }
      this.versionId++;
    }
    splitFutureWorkspaceElement(toRemove, individualMap) {
      for (let j = this._future.length - 1; j >= 0; j--) {
        if (this._future[j] === toRemove) {
          individualMap.has(this.strResource) ? this._future[j] = individualMap.get(this.strResource) : this._future.splice(j, 1);
          break;
        }
      }
      this.versionId++;
    }
    moveBackward(element) {
      this._past.pop();
      this._future.push(element);
      this.versionId++;
    }
    moveForward(element) {
      this._future.pop();
      this._past.push(element);
      this.versionId++;
    }
  }
  class EditStackSnapshot {
    constructor(editStacks) {
      this.editStacks = editStacks;
      this._versionIds = [];
      for (let i = 0, len = this.editStacks.length; i < len; i++) {
        this._versionIds[i] = this.editStacks[i].versionId;
      }
    }
    isValid() {
      for (let i = 0, len = this.editStacks.length; i < len; i++) {
        if (this._versionIds[i] !== this.editStacks[i].versionId) {
          return !1;
        }
      }
      return !0;
    }
  }
  const missingEditStack = new ResourceEditStack("", "");
  missingEditStack.locked = !0;
  let UndoRedoService = class {
    constructor(_dialogService, _notificationService) {
      this._dialogService = _dialogService;
      this._notificationService = _notificationService;
      this._editStacks = new Map();
      this._uriComparisonKeyComputers = [];
    }
    getUriComparisonKey(resource) {
      for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
        if (uriComparisonKeyComputer[0] === resource.scheme) {
          return uriComparisonKeyComputer[1].getComparisonKey(resource);
        }
      }
      return resource.toString();
    }
    _print(label) {
      console.log("------------------------------------");
      console.log(`AFTER ${label}: `);
      label = [];
      for (const element of this._editStacks) {
        label.push(element[1].toString());
      }
      console.log(label.join("\n"));
    }
    pushElement(element, group = require$_DOT__SLASH_undoRedo_DOT_js.UndoRedoGroup.None, source = require$_DOT__SLASH_undoRedo_DOT_js.UndoRedoSource.None) {
      if (element.type === 0) {
        var resourceLabel$jscomp$0 = getResourceLabel(element.resource), strResource$jscomp$0 = this.getUriComparisonKey(element.resource);
        this._pushElement(new ResourceStackElement(element, resourceLabel$jscomp$0, strResource$jscomp$0, group.id, group.nextOrder(), source.id, source.nextOrder()));
      } else {
        resourceLabel$jscomp$0 = new Set();
        strResource$jscomp$0 = [];
        const strResources = [];
        for (const resource of element.resources) {
          const resourceLabel = getResourceLabel(resource), strResource = this.getUriComparisonKey(resource);
          resourceLabel$jscomp$0.has(strResource) || (resourceLabel$jscomp$0.add(strResource), strResource$jscomp$0.push(resourceLabel), strResources.push(strResource));
        }
        strResource$jscomp$0.length === 1 ? this._pushElement(new ResourceStackElement(element, strResource$jscomp$0[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder())) : this._pushElement(new WorkspaceStackElement(element, strResource$jscomp$0, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));
      }
    }
    _pushElement(element) {
      for (let i = 0, len = element.strResources.length; i < len; i++) {
        var resourceLabel = element.resourceLabels[i];
        const strResource = element.strResources[i];
        this._editStacks.has(strResource) ? resourceLabel = this._editStacks.get(strResource) : (resourceLabel = new ResourceEditStack(resourceLabel, strResource), this._editStacks.set(strResource, resourceLabel));
        resourceLabel.pushElement(element);
      }
    }
    getLastElement(resource) {
      resource = this.getUriComparisonKey(resource);
      return this._editStacks.has(resource) ? (resource = this._editStacks.get(resource), resource.hasFutureElements() ? null : (resource = resource.getClosestPastElement()) ? resource.actual : null) : null;
    }
    _splitPastWorkspaceElement(toRemove, ignoreResources) {
      var individualArr = toRemove.actual.split();
      const individualMap = new Map();
      for (const _element of individualArr) {
        individualArr = getResourceLabel(_element.resource);
        const strResource = this.getUriComparisonKey(_element.resource);
        individualArr = new ResourceStackElement(_element, individualArr, strResource, 0, 0, 0, 0);
        individualMap.set(individualArr.strResource, individualArr);
      }
      for (const strResource of toRemove.strResources) {
        ignoreResources && ignoreResources.has(strResource) || this._editStacks.get(strResource).splitPastWorkspaceElement(toRemove, individualMap);
      }
    }
    _splitFutureWorkspaceElement(toRemove, ignoreResources) {
      var individualArr = toRemove.actual.split();
      const individualMap = new Map();
      for (const _element of individualArr) {
        individualArr = getResourceLabel(_element.resource);
        const strResource = this.getUriComparisonKey(_element.resource);
        individualArr = new ResourceStackElement(_element, individualArr, strResource, 0, 0, 0, 0);
        individualMap.set(individualArr.strResource, individualArr);
      }
      for (const strResource of toRemove.strResources) {
        ignoreResources && ignoreResources.has(strResource) || this._editStacks.get(strResource).splitFutureWorkspaceElement(toRemove, individualMap);
      }
    }
    removeElements(resource) {
      resource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
      this._editStacks.has(resource) && (this._editStacks.get(resource).dispose(), this._editStacks.delete(resource));
    }
    setElementsValidFlag(resource, isValid, filter) {
      resource = this.getUriComparisonKey(resource);
      this._editStacks.has(resource) && this._editStacks.get(resource).setElementsValidFlag(isValid, filter);
    }
    createSnapshot(resource) {
      const strResource = this.getUriComparisonKey(resource);
      return this._editStacks.has(strResource) ? this._editStacks.get(strResource).createSnapshot(resource) : new require$_DOT__SLASH_undoRedo_DOT_js.ResourceEditStackSnapshot(resource, []);
    }
    restoreSnapshot(snapshot) {
      const strResource = this.getUriComparisonKey(snapshot.resource);
      if (this._editStacks.has(strResource)) {
        const editStack = this._editStacks.get(strResource);
        editStack.restoreSnapshot(snapshot);
        editStack.hasPastElements() || editStack.hasFutureElements() || (editStack.dispose(), this._editStacks.delete(strResource));
      }
    }
    getElements(resource) {
      resource = this.getUriComparisonKey(resource);
      return this._editStacks.has(resource) ? this._editStacks.get(resource).getElements() : {past:[], future:[]};
    }
    _findClosestUndoElementWithSource(sourceId) {
      if (!sourceId) {
        return [null, null];
      }
      let matchedElement = null, matchedStrResource = null;
      for (const [strResource, editStack] of this._editStacks) {
        const candidate = editStack.getClosestPastElement();
        candidate && candidate.sourceId === sourceId && (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) && (matchedElement = candidate, matchedStrResource = strResource);
      }
      return [matchedElement, matchedStrResource];
    }
    canUndo(resourceOrSource) {
      if (resourceOrSource instanceof require$_DOT__SLASH_undoRedo_DOT_js.UndoRedoSource) {
        return [, resourceOrSource] = this._findClosestUndoElementWithSource(resourceOrSource.id), resourceOrSource ? !0 : !1;
      }
      resourceOrSource = this.getUriComparisonKey(resourceOrSource);
      return this._editStacks.has(resourceOrSource) ? this._editStacks.get(resourceOrSource).hasPastElements() : !1;
    }
    _onError(err, element) {
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_errors_DOT_js.onUnexpectedError)(err);
      for (const strResource of element.strResources) {
        this.removeElements(strResource);
      }
      this._notificationService.error(err);
    }
    _acquireLocks(editStackSnapshot) {
      for (const editStack of editStackSnapshot.editStacks) {
        if (editStack.locked) {
          throw Error("Cannot acquire edit stack lock");
        }
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked = !0;
      }
      return () => {
        for (const editStack of editStackSnapshot.editStacks) {
          editStack.locked = !1;
        }
      };
    }
    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {
      const releaseLocks = this._acquireLocks(editStackSnapshot);
      let result;
      try {
        result = invoke();
      } catch (err) {
        return releaseLocks(), cleanup.dispose(), this._onError(err, element);
      }
      if (result) {
        return result.then(() => {
          releaseLocks();
          cleanup.dispose();
          return continuation();
        }, err => {
          releaseLocks();
          cleanup.dispose();
          return this._onError(err, element);
        });
      }
      releaseLocks();
      cleanup.dispose();
      return continuation();
    }
    async _invokeWorkspacePrepare(element) {
      if (typeof element.actual.prepareUndoRedo === "undefined") {
        return require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None;
      }
      element = element.actual.prepareUndoRedo();
      return typeof element === "undefined" ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None : element;
    }
    _invokeResourcePrepare(element, callback) {
      return element.actual.type !== 1 || typeof element.actual.prepareUndoRedo === "undefined" ? callback(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None) : (element = element.actual.prepareUndoRedo()) ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.isDisposable)(element) ? callback(element) : element.then(disposable => callback(disposable)) : callback(require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_lifecycle_DOT_js.Disposable.None);
    }
    _getAffectedEditStacks(element) {
      const affectedEditStacks = [];
      for (const strResource of element.strResources) {
        affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);
      }
      return new EditStackSnapshot(affectedEditStacks);
    }
    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {
      if (element.canSplit()) {
        return this._splitPastWorkspaceElement(element, ignoreResources), this._notificationService.warn(message), new WorkspaceVerificationError(this._undo(strResource, 0, !0));
      }
      for (const strResource of element.strResources) {
        this.removeElements(strResource);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
      if (element.removedResources) {
        return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({key:"cannotWorkspaceUndo", comment:["{0} is a label for an operation. {1} is another message."]}, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
      }
      if (checkInvalidatedResources && element.invalidatedResources) {
        return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({key:"cannotWorkspaceUndo", comment:["{0} is a label for an operation. {1} is another message."]}, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
      }
      checkInvalidatedResources = [];
      for (var editStack$jscomp$0 of editStackSnapshot.editStacks) {
        editStack$jscomp$0.getClosestPastElement() !== element && checkInvalidatedResources.push(editStack$jscomp$0.resourceLabel);
      }
      if (checkInvalidatedResources.length > 0) {
        return this._tryToSplitAndUndo(strResource, element, null, nls.localize({key:"cannotWorkspaceUndoDueToChanges", comment:["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not undo '{0}' across all files because changes were made to {1}", element.label, checkInvalidatedResources.join(", ")));
      }
      editStack$jscomp$0 = [];
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked && editStack$jscomp$0.push(editStack.resourceLabel);
      }
      return editStack$jscomp$0.length > 0 ? this._tryToSplitAndUndo(strResource, element, null, nls.localize({key:"cannotWorkspaceUndoDueToInProgressUndoRedo", comment:["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, editStack$jscomp$0.join(", "))) : editStackSnapshot.isValid() ? null : this._tryToSplitAndUndo(strResource, element, null, nls.localize({key:"cannotWorkspaceUndoDueToInMeantimeUndoRedo", 
      comment:["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    _workspaceUndo(strResource, element, undoConfirmed) {
      const affectedEditStacks = this._getAffectedEditStacks(element), verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, !1);
      return verificationError ? verificationError.returnValue : this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);
    }
    _isPartOfUndoGroup(element) {
      if (!element.groupId) {
        return !1;
      }
      for (const [, editStack] of this._editStacks) {
        const pastElement = editStack.getClosestPastElement();
        if (pastElement) {
          if (pastElement === element) {
            const secondPastElement = editStack.getSecondClosestPastElement();
            if (secondPastElement && secondPastElement.groupId === element.groupId) {
              return !0;
            }
          }
          if (pastElement.groupId === element.groupId) {
            return !0;
          }
        }
      }
      return !1;
    }
    async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {
      if (element.canSplit() && !this._isPartOfUndoGroup(element)) {
        let UndoChoice;
        (function(UndoChoice) {
          UndoChoice[UndoChoice.All = 0] = "All";
          UndoChoice[UndoChoice.This = 1] = "This";
          UndoChoice[UndoChoice.Cancel = 2] = "Cancel";
        })(UndoChoice ||= {});
        var {result} = await this._dialogService.prompt({type:default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js.default.Info, message:nls.localize("confirmWorkspace", "Would you like to undo '{0}' across all files?", element.label), buttons:[{label:nls.localize({key:"ok", comment:["{0} denotes a number that is \x3e 1, \x26\x26 denotes a mnemonic"]}, "\x26\x26Undo in {0} Files", editStackSnapshot.editStacks.length), run:() => UndoChoice.All}, 
        {label:nls.localize({key:"nok", comment:["\x26\x26 denotes a mnemonic"]}, "Undo this \x26\x26File"), run:() => UndoChoice.This}], cancelButton:{run:() => UndoChoice.Cancel}});
        if (result === UndoChoice.Cancel) {
          return;
        }
        if (result === UndoChoice.This) {
          return this._splitPastWorkspaceElement(element, null), this._undo(strResource, 0, !0);
        }
        if (result = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, !1)) {
          return result.returnValue;
        }
        undoConfirmed = !0;
      }
      let cleanup;
      try {
        cleanup = await this._invokeWorkspacePrepare(element);
      } catch (err) {
        return this._onError(err, element);
      }
      if (strResource = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, !0)) {
        return cleanup.dispose(), strResource.returnValue;
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.moveBackward(element);
      }
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
    }
    _resourceUndo(editStack, element, undoConfirmed) {
      if (element.isValid) {
        if (editStack.locked) {
          const message = nls.localize({key:"cannotResourceUndoDueToInProgressUndoRedo", comment:["{0} is a label for an operation."]}, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
          this._notificationService.warn(message);
        } else {
          return this._invokeResourcePrepare(element, cleanup => {
            editStack.moveBackward(element);
            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
          });
        }
      } else {
        editStack.flushAllElements();
      }
    }
    _findClosestUndoElementInGroup(groupId) {
      if (!groupId) {
        return [null, null];
      }
      let matchedElement = null, matchedStrResource = null;
      for (const [strResource, editStack] of this._editStacks) {
        const candidate = editStack.getClosestPastElement();
        candidate && candidate.groupId === groupId && (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) && (matchedElement = candidate, matchedStrResource = strResource);
      }
      return [matchedElement, matchedStrResource];
    }
    _continueUndoInGroup(groupId, undoConfirmed) {
      if (groupId && ([, groupId] = this._findClosestUndoElementInGroup(groupId), groupId)) {
        return this._undo(groupId, 0, undoConfirmed);
      }
    }
    undo(resourceOrSource) {
      if (resourceOrSource instanceof require$_DOT__SLASH_undoRedo_DOT_js.UndoRedoSource) {
        const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
        return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, !1) : void 0;
      }
      return typeof resourceOrSource === "string" ? this._undo(resourceOrSource, 0, !1) : this._undo(this.getUriComparisonKey(resourceOrSource), 0, !1);
    }
    _undo(strResource, sourceId = 0, undoConfirmed) {
      if (this._editStacks.has(strResource)) {
        var editStack = this._editStacks.get(strResource), element = editStack.getClosestPastElement();
        if (element) {
          if (element.groupId) {
            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);
            if (element !== matchedElement && matchedStrResource) {
              return this._undo(matchedStrResource, sourceId, undoConfirmed);
            }
          }
          return element.sourceId === sourceId && !element.confirmBeforeUndo || undoConfirmed ? element.type === 1 ? this._workspaceUndo(strResource, element, undoConfirmed) : this._resourceUndo(editStack, element, undoConfirmed) : this._confirmAndContinueUndo(strResource, sourceId, element);
        }
      }
    }
    async _confirmAndContinueUndo(strResource, sourceId, element) {
      if ((await this._dialogService.confirm({message:nls.localize("confirmDifferentSource", "Would you like to undo '{0}'?", element.label), primaryButton:nls.localize({key:"confirmDifferentSource.yes", comment:["\x26\x26 denotes a mnemonic"]}, "\x26\x26Yes"), cancelButton:nls.localize("confirmDifferentSource.no", "No")})).confirmed) {
        return this._undo(strResource, sourceId, !0);
      }
    }
    _findClosestRedoElementWithSource(sourceId) {
      if (!sourceId) {
        return [null, null];
      }
      let matchedElement = null, matchedStrResource = null;
      for (const [strResource, editStack] of this._editStacks) {
        const candidate = editStack.getClosestFutureElement();
        candidate && candidate.sourceId === sourceId && (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) && (matchedElement = candidate, matchedStrResource = strResource);
      }
      return [matchedElement, matchedStrResource];
    }
    canRedo(resourceOrSource) {
      if (resourceOrSource instanceof require$_DOT__SLASH_undoRedo_DOT_js.UndoRedoSource) {
        return [, resourceOrSource] = this._findClosestRedoElementWithSource(resourceOrSource.id), resourceOrSource ? !0 : !1;
      }
      resourceOrSource = this.getUriComparisonKey(resourceOrSource);
      return this._editStacks.has(resourceOrSource) ? this._editStacks.get(resourceOrSource).hasFutureElements() : !1;
    }
    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {
      if (element.canSplit()) {
        return this._splitFutureWorkspaceElement(element, ignoreResources), this._notificationService.warn(message), new WorkspaceVerificationError(this._redo(strResource));
      }
      for (const strResource of element.strResources) {
        this.removeElements(strResource);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
      if (element.removedResources) {
        return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({key:"cannotWorkspaceRedo", comment:["{0} is a label for an operation. {1} is another message."]}, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
      }
      if (checkInvalidatedResources && element.invalidatedResources) {
        return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({key:"cannotWorkspaceRedo", comment:["{0} is a label for an operation. {1} is another message."]}, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
      }
      checkInvalidatedResources = [];
      for (var editStack$jscomp$0 of editStackSnapshot.editStacks) {
        editStack$jscomp$0.getClosestFutureElement() !== element && checkInvalidatedResources.push(editStack$jscomp$0.resourceLabel);
      }
      if (checkInvalidatedResources.length > 0) {
        return this._tryToSplitAndRedo(strResource, element, null, nls.localize({key:"cannotWorkspaceRedoDueToChanges", comment:["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not redo '{0}' across all files because changes were made to {1}", element.label, checkInvalidatedResources.join(", ")));
      }
      editStack$jscomp$0 = [];
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked && editStack$jscomp$0.push(editStack.resourceLabel);
      }
      return editStack$jscomp$0.length > 0 ? this._tryToSplitAndRedo(strResource, element, null, nls.localize({key:"cannotWorkspaceRedoDueToInProgressUndoRedo", comment:["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, editStack$jscomp$0.join(", "))) : editStackSnapshot.isValid() ? null : this._tryToSplitAndRedo(strResource, element, null, nls.localize({key:"cannotWorkspaceRedoDueToInMeantimeUndoRedo", 
      comment:["{0} is a label for an operation. {1} is a list of filenames."]}, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    _workspaceRedo(strResource, element) {
      const affectedEditStacks = this._getAffectedEditStacks(element), verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, !1);
      return verificationError ? verificationError.returnValue : this._executeWorkspaceRedo(strResource, element, affectedEditStacks);
    }
    async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
      let cleanup;
      try {
        cleanup = await this._invokeWorkspacePrepare(element);
      } catch (err) {
        return this._onError(err, element);
      }
      if (strResource = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, !0)) {
        return cleanup.dispose(), strResource.returnValue;
      }
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.moveForward(element);
      }
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));
    }
    _resourceRedo(editStack, element) {
      if (element.isValid) {
        if (editStack.locked) {
          const message = nls.localize({key:"cannotResourceRedoDueToInProgressUndoRedo", comment:["{0} is a label for an operation."]}, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
          this._notificationService.warn(message);
        } else {
          return this._invokeResourcePrepare(element, cleanup => {
            editStack.moveForward(element);
            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));
          });
        }
      } else {
        editStack.flushAllElements();
      }
    }
    _findClosestRedoElementInGroup(groupId) {
      if (!groupId) {
        return [null, null];
      }
      let matchedElement = null, matchedStrResource = null;
      for (const [strResource, editStack] of this._editStacks) {
        const candidate = editStack.getClosestFutureElement();
        candidate && candidate.groupId === groupId && (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) && (matchedElement = candidate, matchedStrResource = strResource);
      }
      return [matchedElement, matchedStrResource];
    }
    _continueRedoInGroup(groupId) {
      if (groupId && ([, groupId] = this._findClosestRedoElementInGroup(groupId), groupId)) {
        return this._redo(groupId);
      }
    }
    redo(resourceOrSource) {
      return resourceOrSource instanceof require$_DOT__SLASH_undoRedo_DOT_js.UndoRedoSource ? ([, resourceOrSource] = this._findClosestRedoElementWithSource(resourceOrSource.id), resourceOrSource ? this._redo(resourceOrSource) : void 0) : typeof resourceOrSource === "string" ? this._redo(resourceOrSource) : this._redo(this.getUriComparisonKey(resourceOrSource));
    }
    _redo(strResource) {
      if (this._editStacks.has(strResource)) {
        var editStack = this._editStacks.get(strResource), element = editStack.getClosestFutureElement();
        if (element) {
          if (element.groupId) {
            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);
            if (element !== matchedElement && matchedStrResource) {
              return this._redo(matchedStrResource);
            }
          }
          return element.type === 1 ? this._workspaceRedo(strResource, element) : this._resourceRedo(editStack, element);
        }
      }
    }
  };
  UndoRedoService = require([require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js(0, module.IDialogService), require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_base_SLASH_common_SLASH_severity_DOT_js(1, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_notification_SLASH_common_SLASH_notification_DOT_js.INotificationService)], UndoRedoService);
  class WorkspaceVerificationError {
    constructor(returnValue) {
      this.returnValue = returnValue;
    }
  }
  (0,exports.registerSingleton)(require$_DOT__SLASH_undoRedo_DOT_js.IUndoRedoService, UndoRedoService, 1);
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$platform$undoRedo$common$undoRedoService.js.map
