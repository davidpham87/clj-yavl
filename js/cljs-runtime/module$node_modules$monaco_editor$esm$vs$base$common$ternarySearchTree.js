shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$ternarySearchTree = function(require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ConfigKeysIterator:{enumerable:!0, get:function() {
    return ConfigKeysIterator;
  }}, PathIterator:{enumerable:!0, get:function() {
    return PathIterator;
  }}, StringIterator:{enumerable:!0, get:function() {
    return StringIterator;
  }}, TernarySearchTree:{enumerable:!0, get:function() {
    return TernarySearchTree;
  }}, UriIterator:{enumerable:!0, get:function() {
    return UriIterator;
  }}});
  var require$_DOT__SLASH_strings_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  class StringIterator {
    constructor() {
      this._value = "";
      this._pos = 0;
    }
    reset(key) {
      this._value = key;
      this._pos = 0;
      return this;
    }
    next() {
      this._pos += 1;
      return this;
    }
    hasNext() {
      return this._pos < this._value.length - 1;
    }
    cmp(a) {
      a = a.charCodeAt(0);
      const thisCode = this._value.charCodeAt(this._pos);
      return a - thisCode;
    }
    value() {
      return this._value[this._pos];
    }
  }
  class ConfigKeysIterator {
    constructor(_caseSensitive = !0) {
      this._caseSensitive = _caseSensitive;
    }
    reset(key) {
      this._value = key;
      this._to = this._from = 0;
      return this.next();
    }
    hasNext() {
      return this._to < this._value.length;
    }
    next() {
      this._from = this._to;
      let justSeps = !0;
      for (; this._to < this._value.length; this._to++) {
        if (this._value.charCodeAt(this._to) === 46) {
          if (justSeps) {
            this._from++;
          } else {
            break;
          }
        } else {
          justSeps = !1;
        }
      }
      return this;
    }
    cmp(a) {
      return this._caseSensitive ? (0,require$_DOT__SLASH_strings_DOT_js.compareSubstring)(a, this._value, 0, a.length, this._from, this._to) : (0,require$_DOT__SLASH_strings_DOT_js.compareSubstringIgnoreCase)(a, this._value, 0, a.length, this._from, this._to);
    }
    value() {
      return this._value.substring(this._from, this._to);
    }
  }
  class PathIterator {
    constructor(_splitOnBackslash = !0, _caseSensitive = !0) {
      this._splitOnBackslash = _splitOnBackslash;
      this._caseSensitive = _caseSensitive;
    }
    reset(key) {
      this._to = this._from = 0;
      this._value = key;
      this._valueLen = key.length;
      for (key = key.length - 1; key >= 0; key--, this._valueLen--) {
        const ch = this._value.charCodeAt(key);
        if (!(ch === 47 || this._splitOnBackslash && ch === 92)) {
          break;
        }
      }
      return this.next();
    }
    hasNext() {
      return this._to < this._valueLen;
    }
    next() {
      this._from = this._to;
      let justSeps = !0;
      for (; this._to < this._valueLen; this._to++) {
        const ch = this._value.charCodeAt(this._to);
        if (ch === 47 || this._splitOnBackslash && ch === 92) {
          if (justSeps) {
            this._from++;
          } else {
            break;
          }
        } else {
          justSeps = !1;
        }
      }
      return this;
    }
    cmp(a) {
      return this._caseSensitive ? (0,require$_DOT__SLASH_strings_DOT_js.compareSubstring)(a, this._value, 0, a.length, this._from, this._to) : (0,require$_DOT__SLASH_strings_DOT_js.compareSubstringIgnoreCase)(a, this._value, 0, a.length, this._from, this._to);
    }
    value() {
      return this._value.substring(this._from, this._to);
    }
  }
  class UriIterator {
    constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
      this._ignorePathCasing = _ignorePathCasing;
      this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
      this._states = [];
      this._stateIdx = 0;
    }
    reset(key) {
      this._value = key;
      this._states = [];
      this._value.scheme && this._states.push(1);
      this._value.authority && this._states.push(2);
      this._value.path && (this._pathIterator = new PathIterator(!1, !this._ignorePathCasing(key)), this._pathIterator.reset(key.path), this._pathIterator.value() && this._states.push(3));
      this._ignoreQueryAndFragment(key) || (this._value.query && this._states.push(4), this._value.fragment && this._states.push(5));
      this._stateIdx = 0;
      return this;
    }
    next() {
      this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1;
      return this;
    }
    hasNext() {
      return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
    }
    cmp(a) {
      if (this._states[this._stateIdx] === 1) {
        return (0,require$_DOT__SLASH_strings_DOT_js.compareIgnoreCase)(a, this._value.scheme);
      }
      if (this._states[this._stateIdx] === 2) {
        return (0,require$_DOT__SLASH_strings_DOT_js.compareIgnoreCase)(a, this._value.authority);
      }
      if (this._states[this._stateIdx] === 3) {
        return this._pathIterator.cmp(a);
      }
      if (this._states[this._stateIdx] === 4) {
        return (0,require$_DOT__SLASH_strings_DOT_js.compare)(a, this._value.query);
      }
      if (this._states[this._stateIdx] === 5) {
        return (0,require$_DOT__SLASH_strings_DOT_js.compare)(a, this._value.fragment);
      }
      throw Error();
    }
    value() {
      if (this._states[this._stateIdx] === 1) {
        return this._value.scheme;
      }
      if (this._states[this._stateIdx] === 2) {
        return this._value.authority;
      }
      if (this._states[this._stateIdx] === 3) {
        return this._pathIterator.value();
      }
      if (this._states[this._stateIdx] === 4) {
        return this._value.query;
      }
      if (this._states[this._stateIdx] === 5) {
        return this._value.fragment;
      }
      throw Error();
    }
  }
  class TernarySearchTreeNode {
    constructor() {
      this.height = 1;
    }
    rotateLeft() {
      const tmp = this.right;
      this.right = tmp.left;
      tmp.left = this;
      this.updateHeight();
      tmp.updateHeight();
      return tmp;
    }
    rotateRight() {
      const tmp = this.left;
      this.left = tmp.right;
      tmp.right = this;
      this.updateHeight();
      tmp.updateHeight();
      return tmp;
    }
    updateHeight() {
      this.height = 1 + Math.max(this.heightLeft, this.heightRight);
    }
    balanceFactor() {
      return this.heightRight - this.heightLeft;
    }
    get heightLeft() {
      var _a, _b;
      return (_b = (_a = this.left) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
    }
    get heightRight() {
      var _a, _b;
      return (_b = (_a = this.right) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
    }
  }
  class TernarySearchTree {
    static forUris(ignorePathCasing = () => !1, ignoreQueryAndFragment = () => !1) {
      return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
    }
    static forStrings() {
      return new TernarySearchTree(new StringIterator());
    }
    static forConfigKeys() {
      return new TernarySearchTree(new ConfigKeysIterator());
    }
    constructor(segments) {
      this._iter = segments;
    }
    clear() {
      this._root = void 0;
    }
    set(key, element) {
      var iter = this._iter.reset(key), node;
      this._root || (this._root = new TernarySearchTreeNode(), this._root.segment = iter.value());
      const stack = [];
      for (node = this._root;;) {
        var val = iter.cmp(node.segment);
        if (val > 0) {
          node.left || (node.left = new TernarySearchTreeNode(), node.left.segment = iter.value()), stack.push([-1, node]), node = node.left;
        } else if (val < 0) {
          node.right || (node.right = new TernarySearchTreeNode(), node.right.segment = iter.value()), stack.push([1, node]), node = node.right;
        } else if (iter.hasNext()) {
          iter.next(), node.mid || (node.mid = new TernarySearchTreeNode(), node.mid.segment = iter.value()), stack.push([0, node]), node = node.mid;
        } else {
          break;
        }
      }
      iter = node.value;
      node.value = element;
      node.key = key;
      for (key = stack.length - 1; key >= 0; key--) {
        if (element = stack[key][1], element.updateHeight(), node = element.balanceFactor(), node < -1 || node > 1) {
          node = stack[key][0];
          val = stack[key + 1][0];
          if (node === 1 && val === 1) {
            stack[key][1] = element.rotateLeft();
          } else if (node === -1 && val === -1) {
            stack[key][1] = element.rotateRight();
          } else if (node === 1 && val === -1) {
            element.right = stack[key + 1][1] = stack[key + 1][1].rotateRight(), stack[key][1] = element.rotateLeft();
          } else if (node === -1 && val === 1) {
            element.left = stack[key + 1][1] = stack[key + 1][1].rotateLeft(), stack[key][1] = element.rotateRight();
          } else {
            throw Error();
          }
          if (key > 0) {
            switch(stack[key - 1][0]) {
              case -1:
                stack[key - 1][1].left = stack[key][1];
                break;
              case 1:
                stack[key - 1][1].right = stack[key][1];
                break;
              case 0:
                stack[key - 1][1].mid = stack[key][1];
            }
          } else {
            this._root = stack[0][1];
          }
        }
      }
      return iter;
    }
    get(key) {
      var _a;
      return (_a = this._getNode(key)) === null || _a === void 0 ? void 0 : _a.value;
    }
    _getNode(key) {
      key = this._iter.reset(key);
      let node = this._root;
      for (; node;) {
        const val = key.cmp(node.segment);
        if (val > 0) {
          node = node.left;
        } else if (val < 0) {
          node = node.right;
        } else if (key.hasNext()) {
          key.next(), node = node.mid;
        } else {
          break;
        }
      }
      return node;
    }
    has(key) {
      key = this._getNode(key);
      return !((key === null || key === void 0 ? void 0 : key.value) === void 0 && (key === null || key === void 0 ? void 0 : key.mid) === void 0);
    }
    delete(key) {
      return this._delete(key, !1);
    }
    deleteSuperstr(key) {
      return this._delete(key, !0);
    }
    _delete(key, superStr) {
      const iter = this._iter.reset(key);
      key = [];
      for (var node = this._root; node;) {
        const val = iter.cmp(node.segment);
        if (val > 0) {
          key.push([-1, node]), node = node.left;
        } else if (val < 0) {
          key.push([1, node]), node = node.right;
        } else if (iter.hasNext()) {
          iter.next(), key.push([0, node]), node = node.mid;
        } else {
          break;
        }
      }
      if (node) {
        superStr ? (node.left = void 0, node.mid = void 0, node.right = void 0, node.height = 1) : (node.key = void 0, node.value = void 0);
        if (!node.mid && !node.value) {
          if (node.left && node.right) {
            var _a = this._min(node.right);
            if (_a.key) {
              const {key, value, segment} = _a;
              this._delete(_a.key, !1);
              node.key = key;
              node.value = value;
              node.segment = segment;
            }
          } else {
            if (superStr = (_a = node.left) !== null && _a !== void 0 ? _a : node.right, key.length > 0) {
              const [dir, parent] = key[key.length - 1];
              switch(dir) {
                case -1:
                  parent.left = superStr;
                  break;
                case 0:
                  parent.mid = superStr;
                  break;
                case 1:
                  parent.right = superStr;
              }
            } else {
              this._root = superStr;
            }
          }
        }
        for (_a = key.length - 1; _a >= 0; _a--) {
          if (node = key[_a][1], node.updateHeight(), superStr = node.balanceFactor(), superStr > 1 ? (node.right.balanceFactor() >= 0 || (node.right = node.right.rotateRight()), key[_a][1] = node.rotateLeft()) : superStr < -1 && (node.left.balanceFactor() <= 0 || (node.left = node.left.rotateLeft()), key[_a][1] = node.rotateRight()), _a > 0) {
            switch(key[_a - 1][0]) {
              case -1:
                key[_a - 1][1].left = key[_a][1];
                break;
              case 1:
                key[_a - 1][1].right = key[_a][1];
                break;
              case 0:
                key[_a - 1][1].mid = key[_a][1];
            }
          } else {
            this._root = key[0][1];
          }
        }
      }
    }
    _min(node) {
      for (; node.left;) {
        node = node.left;
      }
      return node;
    }
    findSubstr(key) {
      key = this._iter.reset(key);
      let node = this._root, candidate = void 0;
      for (; node;) {
        const val = key.cmp(node.segment);
        if (val > 0) {
          node = node.left;
        } else if (val < 0) {
          node = node.right;
        } else if (key.hasNext()) {
          key.next(), candidate = node.value || candidate, node = node.mid;
        } else {
          break;
        }
      }
      return node && node.value || candidate;
    }
    findSuperstr(key) {
      return this._findSuperstrOrElement(key, !1);
    }
    _findSuperstrOrElement(key, allowValue) {
      key = this._iter.reset(key);
      let node = this._root;
      for (; node;) {
        const val = key.cmp(node.segment);
        if (val > 0) {
          node = node.left;
        } else if (val < 0) {
          node = node.right;
        } else if (key.hasNext()) {
          key.next(), node = node.mid;
        } else {
          if (node.mid) {
            return this._entries(node.mid);
          }
          if (allowValue) {
            return node.value;
          }
          break;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key);
      }
    }
    *[Symbol.iterator]() {
      yield* this._entries(this._root);
    }
    _entries(node) {
      const result = [];
      this._dfsEntries(node, result);
      return result[Symbol.iterator]();
    }
    _dfsEntries(node, bucket) {
      node && (node.left && this._dfsEntries(node.left, bucket), node.value && bucket.push([node.key, node.value]), node.mid && this._dfsEntries(node.mid, bucket), node.right && this._dfsEntries(node.right, bucket));
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$ternarySearchTree.js.map
