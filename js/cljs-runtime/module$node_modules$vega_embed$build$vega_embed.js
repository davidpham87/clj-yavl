shadow$provide.module$node_modules$vega_embed$build$vega_embed = function(require, module, exports) {
  var process = require("module$node_modules$process$browser");
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("module$node_modules$vega$build$vega_node"), require("module$node_modules$vega_lite$build$vega_lite")) : typeof define === "function" && define.amd ? define(["vega", "vega-lite"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.vegaEmbed = factory(global.vega, global.vegaLite));
  })(this, function(vegaImport, vegaLiteImport) {
    function _interopNamespaceDefault(e) {
      var n = Object.create(null);
      e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {enumerable:!0, get:function() {
            return e[k];
          }});
        }
      });
      n.default = e;
      return Object.freeze(n);
    }
    function _objectKeys(obj) {
      if (Array.isArray(obj)) {
        obj = Array(obj.length);
        for (var k = 0; k < obj.length; k++) {
          obj[k] = "" + k;
        }
        return obj;
      }
      if (Object.keys) {
        return Object.keys(obj);
      }
      k = [];
      for (var i in obj) {
        _hasOwnProperty.call(obj, i) && k.push(i);
      }
      return k;
    }
    function _deepClone(obj) {
      switch(typeof obj) {
        case "object":
          return JSON.parse(JSON.stringify(obj));
        case "undefined":
          return null;
        default:
          return obj;
      }
    }
    function isInteger(str) {
      for (var i = 0, len = str.length, charCode; i < len;) {
        if (charCode = str.charCodeAt(i), charCode >= 48 && charCode <= 57) {
          i++;
        } else {
          return !1;
        }
      }
      return !0;
    }
    function escapePathComponent(path) {
      return path.indexOf("/") === -1 && path.indexOf("~") === -1 ? path : path.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapePathComponent(path) {
      return path.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function hasUndefined(obj) {
      if (obj === void 0) {
        return !0;
      }
      if (obj) {
        if (Array.isArray(obj)) {
          for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
            if (hasUndefined(obj[i_1])) {
              return !0;
            }
          }
        } else if (typeof obj === "object") {
          i_1 = _objectKeys(obj);
          len = i_1.length;
          for (var i = 0; i < len; i++) {
            if (hasUndefined(obj[i_1[i]])) {
              return !0;
            }
          }
        }
      }
      return !1;
    }
    function patchErrorMessageFormatter(message, args) {
      message = [message];
      for (var key in args) {
        var value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
        typeof value !== "undefined" && message.push(key + ": " + value);
      }
      return message.join("\n");
    }
    function getValueByPointer(document, pointer) {
      if (pointer == "") {
        return document;
      }
      pointer = {op:"_get", path:pointer};
      applyOperation(document, pointer);
      return pointer.value;
    }
    function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
      validateOperation === void 0 && (validateOperation = !1);
      mutateDocument === void 0 && (mutateDocument = !0);
      banPrototypeModifications === void 0 && (banPrototypeModifications = !0);
      index === void 0 && (index = 0);
      validateOperation && (typeof validateOperation == "function" ? validateOperation(operation, 0, document, operation.path) : validator(operation, 0));
      if (operation.path === "") {
        banPrototypeModifications = {newDocument:document};
        if (operation.op === "add") {
          return banPrototypeModifications.newDocument = operation.value, banPrototypeModifications;
        }
        if (operation.op === "replace") {
          return banPrototypeModifications.newDocument = operation.value, banPrototypeModifications.removed = document, banPrototypeModifications;
        }
        if (operation.op === "move" || operation.op === "copy") {
          return banPrototypeModifications.newDocument = getValueByPointer(document, operation.from), operation.op === "move" && (banPrototypeModifications.removed = document), banPrototypeModifications;
        }
        if (operation.op === "test") {
          banPrototypeModifications.test = _areEquals(document, operation.value);
          if (banPrototypeModifications.test === !1) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          banPrototypeModifications.newDocument = document;
          return banPrototypeModifications;
        }
        if (operation.op === "remove") {
          return banPrototypeModifications.removed = document, banPrototypeModifications.newDocument = null, banPrototypeModifications;
        }
        if (operation.op === "_get") {
          return operation.value = document, banPrototypeModifications;
        }
        if (validateOperation) {
          throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
        }
        return banPrototypeModifications;
      }
      mutateDocument || (document = _deepClone(document));
      mutateDocument = (operation.path || "").split("/");
      var obj = document, t = 1, len = mutateDocument.length, existingPathFragment = void 0, key, validateFunction;
      for (validateFunction = typeof validateOperation == "function" ? validateOperation : validator;;) {
        (key = mutateDocument[t]) && key.indexOf("~") != -1 && (key = unescapePathComponent(key));
        if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && mutateDocument[t - 1] == "constructor")) {
          throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
        }
        validateOperation && existingPathFragment === void 0 && (obj[key] === void 0 ? existingPathFragment = mutateDocument.slice(0, t).join("/") : t == len - 1 && (existingPathFragment = operation.path), existingPathFragment !== void 0 && validateFunction(operation, 0, document, existingPathFragment));
        t++;
        if (Array.isArray(obj)) {
          if (key === "-") {
            key = obj.length;
          } else {
            if (validateOperation && !isInteger(key)) {
              throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
            }
            isInteger(key) && (key = ~~key);
          }
          if (t >= len) {
            if (validateOperation && operation.op === "add" && key > obj.length) {
              throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
            }
            banPrototypeModifications = arrOps[operation.op].call(operation, obj, key, document);
            if (banPrototypeModifications.test === !1) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
            }
            return banPrototypeModifications;
          }
        } else {
          if (t >= len) {
            banPrototypeModifications = objOps[operation.op].call(operation, obj, key, document);
            if (banPrototypeModifications.test === !1) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
            }
            return banPrototypeModifications;
          }
        }
        obj = obj[key];
        if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
          throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
        }
      }
    }
    function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
      mutateDocument === void 0 && (mutateDocument = !0);
      banPrototypeModifications === void 0 && (banPrototypeModifications = !0);
      if (validateOperation && !Array.isArray(patch)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
      mutateDocument || (document = _deepClone(document));
      mutateDocument = Array(patch.length);
      for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        mutateDocument[i] = applyOperation(document, patch[i], validateOperation, !0, banPrototypeModifications, i), document = mutateDocument[i].newDocument;
      }
      mutateDocument.newDocument = document;
      return mutateDocument;
    }
    function validator(operation, index, document, existingPathFragment) {
      if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
        throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document);
      }
      if (objOps[operation.op]) {
        if (typeof operation.path !== "string") {
          throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document);
        }
        if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
          throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document);
        }
        if (operation.op !== "move" && operation.op !== "copy" || typeof operation.from === "string") {
          if (operation.op !== "add" && operation.op !== "replace" && operation.op !== "test" || operation.value !== void 0) {
            if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
              throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document);
            }
            if (document) {
              if (operation.op == "add") {
                var pathLen = operation.path.split("/").length;
                existingPathFragment = existingPathFragment.split("/").length;
                if (pathLen !== existingPathFragment + 1 && pathLen !== existingPathFragment) {
                  throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document);
                }
              } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
                if (operation.path !== existingPathFragment) {
                  throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
                }
              } else if ((operation.op === "move" || operation.op === "copy") && (pathLen = validate([{op:"_get", path:operation.from, value:void 0}], document)) && pathLen.name === "OPERATION_PATH_UNRESOLVABLE") {
                throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document);
              }
            }
          } else {
            throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document);
          }
        } else {
          throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document);
        }
      } else {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
      }
    }
    function validate(sequence, document, externalValidator) {
      try {
        if (!Array.isArray(sequence)) {
          throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
        }
        if (document) {
          applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || !0);
        } else {
          externalValidator = externalValidator || validator;
          for (var i = 0; i < sequence.length; i++) {
            externalValidator(sequence[i], i, document, void 0);
          }
        }
      } catch (e) {
        if (e instanceof JsonPatchError) {
          return e;
        }
        throw e;
      }
    }
    function _areEquals(a, b) {
      if (a === b) {
        return !0;
      }
      if (a && b && typeof a == "object" && typeof b == "object") {
        var arrA = Array.isArray(a), arrB = Array.isArray(b);
        if (arrA && arrB) {
          var length = a.length;
          if (length != b.length) {
            return !1;
          }
          for (arrA = length; arrA-- !== 0;) {
            if (!_areEquals(a[arrA], b[arrA])) {
              return !1;
            }
          }
          return !0;
        }
        if (arrA != arrB) {
          return !1;
        }
        arrB = Object.keys(a);
        length = arrB.length;
        if (length !== Object.keys(b).length) {
          return !1;
        }
        for (arrA = length; arrA-- !== 0;) {
          if (!b.hasOwnProperty(arrB[arrA])) {
            return !1;
          }
        }
        for (arrA = length; arrA-- !== 0;) {
          if (length = arrB[arrA], !_areEquals(a[length], b[length])) {
            return !1;
          }
        }
        return !0;
      }
      return a !== a && b !== b;
    }
    function generate(observer, invertible) {
      invertible === void 0 && (invertible = !1);
      var mirror = beforeDict.get(observer.object);
      _generate(mirror.value, observer.object, observer.patches, "", invertible);
      observer.patches.length && applyPatch(mirror.value, observer.patches);
      invertible = observer.patches;
      invertible.length > 0 && (observer.patches = [], observer.callback && observer.callback(invertible));
      return invertible;
    }
    function _generate(mirror, obj, patches, path, invertible) {
      if (obj !== mirror) {
        typeof obj.toJSON === "function" && (obj = obj.toJSON());
        for (var newKeys = _objectKeys(obj), oldKeys = _objectKeys(mirror), deleted = !1, t = oldKeys.length - 1; t >= 0; t--) {
          var key = oldKeys[t], oldVal = mirror[key];
          if (!_hasOwnProperty.call(obj, key) || obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === !1) {
            Array.isArray(mirror) === Array.isArray(obj) ? (invertible && patches.push({op:"test", path:path + "/" + escapePathComponent(key), value:_deepClone(oldVal)}), patches.push({op:"remove", path:path + "/" + escapePathComponent(key)}), deleted = !0) : (invertible && patches.push({op:"test", path, value:mirror}), patches.push({op:"replace", path, value:obj}));
          } else {
            var newVal = obj[key];
            typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal) ? _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible) : oldVal !== newVal && (invertible && patches.push({op:"test", path:path + "/" + escapePathComponent(key), value:_deepClone(oldVal)}), patches.push({op:"replace", path:path + "/" + escapePathComponent(key), value:_deepClone(newVal)}));
          }
        }
        if (deleted || newKeys.length != oldKeys.length) {
          for (t = 0; t < newKeys.length; t++) {
            key = newKeys[t], _hasOwnProperty.call(mirror, key) || obj[key] === void 0 || patches.push({op:"add", path:path + "/" + escapePathComponent(key), value:_deepClone(obj[key])});
          }
        }
      }
    }
    function stringify$1(passedObj, options = {}) {
      const indent = JSON.stringify([1], void 0, options.indent === void 0 ? 2 : options.indent).slice(2, -3), maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
      let {replacer} = options;
      return function _stringify(obj, currentIndent, reserved) {
        obj && typeof obj.toJSON === "function" && (obj = obj.toJSON());
        const string = JSON.stringify(obj, replacer);
        if (string === void 0) {
          return string;
        }
        reserved = maxLength - currentIndent.length - reserved;
        if (string.length <= reserved) {
          var prettified = string.replace(stringOrChar, (match, stringLiteral) => stringLiteral || `${match} `);
          if (prettified.length <= reserved) {
            return prettified;
          }
        }
        replacer != null && (obj = JSON.parse(string), replacer = void 0);
        if (typeof obj === "object" && obj !== null) {
          reserved = currentIndent + indent;
          prettified = [];
          let index = 0, start, end;
          if (Array.isArray(obj)) {
            start = "[";
            end = "]";
            for (var {length:length$jscomp$0} = obj; index < length$jscomp$0; index++) {
              prettified.push(_stringify(obj[index], reserved, index === length$jscomp$0 - 1 ? 0 : 1) || "null");
            }
          } else {
            start = "{";
            end = "}";
            length$jscomp$0 = Object.keys(obj);
            const {length} = length$jscomp$0;
            for (; index < length; index++) {
              var key = length$jscomp$0[index];
              const keyPart = `${JSON.stringify(key)}: `;
              key = _stringify(obj[key], reserved, keyPart.length + (index === length - 1 ? 0 : 1));
              key !== void 0 && prettified.push(keyPart + key);
            }
          }
          if (prettified.length > 0) {
            return [start, indent + prettified.join(`,\n${reserved}`), end].join(`\n${currentIndent}`);
          }
        }
        return string;
      }(passedObj, "", 0);
    }
    function requireLrucache() {
      if (hasRequiredLrucache) {
        return lrucache;
      }
      hasRequiredLrucache = 1;
      class LRUCache {
        constructor() {
          this.max = 1000;
          this.map = new Map();
        }
        get(key) {
          const value = this.map.get(key);
          if (value !== void 0) {
            return this.map.delete(key), this.map.set(key, value), value;
          }
        }
        delete(key) {
          return this.map.delete(key);
        }
        set(key, value) {
          if (!this.delete(key) && value !== void 0) {
            if (this.map.size >= this.max) {
              const firstKey = this.map.keys().next().value;
              this.delete(firstKey);
            }
            this.map.set(key, value);
          }
          return this;
        }
      }
      return lrucache = LRUCache;
    }
    function requireParseOptions() {
      if (hasRequiredParseOptions) {
        return parseOptions_1;
      }
      hasRequiredParseOptions = 1;
      const looseOption = Object.freeze({loose:!0}), emptyOpts = Object.freeze({});
      return parseOptions_1 = options => options ? typeof options !== "object" ? looseOption : options : emptyOpts;
    }
    function requireConstants() {
      if (hasRequiredConstants) {
        return constants;
      }
      hasRequiredConstants = 1;
      return constants = {MAX_LENGTH:256, MAX_SAFE_COMPONENT_LENGTH:16, MAX_SAFE_BUILD_LENGTH:250, MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER || 9007199254740991, RELEASE_TYPES:"major premajor minor preminor patch prepatch prerelease".split(" "), SEMVER_SPEC_VERSION:"2.0.0", FLAG_INCLUDE_PRERELEASE:1, FLAG_LOOSE:2};
    }
    function requireDebug() {
      if (hasRequiredDebug) {
        return debug_1;
      }
      hasRequiredDebug = 1;
      return debug_1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
    }
    function requireRe() {
      if (hasRequiredRe) {
        return re.exports;
      }
      hasRequiredRe = 1;
      (function(module, exports) {
        const {MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH} = requireConstants(), debug = requireDebug();
        exports = module.exports = {};
        const re = exports.re = [], safeRe = exports.safeRe = [], src = exports.src = [], t = exports.t = {};
        let R = 0;
        const safeRegexReplacements = [["\\s", 1], ["\\d", MAX_LENGTH], ["[a-zA-Z0-9-]", MAX_SAFE_BUILD_LENGTH]];
        module = (name, value, isGlobal) => {
          var JSCompiler_inline_result = value;
          for (const [token, max] of safeRegexReplacements) {
            JSCompiler_inline_result = JSCompiler_inline_result.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
          }
          const index = R++;
          debug(name, index, value);
          t[name] = index;
          src[index] = value;
          re[index] = new RegExp(value, isGlobal ? "g" : void 0);
          safeRe[index] = new RegExp(JSCompiler_inline_result, isGlobal ? "g" : void 0);
        };
        module("NUMERICIDENTIFIER", "0|[1-9]\\d*");
        module("NUMERICIDENTIFIERLOOSE", "\\d+");
        module("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
        module("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
        module("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
        module("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
        module("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
        module("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
        module("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
        module("BUILDIDENTIFIER", "[a-zA-Z0-9-]+");
        module("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
        module("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
        module("FULL", `^${src[t.FULLPLAIN]}$`);
        module("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
        module("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
        module("GTLT", "((?:\x3c|\x3e)?\x3d?)");
        module("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
        module("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
        module("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + ")?)?");
        module("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + ")?)?");
        module("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
        module("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
        module("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
        module("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
        module("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + "(?:$|[^\\d])");
        module("COERCERTL", src[t.COERCE], !0);
        module("COERCERTLFULL", src[t.COERCEFULL], !0);
        module("LONETILDE", "(?:~\x3e?)");
        module("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0);
        exports.tildeTrimReplace = "$1~";
        module("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
        module("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
        module("LONECARET", "(?:\\^)");
        module("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0);
        exports.caretTrimReplace = "$1^";
        module("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
        module("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
        module("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
        module("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
        module("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0);
        exports.comparatorTrimReplace = "$1$2$3";
        module("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + "\\s+-\\s+" + `(${src[t.XRANGEPLAIN]})` + "\\s*$");
        module("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + "\\s+-\\s+" + `(${src[t.XRANGEPLAINLOOSE]})` + "\\s*$");
        module("STAR", "(\x3c|\x3e)?\x3d?\\s*\\*");
        module("GTE0", "^\\s*\x3e\x3d\\s*0\\.0\\.0\\s*$");
        module("GTE0PRE", "^\\s*\x3e\x3d\\s*0\\.0\\.0-0\\s*$");
      })(re, re.exports);
      return re.exports;
    }
    function requireIdentifiers() {
      if (hasRequiredIdentifiers) {
        return identifiers;
      }
      hasRequiredIdentifiers = 1;
      const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
        const anum = numeric.test(a), bnum = numeric.test(b);
        anum && bnum && (a = +a, b = +b);
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      return identifiers = {compareIdentifiers, rcompareIdentifiers:(a, b) => compareIdentifiers(b, a)};
    }
    function requireSemver() {
      if (hasRequiredSemver) {
        return semver;
      }
      hasRequiredSemver = 1;
      const debug = requireDebug(), {MAX_LENGTH, MAX_SAFE_INTEGER} = requireConstants(), {safeRe:re, t} = requireRe(), parseOptions = requireParseOptions(), {compareIdentifiers} = requireIdentifiers();
      class SemVer {
        constructor(version, options) {
          options = parseOptions(options);
          if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
              return version;
            }
            version = version.version;
          } else if (typeof version !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
          }
          debug("SemVer", version, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          options = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!options) {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          this.raw = version;
          this.major = +options[1];
          this.minor = +options[2];
          this.patch = +options[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          this.prerelease = options[4] ? options[4].split(".").map(id => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          }) : [];
          this.build = options[5] ? options[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`);
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          other instanceof SemVer || (other = new SemVer(other, this.options));
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          other instanceof SemVer || (other = new SemVer(other, this.options));
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          }
          if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          }
          if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i], b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            }
            if (b === void 0) {
              return 1;
            }
            if (a === void 0) {
              return -1;
            }
            if (a !== b) {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          other instanceof SemVer || (other = new SemVer(other, this.options));
          let i = 0;
          do {
            const a = this.build[i], b = other.build[i];
            debug("build compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            }
            if (b === void 0) {
              return 1;
            }
            if (a === void 0) {
              return -1;
            }
            if (a !== b) {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        inc(release, identifier, identifierBase) {
          switch(release) {
            case "premajor":
              this.minor = this.patch = this.prerelease.length = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.patch = this.prerelease.length = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++;
              this.patch = this.minor = 0;
              this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++;
              this.prerelease = [];
              break;
            case "pre":
              release = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === !1) {
                throw Error("invalid increment argument: identifier is empty");
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [release];
              } else {
                let i = this.prerelease.length;
                for (; --i >= 0;) {
                  typeof this.prerelease[i] === "number" && (this.prerelease[i]++, i = -2);
                }
                if (i === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === !1) {
                    throw Error("invalid increment argument: identifier already exists");
                  }
                  this.prerelease.push(release);
                }
              }
              identifier && (release = [identifier, release], identifierBase === !1 && (release = [identifier]), compareIdentifiers(this.prerelease[0], identifier) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = release) : this.prerelease = release);
              break;
            default:
              throw Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          this.build.length && (this.raw += `+${this.build.join(".")}`);
          return this;
        }
      }
      return semver = SemVer;
    }
    function requireCompare() {
      if (hasRequiredCompare) {
        return compare_1;
      }
      hasRequiredCompare = 1;
      const SemVer = requireSemver();
      return compare_1 = (a, b, loose) => (new SemVer(a, loose)).compare(new SemVer(b, loose));
    }
    function requireEq() {
      if (hasRequiredEq) {
        return eq_1;
      }
      hasRequiredEq = 1;
      const compare = requireCompare();
      return eq_1 = (a, b, loose) => compare(a, b, loose) === 0;
    }
    function requireNeq() {
      if (hasRequiredNeq) {
        return neq_1;
      }
      hasRequiredNeq = 1;
      const compare = requireCompare();
      return neq_1 = (a, b, loose) => compare(a, b, loose) !== 0;
    }
    function requireGt() {
      if (hasRequiredGt) {
        return gt_1;
      }
      hasRequiredGt = 1;
      const compare = requireCompare();
      return gt_1 = (a, b, loose) => compare(a, b, loose) > 0;
    }
    function requireGte() {
      if (hasRequiredGte) {
        return gte_1;
      }
      hasRequiredGte = 1;
      const compare = requireCompare();
      return gte_1 = (a, b, loose) => compare(a, b, loose) >= 0;
    }
    function requireLt() {
      if (hasRequiredLt) {
        return lt_1;
      }
      hasRequiredLt = 1;
      const compare = requireCompare();
      return lt_1 = (a, b, loose) => compare(a, b, loose) < 0;
    }
    function requireLte() {
      if (hasRequiredLte) {
        return lte_1;
      }
      hasRequiredLte = 1;
      const compare = requireCompare();
      return lte_1 = (a, b, loose) => compare(a, b, loose) <= 0;
    }
    function requireCmp() {
      if (hasRequiredCmp) {
        return cmp_1;
      }
      hasRequiredCmp = 1;
      const eq = requireEq(), neq = requireNeq(), gt = requireGt(), gte = requireGte(), lt = requireLt(), lte = requireLte();
      return cmp_1 = (a, op, b, loose) => {
        switch(op) {
          case "\x3d\x3d\x3d":
            return typeof a === "object" && (a = a.version), typeof b === "object" && (b = b.version), a === b;
          case "!\x3d\x3d":
            return typeof a === "object" && (a = a.version), typeof b === "object" && (b = b.version), a !== b;
          case "":
          case "\x3d":
          case "\x3d\x3d":
            return eq(a, b, loose);
          case "!\x3d":
            return neq(a, b, loose);
          case "\x3e":
            return gt(a, b, loose);
          case "\x3e\x3d":
            return gte(a, b, loose);
          case "\x3c":
            return lt(a, b, loose);
          case "\x3c\x3d":
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
    }
    function requireComparator() {
      if (hasRequiredComparator) {
        return comparator;
      }
      hasRequiredComparator = 1;
      const ANY = Symbol("SemVer ANY");
      class Comparator {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            }
            comp = comp.value;
          }
          comp = comp.trim().split(/\s+/).join(" ");
          debug("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          this.value = this.semver === ANY ? "" : this.operator + this.semver.version;
          debug("comp", this);
        }
        parse(comp) {
          const m = comp.match(this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          this.operator === "\x3d" && (this.operator = "");
          this.semver = m[2] ? new SemVer(m[2], this.options.loose) : ANY;
        }
        toString() {
          return this.value;
        }
        test(version) {
          debug("Comparator.test", version, this.options.loose);
          if (this.semver === ANY || version === ANY) {
            return !0;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer(version, this.options);
            } catch (er) {
              return !1;
            }
          }
          return cmp(version, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (this.operator === "") {
            return this.value === "" ? !0 : (new Range(comp.value, options)).test(this.value);
          }
          if (comp.operator === "") {
            return comp.value === "" ? !0 : (new Range(this.value, options)).test(comp.semver);
          }
          options = parseOptions(options);
          return options.includePrerelease && (this.value === "\x3c0.0.0-0" || comp.value === "\x3c0.0.0-0") || !options.includePrerelease && (this.value.startsWith("\x3c0.0.0") || comp.value.startsWith("\x3c0.0.0")) ? !1 : this.operator.startsWith("\x3e") && comp.operator.startsWith("\x3e") || this.operator.startsWith("\x3c") && comp.operator.startsWith("\x3c") || this.semver.version === comp.semver.version && this.operator.includes("\x3d") && comp.operator.includes("\x3d") || cmp(this.semver, "\x3c", 
          comp.semver, options) && this.operator.startsWith("\x3e") && comp.operator.startsWith("\x3c") || cmp(this.semver, "\x3e", comp.semver, options) && this.operator.startsWith("\x3c") && comp.operator.startsWith("\x3e") ? !0 : !1;
        }
      }
      comparator = Comparator;
      const parseOptions = requireParseOptions(), {safeRe:re, t} = requireRe(), cmp = requireCmp(), debug = requireDebug(), SemVer = requireSemver(), Range = requireRange();
      return comparator;
    }
    function requireRange() {
      if (hasRequiredRange) {
        return range;
      }
      hasRequiredRange = 1;
      const SPACE_CHARACTERS = /\s+/g;
      class Range {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range) {
            return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
          }
          if (range instanceof Comparator) {
            return this.raw = range.value, this.set = [[range]], this.formatted = void 0, this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
          this.set = this.raw.split("||").map(r => this.parseRange(r.trim())).filter(c => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
          }
          if (this.set.length > 1) {
            if (range = this.set[0], this.set = this.set.filter(c => c[0].value !== "\x3c0.0.0-0"), this.set.length === 0) {
              this.set = [range];
            } else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && c[0].value === "") {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.formatted = void 0;
        }
        get range() {
          if (this.formatted === void 0) {
            this.formatted = "";
            for (let i = 0; i < this.set.length; i++) {
              i > 0 && (this.formatted += "||");
              const comps = this.set[i];
              for (let k = 0; k < comps.length; k++) {
                k > 0 && (this.formatted += " "), this.formatted += comps[k].toString().trim();
              }
            }
          }
          return this.formatted;
        }
        format() {
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          const memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range;
          var cached = cache.get(memoKey);
          if (cached) {
            return cached;
          }
          cached = this.options.loose;
          range = range.replace(cached ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE], hyphenReplace(this.options.includePrerelease));
          debug("hyphen replace", range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug("comparator trim", range);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          debug("tilde trim", range);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          debug("caret trim", range);
          range = range.split(" ").map(comp$jscomp$0 => {
            var comp = comp$jscomp$0;
            comp$jscomp$0 = this.options;
            debug("comp", comp, comp$jscomp$0);
            comp = replaceCarets(comp, comp$jscomp$0);
            debug("caret", comp);
            comp = replaceTildes(comp, comp$jscomp$0);
            debug("tildes", comp);
            comp = replaceXRanges(comp, comp$jscomp$0);
            debug("xrange", comp);
            debug("replaceStars", comp, comp$jscomp$0);
            comp = comp.trim().replace(re[t.STAR], "");
            debug("stars", comp);
            return comp;
          }).join(" ").split(/\s+/).map(comp => {
            var options = this.options;
            debug("replaceGTE0", comp, options);
            return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
          });
          cached && (range = range.filter(comp => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          }));
          debug("range list", range);
          cached = new Map();
          range = range.map(comp => new Comparator(comp, this.options));
          for (var comp of range) {
            if (comp.value === "\x3c0.0.0-0") {
              return [comp];
            }
            cached.set(comp.value, comp);
          }
          cached.size > 1 && cached.has("") && cached.delete("");
          comp = [...cached.values()];
          cache.set(memoKey, comp);
          return comp;
        }
        intersects(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some(thisComparators => isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => rangeComparators.every(rangeComparator => thisComparator.intersects(rangeComparator, options)))));
        }
        test(version$jscomp$0) {
          if (!version$jscomp$0) {
            return !1;
          }
          if (typeof version$jscomp$0 === "string") {
            try {
              version$jscomp$0 = new SemVer(version$jscomp$0, this.options);
            } catch (er) {
              return !1;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            a: {
              var JSCompiler_inline_result = this.set[i];
              var version = version$jscomp$0, options = this.options;
              for (var i$jscomp$0 = 0; i$jscomp$0 < JSCompiler_inline_result.length; i$jscomp$0++) {
                if (!JSCompiler_inline_result[i$jscomp$0].test(version)) {
                  JSCompiler_inline_result = !1;
                  break a;
                }
              }
              if (version.prerelease.length && !options.includePrerelease) {
                for (options = 0; options < JSCompiler_inline_result.length; options++) {
                  if (debug(JSCompiler_inline_result[options].semver), JSCompiler_inline_result[options].semver !== Comparator.ANY && JSCompiler_inline_result[options].semver.prerelease.length > 0 && (i$jscomp$0 = JSCompiler_inline_result[options].semver, i$jscomp$0.major === version.major && i$jscomp$0.minor === version.minor && i$jscomp$0.patch === version.patch)) {
                    JSCompiler_inline_result = !0;
                    break a;
                  }
                }
                JSCompiler_inline_result = !1;
              } else {
                JSCompiler_inline_result = !0;
              }
            }
            if (JSCompiler_inline_result) {
              return !0;
            }
          }
          return !1;
        }
      }
      range = Range;
      const cache = new (requireLrucache())(), parseOptions = requireParseOptions(), Comparator = requireComparator(), debug = requireDebug(), SemVer = requireSemver(), {safeRe:re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace} = requireRe(), {FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE} = requireConstants(), isSatisfiable = (comparators, options) => {
        let result = !0;
        comparators = comparators.slice();
        let testComparator = comparators.pop();
        for (; result && comparators.length;) {
          result = comparators.every(otherComparator => testComparator.intersects(otherComparator, options)), testComparator = comparators.pop();
        }
        return result;
      }, isX = id => !id || id.toLowerCase() === "x" || id === "*", replaceTildes = (comp, options) => comp.trim().split(/\s+/).map(c => replaceTilde(c, options)).join(" "), replaceTilde = (comp, options) => comp.replace(options.loose ? re[t.TILDELOOSE] : re[t.TILDE], (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        isX(M) ? _ = "" : isX(m) ? _ = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? _ = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), _ = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : _ = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        debug("tilde return", _);
        return _;
      }), replaceCarets = (comp, options) => comp.trim().split(/\s+/).map(c => replaceCaret(c, options)).join(" "), replaceCaret = (comp, options) => {
        debug("caret", comp, options);
        const z = options.includePrerelease ? "-0" : "";
        return comp.replace(options.loose ? re[t.CARETLOOSE] : re[t.CARET], (_, M, m, p, pr) => {
          debug("caret", comp, _, M, m, p, pr);
          isX(M) ? _ = "" : isX(m) ? _ = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? _ = M === "0" ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), _ = M === "0" ? m === "0" ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), _ = M === "0" ? m === "0" ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 
          1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`);
          debug("caret return", _);
          return _;
        });
      }, replaceXRanges = (comp, options) => {
        debug("replaceXRanges", comp, options);
        return comp.split(/\s+/).map(c => replaceXRange(c, options)).join(" ");
      }, replaceXRange = (comp, options) => {
        comp = comp.trim();
        return comp.replace(options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE], (ret, gtlt, M, m, p, pr) => {
          debug("xRange", comp, ret, gtlt, M, m, p, pr);
          const xM = isX(M), xm = xM || isX(m);
          p = xm || isX(p);
          gtlt === "\x3d" && p && (gtlt = "");
          pr = options.includePrerelease ? "-0" : "";
          xM ? ret = gtlt === "\x3e" || gtlt === "\x3c" ? "\x3c0.0.0-0" : "*" : gtlt && p ? (xm && (m = 0), p = 0, gtlt === "\x3e" ? (gtlt = "\x3e\x3d", xm ? (M = +M + 1, m = 0) : m = +m + 1, p = 0) : gtlt === "\x3c\x3d" && (gtlt = "\x3c", xm ? M = +M + 1 : m = +m + 1), gtlt === "\x3c" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : p && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`);
          debug("xRange return", ret);
          return ret;
        });
      }, hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
        from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`;
        to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`;
        return `${from} ${to}`.trim();
      };
      return range;
    }
    function interpret(ast, fn, params, datum, event, item) {
      const $ = n => Visitors[n.type]($, n);
      $.memberDepth = 0;
      $.fn = Object.create(fn);
      $.params = params;
      $.datum = datum;
      $.event = event;
      $.item = item;
      EventFunctions.forEach(f => $.fn[f] = function() {
        return event.vega[f](...arguments);
      });
      return $(ast);
    }
    function e(e) {
      const [n, r] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
      return {library:n, version:r};
    }
    function genCarbonConfig({theme, background}) {
      const type = ["white", "g10"].includes(theme) ? "light" : "dark", viewbg = TOKENS.gridBg[theme], titleColor = TOKENS.textPrimary[theme], textColor = TOKENS.textSecondary[theme], markColor = type === "dark" ? "#d4bbff" : "#6929c4";
      return {background, arc:{fill:markColor}, area:{fill:markColor}, path:{stroke:markColor}, rect:{fill:markColor}, shape:{stroke:markColor}, symbol:{stroke:markColor}, circle:{fill:markColor}, view:{fill:viewbg, stroke:viewbg}, group:{fill:viewbg}, title:{color:titleColor, anchor:"start", dy:-15, fontSize:16, font:'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', fontWeight:600}, axis:{labelColor:textColor, labelFontSize:12, labelFont:'IBM Plex Sans Condensed, system-ui, -apple-system, BlinkMacSystemFont, ".SFNSText-Regular", sans-serif', 
      labelFontWeight:400, titleColor, titleFontWeight:600, titleFontSize:12, grid:!0, gridColor:TOKENS.layerAccent01[theme], labelAngle:0}, axisX:{titlePadding:10}, axisY:{titlePadding:2.5}, style:{"guide-label":{font:'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', fill:textColor, fontWeight:400}, "guide-title":{font:'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', fill:textColor, fontWeight:400}}, range:{category:type === 
      "dark" ? darkCategories : lightCategories, diverging:"#750e13 #a2191f #da1e28 #fa4d56 #ff8389 #ffb3b8 #ffd7d9 #fff1f1 #e5f6ff #bae6ff #82cfff #33b1ff #1192e8 #0072c3 #00539a #003a6d".split(" "), heatmap:"#f6f2ff #e8daff #d4bbff #be95ff #a56eff #8a3ffc #6929c4 #491d8b #31135e #1c0f30".split(" ")}};
    }
    function accessor(fn, fields, name) {
      fn.fields = fields || [];
      fn.fname = name;
      return fn;
    }
    function splitAccessPath(p) {
      function push() {
        path.push(s + p.substring(i, j));
        s = "";
        i = j + 1;
      }
      const path = [], n = p.length;
      let q = null, b = 0, s = "", i, j, c;
      p += "";
      for (i = j = 0; j < n; ++j) {
        if (c = p[j], c === "\\") {
          s += p.substring(i, j++), i = j;
        } else if (c === q) {
          push(), q = null, b = -1;
        } else if (!q) {
          if (i === b && c === '"') {
            i = j + 1, q = c;
          } else if (i === b && c === "'") {
            i = j + 1, q = c;
          } else if (c === "." && !b) {
            j > i ? push() : i = j + 1;
          } else if (c === "[") {
            j > i && push(), b = i = j + 1;
          } else if (c === "]") {
            if (!b) {
              throw Error("Access path missing open bracket: " + p);
            }
            b > 0 && push();
            b = 0;
            i = j + 1;
          }
        }
      }
      if (b) {
        throw Error("Access path missing closing bracket: " + p);
      }
      if (q) {
        throw Error("Access path missing closing quote: " + p);
      }
      j > i && (j++, push());
      return path;
    }
    function replacer(maxDepth) {
      const stack = [];
      return function(key, value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        key = stack.indexOf(this) + 1;
        stack.length = key;
        if (stack.length > maxDepth) {
          return "[Object]";
        }
        if (stack.indexOf(value) >= 0) {
          return "[Circular]";
        }
        stack.push(value);
        return value;
      };
    }
    function calculatePositionRelativeToCursor(event, tooltipBox, {offsetX, offsetY}) {
      event = getPositions({x1:event.clientX, x2:event.clientX, y1:event.clientY, y2:event.clientY}, tooltipBox, offsetX, offsetY);
      offsetX = ["bottom-right", "bottom-left", "top-right", "top-left"];
      for (const p of offsetX) {
        if (tooltipIsInViewport(event[p], tooltipBox)) {
          return event[p];
        }
      }
      return event["top-left"];
    }
    function getPositions(markBounds, tooltipBox, offsetX, offsetY) {
      const left = markBounds.x1 - tooltipBox.width - offsetX, center = (markBounds.x1 + markBounds.x2) / 2 - tooltipBox.width / 2;
      offsetX = markBounds.x2 + offsetX;
      const top = markBounds.y1 - tooltipBox.height - offsetY;
      tooltipBox = (markBounds.y1 + markBounds.y2) / 2 - tooltipBox.height / 2;
      markBounds = markBounds.y2 + offsetY;
      return {top:{x:center, y:top}, bottom:{x:center, y:markBounds}, left:{x:left, y:tooltipBox}, right:{x:offsetX, y:tooltipBox}, "top-left":{x:left, y:top}, "top-right":{x:offsetX, y:top}, "bottom-left":{x:left, y:markBounds}, "bottom-right":{x:offsetX, y:markBounds}};
    }
    function tooltipIsInViewport(position, tooltipBox) {
      return position.x >= 0 && position.y >= 0 && position.x + tooltipBox.width <= window.innerWidth && position.y + tooltipBox.height <= window.innerHeight;
    }
    function post(window, url, data) {
      function listen(evt) {
        evt.source === editor && (count = 0, window.removeEventListener("message", listen, !1));
      }
      function send() {
        count <= 0 || (editor.postMessage(data, origin), setTimeout(send, 250), --count);
      }
      const editor = window.open(url), {origin} = new URL(url);
      let count = 40;
      window.addEventListener("message", listen, !1);
      setTimeout(send, 250);
    }
    function mergeDeep(dest, ...src) {
      for (const s of src) {
        src = dest;
        for (const property of Object.keys(s)) {
          vegaImport.writeConfig(src, property, s[property], !0);
        }
      }
      return dest;
    }
    function viewSource(source, sourceHeader, sourceFooter, mode) {
      sourceHeader = `<html><head>${sourceHeader}</head><body><pre><code class="json">`;
      sourceFooter = `</code></pre>${sourceFooter}</body></html>`;
      const win = window.open("");
      win.document.write(sourceHeader + source + sourceFooter);
      win.document.title = `${NAMES[mode]} JSON Source`;
    }
    function guessMode(spec, providedMode) {
      return spec.$schema ? (spec = e(spec.$schema), providedMode && providedMode !== spec.library && console.warn(`The given visualization spec is written in ${NAMES[spec.library]}, but mode argument sets ${NAMES[providedMode] ?? providedMode}.`), providedMode = spec.library, satisfies(VERSION[providedMode], `^${spec.version.slice(1)}`) || console.warn(`The input spec uses ${NAMES[providedMode]} ${spec.version}, but the current version of ${NAMES[providedMode]} is v${VERSION[providedMode]}.`), providedMode) : 
      "mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec ? "vega-lite" : "marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec ? "vega" : providedMode ?? "vega";
    }
    function createLoader(opts) {
      return opts && "load" in opts ? opts : vega.loader(opts);
    }
    async function embed(el, spec, opts$jscomp$0 = {}) {
      let loader;
      vegaImport.isString(spec) && (loader = createLoader(opts$jscomp$0.loader), spec = JSON.parse(await loader.load(spec)));
      var opts = spec.usermeta?.embedOptions ?? {};
      vegaImport.isString(opts.defaultStyle) && (opts.defaultStyle = !1);
      const usermetaLoader = opts.loader;
      if (!loader || usermetaLoader) {
        loader = createLoader(opts$jscomp$0.loader ?? usermetaLoader);
      }
      opts = await loadOpts(opts, loader);
      opts$jscomp$0 = await loadOpts(opts$jscomp$0, loader);
      opts$jscomp$0 = {...mergeDeep(opts$jscomp$0, opts), config:vegaImport.mergeConfig(opts$jscomp$0.config ?? {}, opts.config ?? {})};
      return await _embed(el, spec, opts$jscomp$0, loader);
    }
    async function loadOpts(opt, loader) {
      const config = vegaImport.isString(opt.config) ? JSON.parse(await loader.load(opt.config)) : opt.config ?? {};
      loader = vegaImport.isString(opt.patch) ? JSON.parse(await loader.load(opt.patch)) : opt.patch;
      return {...opt, ...(loader ? {patch:loader} : {}), ...(config ? {config} : {})};
    }
    function getRoot(el) {
      el = el.getRootNode ? el.getRootNode() : document;
      return el instanceof ShadowRoot ? {root:el, rootContainer:el} : {root:document, rootContainer:document.head ?? document.body};
    }
    async function _embed(el, spec, opts = {}, loader) {
      const config = opts.theme ? vegaImport.mergeConfig(themes[opts.theme], opts.config ?? {}) : opts.config;
      var actions = vegaImport.isBoolean(opts.actions) ? opts.actions : mergeDeep({}, DEFAULT_ACTIONS, opts.actions ?? {});
      const i18n = {...I18N, ...opts.i18n}, renderer = opts.renderer ?? "canvas";
      var logLevel = opts.logLevel ?? vega.Warn, downloadFileName = opts.downloadFileName ?? "visualization", element = typeof el === "string" ? document.querySelector(el) : el;
      if (!element) {
        throw Error(`${el} does not exist`);
      }
      if (opts.defaultStyle !== !1) {
        const {root, rootContainer} = getRoot(element);
        root.getElementById("vega-embed-style") || (el = document.createElement("style"), el.id = "vega-embed-style", el.innerHTML = opts.defaultStyle === void 0 || opts.defaultStyle === !0 ? '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) \x3e :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n'.toString() : 
        opts.defaultStyle, rootContainer.appendChild(el));
      }
      const mode = guessMode(spec, opts.mode);
      let vgSpec = PREPROCESSOR[mode](spec, config);
      mode === "vega-lite" && vgSpec.$schema && (el = e(vgSpec.$schema), satisfies(VERSION.vega, `^${el.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${el.version}, but current version is v${VERSION.vega}.`));
      element.classList.add("vega-embed");
      actions && element.classList.add("has-actions");
      element.innerHTML = "";
      let container = element;
      actions && (el = document.createElement("div"), el.classList.add("chart-wrapper"), element.appendChild(el), container = el);
      const patch = opts.patch;
      patch && (vgSpec = patch instanceof Function ? patch(vgSpec) : applyPatch(vgSpec, patch, !0, !1).newDocument);
      opts.formatLocale && vega.formatLocale(opts.formatLocale);
      opts.timeFormatLocale && vega.timeFormatLocale(opts.timeFormatLocale);
      if (opts.expressionFunctions) {
        for (var name in opts.expressionFunctions) {
          el = opts.expressionFunctions[name], "fn" in el ? vega.expressionFunction(name, el.fn, el.visitor) : el instanceof Function && vega.expressionFunction(name, el);
        }
      }
      ({ast:name} = opts);
      el = vega.parse(vgSpec, mode === "vega-lite" ? {} : config, {ast:name});
      const view = new (opts.viewClass || vega.View)(el, {loader, logLevel, renderer, ...(name ? {expr:vega.expressionInterpreter ?? opts.expr ?? expression} : {})});
      view.addSignalListener("autosize", (_, autosize) => {
        ({type:_} = autosize);
        _ == "fit-x" ? (container.classList.add("fit-x"), container.classList.remove("fit-y")) : _ == "fit-y" ? (container.classList.remove("fit-x"), container.classList.add("fit-y")) : _ == "fit" ? container.classList.add("fit-x", "fit-y") : container.classList.remove("fit-x", "fit-y");
      });
      if (opts.tooltip !== !1) {
        const {loader:loader_, tooltip} = opts;
        loader = !loader_ || loader_ && "load" in loader_ ? void 0 : loader_?.baseURL;
        loader = typeof tooltip === "function" ? tooltip : (new Handler({baseURL:loader, ...(tooltip === !0 ? {} : tooltip)})).call;
        view.tooltip(loader);
      }
      ({hover:loader} = opts);
      loader === void 0 && (loader = mode === "vega");
      if (loader) {
        const {hoverSet, updateSet} = typeof loader === "boolean" ? {} : loader;
        view.hover(hoverSet, updateSet);
      }
      opts && (opts.width != null && view.width(opts.width), opts.height != null && view.height(opts.height), opts.padding != null && view.padding(opts.padding));
      await view.initialize(container, opts.bind).runAsync();
      let documentClickHandler;
      if (actions !== !1) {
        loader = element;
        if (opts.defaultStyle !== !1 || opts.forceActionsMenu) {
          const details = document.createElement("details");
          details.title = i18n.CLICK_TO_VIEW_ACTIONS;
          element.append(details);
          loader = details;
          element = document.createElement("summary");
          element.innerHTML = '\n\x3csvg viewBox\x3d"0 0 16 16" fill\x3d"currentColor" stroke\x3d"none" stroke-width\x3d"1" stroke-linecap\x3d"round" stroke-linejoin\x3d"round"\x3e\n  \x3ccircle r\x3d"2" cy\x3d"8" cx\x3d"2"\x3e\x3c/circle\x3e\n  \x3ccircle r\x3d"2" cy\x3d"8" cx\x3d"8"\x3e\x3c/circle\x3e\n  \x3ccircle r\x3d"2" cy\x3d"8" cx\x3d"14"\x3e\x3c/circle\x3e\n\x3c/svg\x3e';
          details.append(element);
          documentClickHandler = ev => {
            details.contains(ev.target) || details.removeAttribute("open");
          };
          document.addEventListener("click", documentClickHandler);
        }
        element = document.createElement("div");
        loader.append(element);
        element.classList.add("vega-actions");
        if (actions === !0 || actions.export !== !1) {
          for (const ext of ["svg", "png"]) {
            if (actions === !0 || actions.export === !0 || actions.export[ext]) {
              loader = i18n[`${ext.toUpperCase()}_ACTION`];
              logLevel = document.createElement("a");
              const scaleFactor = vegaImport.isObject(opts.scaleFactor) ? opts.scaleFactor[ext] : opts.scaleFactor;
              logLevel.text = loader;
              logLevel.href = "#";
              logLevel.target = "_blank";
              logLevel.download = `${downloadFileName}.${ext}`;
              logLevel.addEventListener("mousedown", async function(e) {
                e.preventDefault();
                this.href = await view.toImageURL(ext, scaleFactor);
              });
              element.append(logLevel);
            }
          }
        }
        if (actions === !0 || actions.source !== !1) {
          downloadFileName = document.createElement("a"), downloadFileName.text = i18n.SOURCE_ACTION, downloadFileName.href = "#", downloadFileName.addEventListener("click", function(e) {
            viewSource(stringify$1(spec), opts.sourceHeader ?? "", opts.sourceFooter ?? "", mode);
            e.preventDefault();
          }), element.append(downloadFileName);
        }
        mode !== "vega-lite" || actions !== !0 && actions.compiled === !1 || (downloadFileName = document.createElement("a"), downloadFileName.text = i18n.COMPILED_ACTION, downloadFileName.href = "#", downloadFileName.addEventListener("click", function(e) {
          viewSource(stringify$1(vgSpec), opts.sourceHeader ?? "", opts.sourceFooter ?? "", "vega");
          e.preventDefault();
        }), element.append(downloadFileName));
        if (actions === !0 || actions.editor !== !1) {
          const editorUrl = opts.editorUrl ?? "https://vega.github.io/editor/";
          actions = document.createElement("a");
          actions.text = i18n.EDITOR_ACTION;
          actions.href = "#";
          actions.addEventListener("click", function(e) {
            post(window, editorUrl, {config, mode:patch ? "vega" : mode, renderer, spec:stringify$1(patch ? vgSpec : spec)});
            e.preventDefault();
          });
          element.append(actions);
        }
      }
      return {view, spec, vgSpec, finalize:function() {
        documentClickHandler && document.removeEventListener("click", documentClickHandler);
        view.finalize();
      }, embedOptions:opts};
    }
    async function container(spec, opt = {}) {
      const wrapper = document.createElement("div");
      wrapper.classList.add("vega-embed-wrapper");
      const div = document.createElement("div");
      wrapper.appendChild(div);
      spec = await embed(div, spec, {actions:opt.actions === !0 || opt.actions === !1 ? opt.actions : {export:!0, source:!1, compiled:!0, editor:!0, ...opt.actions}, ...opt});
      wrapper.value = spec.view;
      return wrapper;
    }
    var vegaImport__namespace = _interopNamespaceDefault(vegaImport), vegaLiteImport__namespace = _interopNamespaceDefault(vegaLiteImport), __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__:[]} instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) {
            b.hasOwnProperty(p) && (d[p] = b[p]);
          }
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        function __() {
          this.constructor = d;
        }
        extendStatics(d, b);
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }(), _hasOwnProperty = Object.prototype.hasOwnProperty, PatchError = function(_super) {
      function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor, _this = _super.call(this, patchErrorMessageFormatter(message, {name, index, operation, tree})) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        _this.message = patchErrorMessageFormatter(message, {name, index, operation, tree});
        return _this;
      }
      __extends(PatchError, _super);
      return PatchError;
    }(Error), JsonPatchError = PatchError, objOps = {add:function(obj, key, document) {
      obj[key] = this.value;
      return {newDocument:document};
    }, remove:function(obj, key, document) {
      var removed = obj[key];
      delete obj[key];
      return {newDocument:document, removed};
    }, replace:function(obj, key, document) {
      var removed = obj[key];
      obj[key] = this.value;
      return {newDocument:document, removed};
    }, move:function(obj, key, document) {
      (obj = getValueByPointer(document, this.path)) && (obj = _deepClone(obj));
      key = applyOperation(document, {op:"remove", path:this.from}).removed;
      applyOperation(document, {op:"add", path:this.path, value:key});
      return {newDocument:document, removed:obj};
    }, copy:function(obj, key, document) {
      obj = getValueByPointer(document, this.from);
      applyOperation(document, {op:"add", path:this.path, value:_deepClone(obj)});
      return {newDocument:document};
    }, test:function(obj, key, document) {
      return {newDocument:document, test:_areEquals(obj[key], this.value)};
    }, _get:function(obj, key, document) {
      this.value = obj[key];
      return {newDocument:document};
    }}, arrOps = {add:function(arr, i, document) {
      isInteger(i) ? arr.splice(i, 0, this.value) : arr[i] = this.value;
      return {newDocument:document, index:i};
    }, remove:function(arr, i, document) {
      arr = arr.splice(i, 1);
      return {newDocument:document, removed:arr[0]};
    }, replace:function(arr, i, document) {
      var removed = arr[i];
      arr[i] = this.value;
      return {newDocument:document, removed};
    }, move:objOps.move, copy:objOps.copy, test:objOps.test, _get:objOps._get}, core = Object.freeze({__proto__:null, JsonPatchError, _areEquals, applyOperation, applyPatch, applyReducer:function(document, operation, index) {
      var operationResult = applyOperation(document, operation);
      if (operationResult.test === !1) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
      }
      return operationResult.newDocument;
    }, deepClone:_deepClone, getValueByPointer, validate, validator}), beforeDict = new WeakMap(), Mirror = function() {
      return function(obj) {
        this.observers = new Map();
        this.obj = obj;
      };
    }(), ObserverInfo = function() {
      return function(callback, observer) {
        this.callback = callback;
        this.observer = observer;
      };
    }(), duplex = Object.freeze({__proto__:null, compare:function(tree1, tree2, invertible) {
      invertible === void 0 && (invertible = !1);
      var patches = [];
      _generate(tree1, tree2, patches, "", invertible);
      return patches;
    }, generate, observe:function(obj, callback) {
      var mirror = beforeDict.get(obj);
      if (mirror) {
        var observerInfo = mirror.observers.get(callback);
        var observer = observerInfo && observerInfo.observer;
      } else {
        mirror = new Mirror(obj), beforeDict.set(obj, mirror);
      }
      if (observer) {
        return observer;
      }
      observer = {};
      mirror.value = _deepClone(obj);
      if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function() {
          generate(observer);
        }, fastCheck = function() {
          clearTimeout(observer.next);
          observer.next = setTimeout(dirtyCheck);
        };
        typeof window !== "undefined" && (window.addEventListener("mouseup", fastCheck), window.addEventListener("keyup", fastCheck), window.addEventListener("mousedown", fastCheck), window.addEventListener("keydown", fastCheck), window.addEventListener("change", fastCheck));
      }
      observer.patches = [];
      observer.object = obj;
      observer.unobserve = function() {
        generate(observer);
        clearTimeout(observer.next);
        mirror.observers.delete(observer.callback);
        typeof window !== "undefined" && (window.removeEventListener("mouseup", fastCheck), window.removeEventListener("keyup", fastCheck), window.removeEventListener("mousedown", fastCheck), window.removeEventListener("keydown", fastCheck), window.removeEventListener("change", fastCheck));
      };
      mirror.observers.set(callback, new ObserverInfo(callback, observer));
      return observer;
    }, unobserve:function(root, observer) {
      observer.unobserve();
    }});
    Object.assign({}, core, duplex, {JsonPatchError:PatchError, deepClone:_deepClone, escapePathComponent, unescapePathComponent});
    const stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
    var lrucache, hasRequiredLrucache, parseOptions_1, hasRequiredParseOptions, re = {exports:{}}, constants, hasRequiredConstants, debug_1, hasRequiredDebug, hasRequiredRe, identifiers, hasRequiredIdentifiers, semver, hasRequiredSemver, compare_1, hasRequiredCompare, eq_1, hasRequiredEq, neq_1, hasRequiredNeq, gt_1, hasRequiredGt, gte_1, hasRequiredGte, lt_1, hasRequiredLt, lte_1, hasRequiredLte, cmp_1, hasRequiredCmp, comparator, hasRequiredComparator, range, hasRequiredRange, satisfies_1, hasRequiredSatisfies, 
    satisfies = function(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }(function() {
      if (hasRequiredSatisfies) {
        return satisfies_1;
      }
      hasRequiredSatisfies = 1;
      const Range = requireRange();
      return satisfies_1 = (version, range, options) => {
        try {
          range = new Range(range, options);
        } catch (er) {
          return !1;
        }
        return range.test(version);
      };
    }()), Constants = {NaN, E:Math.E, LN2:Math.LN2, LN10:Math.LN10, LOG2E:Math.LOG2E, LOG10E:Math.LOG10E, PI:Math.PI, SQRT1_2:Math.SQRT1_2, SQRT2:Math.SQRT2, MIN_VALUE:Number.MIN_VALUE, MAX_VALUE:Number.MAX_VALUE}, Ops = {"*":(a, b) => a * b, "+":(a, b) => a + b, "-":(a, b) => a - b, "/":(a, b) => a / b, "%":(a, b) => a % b, "\x3e":(a, b) => a > b, "\x3c":(a, b) => a < b, "\x3c\x3d":(a, b) => a <= b, "\x3e\x3d":(a, b) => a >= b, "\x3d\x3d":(a, b) => a == b, "!\x3d":(a, b) => a != b, "\x3d\x3d\x3d":(a, 
    b) => a === b, "!\x3d\x3d":(a, b) => a !== b, "\x26":(a, b) => a & b, "|":(a, b) => a | b, "^":(a, b) => a ^ b, "\x3c\x3c":(a, b) => a << b, "\x3e\x3e":(a, b) => a >> b, "\x3e\x3e\x3e":(a, b) => a >>> b}, Unary = {"+":a => +a, "-":a => -a, "~":a => ~a, "!":a => !a};
    const slice = Array.prototype.slice, apply = (m, args, cast) => {
      cast = cast ? cast(args[0]) : args[0];
      return cast[m].apply(cast, slice.call(args, 1));
    };
    var Functions = {isNaN:Number.isNaN, isFinite:Number.isFinite, abs:Math.abs, acos:Math.acos, asin:Math.asin, atan:Math.atan, atan2:Math.atan2, ceil:Math.ceil, cos:Math.cos, exp:Math.exp, floor:Math.floor, log:Math.log, max:Math.max, min:Math.min, pow:Math.pow, random:Math.random, round:Math.round, sin:Math.sin, sqrt:Math.sqrt, tan:Math.tan, clamp:(a, b, c) => Math.max(b, Math.min(c, a)), now:Date.now, utc:Date.UTC, datetime:(y, m, d, H, M, S, ms) => new Date(y, m || 0, d != null ? d : 1, H || 
    0, M || 0, S || 0, ms || 0), date:d => (new Date(d)).getDate(), day:d => (new Date(d)).getDay(), year:d => (new Date(d)).getFullYear(), month:d => (new Date(d)).getMonth(), hours:d => (new Date(d)).getHours(), minutes:d => (new Date(d)).getMinutes(), seconds:d => (new Date(d)).getSeconds(), milliseconds:d => (new Date(d)).getMilliseconds(), time:d => (new Date(d)).getTime(), timezoneoffset:d => (new Date(d)).getTimezoneOffset(), utcdate:d => (new Date(d)).getUTCDate(), utcday:d => (new Date(d)).getUTCDay(), 
    utcyear:d => (new Date(d)).getUTCFullYear(), utcmonth:d => (new Date(d)).getUTCMonth(), utchours:d => (new Date(d)).getUTCHours(), utcminutes:d => (new Date(d)).getUTCMinutes(), utcseconds:d => (new Date(d)).getUTCSeconds(), utcmilliseconds:d => (new Date(d)).getUTCMilliseconds(), length:x => x.length, join:function() {
      return apply("join", arguments);
    }, indexof:function() {
      return apply("indexOf", arguments);
    }, lastindexof:function() {
      return apply("lastIndexOf", arguments);
    }, slice:function() {
      return apply("slice", arguments);
    }, reverse:x => x.slice().reverse(), parseFloat, parseInt, upper:x => String(x).toUpperCase(), lower:x => String(x).toLowerCase(), substring:function() {
      return apply("substring", arguments, String);
    }, split:function() {
      return apply("split", arguments, String);
    }, replace:function() {
      return apply("replace", arguments, String);
    }, trim:x => String(x).trim(), regexp:RegExp, test:(r, t) => RegExp(r).test(t)};
    const EventFunctions = "view item group xy x y".split(" "), DisallowedMethods = new Set([Function, eval, setTimeout, setInterval]);
    typeof setImmediate === "function" && DisallowedMethods.add(setImmediate);
    const Visitors = {Literal:($, n) => n.value, Identifier:($, n) => {
      n = n.name;
      return $.memberDepth > 0 ? n : n === "datum" ? $.datum : n === "event" ? $.event : n === "item" ? $.item : Constants[n] || $.params["$" + n];
    }, MemberExpression:($, n) => {
      const d = !n.computed, o = $(n.object);
      d && ($.memberDepth += 1);
      n = $(n.property);
      d && --$.memberDepth;
      if (DisallowedMethods.has(o[n])) {
        console.error(`Prevented interpretation of member "${n}" which could lead to insecure code execution`);
      } else {
        return o[n];
      }
    }, CallExpression:($, n) => {
      const args = n.arguments;
      n = n.callee.name;
      n.startsWith("_") && (n = n.slice(1));
      return n === "if" ? $(args[0]) ? $(args[1]) : $(args[2]) : ($.fn[n] || Functions[n]).apply($.fn, args.map($));
    }, ArrayExpression:($, n) => n.elements.map($), BinaryExpression:($, n) => Ops[n.operator]($(n.left), $(n.right)), UnaryExpression:($, n) => Unary[n.operator]($(n.argument)), ConditionalExpression:($, n) => $(n.test) ? $(n.consequent) : $(n.alternate), LogicalExpression:($, n) => n.operator === "\x26\x26" ? $(n.left) && $(n.right) : $(n.left) || $(n.right), ObjectExpression:($, n) => n.properties.reduce((o, p) => {
      $.memberDepth += 1;
      const k = $(p.key);
      --$.memberDepth;
      DisallowedMethods.has($(p.value)) ? console.error(`Prevented interpretation of property "${k}" which could lead to insecure code execution`) : o[k] = $(p.value);
      return o;
    }, {})};
    var expression = {operator(ctx, expr) {
      const ast = expr.ast, fn = ctx.functions;
      return _ => interpret(ast, fn, _);
    }, parameter(ctx, expr) {
      const ast = expr.ast, fn = ctx.functions;
      return (datum, _) => interpret(ast, fn, _, datum);
    }, event(ctx, expr) {
      const ast = expr.ast, fn = ctx.functions;
      return event => interpret(ast, fn, void 0, void 0, event);
    }, handler(ctx, expr) {
      const ast = expr.ast, fn = ctx.functions;
      return (_, event) => interpret(ast, fn, _, event.item && event.item.datum, event);
    }, encode(ctx, encode) {
      const {marktype, channels} = encode, fn = ctx.functions, swap = marktype === "group" || marktype === "image" || marktype === "rect";
      return (item, _) => {
        const datum = item.datum;
        let m = 0, v;
        for (const name in channels) {
          v = interpret(channels[name].ast, fn, _, datum, void 0, item), item[name] !== v && (item[name] = v, m = 1);
        }
        marktype !== "rule" && (channels.x2 && (channels.x ? (swap && item.x > item.x2 && (_ = item.x, item.x = item.x2, item.x2 = _), item.width = item.x2 - item.x) : item.x = item.x2 - (item.width || 0)), channels.xc && (item.x = item.xc - (item.width || 0) / 2), channels.y2 && (channels.y ? (swap && item.y > item.y2 && (_ = item.y, item.y = item.y2, item.y2 = _), item.height = item.y2 - item.y) : item.y = item.y2 - (item.height || 0)), channels.yc && (item.y = item.yc - (item.height || 0) / 2));
        return m;
      };
    }};
    const colorSchemes$1 = {"category-6":"#ec8431 #829eb1 #c89d29 #3580b1 #adc839 #ab7fb4".split(" "), "fire-7":"#fbf2c7 #f9e39c #f8d36e #f4bb6a #e68a4f #d15a40 #ab4232".split(" "), "fireandice-6":"#e68a4f #f4bb6a #f9e39c #dadfe2 #a6b7c6 #849eae".split(" "), "ice-7":"#edefee #dadfe2 #c4ccd2 #a6b7c6 #849eae #607785 #47525d".split(" ")}, latimesTheme = {background:"#ffffff", title:{anchor:"start", color:"#000000", font:"Benton Gothic Bold, sans-serif", fontSize:22, fontWeight:"normal"}, arc:{fill:"#82c6df"}, 
    area:{fill:"#82c6df"}, line:{stroke:"#82c6df", strokeWidth:2}, path:{stroke:"#82c6df"}, rect:{fill:"#82c6df"}, shape:{stroke:"#82c6df"}, symbol:{fill:"#82c6df", size:30}, axis:{labelFont:"Benton Gothic, sans-serif", labelFontSize:11.5, labelFontWeight:"normal", titleFont:"Benton Gothic Bold, sans-serif", titleFontSize:13, titleFontWeight:"normal"}, axisX:{labelAngle:0, labelPadding:4, tickSize:3}, axisY:{labelBaseline:"middle", maxExtent:45, minExtent:45, tickSize:2, titleAlign:"left", titleAngle:0, 
    titleX:-45, titleY:-11}, legend:{labelFont:"Benton Gothic, sans-serif", labelFontSize:11.5, symbolType:"square", titleFont:"Benton Gothic Bold, sans-serif", titleFontSize:13, titleFontWeight:"normal"}, range:{category:colorSchemes$1["category-6"], diverging:colorSchemes$1["fireandice-6"], heatmap:colorSchemes$1["fire-7"], ordinal:colorSchemes$1["fire-7"], ramp:colorSchemes$1["fire-7"]}}, colorSchemes = {"main-colors":"#1696d2 #d2d2d2 #000000 #fdbf11 #ec008b #55b748 #5c5859 #db2b27".split(" "), 
    "shades-blue":"#CFE8F3 #A2D4EC #73BFE2 #46ABDB #1696D2 #12719E #0A4C6A #062635".split(" "), "shades-gray":"#F5F5F5 #ECECEC #E3E3E3 #DCDBDB #D2D2D2 #9D9D9D #696969 #353535".split(" "), "shades-yellow":"#FFF2CF #FCE39E #FDD870 #FCCB41 #FDBF11 #E88E2D #CA5800 #843215".split(" "), "shades-magenta":"#F5CBDF #EB99C2 #E46AA7 #E54096 #EC008B #AF1F6B #761548 #351123".split(" "), "shades-green":"#DCEDD9 #BCDEB4 #98CF90 #78C26D #55B748 #408941 #2C5C2D #1A2E19".split(" "), "shades-black":"#D5D5D4 #ADABAC #848081 #5C5859 #332D2F #262223 #1A1717 #0E0C0D".split(" "), 
    "shades-red":"#F8D5D4 #F1AAA9 #E9807D #E25552 #DB2B27 #A4201D #6E1614 #370B0A".split(" "), "one-group":["#1696d2", "#000000"], "two-groups-cat-1":["#1696d2", "#000000"], "two-groups-cat-2":["#1696d2", "#fdbf11"], "two-groups-cat-3":["#1696d2", "#db2b27"], "two-groups-seq":["#a2d4ec", "#1696d2"], "three-groups-cat":["#1696d2", "#fdbf11", "#000000"], "three-groups-seq":["#a2d4ec", "#1696d2", "#0a4c6a"], "four-groups-cat-1":["#000000", "#d2d2d2", "#fdbf11", "#1696d2"], "four-groups-cat-2":["#1696d2", 
    "#ec0008b", "#fdbf11", "#5c5859"], "four-groups-seq":["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"], "five-groups-cat-1":["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"], "five-groups-cat-2":["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"], "five-groups-seq":["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"], "six-groups-cat-1":"#1696d2 #ec008b #fdbf11 #000000 #d2d2d2 #55b748".split(" "), "six-groups-cat-2":"#1696d2 #d2d2d2 #ec008b #fdbf11 #332d2f #0a4c6a".split(" "), "six-groups-seq":"#cfe8f3 #a2d4ec #73bfe2 #46abdb #1696d2 #12719e".split(" "), 
    "diverging-colors":"#ca5800 #fdbf11 #fdd870 #fff2cf #cfe8f3 #73bfe2 #1696d2 #0a4c6a".split(" ")}, urbanInstituteTheme = {background:"#FFFFFF", title:{anchor:"start", fontSize:18, font:"Lato"}, axisX:{domain:!0, domainColor:"#000000", domainWidth:1, grid:!1, labelFontSize:12, labelFont:"Lato", labelAngle:0, tickColor:"#000000", tickSize:5, titleFontSize:12, titlePadding:10, titleFont:"Lato"}, axisY:{domain:!1, domainWidth:1, grid:!0, gridColor:"#DEDDDD", gridWidth:1, labelFontSize:12, labelFont:"Lato", 
    labelPadding:8, ticks:!1, titleFontSize:12, titlePadding:10, titleFont:"Lato", titleAngle:0, titleY:-10, titleX:18}, legend:{labelFontSize:12, labelFont:"Lato", symbolSize:100, titleFontSize:12, titlePadding:10, titleFont:"Lato", orient:"right", offset:10}, view:{stroke:"transparent"}, range:{category:colorSchemes["six-groups-cat-1"], diverging:colorSchemes["diverging-colors"], heatmap:colorSchemes["diverging-colors"], ordinal:colorSchemes["six-groups-seq"], ramp:colorSchemes["shades-blue"]}, 
    area:{fill:"#1696d2"}, rect:{fill:"#1696d2"}, line:{color:"#1696d2", stroke:"#1696d2", strokeWidth:5}, trail:{color:"#1696d2", stroke:"#1696d2", strokeWidth:0, size:1}, path:{stroke:"#1696d2", strokeWidth:0.5}, point:{filled:!0}, text:{font:"Lato", color:"#1696d2", fontSize:11, align:"center", fontWeight:400, size:11}, style:{bar:{fill:"#1696d2", stroke:null}}, arc:{fill:"#1696d2"}, shape:{stroke:"#1696d2"}, symbol:{fill:"#1696d2", size:30}}, fontSmallPx = 9 * (1 / 3 + 1), legendFontPx = 10 * 
    (1 / 3 + 1), fontLargePx = 12 * (1 / 3 + 1), divergentPalette = ["#DEEFFF", "#118DFF"], powerbiTheme = {view:{stroke:"transparent"}, background:"transparent", font:"Segoe UI", header:{titleFont:"wf_standard-font, helvetica, arial, sans-serif", titleFontSize:fontLargePx, titleColor:"#252423", labelFont:"Segoe UI", labelFontSize:legendFontPx, labelColor:"#605E5C"}, axis:{ticks:!1, grid:!1, domain:!1, labelColor:"#605E5C", labelFontSize:fontSmallPx, titleFont:"wf_standard-font, helvetica, arial, sans-serif", 
    titleColor:"#252423", titleFontSize:fontLargePx, titleFontWeight:"normal"}, axisQuantitative:{tickCount:3, grid:!0, gridColor:"#C8C6C4", gridDash:[1, 5], labelFlush:!1}, axisBand:{tickExtra:!0}, axisX:{labelPadding:5}, axisY:{labelPadding:10}, bar:{fill:"#118DFF"}, line:{stroke:"#118DFF", strokeWidth:3, strokeCap:"round", strokeJoin:"round"}, text:{font:"Segoe UI", fontSize:fontSmallPx, fill:"#605E5C"}, arc:{fill:"#118DFF"}, area:{fill:"#118DFF", line:!0, opacity:0.6}, path:{stroke:"#118DFF"}, 
    rect:{fill:"#118DFF"}, point:{fill:"#118DFF", filled:!0, size:75}, shape:{stroke:"#118DFF"}, symbol:{fill:"#118DFF", strokeWidth:1.5, size:50}, legend:{titleFont:"Segoe UI", titleFontWeight:"bold", titleColor:"#605E5C", labelFont:"Segoe UI", labelFontSize:legendFontPx, labelColor:"#605E5C", symbolType:"circle", symbolSize:75}, range:{category:"#118DFF #12239E #E66C37 #6B007B #E044A7 #744EC2 #D9B300 #D64550".split(" "), diverging:divergentPalette, heatmap:divergentPalette, ordinal:"#DEEFFF #c7e4ff #b0d9ff #9aceff #83c3ff #6cb9ff #55aeff #3fa3ff #2898ff #118DFF".split(" ")}}, 
    TOKENS = {textPrimary:{g90:"#f4f4f4", g100:"#f4f4f4", white:"#161616", g10:"#161616"}, textSecondary:{g90:"#c6c6c6", g100:"#c6c6c6", white:"#525252", g10:"#525252"}, layerAccent01:{white:"#e0e0e0", g10:"#e0e0e0", g90:"#525252", g100:"#393939"}, gridBg:{white:"#ffffff", g10:"#ffffff", g90:"#161616", g100:"#161616"}}, darkCategories = "#8a3ffc #33b1ff #007d79 #ff7eb6 #fa4d56 #fff1f1 #6fdc8c #4589ff #d12771 #d2a106 #08bdba #bae6ff #ba4e00 #d4bbff".split(" "), lightCategories = "#6929c4 #1192e8 #005d5d #9f1853 #fa4d56 #570408 #198038 #002d9c #ee538b #b28600 #009d9a #012749 #8a3800 #a56eff".split(" "), 
    carbonwhite = genCarbonConfig({theme:"white", background:"#ffffff"}), carbong10 = genCarbonConfig({theme:"g10", background:"#f4f4f4"}), carbong90 = genCarbonConfig({theme:"g90", background:"#262626"}), carbong100 = genCarbonConfig({theme:"g100", background:"#161616"});
    var themes = Object.freeze({__proto__:null, carbong10, carbong100, carbong90, carbonwhite, dark:{background:"#333", view:{stroke:"#888"}, title:{color:"#fff", subtitleColor:"#fff"}, style:{"guide-label":{fill:"#fff"}, "guide-title":{fill:"#fff"}}, axis:{domainColor:"#fff", gridColor:"#888", tickColor:"#fff"}}, excel:{background:"#fff", arc:{fill:"#4572a7"}, area:{fill:"#4572a7"}, line:{stroke:"#4572a7", strokeWidth:2}, path:{stroke:"#4572a7"}, rect:{fill:"#4572a7"}, shape:{stroke:"#4572a7"}, 
    symbol:{fill:"#4572a7", strokeWidth:1.5, size:50}, axis:{bandPosition:0.5, grid:!0, gridColor:"#000000", gridOpacity:1, gridWidth:0.5, labelPadding:10, tickSize:5, tickWidth:0.5}, axisBand:{grid:!1, tickExtra:!0}, legend:{labelBaseline:"middle", labelFontSize:11, symbolSize:50, symbolType:"square"}, range:{category:"#4572a7 #aa4643 #8aa453 #71598e #4598ae #d98445 #94aace #d09393 #b9cc98 #a99cbc".split(" ")}}, fivethirtyeight:{arc:{fill:"#30a2da"}, area:{fill:"#30a2da"}, axis:{domainColor:"#cbcbcb", 
    grid:!0, gridColor:"#cbcbcb", gridWidth:1, labelColor:"#999", labelFontSize:10, titleColor:"#333", tickColor:"#cbcbcb", tickSize:10, titleFontSize:14, titlePadding:10, labelPadding:4}, axisBand:{grid:!1}, background:"#f0f0f0", group:{fill:"#f0f0f0"}, legend:{labelColor:"#333", labelFontSize:11, padding:1, symbolSize:30, symbolType:"square", titleColor:"#333", titleFontSize:14, titlePadding:10}, line:{stroke:"#30a2da", strokeWidth:2}, path:{stroke:"#30a2da", strokeWidth:0.5}, rect:{fill:"#30a2da"}, 
    range:{category:"#30a2da #fc4f30 #e5ae38 #6d904f #8b8b8b #b96db8 #ff9e27 #56cc60 #52d2ca #52689e #545454 #9fe4f8".split(" "), diverging:"#cc0020 #e77866 #f6e7e1 #d6e8ed #91bfd9 #1d78b5".split(" "), heatmap:["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]}, point:{filled:!0, shape:"circle"}, shape:{stroke:"#30a2da"}, bar:{binSpacing:2, fill:"#30a2da", stroke:null}, title:{anchor:"start", fontSize:24, fontWeight:600, offset:20}}, ggplot2:{group:{fill:"#e5e5e5"}, arc:{fill:"#000"}, area:{fill:"#000"}, 
    line:{stroke:"#000"}, path:{stroke:"#000"}, rect:{fill:"#000"}, shape:{stroke:"#000"}, symbol:{fill:"#000", size:40}, axis:{domain:!1, grid:!0, gridColor:"#FFFFFF", gridOpacity:1, labelColor:"#7F7F7F", labelPadding:4, tickColor:"#7F7F7F", tickSize:5.67, titleFontSize:16, titleFontWeight:"normal"}, legend:{labelBaseline:"middle", labelFontSize:11, symbolSize:40}, range:{category:"#000000 #7F7F7F #1A1A1A #999999 #333333 #B0B0B0 #4D4D4D #C9C9C9 #666666 #DCDCDC".split(" ")}}, googlecharts:{arc:{fill:"#3366CC"}, 
    area:{fill:"#3366CC"}, path:{stroke:"#3366CC"}, rect:{fill:"#3366CC"}, shape:{stroke:"#3366CC"}, symbol:{stroke:"#3366CC"}, circle:{fill:"#3366CC"}, background:"#fff", padding:{top:10, right:10, bottom:10, left:10}, style:{"guide-label":{font:"Arial, sans-serif", fontSize:12}, "guide-title":{font:"Arial, sans-serif", fontSize:12}, "group-title":{font:"Arial, sans-serif", fontSize:12}}, title:{font:"Arial, sans-serif", fontSize:14, fontWeight:"bold", dy:-3, anchor:"start"}, axis:{gridColor:"#ccc", 
    tickColor:"#ccc", domain:!1, grid:!0}, range:{category:"#4285F4 #DB4437 #F4B400 #0F9D58 #AB47BC #00ACC1 #FF7043 #9E9D24 #5C6BC0 #F06292 #00796B #C2185B".split(" "), heatmap:["#c6dafc", "#5e97f6", "#2a56c6"]}}, latimes:latimesTheme, powerbi:powerbiTheme, quartz:{background:"#f9f9f9", arc:{fill:"#ab5787"}, area:{fill:"#ab5787"}, line:{stroke:"#ab5787"}, path:{stroke:"#ab5787"}, rect:{fill:"#ab5787"}, shape:{stroke:"#ab5787"}, symbol:{fill:"#ab5787", size:30}, axis:{domainColor:"#979797", domainWidth:0.5, 
    gridWidth:0.2, labelColor:"#979797", tickColor:"#979797", tickWidth:0.2, titleColor:"#979797"}, axisBand:{grid:!1}, axisX:{grid:!0, tickSize:10}, axisY:{domain:!1, grid:!0, tickSize:0}, legend:{labelFontSize:11, padding:1, symbolSize:30, symbolType:"square"}, range:{category:"#ab5787 #51b2e5 #703c5c #168dd9 #d190b6 #00609f #d365ba #154866 #666666 #c4c4c4".split(" ")}}, urbaninstitute:urbanInstituteTheme, version:"2.15.0", vox:{background:"#fff", arc:{fill:"#3e5c69"}, area:{fill:"#3e5c69"}, line:{stroke:"#3e5c69"}, 
    path:{stroke:"#3e5c69"}, rect:{fill:"#3e5c69"}, shape:{stroke:"#3e5c69"}, symbol:{fill:"#3e5c69"}, axis:{domainWidth:0.5, grid:!0, labelPadding:2, tickSize:5, tickWidth:0.5, titleFontWeight:"normal"}, axisBand:{grid:!1}, axisX:{gridWidth:0.2}, axisY:{gridDash:[3], gridWidth:0.4}, legend:{labelFontSize:11, padding:1, symbolType:"square"}, range:{category:"#3e5c69 #6793a6 #182429 #0570b0 #3690c0 #74a9cf #a6bddb #e2ddf2".split(" ")}}});
    const get1 = field => function(obj) {
      return obj[field];
    }, getN = path => {
      const len = path.length;
      return function(obj) {
        for (let i = 0; i < len; ++i) {
          obj = obj[path[i]];
        }
        return obj;
      };
    };
    (function(field, name, opt) {
      name = splitAccessPath(field);
      field = name.length === 1 ? name[0] : field;
      return accessor(name.length === 1 ? get1(name[0]) : getN(name), [field], field);
    })("id");
    accessor(_ => _, [], "identity");
    accessor(() => 0, [], "zero");
    accessor(() => 1, [], "one");
    accessor(() => !0, [], "true");
    accessor(() => !1, [], "false");
    var isArray = Array.isArray;
    const DEFAULT_OPTIONS = {offsetX:10, offsetY:10, id:"vg-tooltip-element", styleId:"vega-tooltip-style", theme:"light", disableDefaultStyle:!1, sanitize:function(value) {
      return String(value).replace(/&/g, "\x26amp;").replace(/</g, "\x26lt;");
    }, maxDepth:2, formatTooltip:function(value, valueToHtml, maxDepth, baseURL) {
      if (isArray(value)) {
        return `[${value.map(v => valueToHtml(typeof v === "string" ? v : JSON.stringify(v, replacer(maxDepth)))).join(", ")}]`;
      }
      if (value === Object(value)) {
        let content = "";
        const {title, image, ...rest} = value;
        title && (content += `<h2>${valueToHtml(title)}</h2>`);
        image && (content += `<img src="${(new URL(valueToHtml(image), baseURL || location.href)).href}">`);
        value = Object.keys(rest);
        if (value.length > 0) {
          content += "\x3ctable\x3e";
          for (const key of value) {
            value = rest[key], value !== void 0 && (value === Object(value) && (value = JSON.stringify(value, replacer(maxDepth))), content += `<tr><td class="key">${valueToHtml(key)}</td><td class="value">${valueToHtml(value)}</td></tr>`);
          }
          content += "\x3c/table\x3e";
        }
        return content || "{}";
      }
      return valueToHtml(value);
    }, baseURL:"", anchor:"cursor", position:"top bottom left right top-left top-right bottom-left bottom-right".split(" ")};
    class Handler {
      constructor(options) {
        this.options = {...DEFAULT_OPTIONS, ...options};
        var elementId = this.options.id;
        this.el = null;
        this.call = this.tooltipHandler.bind(this);
        if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
          options = document.createElement("style");
          options.setAttribute("id", this.options.styleId);
          if (!/^[A-Za-z]+[-:.\w]*$/.test(elementId)) {
            throw Error("Invalid HTML ID");
          }
          elementId = "#vg-tooltip-element {\n  visibility: hidden;\n  padding: 8px;\n  position: fixed;\n  z-index: 1000;\n  font-family: sans-serif;\n  font-size: 11px;\n  border-radius: 3px;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);\n  /* The default theme is the light theme. */\n  background-color: rgba(255, 255, 255, 0.95);\n  border: 1px solid #d9d9d9;\n  color: black;\n}\n#vg-tooltip-element.visible {\n  visibility: visible;\n}\n#vg-tooltip-element h2 {\n  margin-top: 0;\n  margin-bottom: 10px;\n  font-size: 13px;\n}\n#vg-tooltip-element table {\n  border-spacing: 0;\n}\n#vg-tooltip-element table tr {\n  border: none;\n}\n#vg-tooltip-element table tr td {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n#vg-tooltip-element table tr td.key {\n  color: #808080;\n  max-width: 150px;\n  text-align: right;\n  padding-right: 4px;\n}\n#vg-tooltip-element table tr td.value {\n  display: block;\n  max-width: 300px;\n  max-height: 7em;\n  text-align: left;\n}\n#vg-tooltip-element.dark-theme {\n  background-color: rgba(32, 32, 32, 0.9);\n  border: 1px solid #f5f5f5;\n  color: white;\n}\n#vg-tooltip-element.dark-theme td.key {\n  color: #bfbfbf;\n}\n".toString().replace("vg-tooltip-element", 
          elementId);
          options.innerHTML = elementId;
          elementId = document.head;
          elementId.childNodes.length > 0 ? elementId.insertBefore(options, elementId.childNodes[0]) : elementId.appendChild(options);
        }
      }
      tooltipHandler(handler, event, item, value) {
        this.el = document.getElementById(this.options.id);
        this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el));
        if (value == null || value === "") {
          this.el.classList.remove("visible", `${this.options.theme}-theme`);
        } else {
          this.el.innerHTML = this.options.formatTooltip(value, this.options.sanitize, this.options.maxDepth, this.options.baseURL);
          this.el.classList.add("visible", `${this.options.theme}-theme`);
          if (this.options.anchor === "mark") {
            a: {
              value = this.el.getBoundingClientRect();
              var options = this.options;
              const {position, offsetX, offsetY} = options;
              var containerBox = handler._el.getBoundingClientRect(), origin = handler._origin;
              handler = item.isVoronoi ? item.datum.bounds : item.bounds;
              var left = containerBox.left + origin[0] + handler.x1;
              for (containerBox = containerBox.top + origin[1] + handler.y1; item.mark.group;) {
                item = item.mark.group, left += item.x ?? 0, containerBox += item.y ?? 0;
              }
              item = getPositions({x1:left, x2:left + (handler.x2 - handler.x1), y1:containerBox, y2:containerBox + (handler.y2 - handler.y1)}, value, offsetX, offsetY);
              handler = Array.isArray(position) ? position : [position];
              for (const p of handler) {
                if (handler = tooltipIsInViewport(item[p], value)) {
                  handler = event, left = item[p], handler = !(handler.clientX >= left.x && handler.clientX <= left.x + value.width && handler.clientY >= left.y && handler.clientY <= left.y + value.height);
                }
                if (handler) {
                  event = item[p];
                  break a;
                }
              }
              event = calculatePositionRelativeToCursor(event, value, options);
            }
          } else {
            event = calculatePositionRelativeToCursor(event, this.el.getBoundingClientRect(), this.options);
          }
          var {x, y} = event;
          this.el.style.top = `${y}px`;
          this.el.style.left = `${x}px`;
        }
      }
    }
    const vega = vegaImport__namespace;
    let vegaLite = vegaLiteImport__namespace;
    const w = typeof window !== "undefined" ? window : void 0;
    vegaLite === void 0 && w?.vl?.compile && (vegaLite = w.vl);
    const DEFAULT_ACTIONS = {export:{svg:!0, png:!0}, source:!0, compiled:!0, editor:!0}, I18N = {CLICK_TO_VIEW_ACTIONS:"Click to view actions", COMPILED_ACTION:"View Compiled Vega", EDITOR_ACTION:"Open in Vega Editor", PNG_ACTION:"Save as PNG", SOURCE_ACTION:"View Source", SVG_ACTION:"Save as SVG"}, NAMES = {vega:"Vega", "vega-lite":"Vega-Lite"}, VERSION = {vega:vega.version, "vega-lite":vegaLite ? vegaLite.version : "not available"}, PREPROCESSOR = {vega:vgSpec => vgSpec, "vega-lite":(vlSpec, config) => 
    vegaLite.compile(vlSpec, {config}).spec}, wrapper = (...args) => {
      var JSCompiler_temp;
      if (JSCompiler_temp = args.length > 1) {
        if (JSCompiler_temp = vegaImport.isString(args[0])) {
          JSCompiler_temp = args[0], JSCompiler_temp = !(JSCompiler_temp.startsWith("http://") || JSCompiler_temp.startsWith("https://") || JSCompiler_temp.startsWith("//"));
        }
        JSCompiler_temp = JSCompiler_temp || args[0] instanceof HTMLElement || args.length === 3;
      }
      return JSCompiler_temp ? embed(args[0], args[1], args[2]) : container(args[0], args[1]);
    };
    wrapper.vegaLite = vegaLite;
    wrapper.vl = vegaLite;
    wrapper.container = container;
    wrapper.embed = embed;
    wrapper.vega = vega;
    wrapper.default = embed;
    wrapper.version = "6.29.0";
    return wrapper;
  });
};

//# sourceMappingURL=module$node_modules$vega_embed$build$vega_embed.js.map
