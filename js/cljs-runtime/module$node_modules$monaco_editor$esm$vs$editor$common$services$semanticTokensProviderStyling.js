shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$services$semanticTokensProviderStyling = function(require, module, exports) {
  function toMultilineTokens2(tokens, styling, languageId) {
    const srcData = tokens.data;
    tokens = tokens.data.length / 5 | 0;
    const tokensPerArea = Math.max(Math.ceil(tokens / 1024), 400), result = [];
    let tokenIndex = 0;
    for (var lastLineNumber = 1, lastStartCharacter = 0; tokenIndex < tokens;) {
      var tokenStartIndex = tokenIndex, tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokens);
      if (tokenEndIndex < tokens) {
        for (var smallTokenEndIndex = tokenEndIndex; smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0;) {
          smallTokenEndIndex--;
        }
        if (smallTokenEndIndex - 1 === tokenStartIndex) {
          for (; tokenEndIndex + 1 < tokens && srcData[5 * tokenEndIndex] === 0;) {
            tokenEndIndex++;
          }
        } else {
          tokenEndIndex = smallTokenEndIndex;
        }
      }
      tokenStartIndex = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);
      let areaLine = smallTokenEndIndex = 0, prevLineNumber = 0, prevEndCharacter = 0;
      for (; tokenIndex < tokenEndIndex;) {
        var srcOffset = 5 * tokenIndex, deltaLine = srcData[srcOffset], deltaCharacter = srcData[srcOffset + 1];
        lastLineNumber = lastLineNumber + deltaLine | 0;
        lastStartCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter | 0 : deltaCharacter;
        deltaLine = lastStartCharacter + srcData[srcOffset + 2] | 0;
        deltaCharacter = srcData[srcOffset + 3];
        srcOffset = srcData[srcOffset + 4];
        deltaLine <= lastStartCharacter ? styling.warnInvalidLengthSemanticTokens(lastLineNumber, lastStartCharacter + 1) : prevLineNumber === lastLineNumber && prevEndCharacter > lastStartCharacter ? styling.warnOverlappingSemanticTokens(lastLineNumber, lastStartCharacter + 1) : (srcOffset = styling.getMetadata(deltaCharacter, srcOffset, languageId), srcOffset !== 2147483647 && (areaLine === 0 && (areaLine = lastLineNumber), tokenStartIndex[smallTokenEndIndex] = lastLineNumber - areaLine, tokenStartIndex[smallTokenEndIndex + 
        1] = lastStartCharacter, tokenStartIndex[smallTokenEndIndex + 2] = deltaLine, tokenStartIndex[smallTokenEndIndex + 3] = srcOffset, smallTokenEndIndex += 4, prevLineNumber = lastLineNumber, prevEndCharacter = deltaLine));
        tokenIndex++;
      }
      smallTokenEndIndex !== tokenStartIndex.length && (tokenStartIndex = tokenStartIndex.subarray(0, smallTokenEndIndex));
      tokenEndIndex = require$_DOT__DOT__SLASH_tokens_SLASH_sparseMultilineTokens_DOT_js.SparseMultilineTokens.create(areaLine, tokenStartIndex);
      result.push(tokenEndIndex);
    }
    return result;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SemanticTokensProviderStyling:{enumerable:!0, get:function() {
    return SemanticTokensProviderStyling;
  }}, toMultilineTokens2:{enumerable:!0, get:function() {
    return toMultilineTokens2;
  }}});
  var require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$encodedTokenAttributes");
  module = require("module$node_modules$monaco_editor$esm$vs$platform$theme$common$themeService");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js = require("module$node_modules$monaco_editor$esm$vs$platform$log$common$log"), require$_DOT__DOT__SLASH_tokens_SLASH_sparseMultilineTokens_DOT_js = require("module$node_modules$monaco_editor$esm$vs$editor$common$tokens$sparseMultilineTokens");
  require = require("module$node_modules$monaco_editor$esm$vs$editor$common$languages$language");
  exports = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  let SemanticTokensProviderStyling = class {
    constructor(_legend, _themeService, _languageService, _logService) {
      this._legend = _legend;
      this._themeService = _themeService;
      this._languageService = _languageService;
      this._logService = _logService;
      this._hasWarnedInvalidEditStart = this._hasWarnedInvalidLengthTokens = this._hasWarnedOverlappingTokens = !1;
      this._hashTable = new HashTable();
    }
    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {
      const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
      var entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);
      if (entry) {
        languageId = entry.metadata, this._logService.getLevel() === require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.LogLevel.Trace && this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getForeground(languageId)}, fontStyle ${require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getFontStyle(languageId).toString(2)}`);
      } else {
        entry = this._legend.tokenTypes[tokenTypeIndex];
        const tokenModifiers = [];
        if (entry) {
          var modifierSet = tokenModifierSet;
          for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {
            modifierSet & 1 && tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]), modifierSet >>= 1;
          }
          modifierSet > 0 && this._logService.getLevel() === require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.LogLevel.Trace && (this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`), tokenModifiers.push("not-in-legend"));
          modifierSet = this._themeService.getColorTheme().getTokenStyleMetadata(entry, tokenModifiers, languageId);
          typeof modifierSet === "undefined" ? languageId = 2147483647 : (languageId = 0, typeof modifierSet.italic !== "undefined" && (languageId |= (modifierSet.italic ? 1 : 0) << 11 | 1), typeof modifierSet.bold !== "undefined" && (languageId |= (modifierSet.bold ? 2 : 0) << 11 | 2), typeof modifierSet.underline !== "undefined" && (languageId |= (modifierSet.underline ? 4 : 0) << 11 | 4), typeof modifierSet.strikethrough !== "undefined" && (languageId |= (modifierSet.strikethrough ? 8 : 0) << 
          11 | 8), modifierSet.foreground && (languageId |= modifierSet.foreground << 15 | 16), languageId === 0 && (languageId = 2147483647));
        } else {
          this._logService.getLevel() === require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.LogLevel.Trace && this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`), languageId = 2147483647, entry = "not-in-legend";
        }
        this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, languageId);
        this._logService.getLevel() === require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.LogLevel.Trace && this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${entry}) / ${tokenModifierSet} (${tokenModifiers.join(" ")}): foreground ${require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getForeground(languageId)}, fontStyle ${require$_DOT__DOT__SLASH_encodedTokenAttributes_DOT_js.TokenMetadata.getFontStyle(languageId).toString(2)}`);
      }
      return languageId;
    }
    warnOverlappingSemanticTokens(lineNumber, startColumn) {
      this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`));
    }
    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {
      this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = !0, console.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`));
    }
    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {
      this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = !0, console.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`));
    }
  };
  SemanticTokensProviderStyling = (this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
      r = Reflect.decorate(decorators, target, key, desc);
    } else {
      for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) {
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }
      }
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  })([exports(1, module.IThemeService), exports(2, require.ILanguageService), exports(3, require$_DOT__DOT__SLASH__DOT__DOT__SLASH__DOT__DOT__SLASH_platform_SLASH_log_SLASH_common_SLASH_log_DOT_js.ILogService)], SemanticTokensProviderStyling);
  class HashTableEntry {
    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
      this.tokenTypeIndex = tokenTypeIndex;
      this.tokenModifierSet = tokenModifierSet;
      this.languageId = languageId;
      this.metadata = metadata;
      this.next = null;
    }
  }
  class HashTable {
    constructor() {
      this._currentLengthIndex = this._elementsCount = 0;
      this._currentLength = HashTable._SIZES[this._currentLengthIndex];
      this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
      this._elements = [];
      HashTable._nullOutEntries(this._elements, this._currentLength);
    }
    static _nullOutEntries(entries, length) {
      for (let i = 0; i < length; i++) {
        entries[i] = null;
      }
    }
    _hash2(n1, n2) {
      return (n1 << 5) - n1 + n2 | 0;
    }
    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {
      return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;
    }
    get(tokenTypeIndex, tokenModifierSet, languageId) {
      var hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);
      for (hash = this._elements[hash]; hash;) {
        if (hash.tokenTypeIndex === tokenTypeIndex && hash.tokenModifierSet === tokenModifierSet && hash.languageId === languageId) {
          return hash;
        }
        hash = hash.next;
      }
      return null;
    }
    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
      this._elementsCount++;
      if (this._growCount !== 0 && this._elementsCount >= this._growCount) {
        var oldElements = this._elements;
        this._currentLengthIndex++;
        this._currentLength = HashTable._SIZES[this._currentLengthIndex];
        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
        this._elements = [];
        HashTable._nullOutEntries(this._elements, this._currentLength);
        for (const first of oldElements) {
          for (oldElements = first; oldElements;) {
            const oldNext = oldElements.next;
            oldElements.next = null;
            this._add(oldElements);
            oldElements = oldNext;
          }
        }
      }
      this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));
    }
    _add(element) {
      const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);
      element.next = this._elements[hash];
      this._elements[hash] = element;
    }
  }
  HashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$services$semanticTokensProviderStyling.js.map
