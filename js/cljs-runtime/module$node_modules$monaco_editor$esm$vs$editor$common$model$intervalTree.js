shadow$provide.module$node_modules$monaco_editor$esm$vs$editor$common$model$intervalTree = function(require, module, exports) {
  function getNodeColor(node) {
    return (node.metadata & 1) >>> 0;
  }
  function setNodeColor(node, color) {
    node.metadata = node.metadata & 254 | color << 0;
  }
  function getNodeIsVisited(node) {
    return (node.metadata & 2) >>> 1 === 1;
  }
  function setNodeIsVisited(node, value) {
    node.metadata = node.metadata & 253 | (value ? 1 : 0) << 1;
  }
  function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
    return markerOffset < checkOffset ? !0 : markerOffset > checkOffset || moveSemantics === 1 ? !1 : moveSemantics === 2 ? !0 : markerStickToPreviousCharacter;
  }
  function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
    var nodeStickiness = (node.metadata & 24) >>> 3;
    const startStickToPreviousCharacter = nodeStickiness === 0 || nodeStickiness === 2, endStickToPreviousCharacter = nodeStickiness === 1 || nodeStickiness === 2, deletingCnt = end - start, commonLength = Math.min(deletingCnt, textLength);
    nodeStickiness = node.start;
    let startDone = !1;
    const nodeEnd = node.end;
    let endDone = !1;
    start <= nodeStickiness && nodeEnd <= end && (node.metadata & 32) >>> 5 === 1 && (node.start = start, startDone = !0, node.end = start, endDone = !0);
    var moveSemantics = forceMoveMarkers ? 1 : deletingCnt > 0 ? 2 : 0;
    !startDone && adjustMarkerBeforeColumn(nodeStickiness, startStickToPreviousCharacter, start, moveSemantics) && (startDone = !0);
    !endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics) && (endDone = !0);
    commonLength > 0 && !forceMoveMarkers && (moveSemantics = deletingCnt > textLength ? 2 : 0, !startDone && adjustMarkerBeforeColumn(nodeStickiness, startStickToPreviousCharacter, start + commonLength, moveSemantics) && (startDone = !0), !endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics) && (endDone = !0));
    forceMoveMarkers = forceMoveMarkers ? 1 : 0;
    !startDone && adjustMarkerBeforeColumn(nodeStickiness, startStickToPreviousCharacter, end, forceMoveMarkers) && (node.start = start + textLength, startDone = !0);
    !endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, forceMoveMarkers) && (node.end = start + textLength, endDone = !0);
    start = textLength - deletingCnt;
    startDone || (node.start = Math.max(0, nodeStickiness + start));
    endDone || (node.end = Math.max(0, nodeEnd + start));
    node.start > node.end && (node.end = node.start);
  }
  function rbTreeInsert(T, newNode) {
    if (T.root === SENTINEL) {
      return newNode.parent = SENTINEL, newNode.left = SENTINEL, newNode.right = SENTINEL, setNodeColor(newNode, 0), T.root = newNode, T.root;
    }
    var delta = 0, x = T.root;
    const zAbsoluteStart = newNode.start, zAbsoluteEnd = newNode.end;
    for (;;) {
      if (intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta) < 0) {
        if (x.left === SENTINEL) {
          newNode.start -= delta;
          newNode.end -= delta;
          newNode.maxEnd -= delta;
          x.left = newNode;
          break;
        } else {
          x = x.left;
        }
      } else {
        if (x.right === SENTINEL) {
          newNode.start -= delta + x.delta;
          newNode.end -= delta + x.delta;
          newNode.maxEnd -= delta + x.delta;
          x.right = newNode;
          break;
        } else {
          delta += x.delta, x = x.right;
        }
      }
    }
    newNode.parent = x;
    newNode.left = SENTINEL;
    newNode.right = SENTINEL;
    setNodeColor(newNode, 1);
    recomputeMaxEndWalkToRoot(newNode.parent);
    for (delta = newNode; delta !== T.root && getNodeColor(delta.parent) === 1;) {
      delta.parent === delta.parent.parent.left ? (x = delta.parent.parent.right, getNodeColor(x) === 1 ? (setNodeColor(delta.parent, 0), setNodeColor(x, 0), setNodeColor(delta.parent.parent, 1), delta = delta.parent.parent) : (delta === delta.parent.right && (delta = delta.parent, leftRotate(T, delta)), setNodeColor(delta.parent, 0), setNodeColor(delta.parent.parent, 1), rightRotate(T, delta.parent.parent))) : (x = delta.parent.parent.left, getNodeColor(x) === 1 ? (setNodeColor(delta.parent, 0), 
      setNodeColor(x, 0), setNodeColor(delta.parent.parent, 1), delta = delta.parent.parent) : (delta === delta.parent.left && (delta = delta.parent, rightRotate(T, delta)), setNodeColor(delta.parent, 0), setNodeColor(delta.parent.parent, 1), leftRotate(T, delta.parent.parent)));
    }
    setNodeColor(T.root, 0);
    return newNode;
  }
  function rbTreeDelete(T, z) {
    let y;
    if (z.left === SENTINEL) {
      var x = z.right;
      y = z;
      x.delta += z.delta;
      if (x.delta < -1073741824 || x.delta > 1073741824) {
        T.requestNormalizeDelta = !0;
      }
      x.start += z.delta;
      x.end += z.delta;
    } else if (z.right === SENTINEL) {
      x = z.left, y = z;
    } else {
      for (x = z.right; x.left !== SENTINEL;) {
        x = x.left;
      }
      y = x;
      x = y.right;
      x.start += y.delta;
      x.end += y.delta;
      x.delta += y.delta;
      if (x.delta < -1073741824 || x.delta > 1073741824) {
        T.requestNormalizeDelta = !0;
      }
      y.start += z.delta;
      y.end += z.delta;
      y.delta = z.delta;
      if (y.delta < -1073741824 || y.delta > 1073741824) {
        T.requestNormalizeDelta = !0;
      }
    }
    if (y === T.root) {
      T.root = x, setNodeColor(x, 0), z.detach(), resetSentinel(), recomputeMaxEnd(x), T.root.parent = SENTINEL;
    } else {
      var yWasRed = getNodeColor(y) === 1;
      y === y.parent.left ? y.parent.left = x : y.parent.right = x;
      y === z ? x.parent = y.parent : (x.parent = y.parent === z ? y : y.parent, y.left = z.left, y.right = z.right, y.parent = z.parent, setNodeColor(y, getNodeColor(z)), z === T.root ? T.root = y : z === z.parent.left ? z.parent.left = y : z.parent.right = y, y.left !== SENTINEL && (y.left.parent = y), y.right !== SENTINEL && (y.right.parent = y));
      z.detach();
      if (yWasRed) {
        recomputeMaxEndWalkToRoot(x.parent), y !== z && (recomputeMaxEndWalkToRoot(y), recomputeMaxEndWalkToRoot(y.parent));
      } else {
        recomputeMaxEndWalkToRoot(x);
        recomputeMaxEndWalkToRoot(x.parent);
        y !== z && (recomputeMaxEndWalkToRoot(y), recomputeMaxEndWalkToRoot(y.parent));
        for (; x !== T.root && getNodeColor(x) === 0;) {
          x === x.parent.left ? (z = x.parent.right, getNodeColor(z) === 1 && (setNodeColor(z, 0), setNodeColor(x.parent, 1), leftRotate(T, x.parent), z = x.parent.right), getNodeColor(z.left) === 0 && getNodeColor(z.right) === 0 ? (setNodeColor(z, 1), x = x.parent) : (getNodeColor(z.right) === 0 && (setNodeColor(z.left, 0), setNodeColor(z, 1), rightRotate(T, z), z = x.parent.right), setNodeColor(z, getNodeColor(x.parent)), setNodeColor(x.parent, 0), setNodeColor(z.right, 0), leftRotate(T, x.parent), 
          x = T.root)) : (z = x.parent.left, getNodeColor(z) === 1 && (setNodeColor(z, 0), setNodeColor(x.parent, 1), rightRotate(T, x.parent), z = x.parent.left), getNodeColor(z.left) === 0 && getNodeColor(z.right) === 0 ? (setNodeColor(z, 1), x = x.parent) : (getNodeColor(z.left) === 0 && (setNodeColor(z.right, 0), setNodeColor(z, 1), leftRotate(T, z), z = x.parent.left), setNodeColor(z, getNodeColor(x.parent)), setNodeColor(x.parent, 0), setNodeColor(z.left, 0), rightRotate(T, x.parent), x = T.root));
        }
        setNodeColor(x, 0);
      }
      resetSentinel();
    }
  }
  function resetSentinel() {
    SENTINEL.parent = SENTINEL;
    SENTINEL.delta = 0;
    SENTINEL.start = 0;
    SENTINEL.end = 0;
  }
  function leftRotate(T, x) {
    const y = x.right;
    y.delta += x.delta;
    if (y.delta < -1073741824 || y.delta > 1073741824) {
      T.requestNormalizeDelta = !0;
    }
    y.start += x.delta;
    y.end += x.delta;
    x.right = y.left;
    y.left !== SENTINEL && (y.left.parent = x);
    y.parent = x.parent;
    x.parent === SENTINEL ? T.root = y : x === x.parent.left ? x.parent.left = y : x.parent.right = y;
    y.left = x;
    x.parent = y;
    recomputeMaxEnd(x);
    recomputeMaxEnd(y);
  }
  function rightRotate(T, y) {
    const x = y.left;
    y.delta -= x.delta;
    if (y.delta < -1073741824 || y.delta > 1073741824) {
      T.requestNormalizeDelta = !0;
    }
    y.start -= x.delta;
    y.end -= x.delta;
    y.left = x.right;
    x.right !== SENTINEL && (x.right.parent = y);
    x.parent = y.parent;
    y.parent === SENTINEL ? T.root = x : y === y.parent.right ? y.parent.right = x : y.parent.left = x;
    x.right = y;
    y.parent = x;
    recomputeMaxEnd(y);
    recomputeMaxEnd(x);
  }
  function computeMaxEnd(node) {
    let maxEnd = node.end;
    if (node.left !== SENTINEL) {
      const leftMaxEnd = node.left.maxEnd;
      leftMaxEnd > maxEnd && (maxEnd = leftMaxEnd);
    }
    node.right !== SENTINEL && (node = node.right.maxEnd + node.delta, node > maxEnd && (maxEnd = node));
    return maxEnd;
  }
  function recomputeMaxEnd(node) {
    node.maxEnd = computeMaxEnd(node);
  }
  function recomputeMaxEndWalkToRoot(node) {
    for (; node !== SENTINEL;) {
      const maxEnd = computeMaxEnd(node);
      if (node.maxEnd === maxEnd) {
        break;
      }
      node.maxEnd = maxEnd;
      node = node.parent;
    }
  }
  function intervalCompare(aStart, aEnd, bStart, bEnd) {
    return aStart === bStart ? aEnd - bEnd : aStart - bStart;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, IntervalNode:{enumerable:!0, get:function() {
    return IntervalNode;
  }}, IntervalTree:{enumerable:!0, get:function() {
    return IntervalTree;
  }}, SENTINEL:{enumerable:!0, get:function() {
    return SENTINEL;
  }}, getNodeColor:{enumerable:!0, get:function() {
    return getNodeColor;
  }}, intervalCompare:{enumerable:!0, get:function() {
    return intervalCompare;
  }}, nodeAcceptEdit:{enumerable:!0, get:function() {
    return nodeAcceptEdit;
  }}, recomputeMaxEnd:{enumerable:!0, get:function() {
    return recomputeMaxEnd;
  }}});
  class IntervalNode {
    constructor(id, start, end) {
      this.metadata = 0;
      this.parent = this;
      this.left = this;
      this.right = this;
      setNodeColor(this, 1);
      this.start = start;
      this.end = end;
      this.delta = 0;
      this.maxEnd = end;
      this.id = id;
      this.ownerId = 0;
      this.options = null;
      this.metadata = this.metadata & 251 | 0;
      this.metadata = this.metadata & 191 | 0;
      this.metadata = this.metadata & 231 | 8;
      this.metadata = this.metadata & 223 | 0;
      this.cachedVersionId = 0;
      this.cachedAbsoluteStart = start;
      this.cachedAbsoluteEnd = end;
      this.range = null;
      setNodeIsVisited(this, !1);
    }
    reset(versionId, start, end, range) {
      this.start = start;
      this.maxEnd = this.end = end;
      this.cachedVersionId = versionId;
      this.cachedAbsoluteStart = start;
      this.cachedAbsoluteEnd = end;
      this.range = range;
    }
    setOptions(options) {
      this.options = options;
      options = this.options.className;
      this.metadata = this.metadata & 251 | (options === "squiggly-error" || options === "squiggly-warning" || options === "squiggly-info" ? 1 : 0) << 2;
      this.metadata = this.metadata & 191 | (this.options.glyphMarginClassName !== null ? 1 : 0) << 6;
      this.metadata = this.metadata & 231 | this.options.stickiness << 3;
      this.metadata = this.metadata & 223 | (this.options.collapseOnReplaceEdit ? 1 : 0) << 5;
    }
    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {
      this.cachedVersionId !== cachedVersionId && (this.range = null);
      this.cachedVersionId = cachedVersionId;
      this.cachedAbsoluteStart = absoluteStart;
      this.cachedAbsoluteEnd = absoluteEnd;
    }
    detach() {
      this.right = this.left = this.parent = null;
    }
  }
  const SENTINEL = new IntervalNode(null, 0, 0);
  SENTINEL.parent = SENTINEL;
  SENTINEL.left = SENTINEL;
  SENTINEL.right = SENTINEL;
  setNodeColor(SENTINEL, 0);
  class IntervalTree {
    constructor() {
      this.root = SENTINEL;
      this.requestNormalizeDelta = !1;
    }
    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
      if (this.root === SENTINEL) {
        return [];
      }
      let node = this.root, delta = 0;
      let nodeEnd;
      const result = [];
      let resultLen = 0;
      for (; node !== SENTINEL;) {
        if (getNodeIsVisited(node)) {
          setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node === node.parent.right && (delta -= node.parent.delta), node = node.parent;
        } else {
          if (!getNodeIsVisited(node.left)) {
            var nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < start) {
              setNodeIsVisited(node, !0);
              continue;
            }
            if (node.left !== SENTINEL) {
              node = node.left;
              continue;
            }
          }
          nodeMaxEnd = delta + node.start;
          nodeMaxEnd > end ? setNodeIsVisited(node, !0) : (nodeEnd = delta + node.end, nodeEnd >= start && (node.setCachedOffsets(nodeMaxEnd, nodeEnd, cachedVersionId), nodeMaxEnd = !0, filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId && (nodeMaxEnd = !1), filterOutValidation && (node.metadata & 4) >>> 2 === 1 && (nodeMaxEnd = !1), onlyMarginDecorations && (node.metadata & 64) >>> 6 !== 1 && (nodeMaxEnd = !1), nodeMaxEnd && (result[resultLen++] = node)), setNodeIsVisited(node, !0), 
          node.right === SENTINEL || getNodeIsVisited(node.right) || (delta += node.delta, node = node.right));
        }
      }
      setNodeIsVisited(this.root, !1);
      return result;
    }
    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
      if (this.root === SENTINEL) {
        return [];
      }
      let node = this.root, delta = 0;
      let nodeEnd;
      const result = [];
      let resultLen = 0;
      for (; node !== SENTINEL;) {
        if (getNodeIsVisited(node)) {
          setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node === node.parent.right && (delta -= node.parent.delta), node = node.parent;
        } else {
          if (node.left === SENTINEL || getNodeIsVisited(node.left)) {
            var nodeStart = delta + node.start;
            nodeEnd = delta + node.end;
            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
            nodeStart = !0;
            filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId && (nodeStart = !1);
            filterOutValidation && (node.metadata & 4) >>> 2 === 1 && (nodeStart = !1);
            onlyMarginDecorations && (node.metadata & 64) >>> 6 !== 1 && (nodeStart = !1);
            nodeStart && (result[resultLen++] = node);
            setNodeIsVisited(node, !0);
            node.right === SENTINEL || getNodeIsVisited(node.right) || (delta += node.delta, node = node.right);
          } else {
            node = node.left;
          }
        }
      }
      setNodeIsVisited(this.root, !1);
      return result;
    }
    collectNodesFromOwner(ownerId) {
      let node = this.root;
      const result = [];
      let resultLen = 0;
      for (; node !== SENTINEL;) {
        getNodeIsVisited(node) ? (setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node = node.parent) : node.left === SENTINEL || getNodeIsVisited(node.left) ? (node.ownerId === ownerId && (result[resultLen++] = node), setNodeIsVisited(node, !0), node.right === SENTINEL || getNodeIsVisited(node.right) || (node = node.right)) : node = node.left;
      }
      setNodeIsVisited(this.root, !1);
      return result;
    }
    collectNodesPostOrder() {
      let node = this.root;
      const result = [];
      let resultLen = 0;
      for (; node !== SENTINEL;) {
        getNodeIsVisited(node) ? (setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node = node.parent) : node.left === SENTINEL || getNodeIsVisited(node.left) ? node.right === SENTINEL || getNodeIsVisited(node.right) ? (result[resultLen++] = node, setNodeIsVisited(node, !0)) : node = node.right : node = node.left;
      }
      setNodeIsVisited(this.root, !1);
      return result;
    }
    insert(node) {
      rbTreeInsert(this, node);
      this._normalizeDeltaIfNecessary();
    }
    delete(node) {
      rbTreeDelete(this, node);
      this._normalizeDeltaIfNecessary();
    }
    resolveNode(node, cachedVersionId) {
      const initialNode = node;
      let delta = 0;
      for (; node !== this.root;) {
        node === node.parent.right && (delta += node.parent.delta), node = node.parent;
      }
      initialNode.setCachedOffsets(initialNode.start + delta, initialNode.end + delta, cachedVersionId);
    }
    acceptReplace(offset, length, textLength, forceMoveMarkers) {
      var end = offset + length, node = this.root, delta = 0;
      let nodeEnd;
      const result = [];
      for (var resultLen = 0; node !== SENTINEL;) {
        if (getNodeIsVisited(node)) {
          setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node === node.parent.right && (delta -= node.parent.delta), node = node.parent;
        } else {
          if (!getNodeIsVisited(node.left)) {
            var nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < offset) {
              setNodeIsVisited(node, !0);
              continue;
            }
            if (node.left !== SENTINEL) {
              node = node.left;
              continue;
            }
          }
          nodeMaxEnd = delta + node.start;
          nodeMaxEnd > end ? setNodeIsVisited(node, !0) : (nodeEnd = delta + node.end, nodeEnd >= offset && (node.setCachedOffsets(nodeMaxEnd, nodeEnd, 0), result[resultLen++] = node), setNodeIsVisited(node, !0), node.right === SENTINEL || getNodeIsVisited(node.right) || (delta += node.delta, node = node.right));
        }
      }
      setNodeIsVisited(this.root, !1);
      for (let i = 0, len = result.length; i < len; i++) {
        rbTreeDelete(this, result[i]);
      }
      this._normalizeDeltaIfNecessary();
      end = offset + length;
      node = this.root;
      delta = 0;
      for (resultLen = textLength - (end - offset); node !== SENTINEL;) {
        if (getNodeIsVisited(node)) {
          setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node === node.parent.right && (delta -= node.parent.delta), recomputeMaxEnd(node), node = node.parent;
        } else {
          if (!getNodeIsVisited(node.left)) {
            nodeMaxEnd = delta + node.maxEnd;
            if (nodeMaxEnd < offset) {
              setNodeIsVisited(node, !0);
              continue;
            }
            if (node.left !== SENTINEL) {
              node = node.left;
              continue;
            }
          }
          nodeMaxEnd = delta + node.start;
          if (nodeMaxEnd > end) {
            node.start += resultLen;
            node.end += resultLen;
            node.delta += resultLen;
            if (node.delta < -1073741824 || node.delta > 1073741824) {
              this.requestNormalizeDelta = !0;
            }
            setNodeIsVisited(node, !0);
          } else {
            setNodeIsVisited(node, !0), node.right === SENTINEL || getNodeIsVisited(node.right) || (delta += node.delta, node = node.right);
          }
        }
      }
      setNodeIsVisited(this.root, !1);
      this._normalizeDeltaIfNecessary();
      for (let i = 0, len = result.length; i < len; i++) {
        end = result[i], end.start = end.cachedAbsoluteStart, end.end = end.cachedAbsoluteEnd, nodeAcceptEdit(end, offset, offset + length, textLength, forceMoveMarkers), end.maxEnd = end.end, rbTreeInsert(this, end);
      }
      this._normalizeDeltaIfNecessary();
    }
    _normalizeDeltaIfNecessary() {
      if (this.requestNormalizeDelta) {
        this.requestNormalizeDelta = !1;
        for (var node = this.root, delta = 0; node !== SENTINEL;) {
          node.left === SENTINEL || getNodeIsVisited(node.left) ? node.right === SENTINEL || getNodeIsVisited(node.right) ? (node.start = delta + node.start, node.end = delta + node.end, node.delta = 0, recomputeMaxEnd(node), setNodeIsVisited(node, !0), setNodeIsVisited(node.left, !1), setNodeIsVisited(node.right, !1), node === node.parent.right && (delta -= node.parent.delta), node = node.parent) : (delta += node.delta, node = node.right) : node = node.left;
        }
        setNodeIsVisited(this.root, !1);
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$editor$common$model$intervalTree.js.map
