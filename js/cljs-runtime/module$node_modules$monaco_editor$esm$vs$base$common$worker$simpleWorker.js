shadow$provide.module$node_modules$monaco_editor$esm$vs$base$common$worker$simpleWorker = function(require, module, exports) {
  function logOnceWebWorkerWarning(err) {
    require$_DOT__DOT__SLASH_platform_DOT_js.isWeb && (webWorkerWarningLogged || (webWorkerWarningLogged = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(err.message));
  }
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && strings.isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject(methodNames, invoke, proxyListen) {
    const createProxyMethod = method => function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    }, createProxyDynamicEvent = eventName => function(arg) {
      return proxyListen(eventName, arg);
    }, result = {};
    for (const methodName of methodNames) {
      propertyIsDynamicEvent(methodName) ? result[methodName] = createProxyDynamicEvent(methodName) : propertyIsEvent(methodName) ? result[methodName] = proxyListen(methodName, void 0) : result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  function create(postMessage) {
    return new SimpleWorkerServer(postMessage, null);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, SimpleWorkerClient:{enumerable:!0, get:function() {
    return SimpleWorkerClient;
  }}, SimpleWorkerServer:{enumerable:!0, get:function() {
    return SimpleWorkerServer;
  }}, create:{enumerable:!0, get:function() {
    return create;
  }}, logOnceWebWorkerWarning:{enumerable:!0, get:function() {
    return logOnceWebWorkerWarning;
  }}});
  var require$_DOT__DOT__SLASH_errors_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$errors"), require$_DOT__DOT__SLASH_event_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$event");
  module = require("module$node_modules$monaco_editor$esm$vs$base$common$lifecycle");
  var require$_DOT__DOT__SLASH_objects_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$objects"), require$_DOT__DOT__SLASH_platform_DOT_js = require("module$node_modules$monaco_editor$esm$vs$base$common$platform"), strings = require("module$node_modules$monaco_editor$esm$vs$base$common$strings");
  let webWorkerWarningLogged = !1;
  class RequestMessage {
    constructor(vsWorker, req, method, args) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.method = method;
      this.args = args;
      this.type = 0;
    }
  }
  class ReplyMessage {
    constructor(vsWorker, seq, res, err) {
      this.vsWorker = vsWorker;
      this.seq = seq;
      this.res = res;
      this.err = err;
      this.type = 1;
    }
  }
  class SubscribeEventMessage {
    constructor(vsWorker, req, eventName, arg) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.eventName = eventName;
      this.arg = arg;
      this.type = 2;
    }
  }
  class EventMessage {
    constructor(vsWorker, req, event) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.event = event;
      this.type = 3;
    }
  }
  class UnsubscribeEventMessage {
    constructor(vsWorker, req) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.type = 4;
    }
  }
  class SimpleWorkerProtocol {
    constructor(handler) {
      this._workerId = -1;
      this._handler = handler;
      this._lastSentReq = 0;
      this._pendingReplies = Object.create(null);
      this._pendingEmitters = new Map();
      this._pendingEvents = new Map();
    }
    setWorkerId(workerId) {
      this._workerId = workerId;
    }
    sendMessage(method, args) {
      const req = String(++this._lastSentReq);
      return new Promise((resolve, reject) => {
        this._pendingReplies[req] = {resolve, reject};
        this._send(new RequestMessage(this._workerId, req, method, args));
      });
    }
    listen(eventName, arg) {
      let req = null;
      const emitter = new require$_DOT__DOT__SLASH_event_DOT_js.Emitter({onWillAddFirstListener:() => {
        req = String(++this._lastSentReq);
        this._pendingEmitters.set(req, emitter);
        this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
      }, onDidRemoveLastListener:() => {
        this._pendingEmitters.delete(req);
        this._send(new UnsubscribeEventMessage(this._workerId, req));
        req = null;
      }});
      return emitter.event;
    }
    handleMessage(message) {
      message && message.vsWorker && (this._workerId === -1 || message.vsWorker === this._workerId) && this._handleMessage(message);
    }
    _handleMessage(msg) {
      switch(msg.type) {
        case 1:
          return this._handleReplyMessage(msg);
        case 0:
          return this._handleRequestMessage(msg);
        case 2:
          return this._handleSubscribeEventMessage(msg);
        case 3:
          return this._handleEventMessage(msg);
        case 4:
          return this._handleUnsubscribeEventMessage(msg);
      }
    }
    _handleReplyMessage(replyMessage) {
      if (this._pendingReplies[replyMessage.seq]) {
        var reply = this._pendingReplies[replyMessage.seq];
        delete this._pendingReplies[replyMessage.seq];
        if (replyMessage.err) {
          let err = replyMessage.err;
          replyMessage.err.$isError && (err = Error(), err.name = replyMessage.err.name, err.message = replyMessage.err.message, err.stack = replyMessage.err.stack);
          reply.reject(err);
        } else {
          reply.resolve(replyMessage.res);
        }
      } else {
        console.warn("Got reply to unknown seq");
      }
    }
    _handleRequestMessage(requestMessage) {
      const req = requestMessage.req;
      this._handler.handleMessage(requestMessage.method, requestMessage.args).then(r => {
        this._send(new ReplyMessage(this._workerId, req, r, void 0));
      }, e => {
        e.detail instanceof Error && (e.detail = (0,require$_DOT__DOT__SLASH_errors_DOT_js.transformErrorForSerialization)(e.detail));
        this._send(new ReplyMessage(this._workerId, req, void 0, (0,require$_DOT__DOT__SLASH_errors_DOT_js.transformErrorForSerialization)(e)));
      });
    }
    _handleSubscribeEventMessage(msg) {
      const req = msg.req;
      msg = this._handler.handleEvent(msg.eventName, msg.arg)(event => {
        this._send(new EventMessage(this._workerId, req, event));
      });
      this._pendingEvents.set(req, msg);
    }
    _handleEventMessage(msg) {
      this._pendingEmitters.has(msg.req) ? this._pendingEmitters.get(msg.req).fire(msg.event) : console.warn("Got event for unknown req");
    }
    _handleUnsubscribeEventMessage(msg) {
      this._pendingEvents.has(msg.req) ? (this._pendingEvents.get(msg.req).dispose(), this._pendingEvents.delete(msg.req)) : console.warn("Got unsubscribe for unknown req");
    }
    _send(msg) {
      const transfer = [];
      if (msg.type === 0) {
        for (let i = 0; i < msg.args.length; i++) {
          msg.args[i] instanceof ArrayBuffer && transfer.push(msg.args[i]);
        }
      } else {
        msg.type === 1 && msg.res instanceof ArrayBuffer && transfer.push(msg.res);
      }
      this._handler.sendMessage(msg, transfer);
    }
  }
  class SimpleWorkerClient extends module.Disposable {
    constructor(workerFactory, moduleId, host) {
      super();
      let lazyProxyReject = null;
      this._worker = this._register(workerFactory.create("vs/base/common/worker/simpleWorker", msg => {
        this._protocol.handleMessage(msg);
      }, err => {
        lazyProxyReject === null || lazyProxyReject === void 0 || lazyProxyReject(err);
      }));
      this._protocol = new SimpleWorkerProtocol({sendMessage:(msg, transfer) => {
        this._worker.postMessage(msg, transfer);
      }, handleMessage:(method, args) => {
        if (typeof host[method] !== "function") {
          return Promise.reject(Error("Missing method " + method + " on main thread host."));
        }
        try {
          return Promise.resolve(host[method].apply(host, args));
        } catch (e) {
          return Promise.reject(e);
        }
      }, handleEvent:(eventName, arg) => {
        if (propertyIsDynamicEvent(eventName)) {
          arg = host[eventName].call(host, arg);
          if (typeof arg !== "function") {
            throw Error(`Missing dynamic event ${eventName} on main thread host.`);
          }
          return arg;
        }
        if (propertyIsEvent(eventName)) {
          arg = host[eventName];
          if (typeof arg !== "function") {
            throw Error(`Missing event ${eventName} on main thread host.`);
          }
          return arg;
        }
        throw Error(`Malformed event name ${eventName}`);
      }});
      this._protocol.setWorkerId(this._worker.getId());
      workerFactory = null;
      var globalRequire = globalThis.require;
      typeof globalRequire !== "undefined" && typeof globalRequire.getConfig === "function" ? workerFactory = globalRequire.getConfig() : typeof globalThis.requirejs !== "undefined" && (workerFactory = globalThis.requirejs.s.contexts._.config);
      globalRequire = (0,require$_DOT__DOT__SLASH_objects_DOT_js.getAllMethodNames)(host);
      this._onModuleLoaded = this._protocol.sendMessage("$initialize", [this._worker.getId(), JSON.parse(JSON.stringify(workerFactory)), moduleId, globalRequire]);
      const proxyMethodRequest = (method, args) => this._request(method, args), proxyListen = (eventName, arg) => this._protocol.listen(eventName, arg);
      this._lazyProxy = new Promise((resolve, reject) => {
        lazyProxyReject = reject;
        this._onModuleLoaded.then(availableMethods => {
          resolve(createProxyObject(availableMethods, proxyMethodRequest, proxyListen));
        }, e => {
          reject(e);
          this._onError("Worker failed to load " + moduleId, e);
        });
      });
    }
    getProxyObject() {
      return this._lazyProxy;
    }
    _request(method, args) {
      return new Promise((resolve, reject) => {
        this._onModuleLoaded.then(() => {
          this._protocol.sendMessage(method, args).then(resolve, reject);
        }, reject);
      });
    }
    _onError(message, error) {
      console.error(message);
      console.info(error);
    }
  }
  class SimpleWorkerServer {
    constructor(postMessage, requestHandlerFactory) {
      this._requestHandlerFactory = requestHandlerFactory;
      this._requestHandler = null;
      this._protocol = new SimpleWorkerProtocol({sendMessage:(msg, transfer) => {
        postMessage(msg, transfer);
      }, handleMessage:(method, args) => this._handleMessage(method, args), handleEvent:(eventName, arg) => this._handleEvent(eventName, arg)});
    }
    onmessage(msg) {
      this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
      if (method === "$initialize") {
        return this.initialize(args[0], args[1], args[2], args[3]);
      }
      if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
        return Promise.reject(Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _handleEvent(eventName, arg) {
      if (!this._requestHandler) {
        throw Error("Missing requestHandler");
      }
      if (propertyIsDynamicEvent(eventName)) {
        arg = this._requestHandler[eventName].call(this._requestHandler, arg);
        if (typeof arg !== "function") {
          throw Error(`Missing dynamic event ${eventName} on request handler.`);
        }
        return arg;
      }
      if (propertyIsEvent(eventName)) {
        arg = this._requestHandler[eventName];
        if (typeof arg !== "function") {
          throw Error(`Missing event ${eventName} on request handler.`);
        }
        return arg;
      }
      throw Error(`Malformed event name ${eventName}`);
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
      this._protocol.setWorkerId(workerId);
      const hostProxy = createProxyObject(hostMethods, (method, args) => this._protocol.sendMessage(method, args), (eventName, arg) => this._protocol.listen(eventName, arg));
      if (this._requestHandlerFactory) {
        return this._requestHandler = this._requestHandlerFactory(hostProxy), Promise.resolve((0,require$_DOT__DOT__SLASH_objects_DOT_js.getAllMethodNames)(this._requestHandler));
      }
      loaderConfig && (typeof loaderConfig.baseUrl !== "undefined" && delete loaderConfig.baseUrl, typeof loaderConfig.paths !== "undefined" && typeof loaderConfig.paths.vs !== "undefined" && delete loaderConfig.paths.vs, delete loaderConfig.trustedTypesPolicy, loaderConfig.catchError = !0, globalThis.require.config(loaderConfig));
      return new Promise((resolve, reject) => {
        const req = globalThis.require;
        req([moduleId], module => {
          (this._requestHandler = module.create(hostProxy)) ? resolve((0,require$_DOT__DOT__SLASH_objects_DOT_js.getAllMethodNames)(this._requestHandler)) : reject(Error("No RequestHandler!"));
        }, reject);
      });
    }
  }
};

//# sourceMappingURL=module$node_modules$monaco_editor$esm$vs$base$common$worker$simpleWorker.js.map
